+TITLE.
UNDUMAG  2.05/01  23/10/2023  14.26.31
+PATCH,FOR.
*CMZ :  0.00/00 20/04/2016  13.00.13  by  Michael Scheer
+DECK,undumag_end.
*CMZ :  2.05/01 22/10/2023  14.47.55  by  Michael Scheer
*CMZ :  2.04/12 30/08/2023  11.37.07  by  Michael Scheer
*CMZ :  2.04/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  16.57.37  by  Michael Scheer
*CMZ :  2.04/01 20/01/2023  13.43.13  by  Michael Scheer
*CMZ :  2.04/00 16/01/2023  14.39.15  by  Michael Scheer
*CMZ :  2.03/00 01/09/2022  10.41.39  by  Michael Scheer
*CMZ :  2.02/02 26/02/2022  12.52.35  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 29/03/2021  09.45.50  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.14.56  by  Michael Scheer
*CMZ :  2.01/05 05/06/2020  17.09.33  by  Michael Scheer
*CMZ :  2.01/04 29/07/2019  12.05.13  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.25.31  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  16.20.58  by  Michael Scheer
*CMZ :  2.00/03 19/04/2018  11.05.57  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  13.46.37  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  16.46.42  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  11.15.27  by  Michael Scheer
*CMZ :  1.25/03 03/04/2018  08.01.24  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.03.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.17.42  by  Michael Scheer
*CMZ :  1.25/00 14/03/2018  12.58.50  by  Michael Scheer
*CMZ :  1.24/01 13/10/2017  11.37.28  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  14.05.37  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.07.37  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  15.55.08  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.18.42  by  Michael Scheer
*CMZ :  1.22/02 04/08/2017  07.56.26  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.55.33  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.09.09  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  15.38.45  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.35.35  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  16.39.29  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.15.48  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.22.03  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  16.12.25  by  Michael Scheer
*CMZ :  1.18/00 02/06/2017  09.38.06  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  15.20.49  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  08.36.20  by  Michael Scheer
*CMZ :  1.17/06 18/05/2017  22.30.31  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  15.55.38  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  17.57.38  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.15.17  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  09.01.37  by  Michael Scheer
*CMZ :  1.15/07 04/04/2017  13.49.11  by  Michael Scheer
*CMZ :  1.15/05 03/04/2017  13.40.53  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.57.38  by  Michael Scheer
*CMZ :  1.15/03 02/04/2017  15.45.35  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.38.56  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  15.25.06  by  Michael Scheer
*CMZ :  1.15/00 27/03/2017  15.13.40  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  14.39.06  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.16.46  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.26.29  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.53.52  by  Michael Scheer
*CMZ :  1.11/04 23/01/2017  17.22.15  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.28  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.48.13  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.22.30  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.52.38  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.18.26  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.45.21  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.30.02  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.49.21  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.57.45  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.31.52  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  14.13.49  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  15.30.08  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  12.45.07  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.03.06  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.37.39  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  11.57.51  by  Michael Scheer
*CMZ :  0.00/11 18/07/2016  09.18.11  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.57.35  by  Michael Scheer
*CMZ :  0.00/09 28/06/2016  15.42.08  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/05 13/06/2016  12.45.02  by  Michael Scheer
*CMZ :  0.00/02 30/04/2016  13.12.13  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.02.34  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  15.51.06  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.38.32  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.40.54  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  15.11.21  by  Michael Scheer
*CMZ :  1.17/03 22/03/2016  07.59.20  by  Michael Scheer
*CMZ :  1.17/02 07/03/2016  16.32.54  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_end

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

+seq,seqdebug.
+seq,random.

      double precision, dimension (:,:,:,:), allocatable :: bmap
      double precision, dimension (:,:), allocatable :: hmvoxel,hmagvox
      double precision, dimension (:), allocatable ::
     &  xint,bxa,bya,bza,
     &  byint,bzint,byint2,bzint2,
     &  xinti,byai,bzai,
     &  byinti,bzinti,byint2i,bzint2i,
     &  xintnor,bxanor,byanor,bzanor,
     &  byintnor,bzintnor,byint2nor,bzint2nor,
     &  xintd,bxad,byad,bzad,
     &  byintd,bzintd,byint2d,bzint2d,
     &  ws1,ws2,ws3,ws4,coef

      double precision :: retval,undumag_variable_getval,br

      integer, dimension (:), allocatable :: kfailbyeff,kfailbzeff,kfailon

      double precision x,y,z,bx,by,bz,hx,hy,hz,bcx,bcy,bcz,b,bprog,h,
     &  bc,dx,dy,dz,vmaglab(3),a(3),xopt,yopt,yint,zint,
     &  xminbeff,xmaxbeff,dkeffzd,
     &  bymaxbeff,bzmaxbeff,xbymax,xbzmax,xbeffo,
     &  beffd,beffzd,dkeffd,xmaxbeffnor,xminbeffnor,
     &  yp(3),bp(3),dum,bmaxp,
     &  bmaxbeffd,bmnbeffd,bmxbeffd,bmnbeffzd,bmxbeffzd,
     &  y2z2,py,pz,pryz,zr,yr,cosa,sina,
     &  xx,yy,zz,quadperlen,halfperlen,dxkbmode,bdx,bdy,bdz,x3(3),b3(3),a3(3),
     &  zmin,
     &  byif,bzif,bcrecmax,bcrecmin,bcironmax,bcironmin,bn,
     &  hcon,easy(3),easyn

      double precision :: bxexint=0.0d0, byexint=0.0d0, bzexint=0.0d0

      real g(3),xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &  dxpl,dypl,dzpl,xpl(2),ypl(2),zpl(2),
     &  bzplmin,bzplmax,bziplmin,bziplmax,bziiplmin,bziiplmax,
     &  byplmin,byplmax,byiplmin,byiplmax,byiiplmin,byiiplmax,
     &  s0min,s1min,s2min,s3min,s0,s1,s2,s3,
     &  s0max,s1max,s2max,s3max,xlaboff,ylaboff,brn,
     &  zppl(1000),bypl(1000),bzpl(1000),hbmatmin,hbmatmax,
     &  bcmaxrec,bcminrec,hmaxrec,hminrec,hmaxiron

      integer luninf,luni,lun,kfail,ifail77,ifail,imoth,iron,kmag,ix,iy,iz,
     &  matmap2,matmap3,n,lunmag,lunst,lunmat,lmag,
     &  lunpost,idis,mat,mtyp,imat,
     &  iplan,nplan,i,ibmax,ixon,ixonnor,
     &  itry,ixbeff,ixbeffnor,nfirst,nlast,lunkill,irecover,
     &  lunw,icorn,ncorn,nper,ibrn,kbrn,kx

      integer :: jcharge=-1,nthstep=1

      integer nstepp,nphp,npawp
      parameter (nstepp=1000000,nphp=10001,npawp=10000)

      double precision
     &  gammai,dgamtot,powden,xexit,yexit,zexit,
     &  traxyz(14,nstepp),
     &  phener(nphp),stokes(4,nphp),vnxex,vnyex,vnzex,texit,
     &  byint1f,bzint1f,byint2f,bzint2f,
     &  byint1fnor,bzint1fnor,byint2fnor,bzint2fnor,
     &  byint1fd,bzint1fd,byint2fd,bzint2fd,
     &  bxint1inf,byint1inf,bzint1inf,byi,bzi,byint1infd,bzint1infd

      complex*16 aradx(nphp),arady(nphp),aradz(nphp)

      integer ndim,istatus,ifreq,istep,lunz,nz
      real hpaw(npawp)
      common/pawc/hpaw

+seq,mshplt.
+seq,phyconparam.

      character(64) ctitle,chtime,chrun
      character(32) cmag,cmoth
      character(24) cbint

      save

      call  util_random_get_seed(irnsize,irnseed)

      hcon=9999.0d0
      if (halt.ne.0.0d0) then
        call undumag_bconv(hcon)
        hcon=(hcon-halt)/halt
      endif

      open(newunit=lunst,file="undumag.sta")
      write(lunst,*)kundurun,konv,iwarnsum, kiter,iterrectot,iterirontot,hresidiron,hcon
      if (konv.eq.1) then
        write(lunst,*)"Convergence reached"
      else if (konv.eq.0) then
        if (maxiter.eq.0) then
          write(lunst,*)"No iterations done due to maxiter=0"
        else
          write(lunst,*)"Maximum number of iterations reached"
        endif
      else
        write(lunst,*)"Terminated with problems"
      endif

      write(lunst,*)"undumag_end"

      flush(lunst)
      close(lunst)

      if (krunnum.ne.0) then
        write(chrun,*)kundurun
        if (usercom.ne.'') then
          ctitle=trim(usercom)//", Run: "//trim(chrun)
        else
          ctitle=", Run: "//trim(chrun)
        endif
      else
        ctitle=trim(usercom)
      endif

      nowarnugv=1
      retval=undumag_variable_getval("nPeriods")
      if (retval.ne.-9999.0d29) then
        nper=nint(retval)
      else
        nper=-1
      endif
      nowarnugv=0

      call util_zeit_kommentar(lun6,"Writing undumag.mh")

      open(newunit=lunmag,file="undumag.mh")
      write(lunmag,'(a)') '* ' // ctitle

      if (maxiter.eq.0.and.kpreset.eq.0) goto 9999

      if (nmag.eq.0.and.kbextern.eq.0.and.ncwires.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_end: Returning, since there are no magnetic items ***"
        write(lun6,*)
        goto 9999
      endif

      if (maxiter.gt.1) then

        call util_zeit_kommentar(lun6,"Writing undumag.pst")

        open(newunit=lunpost,file='undumag.pst')

        bcrecmax=-1.0d30
        bcrecmin=+1.0d30
        bcironmax=-1.0d30
        bcironmin=1.0d30

        if (nrec.eq.0) then
          bcrecmax=+0.0d0
          bcrecmin=-0.0d0
        endif
        if (niron.eq.0) then
          bcironmax=+0.0d0
          bcironmin=-0.0d0
        endif

        do kmag=1,nmag

          bn=sqrt(bpebc(4,kmag)**2+bpebc(5,kmag)**2+bpebc(6,kmag)**2)

          if (kmag.le.nrec) then
            if (bn.gt.bcrecmax) bcrecmax=bn
            if (bn.lt.bcrecmin) bcrecmin=bn
          else
            if (bn.gt.bcironmax) bcironmax=bn
            if (bn.lt.bcironmin) bcironmin=bn
          endif

          nplan=ibpeplan(kmag)
          write(lunpost,*)nplan,bpebc(1:17,kmag)
          do iplan=1,nplan
            write(lunpost,*)bpemag(1:3,1,iplan,kmag),
     &        bpetm(1:3,8,iplan,kmag)
          enddo !iplan

        enddo
        flush(lunpost)
        close(lunpost)

      endif !(maxiter.gt.0) then

      if (maxiter.gt.0.and.maxiteriron.gt.0) call undumag_residuals_iron

      write(lun6,*)
      write(lun6,*)"File undumag.pst written."
      write(lun6,*)

      write(lun6,*)
      write(lun6,*)"Minimum and maximum magnetization of magnets:",
     &  sngl(bcrecmin),sngl(bcrecmax)
      write(lun6,*)"Minimum and maximum magnetization of iron:",
     &  sngl(bcironmin),sngl(bcironmax)
      write(lun6,*)
      write(lun6,*)"RMS of iron magnetization residuals:",
     &  sngl(hresidiron)
      write(lun6,*)

      if (nxbeff.lt.5) nxbeff=5

      allocate (
     &  kfailbyeff(nxbeff),kfailbzeff(nxbeff),kfailon(nxmap),
     &  xintnor(nxmap),
     &  byintnor(nxmap),bzintnor(nxmap),
     &  byint2nor(nxmap),bzint2nor(nxmap),
     &  xint(nxmap),
     &  byint(nxmap),bzint(nxmap),
     &  byint2(nxmap),bzint2(nxmap),
     &  xintd(nxmap),
     &  byintd(nxmap),bzintd(nxmap),
     &  byint2d(nxmap),bzint2d(nxmap),
     &  bxa(nxmap),bya(nxmap),bza(nxmap),
     &  bxanor(nxmap),byanor(nxmap),bzanor(nxmap),
     &  bxad(nxmap),byad(nxmap),bzad(nxmap),
     &  ws1(nxmap),ws2(nxmap),ws3(nxmap),ws4(nxmap),coef(nxmap))

      if (nmag.eq.0.and.ncwires+nrace.eq.0.and.kbextern.eq.0) then
        xmapmin=0.1
        xmapmax=0.1
      endif

      if (nxmap.gt.1) then
        dx=(xmapmax-xmapmin)/(nxmap-1)
        x=xmapmin-dx
      else
        xmapmin=(xmapmax+xmapmin)/2.0d0
        dx=0.0d0
      endif

      if (nymap.gt.1) then
        dy=(ymapmax-ymapmin)/(nymap-1)
        y=ymapmin-dy
      else
        ymapmin=(ymapmax+ymapmin)/2.0d0
        dy=0.0d0
      endif

      if (nzmap.gt.1) then
        dz=(zmapmax-zmapmin)/(nzmap-1)
        z=zmapmin-dz
      else
        zmapmin=(zmapmax+zmapmin)/2.0d0
        dz=0.0d0
      endif

      if (kbextern.ne.0) then
        bxexint=bxex*(xmapmax-xmapmin)
        byexint=byex*(xmapmax-xmapmin)
        bzexint=bzex*(xmapmax-xmapmin)
      endif

      if (idipoles.ne.0) then
        call util_zeit_kommentar(lun6,"Calculating dipole map")
        do ix=1,nxmap
          x=xmapmin+(ix-1)*dx
          xintd(ix)=x
          call undumag_dipoles_field(x/1000.0d0,0.0d0,0.0d0,
     &      bxad(ix),byad(ix),bzad(ix),ifail)
          if (ifail.gt.0) then
            write(lun6,*)"Undumag_dipoles_field returned failure for on-axis field at point ",
     &        ix,x,y,z
          endif
        enddo
      endif !(idipoles.ne.0) then

      if (intmaglis.ne.0) then

        if (idipoles.ne.0) then
          do kmag=1,ndipoles
            if (dipoles(8,kmag).ne.0.0d0) then
              if (dipoles(8,kmag).eq.2.0d0) then
                dipoles(4,kmag)=-dipoles(4,kmag)
              endif
            else
              dipoles(8,kmag)=-1.0d0
            endif
          enddo
        endif !(idipoles.ne.0) then

        do kmag=1,nmag
          if (bpebc(17,kmag).ne.0.0d0) then
            if (bpebc(17,kmag).eq.2.0d0) then
              bpebc(4:6,kmag)=-bpebc(4:6,kmag)
              if(bpebc(8,kmag).eq.1) then !not rectangular nor cylindrical magnet
                vmaglab(1:3)=bpebc(4:6,kmag)
                nplan=iabs(ibpeplan(kmag))
                do iplan=1,nplan
                  bpetm(1,7,iplan,kmag)=
     &              vmaglab(1)*bpetm(1,8,iplan,kmag)+
     &              vmaglab(2)*bpetm(2,8,iplan,kmag)+
     &              vmaglab(3)*bpetm(3,8,iplan,kmag)
                enddo
              endif
            endif
          else
            bpebc(17,kmag)=-1.0d0
          endif
        enddo
      endif

      x=xmapmin-dx
      ixon=0
      ixonnor=0
      irecover=0
      itry=0

      call util_zeit_kommentar(lun6,"Calculating on-axis field")

      do ix=1,nxmap
        idis=0
11      x=xmapmin+(ix-1)*dx
        ! to avoid boundary effects:
        call util_random(3,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif

        if (itry.eq.0.and.randoz.gt.0.0d0) g=0.

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        xint(ix)=x

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif

        if (randoz.ge.0.0d0) then
          z=g(3)*randoza
        else
          z=randoza
        endif

        ifail=0
        kkfail=0

        if (itry.eq.0) ifail=-1

        call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &    bxa(ix),bya(ix),bza(ix),ifail)

        if (itry.eq.0.and.ifail.eq.-1) then
          ifail=0
        endif

        if (ifail.ne.0) kkfail=ifail

        b=sqrt(bxa(ix)**2+bya(ix)**2+bza(ix)**2)

        ifail77=0

        if (ix.gt.2) then
          call util_parabel(xint(ix-2),bxa(ix-2),
     &      a,yp,xopt,yopt,kfail)
          if (kfail.eq.0) then
            bx=a(1)+a(2)*x+a(3)*x*x
          else
            ifail77=77
          endif
          if (ifail.ne.0) kkfail=ifail
          call util_parabel(xint(ix-2),bya(ix-2),
     &      a,yp,xopt,yopt,kfail)
          if (kfail.eq.0) then
            by=a(1)+a(2)*x+a(3)*x*x
          else
            ifail77=77
          endif
          if (ifail.ne.0) kkfail=ifail
          call util_parabel(xint(ix-2),bza(ix-2),
     &      a,yp,xopt,yopt,kfail)
          if (kfail.eq.0) then
            bz=a(1)+a(2)*x+a(3)*x*x
          else
            ifail77=77
          endif
          if (ifail.ne.0) kkfail=ifail
          bprog=sqrt(bx*bx+by*by+bz*bz)
          if (bprog.gt.1.0d-9.and.abs((b-bprog)/(b+bprog)).gt.rcvthron) then
            ifail77=77
          endif
        endif

        if (bprog.gt.1.0d-9.and.ifail77.eq.77.and.idis.eq.0) then
          write(lun6,*)"Discontinuity or numerical problems for on-axis field discovered, check rcvthron, x, dB, randox etc."
          write(lun6,*)"x, B, Bexpected, dB:",x,b,bprog,abs((b-bprog)/(b+bprog))
          idis=1
        endif

        if (ifail.ne.0.and.itry.lt.10) then
          itry=itry+1
          goto 11
        endif
        itry=0

        if (ifail.gt.0) then
          write(lun6,*)"Undumag_field returned failure for on-axis field at point ",
     &      ix,x,y,z
        else
          if (ifail.lt.0) then
            irecover=irecover+1
          endif
          ixon=ixon+1
          kfailon(ixon)=ifail
          if (ifail.eq.0) then
            ixonnor=ixonnor+1
            xintnor(ixonnor)=xint(ix)
            bxanor(ixonnor)=bxa(ix)
            byanor(ixonnor)=bya(ix)
            bzanor(ixonnor)=bza(ix)
          endif
          xint(ixon)=xint(ix)
          bxa(ixon)=bxa(ix)
          bya(ixon)=bya(ix)
          bza(ixon)=bza(ix)
        endif
      enddo !ix

      if (irecover.ne.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_end:  On-axis field calculations with ",irecover, " recovered errors ***"
        write(lun6,*)
c        do ix=1,ixon
c          if (kfailon(ix).ne.0) then
c            write(lun6,*)ix,xint(ix),bya(ix),bza(ix)
c          endif
c        enddo
c        write(lun6,*)
      endif
      if (ixon.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_end: No field data on-axis calculated ***"
        write(lun6,*)
      endif

      if (ixonnor.gt.1) then

        if (isimpson.eq.0) then
          call util_spline_running_integral(xintnor,byanor,ixonnor,byintnor,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xintnor,bzanor,ixonnor,bzintnor,coef,
     &      ws1,ws2,ws3,ws4)

          call util_spline_running_integral(xintnor,byintnor,ixonnor,
     &      byint2nor,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xintnor,bzintnor,ixonnor,
     &      bzint2nor,coef,
     &      ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixonnor,xintnor,byanor,byintnor)
          call util_simpson_running_integral(ixonnor,xintnor,bzanor,bzintnor)
          call util_simpson_running_integral(ixonnor,xintnor,byintnor,byint2nor)
          call util_simpson_running_integral(ixonnor,xintnor,bzintnor,bzint2nor)
        endif

      endif

      if (ixon.gt.1) then

        if (isimpson.eq.0) then
          call util_spline_running_integral(xint,bya,ixon,byint,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xint,bza,ixon,bzint,coef,
     &      ws1,ws2,ws3,ws4)

          call util_spline_running_integral(xint,byint,ixon,byint2,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xint,bzint,ixon,bzint2,coef,
     &      ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixon,xint,bya,byint)
          call util_simpson_running_integral(ixon,xint,bza,bzint)
          call util_simpson_running_integral(ixon,xint,byint,byint2)
          call util_simpson_running_integral(ixon,xint,bzint,bzint2)
        endif

      endif !ixon

      if (idipoles.ne.0) then
        if (nxmap.gt.0.and.maxiter.gt.0) then
          if (isimpson.eq.0) then
            call util_spline_running_integral(xintd,byad,nxmap,byintd,coef,
     &        ws1,ws2,ws3,ws4)
            call util_spline_running_integral(xintd,bzad,nxmap,bzintd,coef,
     &        ws1,ws2,ws3,ws4)

            call util_spline_running_integral(xintd,byintd,nxmap,byint2d,coef,
     &        ws1,ws2,ws3,ws4)
            call util_spline_running_integral(xintd,bzintd,nxmap,bzint2d,coef,
     &        ws1,ws2,ws3,ws4)
          else
            call util_simpson_running_integral(nxmap,xintd,byad,byintd)
            call util_simpson_running_integral(nxmap,xintd,bzad,bzintd)
            call util_simpson_running_integral(nxmap,xintd,byintd,byint2d)
            call util_simpson_running_integral(nxmap,xintd,bzintd,bzint2d)
          endif
        endif !nxmap
      endif !(idipoles.ne.0) then

      byplmin=1.0e30
      byplmax=-1.0e30
      byiplmin=1.0e30
      byiplmax=-1.0e30
      byiiplmin=1.0e30
      byiiplmax=-1.0e30
      bzplmin=1.0e30
      bzplmax=-1.0e30
      bziplmin=1.0e30
      bziplmax=-1.0e30
      bziiplmin=1.0e30
      bziiplmax=-1.0e30

c Calculate on-axis field{
      open(newunit=lun,file="undumag_on-axis.dat")

      if (ixon.gt.1) then

        do ix=1,ixon
          if (bza(ix).lt.bzplmin) bzplmin=sngl(bza(ix))
          if (bza(ix).gt.bzplmax) bzplmax=sngl(bza(ix))
          if (bzint(ix).lt.bziplmin) bziplmin=sngl(bzint(ix))
          if (bzint(ix).gt.bziplmax) bziplmax=sngl(bzint(ix))
          if (bzint2(ix).lt.bziiplmin) bziiplmin=sngl(bzint2(ix))
          if (bzint2(ix).gt.bziiplmax) bziiplmax=sngl(bzint2(ix))
          if (bya(ix).lt.byplmin) byplmin=sngl(bya(ix))
          if (bya(ix).gt.byplmax) byplmax=sngl(bya(ix))
          if (byint(ix).lt.byiplmin) byiplmin=sngl(byint(ix))
          if (byint(ix).gt.byiplmax) byiplmax=sngl(byint(ix))
          if (byint2(ix).lt.byiiplmin) byiiplmin=sngl(byint2(ix))
          if (byint2(ix).gt.byiiplmax) byiiplmax=sngl(byint2(ix))
          write(lun,'(7(1pe17.7e3)," ",I10)')xint(ix),
     &      bya(ix),bza(ix),
     &      byint(ix),bzint(ix),
     &      byint2(ix),bzint2(ix),kfailon(ix)
        enddo

      else !ixon
        write(lun,*) "0. 0. 0. 0. 0. 0. 0. 0."
      endif !ixon

      flush(lun)
      close(lun)

c Calculate on-axis field}

      if (idipoles.ne.0) then

        open(newunit=lun,file="undumag_on-axis_dipoles.dat")

        if (nxmap.gt.1) then

          do ix=1,nxmap
            write(lun,'(10(1pe17.7e3))')xintd(ix),
     &        byad(ix),bzad(ix),
     &        byintd(ix),bzintd(ix),
     &        byint2d(ix),bzint2d(ix)
          enddo

        else !ixon
          write(lun,*) "0. 0. 0. 0. 0. 0. 0."
        endif !ixon

        flush(lun)
        close(lun)

      endif !(idipoles.ne.0) then

c Calculate field map{

      call util_zeit_kommentar(lun6,"Calculating field map")

      open(newunit=lun,file="undumag.map")

      if (knointmap.eq.0) then
        open(newunit=luni,file="undumag_integral.map")
        call util_zeit_kommentar(lun6,"Writing undumag.map and undumag_integral.map")
      else
        call util_zeit_kommentar(lun6,"Writing undumag.map")
      endif

      if (kmapnohead.eq.0) then

        call util_time_and_date(chtime)

        if (kmapmode.eq.0) then
          write(lun,'(a)') '* ' // trim(ctitle)
          write(lun,'(a)')"* " // trim(chtime)
          write(lun,'(a)')"* imoth imag mat ityp matmod x/mm y/mm z/mm Bx/T By/T Bz/T B/T Hx/T Hy/T Hz/T H/T Mx/T My/T Mz/T M/T BxDip/T ByDip/T BzDip/T ifail kfail cmag cmoth"
        else
          write(lun,'(a)') '* ' // trim(ctitle)
          write(lun,'(a)')"* " // trim(chtime)
          write(lun,'(a)')"* x/mm y/mm z/mm Bx/T By/T Bz/T ifail kfail"
          write(lun,'(a)')"* scaling = 0.001 0.001 0.001 1.0 1.0 1.0 for WAVE"
        endif

        if (knointmap.eq.0) then
          write(luni,'(a)')"* xi/mm xe/mm y/mm z/mm ByInt1/Tmm BzInt1/Tmm ByInt2/Tmm**2 BzInt2/Tmm**2"
        endif

      endif

      if (nxmap*nymap*nzmap.le.0) then
        x=0.0d0
        y=0.0d0
        z=0.0d0
        bx=0.0d0
        by=0.0d0
        bz=0.0d0
        b=0.0d0
        hx=0.0d0
        hy=0.0d0
        hz=0.0d0
        h=0.0d0
        bcx=0.0d0
        bcy=0.0d0
        bcz=0.0d0
        bc=0.0d0
        if (kmapmode.eq.0) then
          write(lun,*)"0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 '' '' "
        else
          write(lun,*)"0.0 0.0 0.0 0.0 0.0 0.0"
        endif

      else !(nxmap*nymap*nzmap.le.0) then

        irecover=0
        x=xmapmin-dx
        itry=0
        kkfail=0

        if (knointmap.eq.0) then
          allocate(xinti(nxmap),byai(nxmap),bzai(nxmap),
     &      byinti(nxmap),bzinti(nxmap),
     &      bmap(4,nxmap,nymap,nzmap),
     &      byint2i(nxmap),bzint2i(nxmap)
     &      )
        endif

        kmag=0
        do ix=1,nxmap
          x=x+dx
          y=ymapmin-dy
          do iy=1,nymap
            y=y+dy
            z=zmapmin-dz
            do iz=1,nzmap
              z=z+dz
              if (knomagmap.eq.0.or.knopolmap.eq.0) then
                kinside=-1
              else
                kinside=0
              endif
14            call util_random(3,g)
              g=g-0.5
              if (abs(g(1)).lt.randox10) then
                if (g(1).gt.0.0d0) then
                  g(1)=g(1)+randox10
                else
                  g(1)=g(1)-randox10
                endif
              endif
              if (abs(g(2)).lt.randoy10) then
                if (g(2).gt.0.0d0) then
                  g(2)=g(2)+randoy10
                else
                  g(2)=g(2)-randoy10
                endif
              endif
              if (abs(g(3)).lt.randoz10) then
                if (g(3).gt.0.0d0) then
                  g(3)=g(3)+randoz10
                else
                  g(3)=g(3)-randoz10
                endif
              endif
              if (itry.eq.0.and.randoz.gt.0.0d0) g=0.
              if (randox.ge.0.0d0) then
                xx=x+g(1)*randoxa ! millimeter!
              else
                xx=x+randoxa ! millimeter!
              endif
              if (randoy.ge.0.0d0) then
                yy=y+g(2)*randoya
              else
                yy=y+randoya
              endif
              if (randoz.ge.0.0d0) then
                zz=z+g(3)*randoza
              else
                zz=z+randoza
              endif
              if (angmaprotx.ne.0.0d0) then
                yr=yy-cenmaprotxy
                zr=zz-cenmaprotxz
                cosa=cos(angmaprotx)
                sina=sin(angmaprotx)
                zz=cosa*zr-sina*yr+cenmaprotxz
                yy=sina*zr+cosa*yr+cenmaprotxy
              endif
c              if (ix.eq.70) iseqdebug=1

              ifail=0
              if (itry.eq.0) ifail=-1

              call undumag_field(xx/1000.0d0,yy/1000.0d0,zz/1000.0d0,
     &          hx,hy,hz,ifail)

              if (itry.eq.0.and.ifail.eq.-1) then
                ifail=0
              endif

              if (ifail.ne.0) kkfail=ifail
              if (ifail.eq.-20000) ifail=0 ! inside magnet
              if (ifail.ne.0.and.itry.lt.10) then
                itry=itry+1
                goto 14
              endif
              itry=0
              if (ifail.gt.0) then
                write(lun6,*)"Undumag_field returned failure at point: ",xx,yy,zz
              else if (ifail.lt.0) then
                irecover=irecover+1
              endif
c              write(lun6,*)"field:",ix,iy,iz
              if (idipoles.ne.0) then
                call undumag_dipoles_field(xx/1000.0d0,yy/1000.0d0,zz/1000.0d0,
     &            bdx,bdy,bdz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)"Undumag_dipoles_field returned failure at point: ",
     &              xx,yy,zz
                endif !(idipoles.ne.0) then
              else if (ifail.lt.0) then
                irecover=irecover+1
              endif

              if (kinside.gt.0) then
                kmag=kinside
                mat=nint(bpebc(9,kmag))
                imoth=nint(bpebc(15,kmag))
                bcx=bpebc(4,kmag)
                bcy=bpebc(5,kmag)
                bcz=bpebc(6,kmag)
                matmap2=matmaps(2,mat)
                matmap3=matmaps(3,mat)
              else !kinside
                imoth=0
                kmag=0
                mat=0
                matmap2=0
                matmap3=0
                bcx=0.0d0
                bcy=0.0d0
                bcz=0.0d0
              endif !kinside

              bx=hx+bcx
              by=hy+bcy
              bz=hz+bcz
              b=sqrt(bx*bx+by*by+bz*bz)
              h=sqrt(hx*hx+hy*hy+hz*hz)
              bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

              if (iforcegrid.ne.0) then
                xx=x
                yy=y
                zz=z
              endif

              cmag='none'
              cmoth='none'

              if (kmapmode.eq.0) then
                if (kmag.gt.0) then
                  if (newclc.eq.0) then
                    write(cmag,'(a)') chmags(:,kmag)
                    write(cmoth,'(a)') chmoths(:,imoth)
                  else
                    cmag=t_magnets(kmag)%cnam
                    cmoth=t_magnets(kmag)%cmoth
                  endif
                endif
                write(lun,*)
     &            imoth,kmag,mat,matmap2,matmap3,
     &            sngl(xx),sngl(yy),sngl(zz),
     &            sngl(bx),sngl(by),sngl(bz),sngl(b),
     &            sngl(hx),sngl(hy),sngl(hz),sngl(h),
     &            sngl(bcx),sngl(bcy),sngl(bcz),sngl(bc),
     &            sngl(bdx),sngl(bdy),sngl(bdz),
     &            ifail,kkfail,trim(cmag),' ',trim(cmoth)
              else
                write(lun,*)
     &            sngl(xx),sngl(yy),sngl(zz),sngl(bx),sngl(by),sngl(bz),ifail,kkfail
              endif
              if (knointmap.eq.0) then
                bmap(1,ix,iy,iz)=x
                bmap(2,ix,iy,iz)=by
                bmap(3,ix,iy,iz)=bz
                bmap(4,ix,iy,iz)=ifail
               endif
            enddo !nzmap
          enddo !nymap
        enddo !nxmap

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif
      endif !(nxmap*nymap*nzmap.le.0) then

      kinside=-1
      if (knomagmap.eq.0) then
        irecover=0
        do kmag=1,nrec

          !x1y1z1
          imoth=nint(bpebc(15,kmag))
          mat=nint(bpebc(9,kmag))
          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          x=bpebc(1,kmag) !mm
          y=bpebc(2,kmag) !mm
          z=bpebc(3,kmag) !mm
          bcx=bpebc(4,kmag)
          bcy=bpebc(5,kmag)
          bcz=bpebc(6,kmag)

          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,hx,hy,hz,ifail)
          if (ifail.gt.0) then
            write(lun6,*)"Undumag_field returned failure at point: ",x,y,z
          else if (ifail.lt.0) then
            irecover=irecover+1
          endif

          bx=hx+bcx
          by=hy+bcy
          bz=hz+bcz
          b=sqrt(bx*bx+by*by+bz*bz)
          h=sqrt(hx*hx+hy*hy+hz*hz)
          bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

          bdx=-9.0d0
          bdy=-9.0d0
          bdz=-9.0d0

          cmag='none'
          cmoth='none'

          if (kmapmode.eq.0) then
            if (kmag.gt.0) then
              if (newclc.eq.0) then
                write(cmag,'(a)') chmags(:,kmag)
                write(cmoth,'(a)') chmoths(:,imoth)
              else
                lmag=t_voxcopy(kmag)%kmagnet
                cmag=t_magnets(lmag)%cnam
                cmoth=t_magnets(lmag)%cmoth
              endif
            endif
            write(lun,*)
     &        imoth,kmag,mat,matmap2,matmap3,
     &        sngl(x),sngl(y),sngl(z),
     &        sngl(bx),sngl(by),sngl(bz),sngl(b),
     &        sngl(hx),sngl(hy),sngl(hz),sngl(h),
     &        sngl(bcx),sngl(bcy),sngl(bcz),sngl(bc),
     &        sngl(bdx),sngl(bdy),sngl(bdz),
     &        ifail,' 0 ',trim(cmag),' ',trim(cmoth)
          else
            write(lun,*)
     &        sngl(x),sngl(y),sngl(z),sngl(bx),sngl(by),sngl(bz)
          endif
        enddo ! kmag

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations inside magnets with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif

      endif !knomagmap

      if (knomagmap.eq.0) then

        irecover=0
        allocate(hmagvox(2,nrec))

        bcminrec=1.0e30
        bcmaxrec=-1.0e30
        hminrec=1.0e30
        hmaxrec=-1.0e30

        do kmag=1,nrec

          easy=bpebc(11:13,kmag)
          easyn=sqrt(easy(1)**2+easy(2)**2+easy(3)**2)

          imoth=nint(bpebc(15,kmag))

          mat=nint(bpebc(9,kmag))

          if (newclc.ne.0) then

            kbrn=0
            do ibrn=1,nbrnmat
              if (nint(brnmat(1,ibrn)).eq.mat) then
                kbrn=ibrn
                exit
              endif
            enddo

            if (kbrn.eq.0) then
              write(lun6,*)
              write(lun6,*)"*** Warning in undumag_end: Could not find REC material in list of Br ***"
              write(lun6,*)"*** Be careful with plots of magnetisation ***"
            endif

          else
            kbrn=1
          endif !newclc

          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          x=bpebc(1,kmag) !mm
          y=bpebc(2,kmag) !mm
          z=bpebc(3,kmag) !mm

          bcx=bpebc(4,kmag)
          bcy=bpebc(5,kmag)
          bcz=bpebc(6,kmag)
          bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,hx,hy,hz,ifail)

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_field returned failure at point: ",x,y,z
          else if (ifail.lt.0) then
            irecover=irecover+1
          endif

          h=(hx*easy(1)+hy*easy(2)+hz*easy(3))/easyn
          bc=(bcx*easy(1)+bcy*easy(2)+bcz*easy(3))/easyn

          write(lunmag,'(a,I5,1p5e12.4,2I5)')"1 ",matmap3,easy,h,bc,mat,kbrn

          hmagvox(1,kmag)=h
          hmagvox(2,kmag)=bc

          if (bc.lt.bcminrec) bcminrec=sngl(bc)
          if (bc.gt.bcmaxrec) bcmaxrec=sngl(bc)

          if (h.lt.hminrec) hminrec=sngl(h)
          if (h.gt.hmaxrec) hmaxrec=sngl(h)

        enddo ! kmag

        if (hmaxrec-hminrec.lt.1.0e-6) then
          hminrec=-2.0
          hmaxrec=0.0
        endif

        if (bcmaxrec-bcminrec.lt.1.0e-6) then
          bcminrec=0.0
          bcmaxrec=2.
        endif

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations inside magnets with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif

      endif !knomagmap

      hmaxiron=2.5

      if (knopolmap.eq.0) then

        irecover=0
        hmaxiron=0.0

        allocate(hmvoxel(2,niron))
        iron=0

        do kmag=nrec+1,nrec+niron

          iron=iron+1

          !x1y1z1
          imoth=nint(bpebc(15,kmag))

          mat=nint(bpebc(9,kmag))

          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          x=bpebc(1,kmag) !mm
          y=bpebc(2,kmag) !mm
          z=bpebc(3,kmag) !mm

          bcx=bpebc(4,kmag)
          bcy=bpebc(5,kmag)
          bcz=bpebc(6,kmag)

          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,hx,hy,hz,ifail)

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_field returned failure at point: ",x,y,z
          else if (ifail.lt.0) then
            irecover=irecover+1
          endif

          bx=hx+bcx
          by=hy+bcy
          bz=hz+bcz
          b=sqrt(bx*bx+by*by+bz*bz)
          h=sqrt(hx*hx+hy*hy+hz*hz)
          bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

          bdx=-9.0d0
          bdy=-9.0d0
          bdz=-9.0d0

          if (matmap2.eq.2) then
            hmvoxel(1,iron)=h
            hmvoxel(2,iron)=bc
            if (h.gt.hmaxiron) hmaxiron=sngl(h)
          endif

          cmag='none'
          cmoth='none'

          if (kmapmode.eq.0) then

            if (kmag.gt.0) then
              if (newclc.eq.0) then
                write(cmag,'(a)') chmags(:,kmag)
                write(cmoth,'(a)') chmoths(:,imoth)
              else
                lmag=t_voxcopy(kmag)%kmagnet
                cmag=t_magnets(lmag)%cnam
                cmoth=t_magnets(lmag)%cmoth
              endif
            endif

            write(lun,*)
     &        imoth,kmag,mat,matmap2,matmap3,
     &        sngl(x),sngl(y),sngl(z),
     &        sngl(bx),sngl(by),sngl(bz),sngl(b),
     &        sngl(hx),sngl(hy),sngl(hz),sngl(h),
     &        sngl(bcx),sngl(bcy),sngl(bcz),sngl(bc),
     &        sngl(bdx),sngl(bdy),sngl(bdz),
     &        ifail,' 0 ',trim(cmag),' ',trim(cmoth)
          else
            write(lun,*)
     &        sngl(x),sngl(y),sngl(z),sngl(bx),sngl(by),sngl(bz)
          endif
        enddo ! kmag

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations inside iron with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif

      endif !knopolmap

      if (knointmap.eq.0) then

        do iy=1,nymap
          do iz=1,nzmap
            yint=ymapmin+(iy-1)*dy
            zint=zmapmin+(iz-1)*dz
            kx=0
            do ix=1,nxmap
              if (bmap(4,ix,iy,iz).ne.0.0d0) cycle
              kx=kx+1
              xinti(kx)=bmap(1,ix,iy,iz)
              byai(kx)=bmap(2,ix,iy,iz)
              bzai(kx)=bmap(3,ix,iy,iz)
            enddo !ix
            if (kx.gt.1.and.knointmap.eq.0) then
              if (isimpson.eq.0) then
                call util_spline_running_integral(xinti,byai,kx,byinti,coef,
     &            ws1,ws2,ws3,ws4)
                call util_spline_running_integral(xinti,bzai,kx,bzinti,coef,
     &            ws1,ws2,ws3,ws4)
                call util_spline_running_integral(xinti,byinti,kx,byint2i,coef,
     &            ws1,ws2,ws3,ws4)
                call util_spline_running_integral(xinti,bzinti,kx,bzint2i,coef,
     &            ws1,ws2,ws3,ws4)
              else
                call util_simpson_running_integral(kx,xinti,byai,byinti)
                call util_simpson_running_integral(kx,xinti,bzai,bzinti)
                call util_simpson_running_integral(kx,xinti,byinti,byint2i)
                call util_simpson_running_integral(kx,xinti,bzinti,bzint2i)
              endif
              write(luni,'(8(1pe17.7e3))')xinti(1),xinti(kx),yint,zint,
     &          byinti(kx),bzinti(kx),byint2i(kx),bzint2i(kx)
            endif !kx
          enddo !iz
        enddo !iy

        flush(luni)
        close(luni)

        flush(lun)
        close(lun)

      endif !knointmap

c Calculate field map}

      call util_zeit_kommentar(lun6,"Writing undumag_mh_rec.eps")
+self,if=debugend.
      !call util_break
+self.
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_mh_rec.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

c{ Plot Magnetization of magnets

      if (nmag.gt.0) then

        xplmin=hminrec
        xplmax=hmaxrec
        yplmin=bcminrec
        yplmax=bcmaxrec

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        xplmin=xplmin-0.1*dxpl
        xplmax=xplmax+0.1*dxpl
        yplmin=yplmin-0.1*dypl
        yplmax=yplmax+0.1*dypl

        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'H [T]','M [T]',' ')
        call mshplt_set_marker_size(0.25)

        call mgset('PLCI',4.)

        xpl(1)=hminrec
        xpl(2)=hmaxrec

        do ibrn=1,nbrnmat
          mat=nint(brnmat(1,ibrn))
          brn=sngl(abs(brnmat(2,ibrn)))
          matmap2=matmaps(2,mat)
          if (matmap2.eq.1) then
            ypl(1)=brn+sngl(bcmat(2,1,mat))*xpl(1)
            ypl(2)=brn+sngl(bcmat(2,1,mat))*xpl(2)
            call mpl(2,xpl,ypl)
          else if (matmap2.eq.2) then
            ypl(1)=brn+sngl(bcmat(3,1,mat))*xpl(1)
            ypl(2)=brn+sngl(bcmat(3,1,mat))*xpl(2)
            call mpl(2,xpl,ypl)
          endif

        enddo !nbrnmat

        call mgset('PLCI',2.)

        if (knomagmap.eq.0) then
          do kmag=1,nrec
            xpl(1)=sngl(hmagvox(1,kmag))
            ypl(1)=sngl(hmagvox(2,kmag))
            call mpm(1,xpl,ypl)
          enddo
        endif

        call muwk(0,0)
        call mshplt_end

      endif !nmag
c} Plot Magnetization of magnets

      if (niron.gt.0.and.(nmag+ncwires+nrace.gt.0.or.kbextern.gt.0)) then

        call util_zeit_kommentar(lun6,"Writing undumag_mh_iron.eps")
        call mshplt_init(20,15.,15.,25,25,600,600,
     &    'undumag_mh_iron.eps','','',0.)

+self,if=debugend.
      !call util_break
+self.
        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif
        if (krunnum.ne.0) then
          write(ctitle,*)kundurun
          call util_string_trim(ctitle,nfirst,nlast)
          ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
        else
          ctitle=trim(usercom)
        endif

        if (kcomment.ne.0) call mtitle(trim(ctitle))
        call mshplt_hplset('YGTI',-0.5)

c{ Plot Magnetization of iron

        gsiz_ps=0.4

        xplmin=0.0
        xplmax=0.005
        yplmin=0.0
        yplmax=2.5

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mshplt_set_pad(3.5,10.,4.,18.)
        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'H [T]','M [T]',' ')
        call mshplt_set_marker_size(0.25)

        call mgset('PLCI',4.)

        do imat=1,nmatfiles

          if (matmaps(2,imat).eq.1) cycle

          mat=matmaps(1,imat)
          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          if (matmap3.eq.0) cycle

          if (matmap3.eq.0) then
            xpl(1)=sngl(xplmin)
            xpl(2)=sngl(xplmax)
            ypl(1:2)=sngl(bcmat(2,1,mat))
            call mpl(2,xpl,ypl)
          else
            do i=1,matmaps(4,mat)-1
              xpl(1:2)=sngl(feh1(i:i+1))
              ypl(1:2)=sngl(fem1(i:i+1))
              call mpl(2,xpl,ypl)
            enddo
          endif

        enddo !imat

        call mgset('PLCI',2.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            easy=0.0
            write(lunmag,'(a,i5,1p5e12.4,2I5)')
     &        "2 ",matmap3,easy,xpl(1),ypl(1),mat, mat*0
            if (matmap3.eq.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
c            if (xpl(1).lt.0.01) then
              call mpm(1,xpl,ypl)
c            else
c              print*,"holla hmvoxel"
c            endif
          enddo
        endif

        call mgset('PLCI',3.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            if (matmap3.ne.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
c            if (xpl(1).lt.0.01) then
              call mpm(1,xpl,ypl)
c            else
c              print*,"holla hmvoxel"
c            endif
            easy=0
            write(lunmag,'(a,i5,1p5e12.4,2I5)')
     &        "2 ",matmap3,easy,xpl(1),ypl(1),mat,mat*0
          enddo
        endif

        call muwk(0,0)

        xplmin=0.0
        xplmax=hmaxiron
        if (hmaxiron.eq.0.0d0) then
          xplmax=sngl(feh1(matmaps(4,2)))
        endif
        yplmin=0.0
        yplmax=2.5

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mshplt_set_pad(12.5,19.,4.,18.)
        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'H [T]','M [T]',' ')

        call mgset('PLCI',4.)
        if (matmap2.eq.0) then
          ypl(1:2)=sngl(bcmat(2,1,2))
          call mpl(2,xpl,ypl)
        else
          do i=1,matmaps(4,2)-1
            xpl(1:2)=sngl(feh1(i:i+1))
            ypl(1:2)=sngl(fem1(i:i+1))
            call mpl(2,xpl,ypl)
          enddo
        endif

        call mgset('PLCI',2.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            if (matmap3.eq.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
            if (xpl(1).lt.0.01) call mpm(1,xpl,ypl)
          enddo
        endif

        call mgset('PLCI',3.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            if (matmap3.ne.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
            if (xpl(1).lt.0.01) call mpm(1,xpl,ypl)
          enddo
        endif

        call mgset('PLCI',2.)

        call muwk(0,0)
        call mshplt_end

      endif !(niron.gt.0) then

c} Magnetization of iron

c      write(lun6,*)"matrix:",matrix

      write(lun6,*)"Symmetries:"
      write(lun6,*)"ixsym, iysym, izsym, xsym:",ixsymo,iysymo,izsymo,xsym

      kinside=0
      write(lun6,*)
      write(lun6,*)"Conv. points and field H[T] there:"
c      iseqdebug=1
      do i=1,nxconv
        call undumag_field(xconv(i),yconv,zconv,hx,hy,hz,ifail)
        if (ifail.gt.0) then
          write(lun6,*)"Undumag_field returned unrecovered failure at convergence point: ",
     &      xconv(i)*1000.0,yconv*1000.0,zconv*1000.0
        endif
        write(lun6,'(a,i6,6g15.5)')" ",i,xconv(i)*1000.,yconv*1000.,zconv*1000.,
     &    hx,hy,hz
      enddo

      byint1fnor=0.0d0
      byint2fnor=0.0d0
      bzint1fnor=0.0d0
      bzint2fnor=0.0d0

      if (ixonnor.gt.1) then
        byint1fnor=byintnor(ixonnor)
        bzint1fnor=bzintnor(ixonnor)
        byint2fnor=byint2nor(ixonnor)
        bzint2fnor=bzint2nor(ixonnor)
      endif

      byint1f=0.0d0
      byint2f=0.0d0
      bzint1f=0.0d0
      bzint2f=0.0d0
      byint1fd=0.0d0
      byint2fd=0.0d0
      bzint1fd=0.0d0
      bzint2fd=0.0d0

      if (ixon.gt.1) then
        byint1f=byint(ixon)
        bzint1f=bzint(ixon)
        byint2f=byint2(ixon)
        bzint2f=bzint2(ixon)
      endif

      if (ixon.gt.1) then
        byint1fd=byintd(ixon)
        bzint1fd=bzintd(ixon)
        byint2fd=byint2d(ixon)
        bzint2fd=bzint2d(ixon)
      endif

      bxint1inf=0.0d0
      byint1inf=0.0d0
      bzint1inf=0.0d0
      byint1infd=0.0d0
      bzint1infd=0.0d0

      x=0.0d0
      y=0.0d0
      z=0.0d0

      if (maxiter.gt.0.and.nxmap.gt.0) then

        !call util_break
        call util_zeit_kommentar(lun6,"Writing undumag_integrals_inf.map")

        open(newunit=luninf,file="undumag_integrals_inf.map")
        write(luninf,'(a)')"* y/mm z/mm ByInt1/Tmm BzInt1/Tmm ByInt1_Dip/Tmm BzInt1_Dip/Tmm"

        y=ymapmin-dy
        do iy=1,nymap

          y=y+dy
          z=zmapmin-dz

          do iz=1,nzmap
            z=z+dz

            y=y/1000.0d0
            z=z/1000.0d0

            bxint1inf=0.0d0
            byint1inf=0.0d0
            bzint1inf=0.0d0

            byint1infd=0.0d0
            bzint1infd=0.0d0

            if (idipoles.ne.0) then
              do kmag=1,nmag
                if (bpebc(17,kmag).lt.0.0d0) cycle
                call undumag_dipoles_int(kmag,y,z,byi,bzi,ifail)
                if (ifail.ne.0) then
                  write(lun6,*)"*** Error in undumag_end: Bad return from undumag_dipoles_int ***"
                endif
                byint1infd=byint1infd+byi
                bzint1infd=bzint1infd+bzi
              enddo !nmag
            endif !(idipoles.ne.0) then

            x=0.0d0

            call undumag_bintinf_sym(0.0d0,y,z,1.0d0,0.0d0,0.0d0,
     &        bxint1inf,byint1inf,bzint1inf,ifail)

            if (ifail.ne.0) then
              write(lun6,*)
              write(lun6,*)"*** Warning in undumag_end: Bad return from undumag_bintinf_sym ***"
              write(lun6,*)"*** y,z:",y,z," ***"
            endif

            y=y*1000.0d0
            z=z*1000.0d0

            write(luninf,'(6(1pe17.7e3))')y,z,
     &        byint1inf*1000.0d0,bzint1inf*1000.0d0,
     &        byint1infd*1000.0d0,bzint1infd*1000.0d0

          enddo !iz
        enddo !iy

        flush(luninf)
        close(luninf)

        bxint1inf=0.0d0
        byint1inf=0.0d0
        bzint1inf=0.0d0

        byint1infd=0.0d0
        bzint1infd=0.0d0

        x=0.0d0 !m
        y=0.0d0 !m
        z=0.0d0 !m

        call undumag_bintinf_sym(x,y,z,1.0d0,0.0d0,0.0d0,
     &    bxint1inf,byint1inf,bzint1inf,ifail)
        if (ifail.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end: Bad return from undumag_bintinf_sym ***"
          write(lun6,*)"*** y,z:",y,z," ***"
        endif

        if (idipoles.ne.0) then

          do kmag=1,ndipoles

            y2z2=dipoles(2,kmag)**2+dipoles(3,kmag)**2
            py=dipoles(6,kmag)*dipoles(4,kmag)
            pz=dipoles(7,kmag)*dipoles(4,kmag)
            pryz=py*dipoles(2,kmag)+pz*dipoles(3,kmag)

            if (y2z2.ne.0.0d0) then
              byint1infd=byint1infd
     &          +3.0d0*pryz*dipoles(2,kmag)*2.0d0/3.0d0/y2z2**2*2.0d0
     &          -2.0d0/y2z2*py
              bzint1infd=bzint1infd
     &          +3.0d0*pryz*dipoles(3,kmag)*2.0d0/3.0d0/y2z2**2*2.0d0
     &          -2.0d0/y2z2*pz
            else
              write(lun6,*)"*** Error in undumag_end: Integration of dipole fields fails, since distance to dipole is zero for dipole",
     &          kmag," ***"
            endif
          enddo
        endif !(idipoles.ne.0) then

      endif !(maxiter.gt.1) then

      bxint1inf=bxint1inf*1000.0d0
      byint1inf=byint1inf*1000.0d0
      bzint1inf=bzint1inf*1000.0d0

      write(lun6,*)
      write(lun6,*)"Initial and final damping factors for relaxation of iron:",
     &  sngl(dampi),sngl(damp8)
      write(lun6,*)
      write(lun6,*)"Maximum iteration used for Chi(H) for iron:",nchimax
      write(lun6,*)
      write(lun6,*) "1. Integrals ByI  and BzI  in [Tmm]:  ",
     &  sngl(byint1f),sngl(bzint1f)
      byif=byint1f
      bzif=bzint1f
      write(lun6,*) "1. Integrals ByI  and BzI  in [Tmm], without recovered points:  ",
     &  sngl(byint1fnor),sngl(bzint1fnor)
      write(lun6,*) "1. Integrals ByI and BzI [Tmm], analytically,"
      write(lun6,*) "NOT including external field:  ",
     &  sngl(byint1inf),sngl(bzint1inf)

      if (idipoles.ne.0) then
        write(lun6,*) "1. Integrals ByI  and BzI  in [Tmm] for dipole approx.:  ",
     &    sngl(byint1fd),sngl(bzint1fd)
        write(lun6,*) "1. Integrals ByI and BzI [Tmm], analytically, dipole approx.,"
        write(lun6,*) "NOT including external field:  ",
     &    sngl(byint1infd),sngl(bzint1infd)
      endif !(idipoles.ne.0) then

      write(lun6,*)
      write(lun6,*) "External field [T]:",sngl(bxex),sngl(byex),sngl(bzex)
      write(lun6,*) "1. Integrals ByI and BzI [Tmm] of external field:  ",
     &  sngl(byexint),sngl(bzexint)

      write(lun6,*)
      write(lun6,*) "2. Integrals ByII and BzII in [Tmm**2]: ",
     &  sngl(byint2f),sngl(bzint2f)
      write(lun6,*) "2. Integrals ByII and BzII in [Tmm**2], without recovered points: ",
     &  sngl(byint2fnor),sngl(bzint2fnor)

      if (idipoles.ne.0) then
        write(lun6,*) "2. Integrals ByII and BzII in [Tmm**2] for dipole approx.: ",
     &    sngl(byint2fd),sngl(bzint2fd)
        write(lun6,*)
      endif !(idipoles.ne.0) then

      write(lun6,*)
      dx=xint(nxmap)-xint(1)
      if (nxmap.gt.1) then
        write(lun6,*)"Range of integration and step size:",xint(1),xint(nxmap),dx/(nxmap-1)
      else
        write(lun6,*)"Range of integration and step size:",xint(1),xint(nxmap)," 0.0"
      endif
      write(lun6,*)"By and Bz there:",
     &  sngl(bya(1)),sngl(bza(1)),sngl(bya(nxmap)),sngl(bza(nxmap))
      write(lun6,*)"By*x-range and Bz*x-range there:",
     &  sngl(bya(1)*dx),sngl(bza(1)*dx),sngl(bya(nxmap)*dx),sngl(bza(nxmap)*dx)
      write(lun6,*)

      call util_zeit_kommentar(lun6,"Writing undumag_on-axis_by_bz.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_on-axis_by_bz.eps','','',0.)

      if (ixon.gt.1) then

        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif
        if (krunnum.ne.0) then
          write(ctitle,*)kundurun
          call util_string_trim(ctitle,nfirst,nlast)
          ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
        else
          ctitle=trim(usercom)
        endif

        if (kcomment.ne.0) call mtitle(trim(ctitle))
        call mshplt_hplset('YGTI',-0.5)

c{ Plot By, Bz

        gsiz_ps=0.4

        xplmin=sngl(xmapmin)
        xplmax=sngl(xmapmax)
        yplmin=min(byplmin,bzplmin)
        yplmax=max(byplmax,bzplmax)
        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bya(ix))
          ypl(2)=sngl(bya(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('PLCI',4.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bza(ix))
          ypl(2)=sngl(bza(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mshplt_set_pad(4.,19.,3.,18.)

        call mshplt_set_text_angle(90.)
        call mshplt_text_ndc(-0.1,0.9,'B [T]')
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.85,-0.1,'x [mm]')

c        call mgset('CHHE',0.4)
c        call mshplt_set_text_angle(0.)
c        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
cc        call mtx(xplmax-dxpl*0.05,yplmin-dypl*0.175,'x [mm]')
c        call mshplt_set_text_angle(90.)
c        if (abs(yplmax).lt.1.0e-3) then
c          call mshplt_text_ndc(-0.1,0.86,'B [T]')
c        else
c          call mshplt_text_ndc(-0.1,0.88,'B [T]')
c        endif
c        call mtx(xplmin-dxpl*0.15,yplmax-dypl*0.05,'B [T]')
        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        call mshplt_text_ndc(0.85,0.9,'By')
        call mshplt_set_text_color(0,0,0,1)
        call mshplt_text_ndc(0.85,0.83,'Bz')
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)

        call muwk(0,0)
        call mshplt_end

      endif !ixon

c} Plot By, Bz

c{ Plot ByInt, BzInt

      call util_zeit_kommentar(lun6,"Writing undumag_on-axis_byint_bzint.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_on-axis_byint_bzint.eps','','',0.)
      if (kcomment.ne.0) call mtitle(trim(ctitle))
      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      call mshplt_hplset('YGTI',-0.5)

      if (ixon.gt.1) then

        call mgset('CHHE',0.3)
        call mshplt_set_text_color(1,0,0,0)
        gsiz_ps=0.4

        xplmin=sngl(xmapmin)
        xplmax=sngl(xmapmax)
        yplmin=min(byiplmin,bziplmin)
        yplmax=max(byiplmax,bziplmax)
        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin
        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(byint(ix))
          ypl(2)=sngl(byint(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('PLCI',4.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bzint(ix))
          ypl(2)=sngl(bzint(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('CHHE',0.4)
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
        call mshplt_set_text_angle(90.)
        call mshplt_text_ndc(-0.1,0.7,'1. Integral of B [Tmm]')
        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        cbint="1. Int By = "
        call mshplt_text_ndc(0.77,0.9,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') byint1f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') byint1f
        cbint(11:14)="Tmm"
        call mshplt_text_ndc(0.77,0.85,cbint)
        call mshplt_set_text_color(0,0,0,1)
        cbint="1. Int Bz = "
        call mshplt_text_ndc(0.77,0.80,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') bzint1f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') bzint1f
        cbint(11:14)="Tmm"
        call mshplt_text_ndc(0.77,0.75,cbint)
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)

      endif !ixon

      call muwk(0,0)
      call mshplt_end

c} Plot ByInt, BzInt

c{ Plot ByInt2, BzInt2

      call util_zeit_kommentar(lun6,"Writing undumag_on-axis_byint2_bzint2.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_on-axis_byint2_bzint2.eps','','',0.)
      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)
      gsiz_ps=0.4

      if (ixon.gt.1) then

        call mgset('CHHE',0.3)
        call mshplt_set_text_color(1,0,0,0)

        xplmin=sngl(xmapmin)
        xplmax=sngl(xmapmax)
        yplmin=min(byiiplmin,bziiplmin)
        yplmax=max(byiiplmax,bziiplmax)
        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin
        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(byint2(ix))
          ypl(2)=sngl(byint2(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('PLCI',4.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bzint2(ix))
          ypl(2)=sngl(bzint2(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('CHHE',0.4)
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
        call mshplt_set_text_angle(90.)
        call mshplt_text_ndc(-0.1,0.77,'2. Integral of B [Tmm^2]')
        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        cbint="2. Int By = "
        call mshplt_text_ndc(0.73,0.9,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') byint2f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') byint2f
        cbint(9:14)="Tmm^2"
        call mshplt_text_ndc(0.73,0.85,cbint)
        call mshplt_set_text_color(0,0,0,1)
        cbint="2. Int Bz = "
        call mshplt_text_ndc(0.73,0.80,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') bzint2f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') bzint2f
        cbint(9:14)="Tmm^2"
        call mshplt_text_ndc(0.73,0.75,cbint)
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)
      endif !ixon

      call muwk(0,0)
      call mshplt_end
c} Plot ByInt2, BzInt2

c Calculate beff{

      deallocate (xintnor)
      deallocate (bxanor)
      deallocate (byanor)
      deallocate (bzanor)
      deallocate (byintnor)
      deallocate (bzintnor)
      deallocate (byint2nor)
      deallocate (bzint2nor)
      deallocate (xint)
      deallocate (bxa)
      deallocate (bya)
      deallocate (bza)
      deallocate (byint)
      deallocate (bzint)
      deallocate (byint2)
      deallocate (bzint2)
      deallocate (ws1)
      deallocate (ws2)
      deallocate (ws3)
      deallocate (ws4)
      deallocate (coef)

      allocate (
     &  xintnor(nxbeff),
     &  byintnor(nxbeff),bzintnor(nxbeff),
     &  byint2nor(nxbeff),bzint2nor(nxbeff),
     &  bxanor(nxbeff),byanor(nxbeff),bzanor(nxbeff),
     &  xint(nxbeff),
     &  byint(nxbeff),bzint(nxbeff),
     &  byint2(nxbeff),bzint2(nxbeff),
     &  bxa(nxbeff),bya(nxbeff),bza(nxbeff),
     &  ws1(nxbeff),ws2(nxbeff),ws3(nxbeff),ws4(nxbeff),coef(nxbeff))

c      if (xbeff.eq.9999.0d0) xbeff=xconv(nxconv/2+1)
      if (xbeff.eq.9999.0d0) xbeff=xcenter
      if (xbeff.eq.-9999.0d0) xbeff=(xmapmin+xmapmax)/2.0d0

      xbeffo=xbeff

      halfperlen=perlen/2.0d0
      quadperlen=perlen/4.0d0

      bymaxbeff=-1.0d30
      bzmaxbeff=-1.0d30

      if (kbeffmode.eq.9999) then
        if (nper.gt.0) then
          kbeffmode=0
        else
          kbeffmode=1
        endif
      endif

      if (kbeffmode.eq.0) then
        xminbeff=xbeff-perlen*0.51
        xmaxbeff=xbeff+perlen*0.51
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
        dxkbmode=abs(kbeffmode)*dx
      else
        xminbeff=xbeff-quadperlen
        xmaxbeff=xbeff+quadperlen
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        dxkbmode=abs(kbeffmode)*dx
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
      endif

      xbymax=xbeff
      xbzmax=xbeff

      do ix=1,nxbeff

        x=xminbeff+(ix-1)*dx
        xx=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          cycle
        endif

        call util_random(3,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        xint(ix)=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          if (x.lt.xbeff) then
            x=xx+abs(xx-x)
          else
            x=xx-abs(xx-x)
          endif
        endif

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif
        if (randoz.ge.0.0d0) then
          z=g(3)*randoza
        else
          z=randoza
        endif

        if (kbeffmode.eq.0) then
          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &      bx,by,bz,ifail)
        else
          if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
            cycle
          endif
          if (abs(x-xbeff).le.quadperlen) then
            call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
          else if (x.lt.xbeff) then
            call undumag_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          else
            call undumag_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          endif
        endif !kbeffmode

        if (ifail.ne.0) cycle

        if (abs(by).gt.bymaxbeff) then
          bymaxbeff=abs(by)
          xbymax=xminbeff+(ix-1)*dx
        endif

        if (abs(bz).gt.bzmaxbeff) then
          bzmaxbeff=abs(bz)
          xbzmax=xminbeff+(ix-1)*dx
        endif

      enddo !ix

      if (bymaxbeff.lt.1.0d-4*bzmaxbeff) xbymax=xbzmax
      if (bzmaxbeff.lt.1.0d-4*bymaxbeff) xbzmax=xbymax

      call undumag_beffy_beffz(
     &  byint1f,bzint1f,
     &  byint2f,bzint2f,
     &  byint1inf,bzint1inf,
     &  byint1fnor,bzint1fnor,
     &  byint2fnor,bzint2fnor,
     &  byexint,bzexint)

      if (idipoles.ne.0) then

        call util_zeit_kommentar(lun6,"Writing undumag_bzeff_dipoles.dat")
        open(newunit=lun,file="undumag_bzeff_dipoles.dat")

        xbeff=xbzmax
        xminbeff=xbeff-perlen/2.0d0
        xmaxbeff=xbeff+perlen/2.0d0

        halfperlen=perlen/2.0d0
        quadperlen=perlen/4.0d0

        if (abs(xbeffo-xminbeff).le.quadperlen) then
          xminbeff=xminbeff-halfperlen
          xmaxbeff=xmaxbeff-halfperlen
        else if (xbeffo-xminbeff.gt.halfperlen*1.001) then
          xminbeff=xminbeff+halfperlen
          xmaxbeff=xmaxbeff+halfperlen
        endif

        if (xbeffz.ne.-9999.0d0) then
          xbeff=xbeffz
          xminbeff=xbeff-perlen/2.0d0
          xmaxbeff=xbeff+perlen/2.0d0
        endif

        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff

        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        x=xminbeff-dx
        dxkbmode=abs(kbeffmode)*dx

        ixbeff=0
        ixbeffnor=0
        irecover=0

        do ix=1,nxbeff

          x=xminbeff+(ix-1)*dx
          xint(ix)=x
          if (kbeffmode.eq.0) then
            call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bxa(ix),bya(ix),bza(ix),ifail)
          else
            if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
              cycle
            endif
            if (abs(x-xbeff).le.quadperlen) then
              call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
            else if (x.lt.xbeff) then
              call undumag_dipoles_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            else
              call undumag_dipoles_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            endif
          endif !kbeffmode

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_dipoles_field returned failure for Bzeff calculation at point ",ix,xint(ix)
          else
            ixbeff=ixbeff+1
            xint(ixbeff)=xint(ix)
            bxa(ixbeff)=bxa(ix)
            bya(ixbeff)=bya(ix)
            bza(ixbeff)=bza(ix)
          endif

        enddo

        if (ixbeff.gt.0) then

          x3=xint(1:3)
          b3=bya(1:3)
          call parabel_short(x3,b3,a3)
          xint(1)=xminbeff
          bya(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2
          b3=bza(1:3)
          call parabel_short(x3,b3,a3)
          bza(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2

          x3=xint(ixbeff-2:ixbeff)
          b3=bya(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          xint(ixbeff)=xmaxbeff
          bya(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2
          b3=bza(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          bza(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2

          do i=1,ixbeff
            write(lun,*)i,xint(i),bya(i),bza(i)
          enddo

          call util_spline_running_integral(xint,bza,ixbeff,bzint,coef,
     &      ws1,ws2,ws3,ws4)

          bmnbeffd=1.0d30
          bmxbeffd=-1.0d30
          bmaxbeffd=-1.0d30
          do i=1,ixbeff
            if (bza(i).gt.bmxbeffd) then
              bmxbeffd=bza(i)
            endif
            if (bza(i).lt.bmnbeffd) then
              bmnbeffd=bza(i)
            endif
            if (abs(bza(i)).gt.bmaxbeffd) then
              bmaxbeffd=abs(bza(i))
              ibmax=i
            endif
            bzint(i)=bzint(i)**2
          enddo

          if (ibmax.eq.1) ibmax=2
          if (ibmax.eq.ixbeff) ibmax=ixbeff-1

          yp(1)=1.0d0
          yp(2)=2.0d0
          yp(3)=3.0d0
          bp(1)=abs(bza(ibmax-1))
          bp(2)=abs(bza(ibmax))
          bp(3)=abs(bza(ibmax+1))

          call util_max_parabel(3,yp,bp,dum,bmaxp,ws1,ws2,ifail)
          if (ifail.eq.0) bmaxbeffd=bmaxp

          call util_spline_running_integral(xint,bzint,ixbeff,bzint2,coef,
     &      ws1,ws2,ws3,ws4)

          beffd= sqrt(bzint2(ixbeff)/(xint(ixbeff)-xint(1)))
c Correct for endpole effects
          if (bmaxbeffd.ne.0.0d0) then
            beffd=beffd*(bmxbeffd-bmnbeffd)/2.0d0/bmaxbeffd
          endif
          bmaxbeffd=(bmxbeffd-bmnbeffd)/2.0d0
          dkeffd = beffd * sqrt(2.0d0)  * 3.0d8 / 0.511d6 / 1000.0d0
          beffd = dkeffd / ((xint(ixbeff)-xint(1))*100.0d0) / 0.934d0 * 1000.0d0

          bmnbeffzd=bmnbeffd
          bmxbeffzd=bmxbeffd
          beffzd=beffd
          dkeffzd=dkeffd

          flush(lun) !undumag_bzeff_dipoles.beff
          close(lun) !undumag_bzeff_dipoles.beff

        else

          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end: No field data for Bzeff calculation ***"
          write(lun6,*)

        endif

        call util_zeit_kommentar(lun6,"Writing undumag_byeff_dipoles.dat")
        open(newunit=lun,file="undumag_byeff_dipoles.dat")

        xbeff=xbymax
        xminbeff=xbeff-perlen/2.0d0
        xmaxbeff=xbeff+perlen/2.0d0

        halfperlen=perlen/2.0d0
        quadperlen=perlen/4.0d0

        if (abs(xbeffo-xminbeff).le.quadperlen) then
          xminbeff=xminbeff-halfperlen
          xmaxbeff=xmaxbeff-halfperlen
        else if (xbeffo-xminbeff.gt.halfperlen*1.001) then
          xminbeff=xminbeff+halfperlen
          xmaxbeff=xmaxbeff+halfperlen
        endif

        if (xbeffy.ne.-9999.0d0) then
          xbeff=xbeffy
          xminbeff=xbeff-perlen/2.0d0
          xmaxbeff=xbeff+perlen/2.0d0
        endif

        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff

        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        x=xminbeff-dx
        dxkbmode=abs(kbeffmode)*dx

        ixbeff=0
        ixbeffnor=0
        irecover=0
        do ix=1,nxbeff
          x=xminbeff+(ix-1)*dx
          xint(ix)=x
          if (kbeffmode.eq.0) then
            call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bxa(ix),bya(ix),bza(ix),ifail)
          else
            if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
              cycle
            endif
            if (abs(x-xbeff).le.quadperlen) then
              call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
            else if (x.lt.xbeff) then
              call undumag_dipoles_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            else
              call undumag_dipoles_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            endif
          endif !kbeffmode

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_dipoles_field returned failure for Byeff calculation at point ",ix,xint(ix)
          else
            ixbeff=ixbeff+1
            xint(ixbeff)=xint(ix)
            bxa(ixbeff)=bxa(ix)
            bya(ixbeff)=bya(ix)
            bza(ixbeff)=bza(ix)
          endif
        enddo

        if (ixbeff.gt.0) then

          x3=xint(1:3)
          b3=bya(1:3)
          call parabel_short(x3,b3,a3)
          xint(1)=xminbeff
          bya(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2
          b3=bza(1:3)
          call parabel_short(x3,b3,a3)
          bza(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2

          x3=xint(ixbeff-2:ixbeff)
          b3=bya(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          xint(ixbeff)=xmaxbeff
          bya(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2
          b3=bza(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          bza(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2

          do i=1,ixbeff
            write(lun,*)i,xint(i),bya(i),bza(i)
          enddo

          call util_spline_running_integral(xint,bya,ixbeff,byint,coef,
     &      ws1,ws2,ws3,ws4)

          bmnbeffd=1.0d30
          bmxbeffd=-1.0d30
          bmaxbeffd=-1.0d30
          do i=1,ixbeff
            if (bya(i).gt.bmxbeffd) then
              bmxbeffd=bya(i)
            endif
            if (bya(i).lt.bmnbeffd) then
              bmnbeffd=bya(i)
            endif
            if (abs(bya(i)).gt.bmaxbeffd) then
              bmaxbeffd=abs(bya(i))
              ibmax=i
            endif
            byint(i)=byint(i)**2
          enddo

          if (ibmax.eq.1) ibmax=2
          if (ibmax.eq.ixbeff) ibmax=ixbeff-1

          yp(1)=1.0d0
          yp(2)=2.0d0
          yp(3)=3.0d0
          bp(1)=abs(bya(ibmax-1))
          bp(2)=abs(bya(ibmax))
          bp(3)=abs(bya(ibmax+1))

          call util_max_parabel(3,yp,bp,dum,bmaxp,ws1,ws2,ifail)
          if (ifail.eq.0) bmaxbeffd=bmaxp

          call util_spline_running_integral(xint,byint,ixbeff,byint2,coef,
     &      ws1,ws2,ws3,ws4)

          beffd= sqrt(byint2(ixbeff)/(xint(ixbeff)-xint(1)))
c Correct for endpole effects
          if (bmaxbeffd.ne.0.0d0) then
            beffd=beffd*(bmxbeffd-bmnbeffd)/2.0d0/bmaxbeffd
          endif
          bmaxbeffd=(bmxbeffd-bmnbeffd)/2.0d0
          dkeffd = beffd * sqrt(2.0d0)  * 3.0d8 / 0.511d6 / 1000.0d0
          beffd = dkeffd / ((xint(ixbeff)-xint(1))*100.0d0) / 0.934d0 * 1000.0d0

          flush(lun) !undumag_byeff_dipoles.beff
          close(lun) !undumag_byeff_dipoles.beff

        else

          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end: No field data for Byeff calculation ***"
          write(lun6,*)

        endif !ixbeff

        write(lun6,*)"XminBeff, XmaxBeff (dipole approx.):",
     &    sngl(xminbeff),sngl(xmaxbeff)

        write(lun6,*)"ByMin, ByMax, (ByMax-ByMin)/2, ByEff (dipoles approx.):",
     &    sngl(bmnbeffd),sngl(bmxbeffd),
     &    sngl((bmxbeffd-bmnbeffd)/2.0d0),sngl(beffd)

        write(lun6,*)"BzMin, BzMax, (BzMax-BzMin)/2, BzEff (dipole approx.):",
     &    sngl(bmnbeffzd),sngl(bmxbeffzd),
     &    sngl((bmxbeffzd-bmnbeffzd)/2.0d0),sngl(beffzd)

        write(lun6,*)
        write(lun6,*)"Beff = Sqrt( ByEff**2 + BzEff**2 ) (dipole approx.):",
     &    sngl(sqrt(beffd**2+beffzd**2))

        dkeffd=sngl(sqrt(dkeffd**2+dkeffzd**2))

        write(lun6,*)

        write(lun6,*)"Keff and first harmonic [eV] (dipole approx):",
     &    sngl(dkeffd),sngl(950.0d0*ebeam**2/(1.0d0+dkeffd**2/2.0d0)/(perlen/10.0d0))
        write(lun6,*)

        call util_zeit_kommentar(lun6,"Writing undumag_dipoles.beff")
        open(newunit=lun,file="undumag_dipoles.beff")
        write(lun,*)"* Run:"
        write(lun,*)kundurun
        write(lun,*)"* XminBeff XmaxBeff:"
        write(lun,*)
     &    sngl(xminbeff),sngl(xmaxbeff)
        write(lun,*)"* ByMin, ByMax, (ByMax-ByMin)/2, ByEff:"
        write(lun,*)
     &    sngl(bmnbeffd),sngl(bmxbeffd),
     &    sngl((bmxbeffd-bmnbeffd)/2.0d0),sngl(beffd)
        write(lun,*)"* BzMin, BzMax, (BzMax-BzMin)/2, BzEff:"
        write(lun,*)
     &    sngl(bmnbeffzd),sngl(bmxbeffzd),
     &    sngl((bmxbeffzd-bmnbeffzd)/2.0d0),sngl(beffzd)
        write(lun,*)"* Beff = Sqrt( ByEff**2 + BzEff**2 ):"
        write(lun,*)
     &    sngl(sqrt(beffd**2+beffzd**2))
        write(lun,*)"* ByInt1, BzInt1, ByInt2, BzInt2:"
        write(lun,*)
     &    sngl(byint1fd),sngl(bzint1fd),
     &    sngl(byint2fd),sngl(bzint2fd)
        write(lun,*)"* ByInt1Inf, BzInt1Inf:"
        write(lun,*)
     &    sngl(byint1infd),sngl(bzint1infd)
        flush(lun)
        close(lun)
!} beff
      endif !(idipoles.ne.0) then

      deallocate (xint)
      deallocate (bxa)
      deallocate (bya)
      deallocate (bza)
      deallocate (byint)
      deallocate (bzint)
      deallocate (byint2)
      deallocate (bzint2)
      deallocate (ws1)
      deallocate (ws2)
      deallocate (ws3)
      deallocate (ws4)
      deallocate (coef)

      if (kurad.ne.0) then

        ndim=nstepp
        gammai=ebeam/emassg1

        if (xelec.eq.9999.0d0) xelec=xmapmin
        if (xf.eq.9999.0d0) xf=xmapmax

        xelec=xelec/1000.0d0
        yelec=yelec/1000.0d0
        zelec=zelec/1000.0d0

        ds=ds/1000.0d0

        xobsv=xobsv/1000.0d0
        yobsv=yobsv/1000.0d0
        zobsv=zobsv/1000.0d0

        xf=xf/1000.0d0
        yf=yf/1000.0d0
        zf=zf/1000.0d0

        call urad(jcharge,
     &    gammai,dgamtot
     &    ,xelec,yelec,zelec,vxelec,vyelec,vzelec
     &    ,xf,yf,zf,efx,efy,efz,
     &    xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds
     &    ,nthstep,nstep,ndim,traxyz
     &    ,xobsv,yobsv,zobsv,phelow,phehig,
     &    nphener,phener,aradx,arady,aradz,stokes,powden
     &    ,ieneloss,ivelofield,istatus
     &    )

        write(lun6,*)
        write(lun6,'(a,3g15.5)')"xelec, yelec, zelec for urad [mm]:",
     &    xelec*1000.,yelec*1000.,zelec*1000.
        write(lun6,'(a,3g15.5)')"vxelec, vyelec, vzelec for urad:",
     &    vxelec,vyelec,vzelec
        write(lun6,'(a,2g15.5)')"ebeam [GeV], gamma for urad:",ebeam, gamma
        write(lun6,'(a,3g15.5)')"xexit, yexit, zexit [mm]:",
     &    xexit*1000.0,yexit*1000.0,zexit*1000.0
        write(lun6,'(a,2g15.5)')"hori. and vert. kick at xexit [mrad]:",
     &    vnzex/vnxex*1000., vnyex/vnxex*1000.

        xplmin=1.0e30
        xplmax=-1.0e30
        yplmin=1.0e30
        yplmax=-1.0e30
        zplmin=1.0e30
        zplmax=-1.0e30

        call util_zeit_kommentar(lun6,"Writing urad_traxyz.dat")
        open(newunit=lun,file='urad_traxyz.dat',recl=256)

        do istep=1,nstep
          if (traxyz(1,istep).lt.xplmin) xplmin=sngl(traxyz(1,istep))
          if (traxyz(1,istep).gt.xplmax) xplmax=sngl(traxyz(1,istep))
          if (traxyz(2,istep).lt.yplmin) yplmin=sngl(traxyz(2,istep))
          if (traxyz(2,istep).gt.yplmax) yplmax=sngl(traxyz(2,istep))
          if (traxyz(3,istep).lt.zplmin) zplmin=sngl(traxyz(3,istep))
          if (traxyz(3,istep).gt.zplmax) zplmax=sngl(traxyz(3,istep))
          write(lun,'(14e17.7e3)')traxyz(1:3,istep)*1000.0,traxyz(4:14,istep)
        enddo

        flush(lun)
        close(lun)

c{ Plot x,y,z

        call util_zeit_kommentar(lun6,"Writing undumag_trajectory.eps")
        call mshplt_init(20,15.,15.,25,25,600,600,
     &    'undumag_trajectory.eps','','',0.)

        gsiz_ps=0.4

        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif

        theta_ps=sngl(traxyz_theta)
        phi_ps=sngl(traxyz_phi)

        xplmin=xplmin*1000.
        xplmax=xplmax*1000.
        yplmin=yplmin*1.0e6
        zplmin=zplmin*1.0e6
        yplmax=yplmax*1.0e6
        zplmax=zplmax*1.0e6

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin
        dzpl=zplmax-zplmin

        if (dypl.lt.1.0e-9) dypl=1.0
        if (dzpl.lt.1.0e-9) dzpl=1.0

        xplmin=xplmin-dxpl*0.05
        xplmax=xplmax+dxpl*0.05
        yplmin=yplmin-dypl*0.05
        yplmax=yplmax+dypl*0.05
        zplmin=zplmin-dzpl*0.05
        zplmax=zplmax+dzpl*0.05

        if (yplmin.le.zplmin) then
          zplmin=yplmin
        else
          yplmin=zplmin
        endif

        if (yplmax.ge.zplmax) then
          zplmax=yplmax
        else
          yplmax=zplmax
        endif

        call mshplt_frame3d_xzy(
     &    xplmin,xplmax,
     &    yplmin,yplmax,
     &    zplmin,zplmax,
     &    'x [mm]','y [mu-m]','z [mu-m]','')

        call mshplt_set_text_color(1,0,0,0)
        gsiz_ps=0.4
        call mgset('CHHE',0.4)
        call mshplt_text_ndc(0.1,1.05,ctitle)

        call mgset('PLCI',2.)

        do istep=1,nstep-1
          xpl(1)=sngl(traxyz(1,istep))*1000.
          xpl(2)=sngl(traxyz(1,istep+1))*1000.
          ypl(1)=sngl(traxyz(2,istep))*1.0e6
          ypl(2)=sngl(traxyz(2,istep+1))*1.0e6
          zpl(1)=zplmax+zplmin-sngl(traxyz(3,istep))*1.0e6
          zpl(2)=zplmax+zplmin-sngl(traxyz(3,istep+1))*1.0e6
          call mpl3(2,xpl,zpl,ypl)
        enddo

        call mshplt_end

c} Plot x,y,z

c{ Plot y,z

      call util_zeit_kommentar(lun6,"Writing undumag_y_z.eps")

      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_y_z.eps','','',0.)

      if (ixon.gt.1) then

        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif
        if (krunnum.ne.0) then
          write(ctitle,*)kundurun
          call util_string_trim(ctitle,nfirst,nlast)
          ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
        else
          ctitle=trim(usercom)
        endif

        if (kcomment.ne.0) call mtitle(trim(ctitle))
        call mshplt_hplset('YGTI',-0.5)

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do istep=1,nstep-1
          xpl(1)=sngl(traxyz(1,istep))*1000.
          xpl(2)=sngl(traxyz(1,istep+1))*1000.
          zpl(1)=sngl(traxyz(2,istep))*1.0e6
          zpl(2)=sngl(traxyz(2,istep+1))*1.0e6
          call mpl(2,xpl,zpl)
        enddo

        call mgset('PLCI',4.)

        do istep=1,nstep-1
          xpl(1)=sngl(traxyz(1,istep))*1000.
          xpl(2)=sngl(traxyz(1,istep+1))*1000.
          ypl(1)=sngl(traxyz(3,istep))*1.0e6
          ypl(2)=sngl(traxyz(3,istep+1))*1.0e6
          call mpl(2,xpl,ypl)
        enddo

        call mgset('CHHE',0.4)
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
        call mshplt_set_text_angle(90.)

        call mshplt_text_ndc(-0.1,0.65,'trajectory [mu-m]')

        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        call mshplt_text_ndc(0.85,0.9,'y')
        call mshplt_set_text_color(0,0,0,1)
        call mshplt_text_ndc(0.85,0.83,'z')
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)

        call muwk(0,0)
        call mshplt_end

      endif !ixon

c} Plot y,z

        s0min=1.0e30
        s1min=1.0e30
        s2min=1.0e30
        s3min=1.0e30
        s0max=-1.0e30
        s1max=-1.0e30
        s2max=-1.0e30
        s3max=-1.0e30
        call util_zeit_kommentar(lun6,"Writing urad_stokes.dat")
        open(newunit=lun,file='urad_stokes.dat',recl=256)
        do ifreq=1,nphener
          s0=sngl(stokes(1,ifreq))
          s1=sngl(stokes(2,ifreq))
          s2=sngl(stokes(3,ifreq))
          s3=sngl(stokes(4,ifreq))
          write(lun,*)sngl(phener(ifreq)),s0,s1,s2,s3
          if (s0.lt.s0min) s0min=s0
          if (s1.lt.s1min) s1min=s1
          if (s2.lt.s2min) s2min=s2
          if (s3.lt.s3min) s3min=s3
          if (s0.gt.s0max) s0max=s0
          if (s1.gt.s1max) s1max=s1
          if (s2.gt.s2max) s2max=s2
          if (s3.gt.s3max) s3max=s3
        enddo
        flush(lun)
        close(lun)

      endif !kurad

      call util_zeit_kommentar(lun6,"Writing undumag_spectrum.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_spectrum.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (krunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      if (nphener.ne.0) then

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

      gsiz_ps=0.4

      xplmin=sngl(phelow)
      xplmax=sngl(phehig)

! S0
      yplmin=s0min
      yplmax=s0max

      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(4.,10.,12.,18.)

      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S0 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_get_axis_label_offset(xlaboff,ylaboff)
      call mshplt_set_axis_label_offset(xlaboff,ylaboff*0.75)
      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  yplmin,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      call mshplt_set_text_angle(0.)

      call mgset('PLCI',2.)

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(1,ifreq))
        ypl(2)=sngl(stokes(1,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

! S1
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(13.,19.,12.,18.)
      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S1 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  -yplmax-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      call mgset('PLCI',2.)

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(2,ifreq))
        ypl(2)=sngl(stokes(2,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

      call mgset('PLCI',4.)

! S2
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(4.,10.,4.,10.)
      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S2 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  -yplmax-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      call mgset('PLCI',2.)

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(3,ifreq))
        ypl(2)=sngl(stokes(3,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

! S3
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(13.,19.,4.,10.)
      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S3 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  -yplmax-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(4,ifreq))
        ypl(2)=sngl(stokes(4,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

      call muwk(0,0)
      call mshplt_end

+self,if=-nowarnings.
      flush(lunwarn)
      close(lunwarn)
+self.,if=-nowarnings.

      endif !(nphener.ne.0) then

      if (kdumpconv.ne.0) then
        flush(lunconv)
        close(lunconv)
      endif

      if (killbadmag.lt.0.and.killbadmag.ne.-9999) then
        i=0
        call util_zeit_kommentar(lun6,"Writing undumag.bad")
        open(newunit=lunkill,file="undumag.bad")
        do kmag=1,nmag
          if (bpebc(16,kmag).ne.0.0d0) then
            write(lunkill,*)kmag,nint(bpebc(16,kmag)),bpebc(1:6,kmag)
            i=i+1
          endif
        enddo
        flush(lunkill)
        close(lunkill)
        write(lun6,*)
        write(lun6,*)"File undumag.bad written, number of bad voxel:",i
      endif

      if (idipoles.ne.0) then
        call util_zeit_kommentar(lun6,"Writing undumag_map.dip")
        open(newunit=lun,file="undumag_map.dip")
        do kmag=1,ndipoles
          write(lun,'(14e17.7e3)')dipoles(1:3,kmag),
     &      dipoles(4,kmag)*dipoles(5:7,kmag),dipoles(9:16,kmag)
        enddo
        flush(lun)
        close(lun)
      endif

      if (intmaglis.ne.0) then
        write(lun6,*)
        write(lun6,*)" --- Due to flag intmaglis, only magnets on file undumag_magmap.lis do contribute to field map ---"
        write(lun6,*)
      endif

c      call muwk(0,0)
c      call mshplt_end

+self,if=debugb.
      yint=0.0d0
      zint=0.0d0
      call undumag_bintinf_sym(0.0d0,yint,zint,1.0d0,0.0d0,0.0d0,
     &  bxintinf,byintinf,bzintinf,ifail)

      call undumag_field_int(1,
     &  1.0d0,yint,zint,
     &  1.0d0,0.0d0,0.0d0,
     &  bxi,byi,bzi,ifail)
      write(lun6,*)"---------------------------------------------"
      write(lun6,*)

      write(lun6,*)"Wahrheit a:",bxi*twopi*1000.0d0,byi*1000.0d0,bzi*1000.0d0
      write(lun6,*)"Wahrheit n:","           Null           ",byif,bzif
      write(lun6,*)"Wahrheit a:",bxi*twopi*1000.0d0,byi*twopi*1000.0d0,bzi*twopi*1000.0d0
      write(lun6,*)"Wahrheit n:","           Null           ",byif*twopi,bzif*twopi

+self.
+self,if=debuge.
      yint=0.0d0
      zint=0.0d0
      call undumag_bintinf_sym(0.0d0,yint,zint,1.0d0,0.0d0,0.0d0,
     &  bxintinf,byintinf,bzintinf,ifail)
      write(lun6,*)"Wahrheit a:",bxi*1000.0d0,byi*1000.0d0,bzi*1000.0d0
      write(lun6,*)"Wahrheit n:","           Null           ",byif,bzif
      write(lun6,*)"Näherung:  ","           Null          ",byint1infd,bzint1infd
      write(lun6,*)"Glaube:     ",
     &  bxintinf*1000.0d0,byintinf*1000.0d0,bzintinf*1000.0d0
+self.
      byplmin=1.0e30
      bzplmin=1.0e30
      byplmax=-1.0e30
      bzplmax=-1.0e30
      call util_zeit_kommentar(lun6,"Writing undumag_field_profile.dat")
      open(newunit=lunz,file='undumag_field_profile.dat')
      nz=(nint(zmaxprof-zminprof))+1
      zmin=dble(nint(zminprof))-1.0d0
      i=0
      do iz=1,nz
22      z=zmin+dble(iz)
        x=(xminbeff+xmaxbeff)/2.0d0
        y=0.0d0
        ! to avoid boundary effects:
        call util_random(3,g)
        g=g-0.5
c+self,if=rando10.
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif
c+self.,if=rando10.

        if (itry.eq.0.and.randoz.gt.0.0d0) g=0.

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif

        if (randoz.ge.0.0d0) then
          z=z+g(3)*randoza
        else
          z=z+randoza
        endif

        ifail=0

        if (itry.eq.0) ifail=-1

        call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,bx,by,bz,ifail)

        if (itry.eq.0.and.ifail.eq.-1) then
          ifail=0
        endif

        if (ifail.ne.0.and.itry.lt.10) then
          itry=itry+1
          goto 22
        endif
        itry=0

        if (ifail.le.0) then
          i=i+1
          write(lunz,*)x,y,z,bx,by,bz
          zppl(i)=sngl(z)
          bypl(i)=sngl(by)
          bzpl(i)=sngl(bz)
          if (by.lt.byplmin) byplmin=sngl(by)
          if (by.gt.byplmax) byplmax=sngl(by)
          if (bz.lt.bzplmin) bzplmin=sngl(bz)
          if (bz.gt.bzplmax) bzplmax=sngl(bz)
        endif

      enddo
      flush(lunz)
      close(lunz)

      nz=i

      call util_zeit_kommentar(lun6,"Writing undumag_field_profile.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_field_profile.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (krunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

c{ Plot By, Bz

      gsiz_ps=0.4

      xplmin=sngl(zminprof)
      xplmax=sngl(zmaxprof)
      yplmin=min(byplmin,bzplmin)
      yplmax=max(byplmax,bzplmax)
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mplfra(
     &  xplmin-dxpl*0.05,
     &  xplmax+dxpl*0.05,
     &  yplmin-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  '')

      call mgset('PLCI',2.)
      call mshplt_set_marker_size(0.5)

      do i=1,nz-1
        xpl(1)=sngl(zppl(i))
        xpl(2)=sngl(zppl(i+1))
        ypl(1)=sngl(bypl(i))
        ypl(2)=sngl(bypl(i+1))
        call mpl(2,xpl,ypl)
      enddo

      call mgset('PLCI',4.)

      do i=1,nz-1
        xpl(1)=sngl(zppl(i))
        xpl(2)=sngl(zppl(i+1))
        ypl(1)=sngl(bzpl(i))
        ypl(2)=sngl(bzpl(i+1))
        call mpl(2,xpl,ypl)
      enddo

      call mgset('CHHE',0.4)
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.9,-0.1,'z [mm]')
      call mshplt_set_text_angle(90.)
      if (abs(yplmax).lt.1.0e-3) then
        call mshplt_text_ndc(-0.1,0.86,'B [T]')
      else
        call mshplt_text_ndc(-0.1,0.88,'B [T]')
      endif
      call mshplt_set_text_angle(0.)
      call mgset('CHHE',0.5)
      call mshplt_set_text_color(0,1,0,0)
      call mshplt_text_ndc(0.85,0.9,'By')
      call mshplt_set_text_color(0,0,0,1)
      call mshplt_text_ndc(0.85,0.83,'Bz')
      call mshplt_set_text_color(1,0,0,0)
      call mgset('CHHE',0.4)

      call muwk(0,0)
      call mshplt_end

      call util_zeit_kommentar(lun6,"Writing undumag.wav")
      open(newunit=lunw,file='undumag.wav')

      write(lunw,'(a)')cundutit
      write(lunw,*)ncwires,nrec,nmag,nplanmax,ncornmax,' 20',' 3',' 8',
     &  " ! ncwires, nrec, nmag, nplanmax, ncornmax, 1_dim_bpebc, 1_dim_bperot, 2_dim_bpetm"
      write(lunw,*)ixsym,iysym,izsym,kxcenter,xsym,xcenter
      write(lunw,*)perlen,xmapmin,xmapmax,nper
      write(lunw,*)kurad,ebeam
      write(lunw,*)xelec,yelec,zelec
      write(lunw,*)vxelec,vyelec,vzelec
      write(lunw,*)xf,yf,zf
      write(lunw,*)efx,efy,efz
      write(lunw,*)tiny,window

      do kmag=1,nmag
        write(lunw,*)kmag
        write(lunw,*)bpebc(:,kmag)
        nplan=ibpeplan(kmag)
        write(lunw,*)nplan,ibpecol(kmag)
        do iplan=1,nplan
          ncorn=ibpecorn(iplan,kmag)
          write(lunw,*)ncorn
          do icorn=1,ncorn
            write(lunw,*)bpemag(1:3,icorn,iplan,kmag)
            write(lunw,*)bperot(1:3,icorn,iplan,kmag)
          enddo
          do i=1,8
            write(lunw,*)bpetm(1:3,i,iplan,kmag)
          enddo
        enddo
      enddo

      do i=1,ncwires
        write(lunw,*)wire(:,i)
      enddo

      flush(lunw)
      close(lunw)

      call undumag_uout

      call util_zeit_kommentar(lun6,"Writing undumag.mat")
+self,if=debugend.
      !call util_break
+self.

      open(newunit=lunmat,file="undumag.mat")

      write(lunmat,'(a)') '* ' // ctitle

      do mat=1,nmatfiles
        n=matmaps(4,mat)
        mtyp=matmaps(2,mat)
        if (mtyp.eq.1.and.nrec.gt.0) then
          if (n.eq.0) then
            if (newclc.ne.0) then
              br=0.0d0
              do ibrn=1,nbrnmat
                if (abs(brnmat(2,ibrn)).gt.br) br=abs(brnmat(2,ibrn))
              enddo
              kbrn=0
              do ibrn=1,nbrnmat
                if (nint(brnmat(1,ibrn)).eq.mat) then
                  kbrn=ibrn
                  exit
                endif
              enddo
              if (kbrn.eq.0) then
                write(lun6,*)
                write(lun6,*)"*** Warning in undumag_end: Could not find REC material in list of Br ***"
                write(lun6,*)"*** Be careful with plots of magnetisation ***"
              endif
              brn=sngl(abs(brnmat(2,ibrn)))
              hbmatmin=sngl(brn-bcmat(2,1,mat)*br)
              hbmatmax=sngl(brn+bcmat(2,1,mat)*br)
            endif !newclc
            write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(-br),hbmatmin,sngl(bcmat(3,1,mat))
            write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(br),hbmatmax,sngl(bcmat(3,1,mat))
          else
            do i=1,n
              write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(bcmat(1:3,i,mat))
            enddo
          endif
        else if (mtyp.eq.2) then
          do i=1,n
            write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(bcmat(1:3,i,mat))
          enddo
        endif !mtyp
      enddo

      flush(lunmat)
      close(lunmat)

      open(newunit=lunmat,file="undumag.brn")

      write(lunmat,'(a)') '* ' // ctitle

      do mat=1,nbrnmat
        write(lunmat,*) brnmat(1:2,mat)
      enddo

      flush(lunmat)
      close(lunmat)

      call clcmag_voxels_list(1)

      open(newunit=lunst,file="undumag.stat")
      write(lunst,*)"0"
      flush(lunst)
      close(lunst)

      flush(lunmag)
      close(lunmag)

9999  continue

      call  util_random_get_seed(irnsize,irnseed)

      call util_get_free_lun(lun)
      call util_zeit_kommentar(lun6,"Writing undumag.seeds")

      open(newunit=lun,file='undumag.seeds',status='unknown')

      write(lun,*)irnsize, kundurun
      do i=1,irnsize
        write(lun,*)i,irnseed(i)
      enddo

      flush(lun)
      close(lun)

      open(newunit=lun,file='undumag.gmd',status='unknown')
      write(lun,*)kundurun,modegui
      flush(lun)
      close(lun)

      return
      end
+DECK,undumag_read_clc.
*CMZ :  2.05/01 02/10/2023  16.19.49  by  Michael Scheer
*CMZ :  2.04/25 28/09/2023  07.22.52  by  Michael Scheer
*CMZ :  2.04/21 21/09/2023  16.12.51  by  Michael Scheer
*CMZ :  2.04/11 29/08/2023  14.43.10  by  Michael Scheer
*CMZ :  2.04/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/01 22/01/2023  13.04.45  by  Michael Scheer
*CMZ :  2.04/00 14/01/2023  14.39.42  by  Michael Scheer
*CMZ :  2.03/00 15/08/2022  12.39.08  by  Michael Scheer
*CMZ :  2.02/02 09/03/2022  09.42.30  by  Michael Scheer
*CMZ :  2.02/01 11/02/2022  08.28.50  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine undumag_read_clc

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      integer i,j,ieof,lunclc,istat,ipos(2,1000),nwords,
     &  lmat,nmat,k,kc,l,ncorn,nfila,lunf

      character(512) cline,cword
      cundutit='* No User Comment'
      unducomment=''
      usercom=''
      cundutit='* ' // adjustl(trim(unducomment))

      nclcbuff=0
      ncwires=0

      nwind=0
      nrace=0
      ncrace=0
      narc=0
      ncarc=0
      nrbar=0
      nthwir=0
      nmagcyl=0

      ntransrotcop=0
      transrotcop=0.0d0

      nmodule_t=0
      modegui=0

      nconcave_t=0

      open(newunit=lunclc,file=Fclc)

      do while (.true.)
        call util_skip_comment_end(lunclc,ieof)
        if (ieof.ne.0) exit
        read(lunclc,'(a)') cline
        !if (kechocalc.ne.0) print*,trim(cline)
        cline=adjustl(cline)
        if (cline(1:4).eq.'Mode') then
          call util_string_split(cline,1000,nwords,ipos,istat)
          if (nwords.gt.1) then
            if (cline(ipos(1,2):ipos(2,2)).eq.'Mirror') then
              modegui=3
            else if (cline(ipos(1,2):ipos(2,2)).eq.'Hybrid') then
              modegui=2
            else if (cline(ipos(1,2):ipos(2,2)).eq.'AppleII') then
              modegui=1
            endif
          endif
        endif
        if (cline(1:1).eq.'&') then
          call util_string_split(cline,1000,nwords,ipos,istat)
          if (cline(ipos(1,2):ipos(2,2)).eq.'User_Comment') then
            nclcbuff=nclcbuff+1
            !if (kechocalc.ne.0) print*,trim(cline)
            call util_skip_comment_end(lunclc,ieof)
            if (ieof.ne.0) exit
            cline=''
            unducomment=''
            read(lunclc,'(a)') cline
            nclcbuff=nclcbuff+1
            unducomment=trim(cline(1:512))
            usercom=adjustl(trim(unducomment))
            cundutit='* ' // adjustl(trim(unducomment))
            read(lunclc,'(a)') cline
            cycle ! to avoid confusion, if key words appear in comment
          endif
        endif
        if (len_trim(cline).eq.0) cycle
        nclcbuff=nclcbuff+1
      enddo

      allocate(
     &  magmodule(nclcbuff),
     &  clcbuff(nclcbuff),
     &  clcmag(nclcbuff),
     &  clcspec(nclcbuff),
     &  clcconcave(nclcbuff),
     &  clcmat(nclcbuff),
     &  clcmod(nclcbuff),
     &  clccoil(nclcbuff),
     &  clccop(nclcbuff),
     &  clcvar(nclcbuff),
     &  clcinhom(nclcbuff)
     &  )

      rewind(lunclc)

      nclcbuff=0
      do while (.true.)
        ieof=0
        call util_skip_comment_end(lunclc,ieof)
        if (ieof.ne.0) exit
        read(lunclc,'(a)') cline
        cline=adjustl(cline)
        !print*,trim(cline)
        if (len_trim(cline).eq.0) cycle
        if (nclcbuff.gt.0.and.cline(1:1).eq.'&') then
          call util_string_split(cline,1000,nwords,ipos,istat)
          if (cline(ipos(1,2):ipos(2,2)).eq.'End') then
            nclcbuff=nclcbuff+1
            cline(1:1)='!'
            clcbuff(nclcbuff)=cline
            cycle
          endif
          if (clcbuff(nclcbuff)(1:1).eq.'&') then
            !print*,cline(ipos(1,2):ipos(2,2))
            !call util_break
            print*,"*** Error in undumag_read_clc: Missing data lines after"
            print*,trim(clcbuff(nclcbuff))
            stop
          endif
          if (cline(ipos(1,2):ipos(2,2)).eq.'User_Comment') then
            ieof=0
            call util_skip_comment_end(lunclc,ieof)
            if (ieof.ne.0) exit
            read(lunclc,'(a)') cline
            cycle
          endif
        endif
        nclcbuff=nclcbuff+1
        clcbuff(nclcbuff)=cline
      enddo

      close(lunclc)

      nclcmag=0
      nclcspec=0
      nclccoil=0
      nclcvar=0
      nclcmod=0
      nclcmat=0

      nmag_t=0
      niron_t=0
      ninhom_t=0

      i=0
      do while (i.lt.nclcbuff)

        i=i+1
        cline=clcbuff(i)
        if (kechocalc.ne.0) print*,trim(cline)
        call util_string_split(cline,1000,nwords,ipos,istat)

        if (cline(ipos(1,1):ipos(2,1)).eq.'&') then
          if (cline(ipos(1,2):ipos(2,2)).eq.'User_Comment') then
            i=i+1
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Inhomogeneity') then
            !call util_break
            ninhom_t=ninhom_t+1
            clcinhom(ninhom_t)=cline(ipos(1,2):ipos(2,2))
            i=i+1
            do while (.true.)
              !print*,i,trim(clcbuff(i))
              ninhom_t=ninhom_t+1
              clcinhom(ninhom_t)=clcbuff(i)
              if (kechocalc.ne.0) print*,trim(clcbuff(i))
              call util_string_split(clcinhom(ninhom_t),1000,nwords,ipos,istat)
              if (clcinhom(ninhom_t)(ipos(1,2):ipos(2,2)).eq.'End') exit
              i=i+1
            enddo
            !call util_break
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Pole' .or.
     &        cline(ipos(1,2):ipos(2,2)).eq.'Magnet') then
            nmag_t=nmag_t+1
            magmodule(nmag_t)=nmodule_t+1
            if (cline(ipos(1,2):ipos(2,2)).eq.'Pole') niron_t=niron_t+1
            nclcmag=nclcmag+1
            clcmag(nclcmag)=cline(ipos(1,2):ipos(2,2))
            i=i+1
            cline=clcbuff(i)
            if (kechocalc.ne.0) print*,trim(cline)
            call util_string_split(cline,1000,nwords,ipos,istat)
            if (
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockChamf'.or.
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockUsChamf'.or.
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockDsChamf'
     &          ) then
              do l=1,5
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Block') then
              do l=1,5
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Cylinder') then
              nmagcyl=nmagcyl+1
              do l=1,5
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Corners') then
              read(clcbuff(i+4),*) ncorn
              if (ncorn.gt.ncornmax) ncornmax=ncorn
              do l=1,5+ncorn
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'File') then
              do l=1,5
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else
              print*,"*** Error in undumag_read_clc: Unknown magnet type in line"
              print*,trim(cline)
              stop
            endif
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Module') then
            nmodule_t=nmodule_t+1
            nclcmod=nclcmod+1
            clcmod(nclcmod)=clcbuff(i)
            do l=1,4
              i=i+1
              nclcmod=nclcmod+1
              clcmod(nclcmod)=clcbuff(i)
              if (kechocalc.ne.0) print*,trim(clcbuff(i))
            enddo
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Translate') then
            ntransrotcop=ntransrotcop+1
            if (ntransrotcop.gt.ntransrotcop_p) then
              stop "*** Error in undumag_read_clc: Too many remanence, translations, rotations changes, check parameter ntransrotcop_p ***"
            endif
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            ctransrotcop(ntransrotcop)=trim(clcbuff(i))
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            !read(clcbuff(i),*) transrotcop(1:3,ntransrotcop)
            transrotcop(1,ntransrotcop)=dble(i)
            transrotcop(8,ntransrotcop)=0.0d0
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Remanence') then
            ntransrotcop=ntransrotcop+1
            if (ntransrotcop.gt.ntransrotcop_p) then
              stop "*** Error in undumag_read_clc: Too many remanence, translations, rotations changes, check parameter ntransrotcop_p ***"
            endif
            transrotcop(8,ntransrotcop)=3.0d0
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            ctransrotcop(ntransrotcop)=trim(clcbuff(i))
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            transrotcop(1,ntransrotcop)=dble(i)
            !read(clcbuff(i),*) transrotcop(1:6,ntransrotcop)
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Copy') then
            nclccop_t=nclccop_t+1
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            clccop(nclccop_t)=trim(clcbuff(i))
            ntransrotcop=ntransrotcop+1
            if (ntransrotcop.gt.ntransrotcop_p) then
              stop "*** Error in undumag_read_clc: Too many remanence, translations, rotations changes, check parameter ntransrotcop_p ***"
            endif
            transrotcop(8,ntransrotcop)=-dble(nclccop_t)
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            cline=clcbuff(i)
            call util_string_split(cline,1000,nwords,ipos,istat)
            cword=cline(ipos(1,1):ipos(2,1))
            ctransrotcop(ntransrotcop)=trim(cword)
          else if (
     &        cline(ipos(1,2):ipos(2,2)).eq.'Rotate'.or.
     &        cline(ipos(1,2):ipos(2,2)).eq.'Rotate_Shape') then
            ntransrotcop=ntransrotcop+1
            if (cline(ipos(1,2):ipos(2,2)).eq.'Rotate_Shape') then
              transrotcop(8,ntransrotcop)=1.0d0
            else
              transrotcop(8,ntransrotcop)=2.0d0
            endif
            if (ntransrotcop.gt.ntransrotcop_p) then
              stop "*** Error in undumag_read_clc: Too many remanence, translations, rotations changes, check parameter ntransrotcop_p ***"
            endif
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            ctransrotcop(ntransrotcop)=trim(clcbuff(i))
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            transrotcop(1,ntransrotcop)=dble(i)
            !read(clcbuff(i),*) transrotcop(1:3,ntransrotcop)
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            !read(clcbuff(i),*) transrotcop(4:7,ntransrotcop)
          else if (
     &        cline(ipos(1,2):ipos(2,2)).eq.'Special_Magnet'.or.
     &        cline(ipos(1,2):ipos(2,2)).eq.'Special_Pole'
     &        ) then
            nclcspec=nclcspec+1
            clcspec(nclcspec)=cline(ipos(1,2):ipos(2,2))
            nspecmag_t=nspecmag_t+1
            i=i+1
            cline=clcbuff(i)
            call util_string_split(cline,1000,nwords,ipos,istat)
            if (
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockChamf'.or.
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockUsChamf'.or.
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockDsChamf'
     &          ) then
              do l=1,5
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Block') then
              do l=1,5
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Cylinder') then
              do l=1,5
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Corners') then
              read(clcbuff(i+4),*) ncorn
              do l=1,5+ncorn
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'File') then
              do l=1,5
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else
              print*,"*** Error in undumag_read_clc: Unknown magnet type in line"
              print*,trim(cline)
              stop
            endif !shape

          else if(
     &        cline(ipos(1,2):ipos(2,2)).eq.'Convex_Magnet'.or.
     &        cline(ipos(1,2):ipos(2,2)).eq.'Convex_Pole'.or.
     &        cline(ipos(1,2):ipos(2,2)).eq.'Special_Convex_Magnet'.or.
     &        cline(ipos(1,2):ipos(2,2)).eq.'Special_Convex_Pole') then
            k=i
            kc=nconcave_t
            do l=1,6
              nconcave_t=nconcave_t+1
              clcconcave(nconcave_t)=clcbuff(i)
              if(l.eq.2) then
                cline=clcbuff(i)
                call util_string_split(cline,1000,nwords,ipos,istat)
                cword=cline(ipos(1,1):ipos(2,1))
              endif
              print*,trim(clcconcave(nconcave_t))
              if (kechocalc.ne.0) print*,trim(clcbuff(i))
              i=i+1
            enddo
            call util_lower_case(cword)
            if (cword.ne.'file') then
              print*,"*** Error in undumag_read_clc: Bad input for concave item!"
              print*,"*** Only data file is allowed to define item!"
              print*,"*** Item will be ignored! Please check line:"
              print*,trim(clcbuff(k+1))
              nconcave_t=kc
            endif
            i=i-1

          else if (cline(ipos(1,2):ipos(2,2)).eq.'Materials') then
            i=i+1
            cline=clcbuff(i)
            nclcmat=nclcmat+1
            clcmat(nclcmat)=clcbuff(i)
            if (kechocalc.ne.0) print*,trim(cline)
            read(cline,*) nmat
            do lmat=1,nmat
              nclcmat=nclcmat+1
              i=i+1
              clcmat(nclcmat)=clcbuff(i)
              if (kechocalc.ne.0) print*,trim(clcbuff(i))
            enddo !nmat

          else if (cline(ipos(1,2):ipos(2,2)).eq.'Coil') then

            ncoils_t=ncoils_t+1
            nclccoil=nclccoil+1
            clccoil(nclccoil)='Coil'
            i=i+1
            cline=clcbuff(i)
            if (kechocalc.ne.0) print*,trim(cline)

            call util_string_split(cline,1000,nwords,ipos,istat)
            nclccoil=nclccoil+1

            if (nwords.gt.1) then
              clccoil(nclccoil)=adjustl(trim(cline(ipos(1,1):ipos(2,2))))
            else
              clccoil(nclccoil)=adjustl(trim(cline(ipos(1,1):ipos(2,1))))
            endif

            cword=adjustl(trim(cline(ipos(1,1):ipos(2,1))))

            i=i+1
            nclccoil=nclccoil+1
            clccoil(nclccoil)=clcbuff(i)
            cline=clcbuff(i)
            if (kechocalc.ne.0) print*,trim(cline)

            if (cword.eq.'Filaments') then
              read(cline,*)nfila
              do l=1,nfila
                nclccoil=nclccoil+1
                i=i+1
                clccoil(nclccoil)=clcbuff(i)
              enddo
              ncwires=ncwires+nfila

            else if (cword.eq.'File') then

              call util_string_split(cline,1000,nwords,ipos,istat)
              cword=adjustl(trim(cline(ipos(1,1):ipos(2,1))))
              call util_unquote(cword)
              clccoil(nclccoil)=adjustl(trim(cword))
              open(newunit=lunf,file=trim(cword),status='old')
              nfila=0
              do while (.true.)
                call util_skip_comment_empty_end(lunf,ieof)
                if (ieof.ne.0) exit
                read(lunf,'(a)')cline
                nfila=nfila+1
              enddo
              close(lunf)
              ncwires=ncwires+nfila

            else if (
     &          cword.eq.'RectArc'.or.
     &          cword.eq.'CircArc'.or.
     &          cword.eq.'RectBar'.or.
     &          cword.eq.'ThickWire'
     &          ) then
              i=i+1
              nclccoil=nclccoil+1
              clccoil(nclccoil)=clcbuff(i)

            else if (
     &          cword.ne.'Rectangular'.and.
     &          cword.ne.'RectangCirc'.and.
     &          cword.ne.'RectWindings'
     &          ) then
              print*,""
              print*,"*** Error in undumag_read_clc: Unknown coil type in line"
              print*,trim(cline)
              stop
            endif

          else
            print*,""
            print*,"*** Error in undumag_read_clc: Unknown key-word in line"
            print*,trim(cline)
            stop
         endif ! &

        else if (cline(1:1).eq.'$') then

          !if (kechocalc.ne.0) print*,trim(cline)
          do j=2,len_trim(cline)-1
            if (cline(j:j).eq.'=') then
              nclcvar=nclcvar+1
              clcvar(nclcvar)=trim(cline(2:))
              exit
            endif
          enddo
        endif !c1
      enddo

      return
      end
+DECK,undumag_ini_old.
*CMZ :  2.04/06 23/10/2023  14.26.43  by  Michael Scheer
*CMZ :  2.04/03 03/03/2023  14.44.40  by  Michael Scheer
*CMZ :  2.04/00 05/12/2022  15.18.35  by  Michael Scheer
*CMZ :  2.03/00 31/08/2022  08.10.44  by  Michael Scheer
*CMZ :  2.02/02 07/07/2022  17.49.27  by  Michael Scheer
*CMZ :  2.02/01 10/02/2022  09.16.42  by  Michael Scheer
*CMZ :  2.02/00 31/03/2021  20.30.51  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.27.23  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  16.04.15  by  Michael Scheer
*CMZ :  2.01/04 18/07/2019  13.56.54  by  Michael Scheer
*CMZ :  2.01/03 13/06/2019  15.03.29  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  14.56.07  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.15.25  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  14.30.21  by  Michael Scheer
*CMZ :  2.00/03 23/04/2018  17.47.12  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.39.07  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.09.03  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  16.25.38  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.30.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.59.20  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.35.49  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  19.08.03  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  13.53.24  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  11.50.12  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  18.37.06  by  Michael Scheer
*CMZ :  1.23/02 17/09/2017  11.21.15  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  16.23.00  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  14.53.35  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  08.50.03  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  11.30.39  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.56.28  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  12.48.09  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  13.11.48  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.31.54  by  Michael Scheer
*CMZ :  1.18/03 13/06/2017  15.30.31  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  14.09.42  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  09.19.34  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.04.28  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.55.08  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.22.37  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  12.23.38  by  Michael Scheer
*CMZ :  1.15/11 26/04/2017  11.23.30  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.22.06  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  14.32.29  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.29.10  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.46.33  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.15.21  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  19.50.52  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  11.26.05  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  09.16.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  10.00.53  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.14.36  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  15.40.55  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  16.37.53  by  Michael Scheer
*CMZ :  1.12/00 24/02/2017  08.47.15  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.24.23  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.18.36  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.27.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  10.13.44  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.40  by  Michael Scheer
*CMZ :  1.11/01 06/01/2017  13.46.07  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  15.56.40  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  15.36.58  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.12.02  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.10/00 01/11/2016  09.47.47  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.08.03  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  09.12.28  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  18.54.27  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.39.27  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.51.14  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.43.31  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.17  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.32.16  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.35.03  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.29.44  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.28  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  13.31.19  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.37.12  by  Michael Scheer
*CMZ :  1.02/02 12/09/2016  10.20.23  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.27.52  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  14.10.42  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  17.52.14  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.06.57  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.47  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.13.39  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  15.05.25  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  17.54.03  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  13.38.55  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.51.40  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.27.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.43  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  15.56.38  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.48.03  by  Michael Scheer
*CMZ :  1.17/15 19/04/2016  15.54.31  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  12.32.55  by  Michael Scheer
*CMZ :  1.17/13 08/04/2016  11.47.10  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.29.22  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  12.46.06  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.46.34  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.41.39  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.58.50  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.42.21  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine undumag_ini_old(kseg)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

! bpemag0(1:3,icorn,iplan,imag) = x,y,z relative to magnet center

! bpebc0(1:3,... position x,y,z
! bpebc0(4:6,... M vector
! bpebc0(7... type, e.g. -6 is rect. angular magnet, 1 polyeder

! ibpeplan(imag)=nplan
! ibpecorn(iplan,imag)=ncorn
! ibpecol(imag) color index

! bpebc(1:3,... position x,y,z
! bpebc(4:6,... M vector, might be changed during relaxation
! bpebc(7,... length of M vector, might be changed during relaxation
! bpebc(8,... type
! bpebc(9,imag)=imat
! bpebc(10,imag) special magnet flag
! bpebc(11:13,imag) normalized M vector at the beginning, will survive
! bpebc(14,imag) length M vector at the beginning, will survive
! bpebc(15,imag) Mother volume
! bpebc(16,imag) kill flag
! bpebc(17,imag) select flag
! bpebc(18:20,imag) external field and field of coils

+seq,phyconparam.
+seq,seqdebug.
+seq,random.

      double precision, dimension (:,:), allocatable :: bciron,bcrec,
     &  bpre16,bc0rec,bc0iron,displace

      double precision, dimension (:,:,:), allocatable :: corn1,corn2,
     &  bcpre
      double precision, dimension (:,:,:,:), allocatable ::
     &  bmagrec,brotrec, bpetmrec,
     &  bmagiron,brotiron, bpetmiron

      double precision bn,x,y,z,hx,hy,hz,bx,by,bz,hxo,hyo,hzo,hold,h,
     &  bci(3),bcj(3),xdiv,ydiv,zdiv,bc04(4),
     &  x1,x2,y1,y2,z1,z2,x3,x4,z3,z4,
     &  xdivmin,xdivmax,ydivmin,ydivmax,zdivmin,zdivmax,dxdiv,dydiv,dzdiv,
     &  x1div(10000),x2div(10000),y1div(10000),y2div(10000),
     &  z1div(10000),z2div(10000),xcen,ycen,zcen,
     &  xidiv(10000),yidiv(10000),zidiv(10000),bc8,bc9,bc10,bpebc15,bpe17,
     &  wind19(19),race17(17),arc21(21)

      double precision x0,y0,y0max,y0min,z0,bc,xm,ym,zm,rmag(3),vmaglab(3),
     &  vnormlab(3),r1(3),bdum,dum,r1lab(3),dx0,dx,dy,dz,x00,y00,z00,pel,
     &  dzdum,hmat,bcm,hmato,bcmo,dlab(3),vcorn(3),vmag(3),
     &  x02(2),y02(2),z02(2),gcen(3),vnor(3),dxfb,dyfb,dzfb,dxcon(100)

      double precision ts(3,3),tsinv(3,3),p1(3),p2(3),p3(3)
      double precision v1x,v1y,v1z,v2x,v2y,v2z,vsx,vsy,vsz,tiny2,rtiny
      double precision xmin,xmax,ymin,ymax,zmin,zmax,rmin,rmax,scalcur,
     &  dxsh,eps10,xx,yy,zz,xsymmm,xconvmm,dist,
     &  xminfb,yminfb,zminfb,xmaxfb,ymaxfb,zmaxfb,
     &  xxmin,xxmax,yymin,yymax,zzmin,zzmax

      double precision space,vspace(3),vbsym(3),rotmod(3,3),
     &  xmod,ymod,zmod,q,qsign,a,b,r2(3),det,
     &  xlen,ylen,ylenmax,ylenmin,zlen,vx,vy,vn,ca,sa,tz(3,3),ws(3,3)
     & ,ts1(3,3),ts1inv(3,3),xl,yl,zl,vz,r

      double precision, dimension (:,:,:,:), allocatable :: bpemag0,shuffle

      double precision
     &  bcx,bcy,bcz,yfracdiv,fracsum,yfacdiv,sinphi,cosphi,curr,
     &  xcwmin,xcwmax,radin,radout,ri,ro,dh,height,angle,rmat(3,3),dr,phi,dphi

      real g(100),color(3),xc,yc,zc,x21,y21,z21,cw
      integer mag,ix,iy,iz,icol,num,nr,nang,nangmin,nh,iphi,ir,ip,ih,kfoundplanes

      integer, dimension (:), allocatable :: ibpeplaniron, ibpeplanrec,
     &  ncorn1,ncorn2

      integer, dimension (:,:), allocatable :: ibpecorniron,ibpecornrec,
     &  mothdiv

      integer ifail,iterold,iron1,iron2,mat,lmat,jmag,ic,jc,
     &  ispec,iron,irec,kiron,nidiv,n1div,n2div,modediv,kplan,mspecmag,
     &  lunf,lunst,lunvox,lunvrml,moth,itype,motho,nmoth,nmotho,ipoimoth,
     &  ncount,imoth,kmoth,lun,ndisp,idisp,mothdis,moth0,mpoi,lunlis,
     &  lunfil,nlines,luncoi,kolor,lunmag,lunrn,kseg

      integer, dimension (:), allocatable :: ibpecolrec,ibpecoliron

      integer ntupp,imat
      parameter(ntupp=12)

      double precision, dimension (:,:), allocatable :: hull
      double precision, dimension (:), allocatable :: xhull,yhull,zhull
      double precision, dimension (:,:), allocatable :: xmoth,ymoth,zmoth
      double precision, dimension (:,:), allocatable :: xmothm,ymothm,zmothm
      double precision, dimension (:,:), allocatable :: xmothi,ymothi,zmothi

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface,npmoth,matmoth,
     &  nplanmoth,ncolmoth,ncolmothi,ncolmothm,npmothm,npmothi,
     &  matmothm,matmothi
      integer, dimension (:,:), allocatable :: khullmoth,kfacemoth

      real*8 htup(ntupp),val
      integer nhull,nedge,kfacelast,kcyl

      integer ntet,ifailhull,nface,next,npoi,npoimoth,ipoi,last
      real xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,theta,pphi,
     &  xp1,yp1,zp1,xp2,yp2,zp2

      integer iwarn,ifilemodus,iplot,imodu,imoduo,
     &  ilast,ifirst,nwords,i2cop,i1cop,i1mod,i2mod,i1moth,i2moth,
     &  nx,ny,nz,ncopies,
     &  nmagdo,nmagrect,nmagdivrect,nmagrectspec,nmagdivrectspec,
     &  nmagdiv,nmagspec,nmagdivspec,
     &  ndiv,idiv,nfediv,nmago,nsmag,nsmallo,
     &  ical,jplan,jcol,
     &  nplan,ncol,ncorn,nmodule,ncopy,
     &  ixdiv,iydiv,izdiv,nxdiv,nydiv,nzdiv,
     &  kmag1,kmag2,kdmag,kdmag1,kmag,
     &  imp,imag,ipol,npol,iplan,iedge,icorn,imodul,icopy,k,i,j,ip1,ip2,
     &  iflange,nflange,
     &  ipos(2,100),istat,ianf,iend,iover,ierr,
     &  nwfil,nwfilo,isleep,ifound,ieof,ise,idum,lunnam,lundum,lun76,
     &  lunmat,kmat,nmatpoi,nmatpoimax,mapmode,lunpre,ipre,npre,maxplan,
     &  imatfile,ispecmag,nmagmaxo,nfirst,nlast,lpos(2,4),nwordsmax,korn,
     &  kornmoth,iplanmoth,kpoi,nline,lunkill,kill,ix1,ix2,iy1,iy2,iz1,iz2

      integer :: ireallo=-1, ihullallo=0
      integer ncutpiece

      character(10) dtday,dttime,dtzone
      character c1
      integer idatetime(8),lunclc

      logical lexist

      character(32) c32,ch32,chmod,chcop,chmoth1,chsel
      character(1) c32a(32),chmoth1a(32)
      character(64) c64
      character(128) c128
      character(2048) cfile,cline,cline1
      equivalence(c32a,c32)

      character(32), dimension (:), allocatable :: chdisp

      equivalence (chmoth1a,chmoth1)

      data eps10/1.0d-10/

      modegui=0

+self,if=trace.
      print*,"-trace-: undumag_ini_old entered"
+self.

      open(newunit=lun,file="undumag.stat")
      write(lun,*)"1"
      flush(lun)
      close(lun)

+seq,unduver.

c+seq,phycon1.

      kfoundplanes=0
      ncornadd=0
      nplanadd=0

      nplanmax=0
      ncornmax=0

c      iwarnbound=0

1111  ireallo=ireallo+1

      ncutpiece=0

      if (ireallo.ne.0) then
        deallocate(ibpecol,bpebc,bpemag,bpemag0,shuffle,bpebc0,
     &    bperot,bpetm,bflange,ibpeplan,ibpeplano,ibpecorn,mothdiv)
        deallocate(corn1,corn2,ncorn1,ncorn2)
        deallocate(hull,khull,kface,kedge,xhull,yhull,zhull)
        deallocate(xmoth,ymoth,zmoth,npmoth,matmoth,ncolmoth)
        deallocate(xmothm,ymothm,zmothm,npmothm,matmothm,ncolmothm)
        deallocate(xmothi,ymothi,zmothi,npmothi,matmothi,ncolmothi)
        deallocate(chmoths,chmothso,chmags,chmagsm,chmothsm,chmagsi,chmothsi)
        deallocate(magcyl)
+self,if=chmagpols.
        deallocate(chmagpols)
+self.,if=chmagpols.
        deallocate(idamp8)
      endif

      nmag=0
      nmoth=0
      nmago=-1
      nmagmax=0
      kcyl=0

      nmagrect=0
      nmagdivrect=0
      nmagdiv=0

      iwarnsum=0
      maxpoints=0
      kallodip=0

+self,if=-nowarnings.
      if (ireallo.eq.0) open(newunit=lunwarn,file="undumag.war")
+self.,if=-nowarnings.

      nmatpoimax=0

      iterrectot=0
      iterirontot=0

      xmin=1.0d30
      xmax=-1.0d30
      ymin=1.0d30
      ymax=-1.0d30
      zmin=1.0d30
      zmax=-1.0d30

cdebug

      iseqdebug=0
      kwave=0

      if (ireallo.ne.0) close(lunnam)
      inquire(file=trim(Fnam),exist=lexist)
      if (lexist.eqv..false.) then
        write(lun6,*)""
        write(lun6,*)"*** Error in undumag_ini_old: File " // trim(Fnam) // " not found ***"
        write(lun6,*)"*** Program UNDUMAG aborted ***"
        stop
      endif

      open(newunit=lunnam,file=trim(Fnam),form='formatted',status='old')
      read(lunnam,undumagn)
      read(lunnam,randomn)
      close(lunnam)

      kcalcvars=1 !to avoid problems with undumag.in if coating is used

      if (hulltiny.le.0d0) hulltiny=1.0e-6

      ndivfby=max(ndivfboxy,1)

      if (matrix.eq.0) then
        write(lun6,*)"**************************************************************************************"
        write(lun6,*)"*         Matrix mode is compulsary for current version of UNDUMAG, switching it on  *"
        write(lun6,*)"**************************************************************************************"
        matrix=1
      endif

      if (kbextern.eq.0) then
        bxex=0.0d0
        byex=0.0d0
        bzex=0.0d0
      endif

      rcvthron=abs(rcvthron)
      if (rcvthron.eq.0.0d0) rcvthron=1.0d30

      ixsymo=ixsym
      iysymo=iysym
      izsymo=izsym

+self,if=trace.
      print*,"-trace-: Mark 1"
+self.
      if (irnmode.eq.1.or.irnmode.eq.2) then
        kundurun=0
        open(newunit=lundum,file="undumag.run",form='formatted',recl=512)
        read(lundum,*,end=197)kundurun
197     kundurun=kundurun+1
        close(lundum)
        if (irnmode.eq.2) irnseed(12)=irnseed(12)+kundurun
        call util_random_set_seed(irnsize,irnseed)
      else if (irnmode<0) then
        open(newunit=lunrn,file='undumag.seeds',status='old')
        read(lunrn,*) k
        do i=1,irnsize
          read(lunrn,*)k,irnseed(k)
        enddo
        close(lunrn)
        call util_random_set_seed(irnsize,irnseed)
      else
        call util_random_init(irnsize,irnseed)
      endif

+self,if=trace.
      print*,"-trace-: Mark 2"
+self.
      ndisp=0
      if (kdisplace.ne.0) then
        if (ixsym.gt.0.or.iysym.gt.0.or.izsym.gt.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_ini_old: kdisplace is set, but set-up is mirrored due to ixsym, iysym, or izsym ***"
          write(lun6,*)
        endif
        open(newunit=lun,file="undumag.dis",status="old")
        do while (.true.)
          call util_skip_comment_end(lun,ieof)
          read(lun,'(a)')cline
          ndisp=ndisp+1
        enddo
        rewind(lun)
        allocate(chdisp(ndisp))
        allocate(displace(18,ndisp))
        do i=1,ndisp
! displace(1:3,i) displacement of magnet
! displace(4:6,i) yrot, zrot, dphi of rotation around x-axis
! displace(7:9,i) change of magnetization
! displace(10:18,i)
          !mode: 0, apply changes as they are
          !mode: 1, apply changes with randomization
          call util_skip_comment(lun)
          read(lun,*)chdisp(i),displace(1:18,i)
          call util_random(9,g)
          do k=1,9
            if (displace(k+9,i).ne.0.0d0) displace(k,i)=displace(k,i)*g(k)
          enddo
        enddo
        close(lun)
      endif
+self,if=trace.
      print*,"-trace-: Mark 3"
+self.

      if (nchiiron.le.0) nchiiron=1
      nchimax=0
      if (chicut.eq.-9999.0d0) chicut=max(abs(hconv),1.0d-10)
      corrtiny=corrtiny/1000.0d0 ! mm->meter

      randoxa=abs(randox)
      randoya=abs(randoy)
      randoza=abs(randoz)
      randox10=randoxa/10.0d0
      randoy10=randoya/10.0d0
      randoz10=randoza/10.0d0

      ifsimpson=isimpson
      open(unit=99,file='.util_spline_or_simpson_integral.dat')
      write(99,*)isimpson
      if (isimpson.gt.0) then
        write(lun6,*)
        write(lun6,*)"*** Simpson integrations applied ***"
        write(lun6,*)
      endif
      close(99)

      hconva=abs(hconv)
      if (hconv.le.-1000.0d0) hconva=0.0d0

      if (dampiron.eq.0.0d0.or.dampiron.gt.1.0d0) then
        dampiron=1.0d0
      endif

      if (maxiteriron.eq.-9999.and.dampiron.lt.1.0d0) then
        maxiteriron=(log(0.001)/log(1.0d0-dampiron)+1)
      endif

      dampi=dampiron

      if (maxiteriron.eq.-9999) maxiteriron=1

      if (ireallo.ne.0) close(lunconv)
      if(kdumpconv.ne.0) open(newunit=lunconv,file="undumag.cnv")
+self,if=trace.
      print*,"-trace-: Mark 4"
+self.

      if (ireallo.eq.0.and.kcalcvars.ne.0) then
        call undumag_calc(kechocalc,kcalcvars)
      endif
+self,if=trace.
      print*,"-trace-: Mark 5"
+self.

      if (ireallo.eq.0) then
        c128="izsym"
        call undumag_parameter(c128,val,istat)
        if (istat.ne.0) then
          c128="iZsym"
          call undumag_parameter(c128,val,istat)
          if (istat.eq.0) izsym=nint(val)
        else
          izsym=nint(val)
        endif
        c128="iysym"
        call undumag_parameter(c128,val,istat)
        if (istat.ne.0) then
          c128="iYsym"
          call undumag_parameter(c128,val,istat)
          if (istat.eq.0) iysym=nint(val)
        else
          iysym=nint(val)
        endif
        c128="ixsym"
        call undumag_parameter(c128,val,istat)
        if (istat.ne.0) then
          c128="iXsym"
          call undumag_parameter(c128,val,istat)
          if (istat.eq.0) ixsym=nint(val)
        else
          ixsym=nint(val)
        endif
        if (perlen.eq.9999.0d0) then
          c128="perlen"
          call undumag_parameter(c128,perlen,istat)
          if (istat.ne.0) then
            c128="Perlen"
            call undumag_parameter(c128,perlen,istat)
            if (istat.ne.0) then
              c128="PerLen"
              call undumag_parameter(c128,perlen,istat)
            endif
          endif
          if (istat.ne.0) then
            write(lun6,*)
            write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_parameter for PerLen ***"
            write(lun6,*)"Make sure, that " // trim(Fclc) // " contains parameter or variable PerLen!"
            write(lun6,*)
            stop
          else
            write(lun6,*)
            write(lun6,*)"Period length read from " // trim(Fclc) // ":",sngl(perlen)
            write(lun6,*)
            if (perlen.le.0.0d0) then
              perlen=100.0d0
              write(lun6,*)
              write(lun6,*)"*** Warning in undumag_ini_old:Zero or negative period-length found ***"
              write(lun6,*)"*** Set to 100 ***"
              write(lun6,*)
            endif
          endif
        endif
      endif
+self,if=trace.
      print*,"-trace-: Mark 6"
+self.

      if (dedgefb.eq.0.0d0) dedgefb=0.02d0

      if (iforce.ne.0.and.dedgefb.le.corrtiny) then
        write(lun6,*)""
        write(lun6,*)"*** Warning in undumag_ini_old: Dedgefb is not greater than corrtiny "
        write(lun6,*)""
      endif

      ubflenx=ubflenx+2.0d0*dedgefb
      ubfleny=ubfleny+2.0d0*dedgefb
      ubflenz=ubflenz+2.0d0*dedgefb

      if (iforce.lt.0) then
+self,if=trace.
        print*,"-trace-: Calling undumag_force_parameters"
+self.
        call undumag_force_parameters
+self,if=trace.
        print*,"-trace-: Passed undumag_force_parameters"
+self.
      endif

      if (iforce.ne.9999) then

        if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
        if (utorqceny.eq.9999.0d0) utorqceny=ubfceny
        if (utorqcenz.eq.9999.0d0) utorqcenz=ubfcenz

        bfcenxmm=ubfcenx
        bfcenymm=ubfceny
        bfcenzmm=ubfcenz
        bflenxmm=ubflenx
        bflenymm=ubfleny
        bflenzmm=ubflenz
        torqcenxmm=utorqcenx
        torqcenymm=utorqceny
        torqcenzmm=utorqcenz
        bfcenx=ubfcenx/1000.0d0
        bfceny=ubfceny/1000.0d0
        bfcenz=ubfcenz/1000.0d0
        bflenx=ubflenx/1000.0d0
        bfleny=ubfleny/1000.0d0
        bflenz=ubflenz/1000.0d0
        torqcenx=utorqcenx/1000.0d0
        torqceny=utorqceny/1000.0d0
        torqcenz=utorqcenz/1000.0d0
        jplforce=iplforce
        if (iforce.eq.0) then
          mbforcex=0
          mbforcey=0
          mbforcez=0
        endif
        nbforcx=mbforcex
        nbforcy=mbforcey
        nbforcz=mbforcez
        iforcol=mfcolor
        forcol=iforcol
        forxpl(1)=bfcenxmm-bflenxmm/2.
        forxpl(2)=bfcenxmm+bflenxmm/2.
        forypl(1)=bfcenymm-bflenymm/2.
        forypl(2)=bfcenymm+bflenymm/2.
        forzpl(1)=bfcenzmm-bflenzmm/2.
        forzpl(2)=bfcenzmm+bflenzmm/2.

      endif !(iforce.ne.9999) then

      xsymmm=xsym
      if (xsymmm.eq.9999.0d0) xsymmm=xcenter
      if (xsym.ne.9999.0d0) xsym=xsym/1000.0d0

      window=uwindow
      kdebug=kudebug

      if (window.le.0.0d0) window=1.0d30

      tiny=1.1d-6
      tiny=corrtiny
      tiny2=tiny*tiny

+self,if=trace.
      print*,"-trace-: Mark 6"
+self.
      scalcur=1.0d0

      TWOPI=2.0D0*PI1

      filebpe='undumag.in'

      iallowin=1
      iplot=iunduplot
      nthreads=nuthreads
      theta=unduplot_theta !plotting angle
      pphi=unduplot_phi   !plotting angle

      lunbpe=98
+self,if=trace.
      print*,"-trace-: Mark 7"
+self.
      close(lunbpe)

+self,if=trace.
      print*,"-trace-: Calling undumag_drop_zero_magnets"
+self.
      call undumag_drop_zero_magnets(kfoundplanes,kechocalc,hulltiny)
+self,if=trace.
      print*,"-trace-: Passed undumag_drop_zero_magnets"
+self.

      open(unit=lunbpe,file=filebpe,form='formatted',status='old')

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,'(a)')usercom
      unducomment=usercom

      if (ireallo.eq.0) then

        kundurun=0
        jcomment=kcomment
        jrunnum=krunnum
        jdate=kdate

        call date_and_time(dtday,dttime,dtzone,idatetime)

        open(newunit=lundum,file="undumag.run",form='formatted',recl=512)
        read(lundum,*,end=97)kundurun
97      kundurun=kundurun+1
        rewind(lundum)
        write(lundum,*) kundurun,trim(usercom),' ',
     &    dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
        close(lundum)
        open(newunit=lundum,file="undumag.runs",form='formatted',recl=512,
     &    access='append')
        write(lundum,*) kundurun,trim(usercom),' ',
     &    dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
        close(lundum)

        open(newunit=lunst,file="undumag.sta")
        write(lunst,*)kundurun,konv,iwarnsum
        write(lunst,*)"undumag_ini_old"
        close(lunst)

        write(lun6,*) "Run:",
     &    kundurun,"      ",
     &    dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)

        write(lun6,*) "User comment: ",trim(usercom)

      endif !(ireallo.eq.0) then

c loop over magnets, modules, and arrays {

11    call util_skip_comment_end(lunbpe,ieof)

      if (nmago.eq.-9.and.ieof.ne.0) then
        goto 992 ! end of magnet section
      endif

      read(lunbpe,'(a)')cline
      if (kechocalc.ne.0) write(lun6,*)trim(cline)

      read(cline,*)x0,y0,z0

      if (x0.eq.-9999..and.y0.eq.-9999..and.z0.eq.-9999.) then
        goto 992 ! end of magnet section
      endif

      nmag=nmag+1
      nmoth=nmoth+1

c get dimensions

      call util_skip_comment_end(lunbpe,ieof)
      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif
      read(lunbpe,*)bc,xm,ym,zm,imat

      if (imat.eq.0) bc=0.0d0

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,'(a)')cline
      if (kechocalc.ne.0) then
        write(lun6,*)trim(cline)
      endif

      c64='Cyl'
      call util_string_substring(cline,trim(c64),ianf,iend,istat)
      if (istat.eq.0) then
        !Cylinder
        read(cline(4:len_trim(cline)),*)ncol
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)radin,radout,height,angle,nr,nang,nh
        if (angle.gt.360.0d0) angle=360.0d0
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(1,1:3)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(2,1:3)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(3,1:3)
        nplan=-11
        if (bc.ne.0.0d0) nmagcyl=nmagcyl+1

      else ! Cyl

        c64='Block'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)

        if (istat.ne.0) then
          c64='File'
          call util_string_substring(cline,trim(c64),ianf,iend,istat)
          if (istat.ne.0) then
            c64='Corners'
            call util_string_substring(cline,trim(c64),ianf,iend,istat)
            if (istat.ne.0) then
              read(cline,*)nplan,ncol
            else
              !Corners
c            nplan=-10
              cline(ianf:iend)=' -10   '
              read(cline,*)nplan,ncol
            endif
          else
            !File with corners
            nplan=-9
            cline(ianf:iend)=' -9 '
          endif
        else
          !Block
          nplan=-6
          read(cline(iend+1:len_trim(cline)),*)ncol
          cline(ianf:iend)=' -6  '
        endif
      endif ! Cyl

      if (nplan.gt.0.and.nplan.gt.nplanmax) then
        kfoundplanes=1
        nplanmax=nplan
      endif

      if ((nplan.eq.-11.or.nplan.eq.-1.or.nplan.eq.-6.or.nplan.eq.-7).and.
     &    nplanmax.lt.6) then
        if (nplanmax.lt.6) nplanmax=6
        if (ncornmax.lt.5) ncornmax=5
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
      else if (nplan.eq.-9.or.nplan.eq.-10) then

        if (kechocalc.ne.0) then
          write(lun6,*)trim(cline)
        endif

        read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        call util_skip_comment_end(lunbpe,ieof)

        if (nplan.eq.-9) then

          if (kechocalc.ne.0) then
            write(lun6,*)trim(cline)
          endif
          read(lunbpe,*)cline

          open(newunit=lundum,file=trim(cline))

          npoi=0
          last=1

          do while (last.gt.0)
            call util_read_line(lundum,cline,last)
            if (last.gt.0) then
              npoi=npoi+1
            endif
          enddo

          if (maxpoints.eq.0) then
            maxpoints=100
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else if (npoi.gt.maxpoints) then
            if (ihullallo.ne.0) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
            endif
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          endif

          rewind(lundum)

          do ipoi=1,npoi
            call util_skip_comment_end(lundum,ieof)
            read(lundum,*)hull(1:3,ipoi)
          enddo

          close(lundum)

        else if (nplan.eq.-10) then

          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          read(lunbpe,*)npoi

          if (maxpoints.eq.0) then
            maxpoints=100
            ihullallo=1
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          else if (npoi.gt.maxpoints) then
            if (ihullallo.ne.0) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
            endif
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          endif

          do ipoi=1,npoi
            call util_skip_comment_end(lunbpe,ieof)
            if (kechocalc.ne.0) then
              read(lunbpe,'(a)')cline
              write(lun6,*)trim(cline)
              backspace(lunbpe)
            endif
            read(lunbpe,*)hull(1:3,ipoi)
          enddo

        endif !nplan.eq.-9/-10

        if (npoi.lt.4) then
          write(lun6,*)"*** Error in undumag_ini_old: Less data than four points on file ***",
     &      trim(cline)
          stop
        endif

        xhull(1:npoi)=hull(1,1:npoi)
        yhull(1:npoi)=hull(2,1:npoi)
        zhull(1:npoi)=hull(3,1:npoi)

        call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &    nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
+self,if=trace.
        print*,"-trace-: Passed util_convex_hull_3d"
+self.

        if (ifailhull.ne.0.or.nhull.lt.4) then
          write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &      trim(cline)
          stop
        endif

c        khull(1:kfacelast)=kface(1:kfacelast)

        nmagdiv=nmagdiv+nxdiv*nydiv*nzdiv

        next=1
        do iplan=1,nface
          ncorn=kface(next)
          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
          next=next+ncorn+1
        enddo
        if (nface.gt.nplanmax) nplanmax=nface

      else if (ireallo.eq.0.and.abs(nplan).gt.nplanmax) then
        nplanmax=abs(nplan)+3
        ncornmax=5
      endif !nplan .eq. -9/-10

      if (nplan.ne.-11.and.nplan.ne.-9.and.nplan.ne.-10) then
        nxdiv=1
        nydiv=1
        nzdiv=1
      endif

      if (nplan.gt.0) then

        ! normal polyhedron

c        backspace(lunbpe)
c        read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (kechocalc.ne.0) then
          write(lun6,*)trim(cline)
        endif

        read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif


        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        nmagdiv=nmagdiv+nxdiv*nydiv*nzdiv

        npoi=0
        do iplan=1,nplan

          call util_skip_comment_end(lunbpe,ieof)
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          read(lunbpe,*)ncorn

          if (ncorn.lt.3) then
            write(lun6,*)
            write(lun6,*)'*** ERROR IN undumag_ini_old: Too few points'
            write(lun6,*)'Magnet, plane: ',nmag,iplan
            write(lun6,*)
            stop
          endif

          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1

          do icorn=1,ncorn
            call util_skip_comment_end(lunbpe,ieof)
            if (kechocalc.ne.0) then
              read(lunbpe,'(a)')cline
              write(lun6,*)trim(cline)
              backspace(lunbpe)
            endif
            read(lunbpe,*)x0,y0,z0
            npoi=npoi+1
          enddo

        enddo !nplan

        if (maxpoints.eq.0) then
          maxpoints=100
          allocate(hull(3,maxpoints))
          allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
          allocate(khull(maxpoints))
          allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          ihullallo=1
        else if (npoi.gt.maxpoints) then
          if (ihullallo.ne.0) then
            deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
          endif
          maxpoints=npoi
          allocate(hull(3,maxpoints))
          allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
          allocate(khull(maxpoints))
          allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
        endif

      else if (nplan.eq.-9.or.nplan.eq.-10) then

        continue

      else if (nplan.eq.-6) then

        ncorn=4
        if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
        ncorn=ncorn+1

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif

        read(lunbpe,*,iostat=ieof)xlen,ylen,zlen,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        nmagdivrect=nmagdivrect+nxdiv*nydiv*nzdiv
        nmagrect=nmagrect+1

      else if (nplan.eq.-11) then

        ncorn=4
        if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
        ncorn=ncorn+1

        nangmin=1+abs(angle)/(90.0d0+tiny)

        if (nang.lt.nangmin) nang=nangmin
        if (nr.lt.1) nr=1
        if (nh.lt.1) nh=1

        nmagdiv=nmagdiv+nr*nang*nh

      else !(nplan.eq.-6)

        write(lun6,*) '*** Error in undumag_ini_old: Bad number of planes'
        write(lun6,*) '*** Magnet:', nmag
        write(lun6,*)'*** Program aborted ***'
        stop

      endif !nplan.gt.0

      goto 11

992   continue ! end of magnet section

      if (nmago.eq.-9.or.nmago.eq.-9999.or.nmago.eq.-8888) then
        close(lunbpe)
        lunbpe=98
      endif !nmago

      call util_skip_comment_end(lunbpe,ieof)
      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif
      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,*)nmodule

      if (nmodule.le.0) then
        write(lun6,*)'*** Error in undumag_ini_old: Number of modules is zero'
        stop
      endif

      ncopies=0
      nmotho=nmoth
      nmoth=0
      do imodul=1,nmodule

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)xmod,ymod,zmod

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(1,1),rotmod(1,2),rotmod(1,3)

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(2,1),rotmod(2,2),rotmod(2,3)

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(3,1),rotmod(3,2),rotmod(3,3)

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)ncopy

        call util_skip_comment_end(lunbpe,ieof)

        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)space,vspace(1),vspace(2),vspace(3)
        call util_vnorm(3,vspace,vspace)

        call util_skip_comment_end(lunbpe,ieof)

        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)vbsym(1),vbsym(2),vbsym(3)

        ncopies=ncopies+ncopy*(nmagdiv+nmagdivrect)
        nmoth=nmoth+nmotho*ncopy

      enddo !imodul=1,nmodule

      nmagmax=nmagmax+ncopies

c Special magnets

      nspecmag=0
      nmagrectspec=0
      nmagdivrectspec=0
      nmagdivspec=0

      x0=-1.0d30
      y0=-1.0d30
      z0=-1.0d30

1     call util_skip_comment(lunbpe)

      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif
      read(lunbpe,*)x0,y0,z0
      if (x0.eq.-9999..and.y0.eq.-9999..and.z0.eq.-9999.) goto 993

      nspecmag=nspecmag+1

      call util_skip_comment_end(lunbpe,ieof)
      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif
      read(lunbpe,*)bc,xm,ym,zm,imat
      if (imat.eq.0) bc=0.0d0

      call util_skip_comment_end(lunbpe,ieof)
      if (kechocalc.ne.0) then
        write(lun6,*)trim(cline)
      endif
      read(lunbpe,'(a)')cline

      c64='Cyl'
      call util_string_substring(cline,trim(c64),ianf,iend,istat)
      if (istat.eq.0) then
        !Cylinder
        read(cline(4:len_trim(cline)),*)ncol
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)radin,radout,height,angle,nr,nang,nh
        if (angle.gt.360.0d0) angle=360.0d0
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(1,1:3)
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(2,1:3)
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(3,1:3)
        ncornmax=5
        nplanmax=6
        nplan=-11

      else ! Cyl

        c64='Block'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)
        if (istat.ne.0) then
          c64='File'
          call util_string_substring(cline,trim(c64),ianf,iend,istat)
          if (istat.ne.0) then
            c64='Corners'
            call util_string_substring(cline,trim(c64),ianf,iend,istat)
            if (istat.ne.0) then
c            c64='Corners'
c            call util_string_substring(cline,trim(c64),ianf,iend,istat)
              read(cline,*)nplan,ncol
            else
c            nplan=-10
              cline(ianf:iend)=' -10   '
              read(cline,*)nplan,ncol
            endif
          else
            nplan=-9
            cline(ianf:iend)=' -9 '
          endif
        else
          nplan=-6
          cline(ianf:iend)=' -6  '
        endif

      endif ! Cyl

      if (nplan.gt.0) then

c        backspace(lunbpe)
c        read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (kechocalc.ne.0) then
          write(lun6,*)trim(cline)
        endif

        read(cline,*,iostat=ieof)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        nmagdivspec=nmagdivspec+nxdiv*nydiv*nzdiv

        if (nplan.gt.0.and.nplan.gt.nplanmax) nplanmax=nplan

        if ((nplan.eq.-1.or.nplan.eq.-6.or.nplan.eq.-7).and.nplanmax.lt.6) then
          if (ireallo.eq.0.and.nplanmax.lt.6) nplanmax=6
          if (ireallo.eq.0.and.ncornmax.lt.5) ncornmax=5
        endif

        npoi=0
        do iplan=1,nplan

          call util_skip_comment_end(lunbpe,ieof)
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          read(lunbpe,*)ncorn

          if (ncorn.lt.3) then
            write(lun6,*)
            write(lun6,*)'*** ERROR IN undumag_ini_old: Too few points'
            write(lun6,*)'Magnet, plane: ',nmag,iplan
            write(lun6,*)
            stop
          endif

          do icorn=1,ncorn
            call util_skip_comment_end(lunbpe,ieof)
            if (kechocalc.ne.0) then
              read(lunbpe,'(a)')cline
              write(lun6,*)trim(cline)
              backspace(lunbpe)
            endif
            read(lunbpe,*)xx,yy,zz
            npoi=npoi+1
          enddo

          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1

          ncorn=ncorn+1

        enddo !nplan

        if (maxpoints.eq.0) then
          maxpoints=100
          allocate(hull(3,maxpoints))
          allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
          allocate(khull(maxpoints))
          allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          ihullallo=1
        else if (npoi.gt.maxpoints) then
          if (ihullallo.ne.0) then
            deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
          endif
          maxpoints=npoi
          allocate(hull(3,maxpoints))
          allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
          allocate(khull(maxpoints))
          allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
        endif

      else if (nplan.eq.-9.or.nplan.eq.-10) then
cxxxxxxxxxxx

c        backspace(lunbpe)
c        read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (kechocalc.ne.0) then
          write(lun6,*)trim(cline)
        endif

        read(cline,*,iostat=ieof)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        call util_skip_comment_end(lunbpe,ieof)

        if (nplan.eq.-9) then
          read(lunbpe,*)cline
          if (kechocalc.ne.0) then
            write(lun6,*)trim(cline)
          endif
          open(newunit=lundum,file=trim(cline))

          npoi=0
          last=1

          do while (last.gt.0)
            call util_read_line(lundum,cline,last)
            if (last.gt.0) then
              npoi=npoi+1
            endif
          enddo

          if (maxpoints.eq.0) then
            maxpoints=100
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else if (npoi.gt.maxpoints) then
            if (ihullallo.ne.0) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
            endif
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          endif

          rewind(lundum)

          do ipoi=1,npoi
            call util_skip_comment_end(lundum,ieof)
            read(lundum,*)hull(1:3,ipoi)
          enddo

          close(lundum)

        else if (nplan.eq.-10) then

          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          read(lunbpe,*)npoi

          if (maxpoints.eq.0) then
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else if (npoi.gt.maxpoints) then
            if (ihullallo.ne.0) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
            endif
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          endif

          do ipoi=1,npoi
            call util_skip_comment_end(lunbpe,ieof)
            if (kechocalc.ne.0) then
              read(lunbpe,'(a)')cline
              write(lun6,*)trim(cline)
              backspace(lunbpe)
            endif
            read(lunbpe,*)hull(1:3,ipoi)
          enddo

        endif

        if (npoi.lt.4) then
          write(lun6,*)"*** Error in undumag_ini_old: Less data than four points on file ***",
     &      trim(cline)
          stop
        endif

        xhull(1:npoi)=hull(1,1:npoi)
        yhull(1:npoi)=hull(2,1:npoi)
        zhull(1:npoi)=hull(3,1:npoi)
        call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &    nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
        if (ifailhull.ne.0.or.nhull.lt.4) then
          write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &      trim(cline)
          stop
        endif

c        khull(1:kfacelast)=kface(1:kfacelast)

        nmagdivspec=nmagdivspec+nxdiv*nydiv*nzdiv
        next=1

        do iplan=1,nface
          ncorn=kface(next)
          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
          next=next+ncorn+1
        enddo

        if (nface.gt.nplanmax) nplanmax=nface

      else if (nplan.eq.-6) then

        ncorn=4
        if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
        ncorn=ncorn+1

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif

        read(lunbpe,*,iostat=ieof)xlen,ylen,zlen,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        nmagdivrectspec=nmagdivrectspec+nxdiv*nydiv*nzdiv
        nmagrectspec=nmagrectspec+1

      else if (nplan.eq.-11) then

        ncorn=4
        if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
        ncorn=ncorn+1

        if (nang.lt.nangmin) nang=nangmin
        if (nr.lt.1) nr=1
        if (nh.lt.1) nh=1

        nmagdivspec=nmagdivspec+nr*nang*nh

      else !(nplan.eq.-6)

        write(lun6,*) '*** Error in undumag_ini_old: Bad value of number of planes'
        write(lun6,*) '*** Magnet:', nmag
        write(lun6,*)'*** Program aborted ***'
        stop

      endif !nplan.gt.0

      goto 1

993   continue

      mspecmag=nmagdivspec+nmagdivrectspec
      if (ireallo.eq.0.and.nmagrectspec.gt.0.and.nplanmax.lt.6) nplanmax=6

      call util_skip_comment(lunbpe)
      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif

      call util_skip_comment(lunbpe)

      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif

+self,if=trace.
      print*,"-trace-: Going to material files"
+self.

      read(lunbpe,*)nmatfiles

      bcmo=-1.0d30
      hmato=-1.0d30
      do imatfile=1,nmatfiles
        call util_skip_comment(lunbpe)
        read(lunbpe,*) imat,lmat,mapmode,cfile
        nmatpoi=0
        open(newunit=lunmat,file=trim(cfile),status='old')
114     call util_skip_comment_end(lunmat,ieof)
        if (ieof.ne.0) goto 994
        read(lunmat,*)hmat,bcm
c        if (bcm.ne.bcmo.or.hmato.ne.hmat) then
        if (bcm.ne.bcmo) then
          nmatpoi=nmatpoi+1
c          hmato=hmat
c          bcmo=bcm
        endif
        hmato=hmat
        bcmo=bcm
        if (nmatpoi.gt.nmatpoimax) nmatpoimax=nmatpoi
        goto 114
994     close(lunmat)
      enddo

c loop over magnets, modules, and arrays }

      !nmag is number primary magnets, without special ones and modules

      nmagmaxo=nmagmax
      nsmag=max(nmag,nmagmax)+mspecmag
      nsmallo=nsmag

      if (ixsym.lt.0) then
        nsmag=2*nsmag
        nmoth=2*nmoth
      endif
      if (iysym.lt.0) then
        nsmag=2*nsmag
        nmoth=2*nmoth
      endif
      if (izsym.lt.0) then
        nsmag=2*nsmag
        nmoth=2*nmoth
      endif

      allocate(
     &  chmoths(32,nsmag+nmoth),
     &  chmothso(32,nsmag+nmoth),
     &  chmags(32,nsmag),
     &  chmagsm(32,nsmag),chmothsm(32,nsmag),
     &  chmagsi(32,nsmag),chmothsi(32,nsmag)
+self,if=chmagpols.
     &  ,chmagpols(32,nsmag)
+self.,if=chmagpols.
     &  )

      allocate(bpebc0(7,nsmag))
      allocate(bpebc(20,nsmag))
      bpebc=0.0d0
      allocate(bpemag(3,ncornmax,nplanmax,nsmag))
      allocate(bpemag0(3,ncornmax,nplanmax,nsmag))
      allocate(shuffle(6,ncornmax,nplanmax,nsmag))
      allocate(bperot(3,ncornmax,nplanmax,nsmag))
      allocate(bpetm(3,8,nplanmax,nsmag))
      bpetm=0.0d0
      allocate(bflange(7,(ncornmax)*(nplanmax)))

      allocate(ibpeplan(nsmag))
      allocate(ibpeplano(nsmag))
      allocate(ibpecol(nsmag))
      allocate(ibpecorn(nplanmax,nsmag),mothdiv(4,nsmag))

      allocate(corn1(3,2*ncornmax,2*nplanmax),
     &  corn2(3,2*ncornmax,2*nplanmax))
      allocate(ncorn1(2*nplanmax),ncorn2(2*nplanmax))

      allocate(idamp8(nsmag))

      mothdiv=1

      rewind(lunbpe)

      write(lun6,*)
      write(lun6,*)'Setup read first time from undumag.in to get dimensions'
      write(lun6,*)'Starting rereading and performing segmentations and geometry setup'
      write(lun6,*)
cdebug
      if (maxpoints.lt.8) maxpoints=8

      if (ixsymo.ne.0) then
        nspecmag=2*nspecmag
      endif
       if (iysymo.ne.0) then
        nspecmag=2*nspecmag
      endif
       if (izsymo.ne.0) then
        nspecmag=2*nspecmag
      endif

      nsmallo=max(nsmallo,nmoth+nspecmag)

      allocate(xmoth(maxpoints,nsmallo),
     &  ymoth(maxpoints,nsmallo),
     &  zmoth(maxpoints,nsmallo),
     &  npmoth(nsmallo),
     &  matmoth(nsmallo),
     &  ncolmoth(nsmallo)
     &  )
      allocate(xmothm(maxpoints,nsmallo),
     &  ymothm(maxpoints,nsmallo),
     &  zmothm(maxpoints,nsmallo),
     &  npmothm(nsmallo),
     &  matmothm(nsmallo),
     &  ncolmothm(nsmallo)
     &  )
      allocate(xmothi(maxpoints,nsmallo),
     &  ymothi(maxpoints,nsmallo),
     &  zmothi(maxpoints,nsmallo),
     &  npmothi(nsmallo),
     &  matmothi(nsmallo),
     &  ncolmothi(nsmallo)
     &  )

      allocate(magcyl(nmagcyl,2))

      nmoth=0
      if (ixsymo.ne.0) then
        nspecmag=nspecmag/2
      endif
       if (iysymo.ne.0) then
         nspecmag=nspecmag/2
      endif
       if (izsymo.ne.0) then
         nspecmag=nspecmag/2
      endif

c read and store data

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,'(a)')usercom

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,*)x0,y0,z0

      nmagmax=0
      kmag1=1
      kmag2=nmag
      kcyl=0

      if (nmago.eq.-1) then
        backspace(lunbpe)
      endif

      if (ireallo.ne.0) close(lun76)
      open(newunit=lun76,file="undumag.pla")

      nmoth=0
      nmagdo=nmag
cdebug
      do imag=1,nmagdo


        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,'(a)') cline
        call util_string_split_sep(cline,100,nwords,ipos,'!',istat)
        cline=cline(ipos(1,1):ipos(2,1))
        call util_string_split_sep(cline,100,nwords,ipos,' ',istat)

        if (nwords.eq.5) then
          read(cline,*)x00,y00,z00,chmag,chmoth
        else
          read(cline,*)x00,y00,z00
          write(chmag,*) imag
          call util_string_trim(chmag,nfirst,nlast)
          chmag="mag_" // chmag(nfirst:nlast)
          chmoth="Mag_" // chmag(nfirst:nlast)
        endif

        ifound=0
        do kmag=1,nmagmax
          ifound=1
          do ic=1,32
            if (chmags(ic,kmag).ne.chmag(ic:ic)) then
              ifound=0
              exit
            endif
          enddo
          if (ifound.eq.1) exit
        enddo

        if (ifound.ne.0) then
          write(lun6,*)"*** Error in undumag_ini_old: Duplicate magnet name: ",chmag
          stop
        endif

        nmagmax=nmagmax+1
        nmoth=nmoth+1

        c32=chmoth
        write(chmoths(1:32,nmagmax),'(a)')c32a(1:32)
        c32=chmag
        write(chmags(1:32,nmagmax),'(a)')c32a(1:32)

        bpebc(15,nmagmax)=nmagmax
        bpebc15=bpebc(15,nmagmax)
        mothdiv(1,nmagmax)=bpebc15

        bpebc0(1,nmagmax)=x00
        bpebc0(2,nmagmax)=y00
        bpebc0(3,nmagmax)=z00

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)bc,xm,ym,zm,imat !magnetization vector M

        if (imat.eq.0) bc=0.0d0

        bpebc(9,nmagmax)=imat
        bpebc(10,nmagmax)=0

        bdum=sqrt(xm*xm+ym*ym+zm*zm)

        if (bdum.eq.0.0d0.and.abs(bc).gt.0.01) then
          write(lun6,*)
          write(lun6,*)'*** Error in undumag_ini_old: Bad magnetization vector'
          write(lun6,*)'Magnet ',imag
          write(lun6,*)
          stop
        endif

c        call util_skip_comment_end(lunbpe,ieof)
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,'(a)')cline

        c64='Cyl'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)
        if (istat.eq.0) then
          !Cylinder
          read(cline(4:len_trim(cline)),*)ncol
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)radin,radout,height,angle,nr,nang,nh
          if (angle.gt.360.0d0) angle=360.0d0
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(1,1:3)
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(2,1:3)
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(3,1:3)
          nplan=-11

        else ! Cyl

          c64='Block'
          call util_string_substring(cline,trim(c64),ianf,iend,istat)
          if (istat.ne.0) then
            c64='File'
            call util_string_substring(cline,trim(c64),ianf,iend,istat)
            if (istat.ne.0) then
              c64='Corners'
              call util_string_substring(cline,trim(c64),ianf,iend,istat)
              if (istat.ne.0) then
c              c64='Corners'
c              call util_string_substring(cline,trim(c64),ianf,iend,istat)
                read(cline,*)nplan,ncol
              else
                nplan=-10
                cline(ianf:iend)=' -10   '
                read(cline,*)nplan,ncol
              endif
            else
              nplan=-9
              cline(ianf:iend)=' -9 '
            endif
          else
            cline(ianf:iend)=' -6  '
            read(cline,*)nplan,ncol
          endif

        endif !Cyl

        if (nplan.gt.0.or.nplan.eq.-9) then
c          backspace(lunbpe)
c          read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv

          read(cline,*,iostat=ieof)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          if (ieof.ne.0) then
            yfacdiv=1.0d0
          endif

          if (nxdiv.lt.1) nxdiv=1
          if (nydiv.lt.1) nydiv=1
          if (nzdiv.lt.1) nzdiv=1

        endif

        bdum=bc/bdum

        bpebc0(4,nmagmax)=xm*bdum
        bpebc0(5,nmagmax)=ym*bdum
        bpebc0(6,nmagmax)=zm*bdum

        ibpecol(nmagmax)=ncol
        ibpeplano(nmagmax)=nplan
        ibpeplan(nmagmax)=nplan

        if (nplan.gt.0.or.nplan.eq.-9.or.nplan.eq.-10) then

c          backspace(lunbpe)
c          read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
c          read(cline,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          if (ieof.ne.0) then
            yfacdiv=1.0d0
          endif


          if (nxdiv.lt.1) nxdiv=1
          if (nydiv.lt.1) nydiv=1
          if (nzdiv.lt.1) nzdiv=1

          nmag=nmag+nxdiv*nydiv*nzdiv-1
          kmag2=kmag2+nxdiv*nydiv*nzdiv-1

          bpebc0(7,nmagmax)=1

          xdivmin=1.0d30
          xdivmax=-1.0d30
          ydivmin=1.0d30
          ydivmax=-1.0d30
          zdivmin=1.0d30
          zdivmax=-1.0d30

          ncorn1=0
          ncorn2=0

          fracsum=0.0d0
          ! yfracdiv**(nydiv-1)=yfacdiv
          ! ln(yfracdiv)*(nydiv-1)=ln(yfacdiv)
          if (nydiv.gt.1) then
            yfracdiv=exp(log(yfacdiv)/(nydiv-1))
          else
            yfracdiv=1.0d0
          endif
          do iydiv=0,nydiv-1
            fracsum=fracsum+yfracdiv**iydiv
          enddo

          if (nplan.eq.-9.or.nplan.eq.-10) then
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

c            backspace(lunbpe)
c            read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
c            read(cline,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
            read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
            if (ieof.ne.0) then
              yfacdiv=1.0d0
            endif


            if (nxdiv.lt.1) nxdiv=1
            if (nydiv.lt.1) nydiv=1
            if (nzdiv.lt.1) nzdiv=1

            call util_skip_comment_end(lunbpe,ieof)

            if (nplan.eq.-9) then

              read(lunbpe,*)cline
              open(newunit=lundum,file=trim(cline))

              last=1
              npoi=0
              gcen=0.0d0

              do while (last.gt.0)
                call util_read_line(lundum,cline,last)
                if (last.gt.0) then
                  npoi=npoi+1
                endif
              enddo

              if (maxpoints.eq.0) then
                maxpoints=100
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                ihullallo=1
              else if (npoi.gt.maxpoints) then
                if (ihullallo.ne.0) then
                  deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                endif
                maxpoints=npoi
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
              endif

              rewind(lundum)

c              nmoth=nmagmax
              do ipoi=1,npoi
                call util_skip_comment_end(lundum,ieof)
                read(lundum,*)hull(1:3,ipoi)
                gcen=gcen+bpebc0(1:3,nmagmax)+hull(1:3,ipoi)
              enddo

              close(lundum)

            else if (nplan.eq.-10) then

              read(lunbpe,*)npoi

              if (maxpoints.eq.0) then
                maxpoints=100
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                ihullallo=1
              else if (npoi.gt.maxpoints) then
                if (ihullallo.ne.0) then
                  deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                endif
                maxpoints=npoi
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
              endif

              gcen=0.0d0
c              nmoth=nmagmax
              do ipoi=1,npoi
                call util_skip_comment_end(lunbpe,ieof)
                read(lunbpe,*)hull(1:3,ipoi)
                gcen=gcen+bpebc0(1:3,nmagmax)+hull(1:3,ipoi)
              enddo

            endif !nplan.eq.-9/-10

            gcen=gcen/npoi

            xhull(1:npoi)=hull(1,1:npoi)
            yhull(1:npoi)=hull(2,1:npoi)
            zhull(1:npoi)=hull(3,1:npoi)

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &          trim(cline)
              stop
            endif

            gcen=0.0d0
            do ipoi=1,nhull
              korn=khull(nhull)
              gcen=gcen+bpebc0(1:3,nmagmax)+hull(1:3,ipoi)
            enddo
            gcen=gcen/nhull
c            khull(1:kfacelast)=kface(1:kfacelast)

            ibpeplano(nmagmax)=nface
            ibpeplan(nmagmax)=nface

            npmoth(nmoth)=npoi
            matmoth(nmoth)=imat
            ncolmoth(nmoth)=ibpecol(nmagmax)
            do ipoi=1,npoi
              xmoth(ipoi,nmoth)=bpebc0(1,nmagmax)+hull(1,ipoi)
              ymoth(ipoi,nmoth)=bpebc0(2,nmagmax)+hull(2,ipoi)
              zmoth(ipoi,nmoth)=bpebc0(3,nmagmax)+hull(3,ipoi)
              hull(1:3,ipoi)=bpebc0(1:3,nmagmax)+hull(1:3,ipoi)-gcen
            enddo

            bpebc0(1:3,nmagmax)=gcen

            x00=bpebc0(1,nmagmax)
            y00=bpebc0(2,nmagmax)
            z00=bpebc0(3,nmagmax)

            next=1
+self,if=debug.
            open(unit=97)
+self.,if=debug.
            do iplan=1,nface

              ncorn=kface(next)

              ncorn=ncorn+1
              ibpecorn(iplan,nmagmax)=ncorn

              do icorn=1,ncorn

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                if (icorn.lt.ncorn) then

                  x0=hull(1,kface(next+icorn))
                  y0=hull(2,kface(next+icorn))
                  z0=hull(3,kface(next+icorn))

                  if (x0.lt.xdivmin) xdivmin=x0
                  if (x0.gt.xdivmax) xdivmax=x0
                  if (y0.lt.ydivmin) ydivmin=y0
                  if (y0.gt.ydivmax) ydivmax=y0
                  if (z0.lt.zdivmin) zdivmin=z0
                  if (z0.gt.zdivmax) zdivmax=z0

                  bpemag0(1,icorn,iplan,nmagmax)=x0
                  bpemag0(2,icorn,iplan,nmagmax)=y0
                  bpemag0(3,icorn,iplan,nmagmax)=z0

                  write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 0"

                  corn1(1,icorn,iplan)=x0
                  corn1(2,icorn,iplan)=y0
                  corn1(3,icorn,iplan)=z0
+self,if=debug.
                  !w97
                  write(97,*)"-99999. ",ireallo," -99999. ",nmagmax,iplan,icorn,
     &              sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,nmagmax))
+self.

                else ! icorn.lt.ncorn

                  bpemag0(1,icorn,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                  bpemag0(2,icorn,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                  bpemag0(3,icorn,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)

                endif ! icorn.lt.ncorn

              enddo !icorn

              ncorn1(iplan)=ncorn

              next=next+ncorn ! here, ncorn is already increamented by 1

            enddo !nface
+self,if=debug.
            close(97)
+self.,if=debug.

            nplan=nface

cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

          else ! nplan.eq.-9

            ! magnet definition by planes

            npoi=0

            do iplan=1,nplan

              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)ncorn

              ncorn=ncorn+1
              ibpecorn(iplan,nmagmax)=ncorn

              do icorn=1,ncorn

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                if (icorn.lt.ncorn) then

                  call util_skip_comment_end(lunbpe,ieof)
                  read(lunbpe,*)x0,y0,z0

                  bpemag0(1,icorn,iplan,nmagmax)=x0
                  bpemag0(2,icorn,iplan,nmagmax)=y0
                  bpemag0(3,icorn,iplan,nmagmax)=z0

                  npoi=npoi+1

                  if (maxpoints.eq.0) then
                    maxpoints=100
                    allocate(hull(3,maxpoints))
                    allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                    allocate(khull(maxpoints))
                    allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                    ihullallo=1
                  else if (npoi.gt.maxpoints) then
                    if (ihullallo.ne.0) then
                      deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                    endif
                    maxpoints=npoi
                    allocate(hull(3,maxpoints))
                    allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                    allocate(khull(maxpoints))
                    allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                  endif

                  xhull(npoi)=x00+x0
                  yhull(npoi)=y00+y0
                  zhull(npoi)=z00+z0

                  write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 0"

                else ! icorn.lt.ncorn

                  bpemag0(1,icorn,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                  bpemag0(2,icorn,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                  bpemag0(3,icorn,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)

                endif ! icorn.lt.ncorn

              enddo !icorn

              ncorn1(iplan)=ncorn

            enddo !nplan

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &          trim(cline)
              stop
            endif

            gcen=0.0d0
            npmoth(nmoth)=nhull
            matmoth(nmoth)=imat
            ncolmoth(nmoth)=ibpecol(nmagmax)
            do ipoi=1,nhull
              kpoi=khull(ipoi)
              x0=xhull(kpoi)
              y0=yhull(kpoi)
              z0=zhull(kpoi)
              xmoth(ipoi,nmoth)=x0
              ymoth(ipoi,nmoth)=y0
              zmoth(ipoi,nmoth)=z0
              gcen(1)=gcen(1)+x0
              gcen(2)=gcen(2)+y0
              gcen(3)=gcen(3)+z0
            enddo

            gcen=gcen/nhull

            do iplan=1,nplan
              ncorn=ncorn1(iplan)
              do icorn=1,ncorn
                bpemag0(1:3,icorn,iplan,nmagmax)=bpebc0(1:3,nmagmax)+
     &            bpemag0(1:3,icorn,iplan,nmagmax)-gcen
                corn1(1:3,icorn,iplan)=bpemag0(1:3,icorn,iplan,nmagmax)
c                write(lun6,*)nmagmax,iplan,icorn,corn1(1:3,icorn,iplan)
              enddo !icorn
            enddo !nplan

            ! sort points such that normal vectors of planes points outside
            call undumag_sortcorn(2*ncornmax,2*nplanmax,
     &        nplan,ncorn1,corn1,corn2,tiny2,ifail)

            if (ifail.ne.0) then
              write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_sortcorn for magnet ",nmagmax
              stop
            else
              do iplan=1,nplan
                ncorn=ncorn1(iplan)
                do icorn=1,ncorn
                  bpemag0(1:3,icorn,iplan,nmagmax)=corn2(1:3,icorn,iplan)
                enddo !icorn
              enddo !nplan
            endif

            x00=gcen(1)
            y00=gcen(2)
            z00=gcen(3)

            bpebc0(1:3,nmagmax)=gcen

            do iplan=1,nplan

              ncorn=ncorn1(iplan)

              do icorn=1,ncorn-1

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                x0=bpemag0(1,icorn,iplan,nmagmax)
                y0=bpemag0(2,icorn,iplan,nmagmax)
                z0=bpemag0(3,icorn,iplan,nmagmax)

                if (x0.lt.xdivmin) xdivmin=x0
                if (x0.gt.xdivmax) xdivmax=x0
                if (y0.lt.ydivmin) ydivmin=y0
                if (y0.gt.ydivmax) ydivmax=y0
                if (z0.lt.zdivmin) zdivmin=z0
                if (z0.gt.zdivmax) zdivmax=z0

                corn1(1,icorn,iplan)=x0 !Relative
                corn1(2,icorn,iplan)=y0
                corn1(3,icorn,iplan)=z0

                write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 1"

              enddo !icorn
            enddo !nplan

          endif ! nplan.eq.-9

          x02(2)=x00
          y02(2)=y00
          z02(2)=z00

          bc04=bpebc0(4:7,nmagmax)
          bc9=bpebc(9,nmagmax)
          bc10=bpebc(10,nmagmax)

          dxdiv=(xdivmax-xdivmin)/nxdiv
          xdiv=bpebc0(1,nmagmax)+xdivmin !Labor

          bpebc15=bpebc(15,nmagmax)
          mothdiv(1,nmagmax)=bpebc15

          do ic=1,32
            chmag(ic:ic)=chmags(ic,nmagmax)
            chmoth(ic:ic)=chmoths(ic,nmagmax)
          enddo

          ncutpiece=ncutpiece+1
cdebug ixdiv 1
          do ixdiv=1,nxdiv-1

            xdiv=xdiv+dxdiv

            x02(1)=x02(2) !Labor
            y02(1)=y02(2)
            z02(1)=z02(2)

            call undumag_cut_magnet(nmagmax,x02,y02,z02, !debug 1
     &        2*nplanmax,2*ncornmax,
     &        ncorn1,corn1,ncorn2,corn2
     &        ,1,xdiv,hulltiny,ifail)
            if (ifail.ne.0) then
              write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, ixdiv, xdiv:",
     &          ifail,nmagmax,ixdiv,xdiv
              stop
            endif

c?            nmagmax=nmagmax-1

            if (ncorn2(1).gt.0) then

+self,if=debug.
              write(lun6,*)
              write(lun6,*)"ireallo, x-cut for magnet:",ireallo,nmagmax
+self.
              ! Magnet has been cut

              ! First piece

c?              nmagmax=nmagmax+1

              ncutpiece=ncutpiece+1

              bpebc(15,nmagmax)=bpebc15
              mothdiv(1,nmagmax)=bpebc15

              mothdiv(2,nmagmax)=ixdiv

              do ic=1,32
                chmags(ic,nmagmax)=chmag(ic:ic)
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo

              bpebc(9,nmagmax)=bc9
              bpebc(10,nmagmax)=bc10

              bpebc0(1,nmagmax)=x02(1)
              bpebc0(2,nmagmax)=y02(1)
              bpebc0(3,nmagmax)=z02(1)

              bpebc0(4:7,nmagmax)=bc04

              nplan=0
              do i=1,2*nplanmax
                if (ncorn1(i).gt.0) then
                  nplan=nplan+1
                endif
              enddo

              if (nplan.gt.nplanmax) then
                nplanmax=nplan
                goto 1111
              endif

              ibpecol(nmagmax)=ncol
              ibpeplan(nmagmax)=nplan
              ibpeplano(nmagmax)=nplan

+self,if=debug.
              open(unit=97,access='append')
+self.,if=debug.
              do iplan=1,nplan
                ncorn=ncorn1(iplan)
                ibpecorn(iplan,nmagmax)=ncorn+1
                if (ncorn+1.gt.ncornmax) then
                  ncornmax=ncorn+1
                  goto 1111
                endif
                do icorn=1,ncorn
                  bpemag0(1:3,icorn,iplan,nmagmax)=
     &              corn1(1:3,icorn,iplan)
+self,if=debug.
                  !w97
                  write(97,*)"11 ",ireallo,xdiv,nmagmax,iplan,icorn,
     &              sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,nmagmax))
+self.
                enddo
                ncorn=ncorn+1
                bpemag0(1:3,ncorn,iplan,nmagmax)=
     &            corn1(1:3,1,iplan) !debug 1
              enddo
+self,if=debug.
              close(97)
+self.,if=debug.

              !{ check orientation of planes

              kdmag=nmagmax

              x0=0.0d0
              y0=0.0d0
              z0=0.0d0

              i=0
              nplan=ibpeplan(kdmag)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,kdmag)-1
                do icorn=1,ncorn
                  i=i+1
                  x0=x0+bpemag0(1,icorn,iplan,kdmag)
                  y0=y0+bpemag0(2,icorn,iplan,kdmag)
                  z0=z0+bpemag0(3,icorn,iplan,kdmag)
                enddo ! icorn
              enddo !iplan

              x0=x0/i
              y0=y0/i
              z0=z0/i
+self,if=debug.
              write(lun6,*)"First piece:",kdmag
+self.
              do iplan=1,nplan

                p1(1)=bpemag0(1,1,iplan,kdmag)
                p1(2)=bpemag0(2,1,iplan,kdmag)
                p1(3)=bpemag0(3,1,iplan,kdmag)

                p2(1)=bpemag0(1,2,iplan,kdmag)
                p2(2)=bpemag0(2,2,iplan,kdmag)
                p2(3)=bpemag0(3,2,iplan,kdmag)

                p3(1)=bpemag0(1,3,iplan,kdmag)
                p3(2)=bpemag0(2,3,iplan,kdmag)
                p3(3)=bpemag0(3,3,iplan,kdmag)

                call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)

                if (ifail.ne.0) then
                  write(lun6,*)"*** Error 1 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &              kdmag,iplan
                  stop
                endif

                ! does normal vector point outside?

                vsx=bpemag0(1,1,iplan,kdmag)-x0
                vsy=bpemag0(2,1,iplan,kdmag)-y0
                vsz=bpemag0(3,1,iplan,kdmag)-z0

                if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,kdmag)=ncorn

                  do icorn=1,ncorn
                    corn1(1:3,icorn,iplan)=
     &                bpemag0(1:3,icorn,iplan,kdmag)
                  enddo

                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,ncorn+1-icorn,iplan)
                  enddo

                endif

              enddo !nplan
              !} check orientation of planes

              ! Second piece

              nmagmax=nmagmax+1
+self,if=debug.
              write(lun6,*)"Second piece:",nmagmax
+self.

              bpebc(15,nmagmax)=bpebc15
              mothdiv(1,nmagmax)=bpebc15

              mothdiv(2,nmagmax)=ixdiv+1

              do ic=1,32
                chmags(ic,nmagmax)=chmag(ic:ic)
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo

              bpebc(9,nmagmax)=bc9
              bpebc(10,nmagmax)=bc10

              bpebc0(1,nmagmax)=x02(2)
              bpebc0(2,nmagmax)=y02(2)
              bpebc0(3,nmagmax)=z02(2)

              bpebc0(4:7,nmagmax)=bc04

              nplan=0
              do i=1,2*nplanmax
                if (ncorn2(i).gt.0) then
                  nplan=nplan+1
                endif
              enddo

              if (nplan.gt.nplanmax) then
                nplanmax=nplan
                goto 1111
              endif

              ibpeplan(nmagmax)=nplan
              ibpeplano(nmagmax)=nplan
              ibpecol(nmagmax)=ncol

+self,if=debug.
              open(unit=97,access='append')
+self.,if=debug.
              do iplan=1,nplan
                ncorn=ncorn2(iplan)
                if (ncorn+1.gt.ncornmax) then
                  ncornmax=ncorn+1
                  goto 1111
                endif
                ibpecorn(iplan,nmagmax)=ncorn+1
                do icorn=1,ncorn
                  bpemag0(1:3,icorn,iplan,nmagmax)=
     &              corn2(1:3,icorn,iplan)
+self,if=debug.
                  !w97
                  write(97,*)"22 ",ireallo,xdiv,nmagmax,iplan,icorn,
     &              sngl(corn2(1:3,icorn,iplan)+bpebc0(1:3,nmagmax))
+self.
                enddo
                ncorn=ncorn+1
                bpemag0(1:3,ncorn,iplan,nmagmax)=
     &            corn2(1:3,1,iplan) !debug 1
              enddo
+self,if=debug.
              close(97)
+self.,if=debug.

              ncorn1=0
              corn1=0.0d0
              ncorn1=ncorn2
              corn1=corn2

              !{ check orientation of planes

              x0=0.0d0
              y0=0.0d0
              z0=0.0d0

              i=0
              nplan=ibpeplan(nmagmax)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,nmagmax)-1
                do icorn=1,ncorn
                  i=i+1
                  x0=x0+bpemag0(1,icorn,iplan,nmagmax)
                  y0=y0+bpemag0(2,icorn,iplan,nmagmax)
                  z0=z0+bpemag0(3,icorn,iplan,nmagmax)
                enddo ! icorn
              enddo !iplan

              x0=x0/i
              y0=y0/i
              z0=z0/i

              do iplan=1,nplan

                p1(1)=bpemag0(1,1,iplan,nmagmax)
                p1(2)=bpemag0(2,1,iplan,nmagmax)
                p1(3)=bpemag0(3,1,iplan,nmagmax)

                p2(1)=bpemag0(1,2,iplan,nmagmax)
                p2(2)=bpemag0(2,2,iplan,nmagmax)
                p2(3)=bpemag0(3,2,iplan,nmagmax)

                p3(1)=bpemag0(1,3,iplan,nmagmax)
                p3(2)=bpemag0(2,3,iplan,nmagmax)
                p3(3)=bpemag0(3,3,iplan,nmagmax)

                call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                if (ifail.ne.0) then
                  write(lun6,*)"*** Error 2 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &              nmagmax,iplan
                  stop
                endif

                ! does normal vector point outside?

                vsx=bpemag0(1,1,iplan,nmagmax)-x0
                vsy=bpemag0(2,1,iplan,nmagmax)-y0
                vsz=bpemag0(3,1,iplan,nmagmax)-z0

                if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,nmagmax)=ncorn

                  do icorn=1,ncorn
                    corn1(1:3,icorn,iplan)=
     &                bpemag0(1:3,icorn,iplan,nmagmax)
                  enddo

                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,nmagmax)=
     &                corn1(1:3,ncorn+1-icorn,iplan)
                  enddo

                endif

              enddo !nplan
              !} check orientation of planes

            endif !cut

          enddo !nxdiv

          dydiv=(ydivmax-ydivmin)/fracsum*yfacdiv
c          dydiv=(ydivmax-ydivmin)/nydiv

          do kdmag1=nmagmax-nxdiv+1,nmagmax

            ncorn1=0
            corn1=0.0d0
            ncorn2=0
            corn2=0.0d0

            nplan=ibpeplan(kdmag1)

            ydivmin=1.0d30
            ydivmax=-1.0d30
+self,if=debug.
            open(unit=97,access='append')
+self.,if=debug.
            do iplan=1,nplan
              ncorn=ibpecorn(iplan,kdmag1)
              ncorn1(iplan)=ncorn
              do icorn=1,ncorn
                corn1(1:3,icorn,iplan)=bpemag0(1:3,icorn,iplan,kdmag1)
+self,if=debug.
                  !w97
                write(97,*)"-9999. ",ireallo," -9999. ",kdmag1,iplan,icorn,
     &            sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,kdmag1))
+self.
                if (corn1(2,icorn,iplan).lt.ydivmin)
     &            ydivmin=corn1(2,icorn,iplan)
                if (corn1(2,icorn,iplan).gt.ydivmax)
     &            ydivmax=corn1(2,icorn,iplan)
              enddo
            enddo
+self,if=debug.
            close(97)
+self.,if=debug.

            dydiv=(ydivmax-ydivmin)/fracsum*yfacdiv
            ydiv=bpebc0(2,kdmag1)+ydivmin
c            ydiv=bpebc0(2,kdmag1)+ydivmax

            x02(2)=bpebc0(1,kdmag1)
            y02(2)=bpebc0(2,kdmag1)
            z02(2)=bpebc0(3,kdmag1)
cdebug iydiv 1
            do iydiv=1,nydiv-1

              if (iydiv.eq.1) then
                kdmag=kdmag1
              else
                kdmag=nmagmax
              endif

              ydiv=ydiv+dydiv
c              ydiv=ydiv-dydiv

              !Labor
              x02(1)=x02(2)
              y02(1)=y02(2)
              z02(1)=z02(2)

c              if (ireallo.eq.4.and.kdmag.eq.4) then
+self,if=debug.
              write(lun6,*)"ireallo, iydiv, ydiv:",ireallo,iydiv,ydiv
              open(unit=97,access='append')
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,kdmag)
                do icorn=1,ncorn
                  !w97
                  write(97,*)"0 ",ireallo,ydiv,kdmag,iplan,icorn,
     &              sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,kdmag))
                enddo
              enddo
c              endif
              close(97)
+self.

              call undumag_cut_magnet(kdmag,x02,y02,z02, !debug 2
     &          2*nplanmax,2*ncornmax,
     &          ncorn1,corn1,ncorn2,corn2
     &          ,2,ydiv,hulltiny,ifail)

              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, iydiv, ydiv:",
     &            ifail,kdmag,iydiv,ydiv
                stop
              endif

              !kdmag is mother

c              ncutpiece=ncutpiece+1
              if (ncorn2(1).gt.0) then
                ! Magnet has been cut

+self,if=debug.
                write(lun6,*)"y-cut for magnet:",kdmag
+self.
                ncutpiece=ncutpiece+1

                ! First piece, replaces mother

                bpebc(15,kdmag)=bpebc15
                mothdiv(1,kdmag)=bpebc15
                mothdiv(3,kdmag)=iydiv

                do ic=1,32
                  chmags(ic,kdmag)=chmag(ic:ic)
                  chmoths(ic,kdmag)=chmoth(ic:ic)
                enddo

                bpebc(9,kdmag)=bc9
                bpebc(10,kdmag)=bc10

                bpebc0(1,kdmag)=x02(1)
                bpebc0(2,kdmag)=y02(1)
                bpebc0(3,kdmag)=z02(1)

                bpebc0(4:7,kdmag)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                if (nplan.gt.nplanmax) then
                  nplanmax=nplan
                  goto 1111
                endif

                ibpecol(kdmag)=ncol
                ibpeplan(kdmag)=nplan
                ibpeplano(kdmag)=nplan

+self,if=debug.
                open(unit=97,access='append')
+self.,if=debug.
                do iplan=1,nplan
                  ncorn=ncorn1(iplan)
                  if (ncorn+1.gt.ncornmax) then
                    ncornmax=ncorn+1
                    goto 1111
                  endif
                  ibpecorn(iplan,kdmag)=ncorn+1
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,icorn,iplan)
+self,if=debug.
                  !w97
                    write(97,*)"1 ",ireallo,ydiv,kdmag,iplan,icorn,
     &                sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,kdmag))
+self.
                  enddo
                  ncorn=ncorn+1
                  bpemag0(1:3,ncorn,iplan,kdmag)=
     &              corn1(1:3,1,iplan) !debug 2
                enddo
+self,if=debug.
                close(97)
+self.,if=debug.

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                do iplan=1,ibpeplan(kdmag)
                  do icorn=1,ibpecorn(iplan,kdmag)-1
                    i=i+1
                    x0=x0+bpemag0(1,icorn,iplan,kdmag)
                    y0=y0+bpemag0(2,icorn,iplan,kdmag)
                    z0=z0+bpemag0(3,icorn,iplan,kdmag)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(kdmag)

                  p1(1)=bpemag0(1,1,iplan,kdmag)
                  p1(2)=bpemag0(2,1,iplan,kdmag)
                  p1(3)=bpemag0(3,1,iplan,kdmag)

                  p2(1)=bpemag0(1,2,iplan,kdmag)
                  p2(2)=bpemag0(2,2,iplan,kdmag)
                  p2(3)=bpemag0(3,2,iplan,kdmag)

                  p3(1)=bpemag0(1,3,iplan,kdmag)
                  p3(2)=bpemag0(2,3,iplan,kdmag)
                  p3(3)=bpemag0(3,3,iplan,kdmag)

                  call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)

                  if (ifail.ne.0) then
                    write(lun6,*)
                    write(lun6,*)"*** Error 3 in undumag_ini_old: Failure in undumag_bpen"
                    write(lun6,*)"mag, plane:",kdmag,iplan
                    write(lun6,*)
                    do icorn=1,ibpecorn(iplan,kdmag)
                      write(lun6,*)icorn,bpemag0(1:3,icorn,iplan,kdmag)
                    enddo
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag0(1,1,iplan,kdmag)-x0
                  vsy=bpemag0(2,1,iplan,kdmag)-y0
                  vsz=bpemag0(3,1,iplan,kdmag)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn1(iplan)
                    ibpecorn(iplan,kdmag)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                   bpemag0(1:3,icorn,iplan,kdmag)
                    enddo

                    do icorn=1,ncorn
                      bpemag0(1:3,icorn,iplan,kdmag)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ! Second piece

                nmagmax=nmagmax+1
+self,if=debug.
                write(lun6,*)"Second piece:",nmagmax
+self.

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15
                mothdiv(3,nmagmax)=iydiv+1

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=bc9
                bpebc(10,nmagmax)=bc10

                bpebc0(1,nmagmax)=x02(2)
                bpebc0(2,nmagmax)=y02(2)
                bpebc0(3,nmagmax)=z02(2)

                bpebc0(4:7,nmagmax)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn2(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                if (nplan.gt.nplanmax) then
                  nplanmax=nplan
                  goto 1111
                endif

                ibpeplan(nmagmax)=nplan
                ibpeplano(nmagmax)=nplan
                ibpecol(nmagmax)=ncol

+self,if=debug.
                open(unit=97,access='append')
+self.,if=debug.
                do iplan=1,nplan
                  ncorn=ncorn2(iplan)
                  if (ncorn+1.gt.ncornmax) then
                    ncornmax=ncorn+1
                    goto 1111
                  endif
                  ibpecorn(iplan,nmagmax)=ncorn+1
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,nmagmax)=
     &                corn2(1:3,icorn,iplan)
+self,if=debug.
                  !w97
                    write(97,*)"2 ",ireallo,ydiv,kdmag,iplan,icorn,
     &                sngl(corn2(1:3,icorn,iplan)+bpebc0(1:3,nmagmax))
+self.
                  enddo
                  ncorn=ncorn+1
                  bpemag0(1:3,ncorn,iplan,nmagmax)=
     &              corn2(1:3,1,iplan) !debug 2
                enddo
+self,if=debug.
                close(97)
+self.,if=debug.

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                do iplan=1,ibpeplan(nmagmax)
                  do icorn=1,ibpecorn(iplan,nmagmax)-1
                    i=i+1
                    x0=x0+bpemag0(1,icorn,iplan,nmagmax)
                    y0=y0+bpemag0(2,icorn,iplan,nmagmax)
                    z0=z0+bpemag0(3,icorn,iplan,nmagmax)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(nmagmax)

                  p1(1)=bpemag0(1,1,iplan,nmagmax)
                  p1(2)=bpemag0(2,1,iplan,nmagmax)
                  p1(3)=bpemag0(3,1,iplan,nmagmax)

                  p2(1)=bpemag0(1,2,iplan,nmagmax)
                  p2(2)=bpemag0(2,2,iplan,nmagmax)
                  p2(3)=bpemag0(3,2,iplan,nmagmax)

                  p3(1)=bpemag0(1,3,iplan,nmagmax)
                  p3(2)=bpemag0(2,3,iplan,nmagmax)
                  p3(3)=bpemag0(3,3,iplan,nmagmax)

                  call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 4 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                nmagmax,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag0(1,1,iplan,nmagmax)-x0
                  vsy=bpemag0(2,1,iplan,nmagmax)-y0
                  vsz=bpemag0(3,1,iplan,nmagmax)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn2(iplan)
                    ibpecorn(iplan,nmagmax)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag0(1:3,icorn,iplan,nmagmax)
                    enddo

                    do icorn=1,ncorn
                      bpemag0(1:3,icorn,iplan,nmagmax)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ncorn1=0
                corn1=0.0d0
                ncorn1=ncorn2
                corn1=corn2

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ydivmin=1.0d30
                ydivmax=-1.0d30
                do iplan=1,nplan
                  do icorn=1,ncorn
                    if (corn1(2,icorn,iplan).lt.ydivmin)
     &                ydivmin=corn1(2,icorn,iplan)
                    if (corn1(2,icorn,iplan).gt.ydivmax)
     &                ydivmax=corn1(2,icorn,iplan)
                  enddo
                enddo

              endif !cut

              dydiv=dydiv/yfracdiv

            enddo !nydiv

          enddo !kdmag1

          dzdiv=(zdivmax-zdivmin)/nzdiv

          do kdmag1=nmagmax-nxdiv*nydiv+1,nmagmax

            ncorn1=0
            corn1=0.0d0
            ncorn2=0
            corn2=0.0d0

            nplan=ibpeplan(kdmag1)

            zdivmin=1.0d30
            zdivmax=-1.0d30
            do iplan=1,nplan
              ncorn=ibpecorn(iplan,kdmag1)
              ncorn1(iplan)=ncorn
              do icorn=1,ncorn
                corn1(1:3,icorn,iplan)=bpemag0(1:3,icorn,iplan,kdmag1)
c                write(lun6,*)kdmag1,icorn,iplan,corn1(1:3,icorn,iplan)
                if (corn1(3,icorn,iplan).lt.zdivmin)
     &            zdivmin=corn1(3,icorn,iplan)
                if (corn1(3,icorn,iplan).gt.zdivmax)
     &            zdivmax=corn1(3,icorn,iplan)
              enddo
            enddo

            zdiv=bpebc0(3,kdmag1)+zdivmin

            x02(2)=bpebc0(1,kdmag1)
            y02(2)=bpebc0(2,kdmag1)
            z02(2)=bpebc0(3,kdmag1)

cdebug izdiv 1
            do izdiv=1,nzdiv-1

              if (izdiv.eq.1) then
                kdmag=kdmag1
              else
                kdmag=nmagmax
              endif

              zdiv=zdiv+dzdiv

              x02(1)=x02(2)
              y02(1)=y02(2)
              z02(1)=z02(2)

              call undumag_cut_magnet(kdmag,x02,y02,z02, !debug 3
     &          2*nplanmax,2*ncornmax,
     &          ncorn1,corn1,ncorn2,corn2
     &          ,3,zdiv,hulltiny,ifail)

              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, ixdiv, iydiv, izdiv, zdiv:",
     &            ifail,kdmag,ixdiv,iydiv,izdiv
                stop
              endif
c              write(lun6,*)"Nachher:",z02

              !kdmag is mother

c              ncutpiece=ncutpiece+1
              if (ncorn2(1).gt.0) then
                ! Magnet has been cut

                ncutpiece=ncutpiece+1
+self,if=debug.
                write(lun6,*)"z-cut for magnet:",kdmag
+self.

                ! First piece, replaces mother

                bpebc(15,kdmag)=bpebc15
                mothdiv(1,kdmag)=bpebc15
                mothdiv(4,kdmag)=izdiv

                do ic=1,32
                  chmags(ic,kdmag)=chmag(ic:ic)
                  chmoths(ic,kdmag)=chmoth(ic:ic)
                enddo

                bpebc(9,kdmag)=bc9
                bpebc(10,kdmag)=bc10

                bpebc0(1,kdmag)=x02(1)
                bpebc0(2,kdmag)=y02(1)
                bpebc0(3,kdmag)=z02(1)

                bpebc0(4:7,kdmag)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                if (nplan.gt.nplanmax) then
                  nplanmax=nplan
                  goto 1111
                endif

                ibpecol(kdmag)=ncol
                ibpeplan(kdmag)=nplan
                ibpeplano(kdmag)=nplan

                do iplan=1,nplan
                  ncorn=ncorn1(iplan)
                  if (ncorn+1.gt.ncornmax) then
                    ncornmax=ncorn+1
                    goto 1111
                  endif
                  ibpecorn(iplan,kdmag)=ncorn+1
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag0(1:3,ncorn,iplan,kdmag)=
     &              corn1(1:3,1,iplan) !debug 3
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                nplan=ibpeplan(kdmag)
                do iplan=1,nplan
                  ncorn=ibpecorn(iplan,kdmag)-1
                  do icorn=1,ncorn
                    i=i+1
                    x0=x0+bpemag0(1,icorn,iplan,kdmag)
                    y0=y0+bpemag0(2,icorn,iplan,kdmag)
                    z0=z0+bpemag0(3,icorn,iplan,kdmag)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(kdmag)

                  p1(1)=bpemag0(1,1,iplan,kdmag)
                  p1(2)=bpemag0(2,1,iplan,kdmag)
                  p1(3)=bpemag0(3,1,iplan,kdmag)

                  p2(1)=bpemag0(1,2,iplan,kdmag)
                  p2(2)=bpemag0(2,2,iplan,kdmag)
                  p2(3)=bpemag0(3,2,iplan,kdmag)

                  p3(1)=bpemag0(1,3,iplan,kdmag)
                  p3(2)=bpemag0(2,3,iplan,kdmag)
                  p3(3)=bpemag0(3,3,iplan,kdmag)

                  call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 5 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                kdmag,iplan
                    write(lun6,*)"icorn,x,y,z:"
                    do icorn=1,ibpecorn(iplan,kdmag)
                      write(lun6,*)icorn,bpemag0(1:3,icorn,iplan,kdmag)
                    enddo
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag0(1,1,iplan,kdmag)-x0
                  vsy=bpemag0(2,1,iplan,kdmag)-y0
                  vsz=bpemag0(3,1,iplan,kdmag)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn1(iplan)
                    ibpecorn(iplan,kdmag)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag0(1:3,icorn,iplan,kdmag)
                    enddo

                    do icorn=1,ncorn
                      bpemag0(1:3,icorn,iplan,kdmag)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ! Second piece

                nmagmax=nmagmax+1
+self,if=debug.
                write(lun6,*)"Second piece:",nmagmax
+self.

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15
                mothdiv(4,nmagmax)=izdiv+1

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=bc9
                bpebc(10,nmagmax)=bc10

                bpebc0(1,nmagmax)=x02(2)
                bpebc0(2,nmagmax)=y02(2)
                bpebc0(3,nmagmax)=z02(2)

                bpebc0(4:7,nmagmax)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn2(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                if (nplan.gt.nplanmax) then
                  nplanmax=nplan
                  goto 1111
                endif

                ibpeplan(nmagmax)=nplan
                ibpeplano(nmagmax)=nplan
                ibpecol(nmagmax)=ncol

                do iplan=1,nplan
                  ncorn=ncorn2(iplan)
                  if (ncorn+1.gt.ncornmax) then
                    ncornmax=ncorn+1
                    goto 1111
                  endif
                  ibpecorn(iplan,nmagmax)=ncorn+1
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,nmagmax)=
     &                corn2(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag0(1:3,ncorn,iplan,nmagmax)=
     &              corn2(1:3,1,iplan) !debug 3
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                do iplan=1,ibpeplan(nmagmax)
                  do icorn=1,ibpecorn(iplan,nmagmax)-1
                    i=i+1
                    x0=x0+bpemag0(1,icorn,iplan,nmagmax)
                    y0=y0+bpemag0(2,icorn,iplan,nmagmax)
                    z0=z0+bpemag0(3,icorn,iplan,nmagmax)
c                    write(37,*)"3 ",nmagmax,iplan,icorn,
c     &                sngl(bpemag0(1,icorn,iplan,nmagmax)+bpebc0(1,nmagmax)),
c     &                sngl(bpemag0(2,icorn,iplan,nmagmax)+bpebc0(2,nmagmax)),
c     &                sngl(bpemag0(3,icorn,iplan,nmagmax)+bpebc0(3,nmagmax))
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(nmagmax)

                  p1(1)=bpemag0(1,1,iplan,nmagmax)
                  p1(2)=bpemag0(2,1,iplan,nmagmax)
                  p1(3)=bpemag0(3,1,iplan,nmagmax)

                  p2(1)=bpemag0(1,2,iplan,nmagmax)
                  p2(2)=bpemag0(2,2,iplan,nmagmax)
                  p2(3)=bpemag0(3,2,iplan,nmagmax)

                  p3(1)=bpemag0(1,3,iplan,nmagmax)
                  p3(2)=bpemag0(2,3,iplan,nmagmax)
                  p3(3)=bpemag0(3,3,iplan,nmagmax)

                  call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 6 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                nmagmax,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag0(1,1,iplan,nmagmax)-x0
                  vsy=bpemag0(2,1,iplan,nmagmax)-y0
                  vsz=bpemag0(3,1,iplan,nmagmax)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn2(iplan)
                    ibpecorn(iplan,nmagmax)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag0(1:3,icorn,iplan,nmagmax)
                    enddo

                    do icorn=1,ncorn
                      bpemag0(1:3,icorn,iplan,nmagmax)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ncorn1=0
                corn1=0.0d0
                ncorn1=ncorn2
                corn1=corn2

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                zdivmin=1.0d30
                zdivmax=-1.0d30
                do iplan=1,nplan
                  do icorn=1,ncorn
                    if (corn1(3,icorn,iplan).lt.zdivmin)
     &                zdivmin=corn1(3,icorn,iplan)
                    if (corn1(3,icorn,iplan).gt.zdivmax)
     &                zdivmax=corn1(3,icorn,iplan)
                  enddo
                enddo

              endif !cut

            enddo !nzdiv

          enddo !kdmag1

        else if (nplan.eq.-11) then

          ncorn=4
          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
          ncorn=ncorn+1

          if (nang.lt.nangmin) nang=nangmin
          if (nr.lt.1) nr=1
          if (nh.lt.1) nh=1

! cyl magnet, i.e. nplan=-11{

          kcyl=kcyl+1
          magcyl(kcyl,1)=nmagmax

          if (radin.lt.tiny) radin=tiny

          x00=bpebc0(1,nmagmax)
          y00=bpebc0(2,nmagmax)
          z00=bpebc0(3,nmagmax)

          npmoth(nmoth)=8
          matmoth(nmoth)=imat
          ncolmoth(nmoth)=ibpecol(nmagmax)

          ip=0
          dphi=angle/nang*grarad1
          dr=(radout-radin)/nr
          dh=height/nh
          r=radin
          do ir=1,2
            h=-height/2.0d0
            do ih=1,2
              phi=-angle/2.0d0*grarad1
              do iphi=1,2
                ip=ip+1
                x1=r*sin(phi)
                y1=h
                z1=r*cos(phi)
                xmoth(ip,nmoth)=rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1+x00
                ymoth(ip,nmoth)=rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1+y00
                zmoth(ip,nmoth)=rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1+z00
                phi=angle/2.0d0*grarad1
              enddo
              h=height/2.0d0
            enddo
            r=radout
          enddo

          jplan=ibpeplano(nmagmax)

          if (ihullallo.eq.0) then
            maxpoints=8
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else
            if (maxpoints.lt.8) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
              maxpoints=8
              allocate(hull(3,maxpoints))
              allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
              allocate(khull(maxpoints))
              allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            endif
          endif

          r=radin+dr/2.0d0
          do ir=1,nr
            h=-height/2.0d0+dh/2.0d0
            do ih=1,nh
              phi=-angle/2.0d0*grarad1+dphi/2.0d0
              do iphi=1,nang

                x0=r*sin(phi)
                y0=h
                z0=r*cos(phi)

                ri=r-dr/2.0d0
                ro=r+dr/2.0d0

                y1=y0-dh/2.0d0
                y2=y0+dh/2.0d0

                x1=ri*sin(phi-dphi/2.0d0)
                z1=ri*cos(phi-dphi/2.0d0)
                x2=ro*sin(phi-dphi/2.0d0)
                z2=ro*cos(phi-dphi/2.0d0)
                x3=ro*sin(phi+dphi/2.0d0)
                z3=ro*cos(phi+dphi/2.0d0)
                x4=ri*sin(phi+dphi/2.0d0)
                z4=ri*cos(phi+dphi/2.0d0)

                xhull(1)=rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1
                yhull(1)=rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1
                zhull(1)=rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1

                xhull(2)=rmat(1,1)*x2+rmat(1,2)*y1+rmat(1,3)*z2
                yhull(2)=rmat(2,1)*x2+rmat(2,2)*y1+rmat(2,3)*z2
                zhull(2)=rmat(3,1)*x2+rmat(3,2)*y1+rmat(3,3)*z2

                xhull(3)=rmat(1,1)*x3+rmat(1,2)*y1+rmat(1,3)*z3
                yhull(3)=rmat(2,1)*x3+rmat(2,2)*y1+rmat(2,3)*z3
                zhull(3)=rmat(3,1)*x3+rmat(3,2)*y1+rmat(3,3)*z3

                xhull(4)=rmat(1,1)*x4+rmat(1,2)*y1+rmat(1,3)*z4
                yhull(4)=rmat(2,1)*x4+rmat(2,2)*y1+rmat(2,3)*z4
                zhull(4)=rmat(3,1)*x4+rmat(3,2)*y1+rmat(3,3)*z4

                xhull(5)=rmat(1,1)*x1+rmat(1,2)*y2+rmat(1,3)*z1
                yhull(5)=rmat(2,1)*x1+rmat(2,2)*y2+rmat(2,3)*z1
                zhull(5)=rmat(3,1)*x1+rmat(3,2)*y2+rmat(3,3)*z1

                xhull(6)=rmat(1,1)*x2+rmat(1,2)*y2+rmat(1,3)*z2
                yhull(6)=rmat(2,1)*x2+rmat(2,2)*y2+rmat(2,3)*z2
                zhull(6)=rmat(3,1)*x2+rmat(3,2)*y2+rmat(3,3)*z2

                xhull(7)=rmat(1,1)*x3+rmat(1,2)*y2+rmat(1,3)*z3
                yhull(7)=rmat(2,1)*x3+rmat(2,2)*y2+rmat(2,3)*z3
                zhull(7)=rmat(3,1)*x3+rmat(3,2)*y2+rmat(3,3)*z3

                xhull(8)=rmat(1,1)*x4+rmat(1,2)*y2+rmat(1,3)*z4
                yhull(8)=rmat(2,1)*x4+rmat(2,2)*y2+rmat(2,3)*z4
                zhull(8)=rmat(3,1)*x4+rmat(3,2)*y2+rmat(3,3)*z4

                npoi=8
                call util_convex_hull_3d(npoi,xhull,yhull,zhull,
     &            khull,kedge,kface,
     &            nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
                if (ifailhull.ne.0.or.nhull.lt.4) then
                  write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &              trim(cline)
                  stop
                endif

                ibpeplano(nmagmax)=nface
                ibpeplan(nmagmax)=nface

                next=1

                gcen=0.0d0
                k=0
                do iplan=1,nface

                  ncorn=kface(next)

                  ncorn=ncorn+1
                  ibpecorn(iplan,nmagmax)=ncorn

                  do icorn=1,ncorn

                    if (icorn.lt.ncorn) then
                      ip=kface(next+icorn)
                      bpemag0(1,icorn,iplan,nmagmax)=xhull(ip)+x00
                      bpemag0(2,icorn,iplan,nmagmax)=yhull(ip)+y00
                      bpemag0(3,icorn,iplan,nmagmax)=zhull(ip)+z00

                      k=k+1
                      gcen(1)=gcen(1)+xhull(ip)+x00
                      gcen(2)=gcen(2)+yhull(ip)+y00
                      gcen(3)=gcen(3)+zhull(ip)+z00

c                      write(99,*)nmagmax,iplan,icorn,bpemag0(1:3,icorn,iplan,nmagmax)
                    else ! icorn.lt.ncorn

                      bpemag0(1,icorn,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                      bpemag0(2,icorn,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                      bpemag0(3,icorn,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)

                    endif ! icorn.lt.ncorn

                  enddo !icorn

                  next=next+ncorn ! here, ncorn is already increamented by 1

                enddo !nface

                gcen=gcen/k

               do iplan=1,nface
                 ncorn=ibpecorn(iplan,nmagmax)
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,nmagmax)=
     &                bpemag0(1:3,icorn,iplan,nmagmax)-gcen(1:3)
                  enddo !icorn
                enddo !nface

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15

                mothdiv(2,nmagmax)=ir
                mothdiv(3,nmagmax)=iy
                mothdiv(4,nmagmax)=iphi

                c32=chmag
                write(chmags(1:32,nmagmax),'(a)')c32a(1:32)
                c32=chmoth
                write(chmoths(1:32,nmagmax),'(a)')c32a(1:32)

                bpebc(9,nmagmax)=imat
                bpebc(10,nmagmax)=0

                ibpeplano(nmagmax)=jplan

                bpebc0(1:3,nmagmax)=gcen(1:3)

                x1=xm*bdum
                y1=ym*bdum
                z1=zm*bdum

                bpebc0(4,nmagmax)=
     &            rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1
                bpebc0(5,nmagmax)=
     &            rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1
                bpebc0(6,nmagmax)=
     &            rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1

                bpebc0(7,nmagmax)=1
                ibpeplan(nmagmax)=6
                ibpecol(nmagmax)=ncol

                phi=phi+dphi

                nmagmax=nmagmax+1
              enddo
              h=h+dh
            enddo !ih
            r=r+dr
          enddo !ir

          nmagmax=nmagmax-1
          magcyl(kcyl,2)=nmagmax
          ncutpiece=ncutpiece+nr*nang*nh

! cyl magnet, i.e. nplan=-11}

        else ! :nplan>0

! rectangular magnet, i.e. nplan=-6{

          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*,iostat=ieof) xlen,ylen,zlen, nxdiv,nydiv,nzdiv,yfacdiv
          if (ieof.ne.0) then
            yfacdiv=1.0d0
          endif

cdebug
          npmoth(nmoth)=8
          matmoth(nmoth)=imat
          ncolmoth(nmoth)=ibpecol(nmagmax)
          xmoth(1,nmoth)=x00-xlen/2.0d0
          ymoth(1,nmoth)=y00-ylen/2.0d0
          zmoth(1,nmoth)=z00-zlen/2.0d0

          xmoth(2,nmoth)=x00+xlen/2.0d0
          ymoth(2,nmoth)=y00-ylen/2.0d0
          zmoth(2,nmoth)=z00-zlen/2.0d0

          xmoth(3,nmoth)=x00+xlen/2.0d0
          ymoth(3,nmoth)=y00+ylen/2.0d0
          zmoth(3,nmoth)=z00-zlen/2.0d0

          xmoth(4,nmoth)=x00-xlen/2.0d0
          ymoth(4,nmoth)=y00+ylen/2.0d0
          zmoth(4,nmoth)=z00-zlen/2.0d0

          xmoth(5,nmoth)=x00-xlen/2.0d0
          ymoth(5,nmoth)=y00-ylen/2.0d0
          zmoth(5,nmoth)=z00+zlen/2.0d0

          xmoth(6,nmoth)=x00+xlen/2.0d0
          ymoth(6,nmoth)=y00-ylen/2.0d0
          zmoth(6,nmoth)=z00+zlen/2.0d0

          xmoth(7,nmoth)=x00+xlen/2.0d0
          ymoth(7,nmoth)=y00+ylen/2.0d0
          zmoth(7,nmoth)=z00+zlen/2.0d0

          xmoth(8,nmoth)=x00-xlen/2.0d0
          ymoth(8,nmoth)=y00+ylen/2.0d0
          zmoth(8,nmoth)=z00+zlen/2.0d0

          nmag=nmag+nxdiv*nydiv*nzdiv-1
          kmag2=kmag2+nxdiv*nydiv*nzdiv-1

          dx=xlen/nxdiv

          fracsum=0.0d0
          ! yfracdiv**(nydiv-1)=yfacdiv
          ! ln(yfracdiv)*(nydiv-1)=ln(yfacdiv)
          if (nydiv.gt.1) then
            yfracdiv=exp(log(yfacdiv)/(nydiv-1))
          else
            yfracdiv=1.0d0
          endif
          do iydiv=0,nydiv-1
            fracsum=fracsum+yfracdiv**iydiv
          enddo

          dz=zlen/nzdiv

          x00=bpebc0(1,nmagmax)-xlen/2.0d0-dx/2.0d0
          y00=bpebc0(2,nmagmax)+ylen/2.0d0
          z00=bpebc0(3,nmagmax)-zlen/2.0d0-dz/2.0d0

          jplan=ibpeplano(nmagmax)

          nmagmax=nmagmax-1

          ncutpiece=ncutpiece+1
cdebug ixdiv 2
          do ixdiv=1,nxdiv
            x0=x00+dx*ixdiv
            y0=y00
            dy=ylen/fracsum
cdebug iydiv 2
            do iydiv=1,nydiv

              y0=y0-dy/2.0d0

cdebug izdiv 2
              do izdiv=1,nzdiv

                z0=z00+dz*izdiv

                nmagmax=nmagmax+1
                ncutpiece=ncutpiece+1

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15

                mothdiv(2,nmagmax)=ixdiv
                mothdiv(3,nmagmax)=iydiv
                mothdiv(4,nmagmax)=izdiv

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=imat
                bpebc(10,nmagmax)=0

                ibpeplano(nmagmax)=jplan

                bpebc0(1,nmagmax)=x0
                bpebc0(2,nmagmax)=y0
                bpebc0(3,nmagmax)=z0

                bpebc0(4,nmagmax)=xm*bdum
                bpebc0(5,nmagmax)=ym*bdum
                bpebc0(6,nmagmax)=zm*bdum

                bpebc0(7,nmagmax)=-6
                ibpeplan(nmagmax)=6
                ibpecol(nmagmax)=ncol

                iplan=1
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=2
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=3
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=4
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=5
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=6
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0

                do iplan=1,6
                  bpemag0(1,5,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                  bpemag0(2,5,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                  bpemag0(3,5,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)
                enddo !iplan

                do iplan=1,6
                  bpemag0(1,5,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                  bpemag0(2,5,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                  bpemag0(3,5,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)
                enddo !iplan

              enddo !nzdiv

              y0=y0-dy/2.0d0
              dy=dy*yfracdiv

            enddo !nydiv
          enddo !nxdiv
! rectangular magnet, i.e. nplan=-6}

        endif !nplan>0

        if (ncutpiece.lt.nmagmax) then
          nmagmax=ncutpiece
          nmag=ncutpiece
        endif

      enddo !nmagdo

      kmag2=nmagmax

      call util_skip_comment_end(lunbpe,ieof)
      if (ieof.eq.0) then
        read(lunbpe,*)x0,y0,z0
      endif

      if (nmago.eq.-99) then
        close(lunbpe)
        lunbpe=98
      endif !nmago

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,*)nmodule

      if (nmodule.le.0) then
        write(lun6,*)'*** Error in undumag_ini_old: Number of modules is zero'
        stop
      endif

c      nmagmax=nmagmaxo-nmag*ncopy
      nmagmax=nmagmaxo-ncopies
      nmoth=0

      chmothso=chmoths
      do imodul=1,nmodule

        write(chmod,*)imodul
        call util_string_trim(chmod,i1mod,i2mod)

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)xmod,ymod,zmod

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(1,1),rotmod(1,2),rotmod(1,3)

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(2,1),rotmod(2,2),rotmod(2,3)

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(3,1),rotmod(3,2),rotmod(3,3)

        call util_determinante(3,rotmod,det,ifail)

        if (ifail.ne.0.or.abs(abs(det)-1.0d0).gt.tiny) then
          write(lun6,*)
     &      '*** Error in undumag_ini_old: Bad rotation matrix'
          write(lun6,*)'magnet, plane: ',imag,iplan
          stop
        endif

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)ncopy

        call util_skip_comment_end(lunbpe,ieof)

        read(lunbpe,*)space,vspace(1),vspace(2),vspace(3)

        call util_vnorm(3,vspace,vspace)

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)vbsym(1),vbsym(2),vbsym(3)

        do icopy=1,ncopy

          write(chcop,*)icopy
          call util_string_trim(chcop,i1cop,i2cop)

          do moth=1,nmotho

            nmoth=nmoth+1
            chmoths(1:32,nmoth)=chmothso(1:32,moth)
c            write(lun6,*)imodul,icopy,moth,chmoths(1:32,4)

            npmoth(nmoth)=npmoth(moth)
            matmoth(nmoth)=matmoth(moth)
            ncolmoth(nmoth)=ncolmoth(moth)
            xmoth(1:npmoth(nmoth),nmoth)=xmoth(1:npmoth(moth),moth)
     &        +(icopy-1)*space*vspace(1)
            ymoth(1:npmoth(nmoth),nmoth)=ymoth(1:npmoth(moth),moth)
     &        +(icopy-1)*space*vspace(2)
            zmoth(1:npmoth(nmoth),nmoth)=zmoth(1:npmoth(moth),moth)
     &        +(icopy-1)*space*vspace(3)

          enddo
        enddo !ncopy

        do icopy=1,ncopy

          write(chcop,*)icopy
          call util_string_trim(chcop,i1cop,i2cop)

          do imag=kmag1,kmag2

            nmagmax=nmagmax+1

            ibpecol(nmagmax)=ibpecol(imag)
            ibpeplan(nmagmax)=ibpeplan(imag)
            ibpeplano(nmagmax)=ibpeplano(imag)

            x0=xmod+bpebc0(1,imag)
     &        +(icopy-1)*space*vspace(1)
            y0=ymod+bpebc0(2,imag)
     &        +(icopy-1)*space*vspace(2)
            z0=zmod+bpebc0(3,imag)
     &        +(icopy-1)*space*vspace(3)

            bpebc(1,nmagmax)=x0
            bpebc(2,nmagmax)=y0
            bpebc(3,nmagmax)=z0

            bpebc(4,nmagmax)=bpebc0(4,imag)*vbsym(1)
            bpebc(5,nmagmax)=bpebc0(5,imag)*vbsym(2)
            bpebc(6,nmagmax)=bpebc0(6,imag)*vbsym(3)

            bc=sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
            bpebc(7,nmagmax)=bc

            bpebc(8,nmagmax)=bpebc0(7,imag)
            bpebc15=bpebc(15,imag)

            mothdiv(1:4,nmagmax)=mothdiv(1:4,imag)

            motho=nint(bpebc15)
            moth=nint(bpebc15)
            if (icopy.gt.1) moth=nmotho+(imodul-1)*ncopy+icopy-1
c            moth=nmotho+(imodul-1)*ncopy+icopy-1
c            write(lun6,*)imag,nmagmax,motho,moth

c            if (icopy.gt.1) then
            do ic=1,32
              chmoth(ic:ic)=chmothso(ic,motho)
            enddo
c              write(lun6,*)chmoth
c              write(lun6,*)chmod
c              write(lun6,*)chcop
            call util_string_trim(chmoth,i1moth,i2moth)
            if (i2moth-i1moth+1+i2cop-i1cop+1+i2mod-i1mod+1+2.gt.32) then
              write(lun6,*)
              write(lun6,*)"*** Error in undumag_ini_old: Too long a magnet name: ",
     &          chmoth
              write(lun6,*)"UNDUMAG ABORTED"
              stop
            endif

            if (bpebc(15,nmagmax).eq.0) then
              bpebc(15,nmagmax)=nmagmax
            endif

            if (icopy.gt.1) then
              chmoth=chmoth(i1moth:i2moth)//"_"//chmod(i1mod:i2mod)//
     &          "_"//chcop(i1cop:i2cop)
              do ic=1,32
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo
            else
              chmoths(1:32,nmagmax)=chmothso(1:32,moth)
            endif

            chmags(1:32,nmagmax)=chmags(1:32,imag)

            bpebc(9,nmagmax)=bpebc(9,imag)
            bpebc(10,nmagmax)=0

            vmag=bpebc(1:3,nmagmax)

            bpebc(1,nmagmax)=
     &        rotmod(1,1)*vmag(1)+
     &        rotmod(1,2)*vmag(2)+
     &        rotmod(1,3)*vmag(3)

            bpebc(2,nmagmax)=
     &        rotmod(2,1)*vmag(1)+
     &        rotmod(2,2)*vmag(2)+
     &        rotmod(2,3)*vmag(3)

            bpebc(3,nmagmax)=
     &        rotmod(3,1)*vmag(1)+
     &        rotmod(3,2)*vmag(2)+
     &        rotmod(3,3)*vmag(3)

            do iplan=1,ibpeplan(nmagmax)

              ibpecorn(iplan,nmagmax)=ibpecorn(iplan,imag)

              do icorn=1,ibpecorn(iplan,nmagmax)

                bpemag(1,icorn,iplan,nmagmax)=x0+
     &            bpemag0(1,icorn,iplan,imag)
                bpemag(2,icorn,iplan,nmagmax)=y0+
     &            bpemag0(2,icorn,iplan,imag)
                bpemag(3,icorn,iplan,nmagmax)=z0+
     &            bpemag0(3,icorn,iplan,imag)

c rotation of magnet

                vcorn(1:3)=bpemag(1:3,icorn,iplan,nmagmax)

                bpemag(1,icorn,iplan,nmagmax)=
     &            rotmod(1,1)*vcorn(1)+
     &            rotmod(1,2)*vcorn(2)+
     &            rotmod(1,3)*vcorn(3)

                bpemag(2,icorn,iplan,nmagmax)=
     &            rotmod(2,1)*vcorn(1)+
     &            rotmod(2,2)*vcorn(2)+
     &            rotmod(2,3)*vcorn(3)

                bpemag(3,icorn,iplan,nmagmax)=
     &            rotmod(3,1)*vcorn(1)+
     &            rotmod(3,2)*vcorn(2)+
     &            rotmod(3,3)*vcorn(3)

                vcorn(1:3)=bpemag(1:3,icorn,iplan,nmagmax)

                if (bc.ne.0.0d0.and.vcorn(1).lt.xmin) xmin=vcorn(1)
                if (bc.ne.0.0d0.and.vcorn(1).gt.xmax) xmax=vcorn(1)
                if (bc.ne.0.0d0.and.vcorn(2).lt.ymin) ymin=vcorn(2)
                if (bc.ne.0.0d0.and.vcorn(2).gt.ymax) ymax=vcorn(2)
                if (bc.ne.0.0d0.and.vcorn(3).lt.zmin) zmin=vcorn(3)
                if (bc.ne.0.0d0.and.vcorn(3).gt.zmax) zmax=vcorn(3)

              enddo !icorn

              if (det.lt.0.0d0) then

                do icorn=1,ibpecorn(iplan,nmagmax)
                  ip1=ibpecorn(iplan,nmagmax)-icorn+1
                  shuffle(1,ip1,iplan,nmagmax)=bpemag(1,icorn,iplan,nmagmax)
                  shuffle(2,ip1,iplan,nmagmax)=bpemag(2,icorn,iplan,nmagmax)
                  shuffle(3,ip1,iplan,nmagmax)=bpemag(3,icorn,iplan,nmagmax)
                enddo !icorn

                do icorn=1,ibpecorn(iplan,nmagmax)
                  bpemag(1,icorn,iplan,nmagmax)=
     &              shuffle(1,icorn,iplan,nmagmax)
                  bpemag(2,icorn,iplan,nmagmax)=
     &              shuffle(2,icorn,iplan,nmagmax)
                  bpemag(3,icorn,iplan,nmagmax)=
     &              shuffle(3,icorn,iplan,nmagmax)
                enddo !icorn

              endif !det

            enddo !iplan

          enddo !imag

        enddo !icopy

      enddo !imodul=1,nmodul

      nmag=nmagmax !without special magnets

      allocate(bcmat(3,nmatpoimax,nmatfiles))
      bcmat=0.0d0

      allocate(feh1(nmatpoimax))
      allocate(fem1(nmatpoimax))

      if (isplinefm.ne.0) then
        allocate(fespl1(nmatpoimax))
        allocate(ufespl1(nmatpoimax))
        allocate(fewspl1(nmatpoimax))
        allocate(fewspl2(nmatpoimax))
        allocate(fewspl3(nmatpoimax))
        allocate(fewspl4(nmatpoimax))
      endif

      kmag1=nmagmax+1
      kmag2=nmagmax+nspecmag

* Special magnets
cdebug
      do ispecmag=1,nspecmag

        nmoth=nmoth+1

        nmagmax=nmagmax+1
        bpebc(15,nmagmax)=nmagmax
        bpebc15=bpebc(15,nmagmax)
        mothdiv(1,nmagmax)=bpebc15

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,'(a)') cline
        call util_string_split_sep(cline,100,nwords,ipos,'!',istat)
        cline=cline(ipos(1,1):ipos(2,1))
        call util_string_split_sep(cline,100,nwords,ipos,' ',istat)

        if (nwords.eq.5) then
          read(cline,*)x00,y00,z00,chmag,chmoth
        else
          read(cline,*)x00,y00,z00
          write(chmag,*) ispecmag
          call util_string_trim(chmag,nfirst,nlast)
          chmag="smag_" // chmag(nfirst:nlast)
          chmoth="sMag_" // chmag(nfirst:nlast)
        endif

        ifound=0
        do kmag=1,nmagmax
          ifound=1
          do ic=1,32
            if (chmags(ic,kmag).ne.chmag(ic:ic)) then
              ifound=0
              exit
            endif
          enddo
          if (ifound.eq.1) exit
        enddo

        if (ifound.ne.0) then
          write(lun6,*)"*** Error in undumag_ini_old: Duplicate magnet name: ",chmag
          stop
        endif

        do ic=1,32
           chmags(ic,nmagmax)=chmag(ic:ic)
           chmoths(ic,nmagmax)=chmoth(ic:ic)
        enddo

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)bc,xm,ym,zm,imat !magnetization vector M

        if (imat.eq.0) bc=0.0d0

        bpebc(9,nmagmax)=imat
        bpebc(10,nmagmax)=ispecmag

        bdum=sqrt(xm*xm+ym*ym+zm*zm)

        if (bdum.eq.0.0d0.and.abs(bc).gt.0.01) then
          write(lun6,*)
          write(lun6,*)'*** Error in undumag_ini_old: Bad magnetization vector'
          write(lun6,*)'Magnet ',imag
          write(lun6,*)
          stop
        endif

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,'(a)')cline

        c64='Cyl'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)

        if (istat.eq.0) then
          !Cylinder
          read(cline(4:len_trim(cline)),*)ncol
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)radin,radout,height,angle,nr,nang,nh
          if (angle.gt.360.0d0) angle=360.0d0
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(1,1:3)
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(2,1:3)
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(3,1:3)
          nplan=-11
          if (bc.ne.0.0d0) nmagcyl=nmagcyl+1

        else ! Cyl

          c64='Block'
          call util_string_substring(cline,trim(c64),ianf,iend,istat)
          if (istat.ne.0) then
            c64='File'
            call util_string_substring(cline,trim(c64),ianf,iend,istat)
            if (istat.ne.0) then
              c64='Corners'
              call util_string_substring(cline,trim(c64),ianf,iend,istat)
              if (istat.ne.0) then
c              c64='Corners'
c              call util_string_substring(cline,trim(c64),ianf,iend,istat)
                read(cline,*)nplan,ncol
              else
                nplan=-10
                cline(ianf:iend)=' -10   '
                read(cline,*)nplan,ncol
              endif
            else
              nplan=-9
              cline(ianf:iend)=' -9 '
            endif
          else
            nplan=-6
            cline(ianf:iend)=' -6  '
          endif

c        call util_skip_comment_end(lunbpe,ieof)
c        read(lunbpe,*)nplan,ncol
          read(cline,*)nplan,ncol

        endif !Cyl

        bdum=bc/bdum

        bpebc0(1,nmagmax)=x00
        bpebc0(2,nmagmax)=y00
        bpebc0(3,nmagmax)=z00

        bpebc0(4,nmagmax)=xm*bdum
        bpebc0(5,nmagmax)=ym*bdum
        bpebc0(6,nmagmax)=zm*bdum

        bpebc0(7,nmagmax)=nplan

        ibpecol(nmagmax)=ncol
        ibpeplano(nmagmax)=nplan
        ibpeplan(nmagmax)=nplan

        if (nplan.gt.0.or.nplan.eq.-9.or.nplan.eq.-10) then

          bpebc(1,nmagmax)=x00
          bpebc(2,nmagmax)=y00
          bpebc(3,nmagmax)=z00

          bpebc(4,nmagmax)=xm*bdum
          bpebc(5,nmagmax)=ym*bdum
          bpebc(6,nmagmax)=zm*bdum

          bpebc(7,nmagmax)=bc
          bpebc(8,nmagmax)=1

c          backspace(lunbpe)
c          read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          if (ieof.ne.0) then
            yfacdiv=1.0d0
          endif

          if (nxdiv.lt.1) nxdiv=1
          if (nydiv.lt.1) nydiv=1
          if (nzdiv.lt.1) nzdiv=1

          nspecmag=nspecmag+nxdiv*nydiv*nzdiv-1
          kmag2=kmag2+nxdiv*nydiv*nzdiv-1

          xdivmin=1.0d30
          xdivmax=-1.0d30
          ydivmin=1.0d30
          ydivmax=-1.0d30
          zdivmin=1.0d30
          zdivmax=-1.0d30

          ncorn1=0
          ncorn2=0

          gcen=0.0d0
          npoi=0

          fracsum=0.0d0
          ! yfracdiv**(nydiv-1)=yfacdiv
          ! ln(yfracdiv)*(nydiv-1)=ln(yfacdiv)
          if (nydiv.gt.1) then
            yfracdiv=exp(log(yfacdiv)/(nydiv-1))
          else
            yfracdiv=1.0d0
          endif
          do iydiv=0,nydiv-1
            fracsum=fracsum+yfracdiv**iydiv
          enddo

          if (nplan.gt.0) then
            ! magnet definition by planes

            npoi=0

            do iplan=1,nplan

              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)ncorn

              ncorn=ncorn+1

              ibpecorn(iplan,nmagmax)=ncorn

              do icorn=1,ncorn

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                if (icorn.lt.ncorn) then

                  call util_skip_comment_end(lunbpe,ieof)
                  read(lunbpe,*)x0,y0,z0

                  bpemag(1,icorn,iplan,nmagmax)=x0
                  bpemag(2,icorn,iplan,nmagmax)=y0
                  bpemag(3,icorn,iplan,nmagmax)=z0

                  npoi=npoi+1

                  xhull(npoi)=x00+x0
                  yhull(npoi)=y00+y0
                  zhull(npoi)=z00+z0

                  write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 0"

                else ! icorn.lt.ncorn

                  bpemag(1,icorn,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                  bpemag(2,icorn,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                  bpemag(3,icorn,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)

                endif ! icorn.lt.ncorn

                vcorn(1:3)=bpemag(1:3,icorn,iplan,nmagmax)

              enddo !icorn

              ncorn1(iplan)=ncorn

            enddo !iplan

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &          trim(cline)
              stop
            endif

            gcen=0.0d0
            npmoth(nmoth)=nhull
            matmoth(nmoth)=imat
            ncolmoth(nmoth)=ibpecol(nmagmax)
            do ipoi=1,nhull
              kpoi=khull(ipoi)
              x0=xhull(kpoi)
              y0=yhull(kpoi)
              z0=zhull(kpoi)
              xmoth(ipoi,nmoth)=x0
              ymoth(ipoi,nmoth)=y0
              zmoth(ipoi,nmoth)=z0
              gcen(1)=gcen(1)+x0
              gcen(2)=gcen(2)+y0
              gcen(3)=gcen(3)+z0
            enddo

            gcen=gcen/nhull

            ibpeplan(nmagmax)=nplan

            do iplan=1,nplan
              ncorn=ncorn1(iplan)
              do icorn=1,ncorn
                bpemag(1:3,icorn,iplan,nmagmax)=bpebc(1:3,nmagmax)+
     &            bpemag(1:3,icorn,iplan,nmagmax)-gcen
                corn1(1:3,icorn,iplan)=bpemag(1:3,icorn,iplan,nmagmax)
              enddo !icorn
            enddo !nplan

            ! sort points such that normal vectors of planes points outside
            call undumag_sortcorn(2*ncornmax,2*nplanmax,
     &        nplan,ncorn1,corn1,corn2,tiny,ifail)

            if (ifail.ne.0) then
              write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_sortcorn for magnet ",nmagmax
              stop
            else
              do iplan=1,nplan
                ncorn=ncorn1(iplan)
                do icorn=1,ncorn
                  bpemag(1:3,icorn,iplan,nmagmax)=corn2(1:3,icorn,iplan)
                enddo !icorn
              enddo !nplan
            endif

          else if (nplan.eq.-9.or.nplan.eq.-10) then
cxxxxxxxxxx

            call util_skip_comment_end(lunbpe,ieof)

            if (nplan.eq.-9) then

              read(lunbpe,*)cline
              open(newunit=lundum,file=trim(cline))

              npoi=0
              last=1
              gcen=0.0d0

              do while (last.gt.0)
                call util_read_line(lundum,cline,last)
                if (last.gt.0) then
                  npoi=npoi+1
                endif
              enddo

              if (maxpoints.eq.0) then
                maxpoints=100
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                ihullallo=1
              else if (npoi.gt.maxpoints) then
                if (ihullallo.ne.0) then
                  deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                endif
                maxpoints=npoi
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
              endif

              rewind(lundum)

              do ipoi=1,npoi
                call util_skip_comment_end(lundum,ieof)
                read(lundum,*)hull(1:3,ipoi)
                gcen=gcen+bpebc(1:3,nmagmax)+hull(1:3,ipoi)
              enddo

              close(lundum)

            else if (nplan.eq.-10) then

              read(lunbpe,*)npoi

              if (maxpoints.eq.0) then
                maxpoints=100
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                ihullallo=1
              else if (npoi.gt.maxpoints) then
                if (ihullallo.ne.0) then
                  deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                endif
                maxpoints=npoi
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
              endif

              do ipoi=1,npoi
                call util_skip_comment_end(lunbpe,ieof)
                read(lunbpe,*)hull(1:3,ipoi)
                gcen=gcen+bpebc(1:3,nmagmax)+hull(1:3,ipoi)
              enddo

            endif

            xhull(1:npoi)=hull(1,1:npoi)
            yhull(1:npoi)=hull(2,1:npoi)
            zhull(1:npoi)=hull(3,1:npoi)

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &          trim(cline)
              stop
            endif

            gcen=0.0d0
            do ipoi=1,nhull
              korn=khull(nhull)
              gcen=gcen+bpebc(1:3,nmagmax)+hull(1:3,ipoi)
            enddo
            gcen=gcen/nhull

c            khull(1:kfacelast)=kface(1:kfacelast)

            bpebc0(7,nmagmax)=nface
            ibpeplano(nmagmax)=nface
            ibpeplan(nmagmax)=nface

            npmoth(nmoth)=npoi
            matmoth(nmoth)=imat
            ncolmoth(nmoth)=ibpecol(nmagmax)
            do ipoi=1,npoi
              xmoth(ipoi,nmoth)=bpebc(1,nmagmax)+hull(1,ipoi)
              ymoth(ipoi,nmoth)=bpebc(2,nmagmax)+hull(2,ipoi)
              zmoth(ipoi,nmoth)=bpebc(3,nmagmax)+hull(3,ipoi)
              hull(1:3,ipoi)=bpebc(1:3,nmagmax)+hull(1:3,ipoi)-gcen
            enddo

c            bpebc(1:3,nmagmax)=gcen

            x00=bpebc(1,nmagmax)
            y00=bpebc(2,nmagmax)
            z00=bpebc(3,nmagmax)

            next=1
            do iplan=1,nface

              ncorn=kface(next)

              ncorn=ncorn+1
              ibpecorn(iplan,nmagmax)=ncorn

              do icorn=1,ncorn

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                if (icorn.lt.ncorn) then

                  x0=hull(1,kface(next+icorn))
                  y0=hull(2,kface(next+icorn))
                  z0=hull(3,kface(next+icorn))

                  if (x0.lt.xdivmin) xdivmin=x0
                  if (x0.gt.xdivmax) xdivmax=x0
                  if (y0.lt.ydivmin) ydivmin=y0
                  if (y0.gt.ydivmax) ydivmax=y0
                  if (z0.lt.zdivmin) zdivmin=z0
                  if (z0.gt.zdivmax) zdivmax=z0

                  bpemag(1,icorn,iplan,nmagmax)=x0
                  bpemag(2,icorn,iplan,nmagmax)=y0
                  bpemag(3,icorn,iplan,nmagmax)=z0

                  write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 0"

                  corn1(1,icorn,iplan)=x0
                  corn1(2,icorn,iplan)=y0
                  corn1(3,icorn,iplan)=z0

                else ! icorn.lt.ncorn

                  bpemag(1,icorn,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                  bpemag(2,icorn,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                  bpemag(3,icorn,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)

                endif ! icorn.lt.ncorn

              enddo !icorn

              ncorn1(iplan)=ncorn

              next=next+ncorn ! here, ncorn is already increamented by 1

            enddo !nface

            nplan=nface

cxxxxxxxxxxxxxx

          endif !nplan

          x00=gcen(1)
          y00=gcen(2)
          z00=gcen(3)

          bpebc(1:3,nmagmax)=gcen

          do iplan=1,nplan

            ncorn=ncorn1(iplan)

            do icorn=1,ncorn-1

              if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

              x0=bpemag(1,icorn,iplan,nmagmax)
              y0=bpemag(2,icorn,iplan,nmagmax)
              z0=bpemag(3,icorn,iplan,nmagmax)

              if (x0.lt.xdivmin) xdivmin=x0
              if (x0.gt.xdivmax) xdivmax=x0
              if (y0.lt.ydivmin) ydivmin=y0
              if (y0.gt.ydivmax) ydivmax=y0
              if (z0.lt.zdivmin) zdivmin=z0
              if (z0.gt.zdivmax) zdivmax=z0

              corn1(1,icorn,iplan)=x0
              corn1(2,icorn,iplan)=y0
              corn1(3,icorn,iplan)=z0

              write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 1"
c                write(lun6,*)iplan,icorn,sngl(corn1(1:3,icorn,iplan))
            enddo !icorn

          enddo !nplan

          x02(2)=x00
          y02(2)=y00
          z02(2)=z00

          bc04=bpebc(4:7,nmagmax)
          bc8=bpebc(8,nmagmax)
          bc9=bpebc(9,nmagmax)
          bc10=bpebc(10,nmagmax)

          bpebc15=bpebc(15,nmagmax)
          mothdiv(1,nmagmax)=bpebc15

          do ic=1,32
            chmag(ic:ic)=chmags(ic,nmagmax)
            chmoth(ic:ic)=chmoths(ic,nmagmax)
          enddo

          dxdiv=(xdivmax-xdivmin)/nxdiv
          xdiv=bpebc(1,nmagmax)+xdivmin

          ncutpiece=ncutpiece+1
cdebug ixdiv 3
          do ixdiv=1,nxdiv-1

            xdiv=xdiv+dxdiv

            x02(1)=x02(2)
            y02(1)=y02(2)
            z02(1)=z02(2)

            call undumag_cut_magnet(nmagmax,x02,y02,z02, !debug 4
     &        2*nplanmax,2*ncornmax,
     &        ncorn1,corn1,ncorn2,corn2
     &        ,1,xdiv,hulltiny,ifail)
            if (ifail.ne.0) then
              write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, ixdiv, xdiv:",
     &          ifail, nmagmax,ixdiv,xdiv
              stop
            endif

c?            nmagmax=nmagmax-1

c            ncutpiece=ncutpiece+1
            if (ncorn2(1).gt.0) then
              ! Magnet has been cut

              ! First piece
              ncutpiece=ncutpiece+1

c?              nmagmax=nmagmax+1

              bpebc(8,nmagmax)=bc8
              bpebc(15,nmagmax)=bpebc15

              mothdiv(1,nmagmax)=bpebc15
              mothdiv(2,nmagmax)=ixdiv

              do ic=1,32
                chmags(ic,nmagmax)=chmag(ic:ic)
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo

              bpebc(9,nmagmax)=bc9
              bpebc(10,nmagmax)=bc10

              bpebc(1,nmagmax)=x02(1)
              bpebc(2,nmagmax)=y02(1)
              bpebc(3,nmagmax)=z02(1)

              bpebc(4:7,nmagmax)=bc04

              nplan=0
              do i=1,2*nplanmax
                if (ncorn1(i).gt.0) then
                  nplan=nplan+1
                endif
              enddo

              ibpecol(nmagmax)=ncol
              ibpeplan(nmagmax)=nplan
              ibpeplano(nmagmax)=nplan

              do iplan=1,nplan
                ncorn=ncorn1(iplan)
                ibpecorn(iplan,nmagmax)=ncorn+1
                do icorn=1,ncorn
                  bpemag(1:3,icorn,iplan,nmagmax)=
     &              corn1(1:3,icorn,iplan)
                enddo
                ncorn=ncorn+1
                bpemag(1:3,ncorn,iplan,nmagmax)=
     &            corn1(1:3,1,iplan) !debug 4
              enddo

              !{ check orientation of planes

              kdmag=nmagmax

              x0=0.0d0
              y0=0.0d0
              z0=0.0d0

              i=0
              nplan=ibpeplan(kdmag)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,kdmag)-1
                do icorn=1,ncorn
                  i=i+1
                  x0=x0+bpemag(1,icorn,iplan,kdmag)
                  y0=y0+bpemag(2,icorn,iplan,kdmag)
                  z0=z0+bpemag(3,icorn,iplan,kdmag)
                enddo ! icorn
              enddo !iplan

              x0=x0/i
              y0=y0/i
              z0=z0/i

              do iplan=1,ibpeplan(kdmag)

                p1(1)=bpemag(1,1,iplan,kdmag)
                p1(2)=bpemag(2,1,iplan,kdmag)
                p1(3)=bpemag(3,1,iplan,kdmag)

                p2(1)=bpemag(1,2,iplan,kdmag)
                p2(2)=bpemag(2,2,iplan,kdmag)
                p2(3)=bpemag(3,2,iplan,kdmag)

                p3(1)=bpemag(1,3,iplan,kdmag)
                p3(2)=bpemag(2,3,iplan,kdmag)
                p3(3)=bpemag(3,3,iplan,kdmag)

                call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)
                if (ifail.ne.0) then
                  write(lun6,*)"*** Error 7 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &              kdmag,iplan
                  stop
                endif

                ! does normal vector point outside?

                vsx=bpemag(1,1,iplan,kdmag)-x0
                vsy=bpemag(2,1,iplan,kdmag)-y0
                vsz=bpemag(3,1,iplan,kdmag)-z0

                if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,kdmag)=ncorn

                  do icorn=1,ncorn
                    corn1(1:3,icorn,iplan)=
     &                bpemag(1:3,icorn,iplan,kdmag)
                  enddo

                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,ncorn+1-icorn,iplan)
                  enddo

                endif

              enddo !nplan
              !} check orientation of planes

              ! Second piece

              nmagmax=nmagmax+1
+self,if=debug.
              write(lun6,*)"Second piece:",nmagmax
+self.

              bpebc(8,nmagmax)=bc8
              bpebc(9,nmagmax)=bc9
              bpebc(15,nmagmax)=bpebc15

              mothdiv(1,nmagmax)=bpebc15
              mothdiv(2,nmagmax)=ixdiv+1

              do ic=1,32
                chmags(ic,nmagmax)=chmag(ic:ic)
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo

              bpebc(10,nmagmax)=bc10

              bpebc(1,nmagmax)=x02(2)
              bpebc(2,nmagmax)=y02(2)
              bpebc(3,nmagmax)=z02(2)

              bpebc(4:7,nmagmax)=bc04

              nplan=0
              do i=1,2*nplanmax
                if (ncorn2(i).gt.0) then
                  nplan=nplan+1
                endif
              enddo

              ibpeplan(nmagmax)=nplan
              ibpeplano(nmagmax)=nplan
              ibpecol(nmagmax)=ncol

              do iplan=1,nplan
                ncorn=ncorn2(iplan)
                ibpecorn(iplan,nmagmax)=ncorn+1
                do icorn=1,ncorn
                  bpemag(1:3,icorn,iplan,nmagmax)=
     &              corn2(1:3,icorn,iplan)
                enddo
                ncorn=ncorn+1
                bpemag(1:3,ncorn,iplan,nmagmax)=
     &            corn2(1:3,1,iplan) !debug 4
              enddo

              ncorn1=0
              corn1=0.0d0
              ncorn1=ncorn2
              corn1=corn2

              !{ check orientation of planes

              x0=0.0d0
              y0=0.0d0
              z0=0.0d0

              i=0
              nplan=ibpeplan(nmagmax)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,nmagmax)-1
                do icorn=1,ncorn
                  i=i+1
                  x0=x0+bpemag(1,icorn,iplan,nmagmax)
                  y0=y0+bpemag(2,icorn,iplan,nmagmax)
                  z0=z0+bpemag(3,icorn,iplan,nmagmax)
                enddo ! icorn
              enddo !iplan

              x0=x0/i
              y0=y0/i
              z0=z0/i

              do iplan=1,ibpeplan(nmagmax)

                p1(1)=bpemag(1,1,iplan,nmagmax)
                p1(2)=bpemag(2,1,iplan,nmagmax)
                p1(3)=bpemag(3,1,iplan,nmagmax)

                p2(1)=bpemag(1,2,iplan,nmagmax)
                p2(2)=bpemag(2,2,iplan,nmagmax)
                p2(3)=bpemag(3,2,iplan,nmagmax)

                p3(1)=bpemag(1,3,iplan,nmagmax)
                p3(2)=bpemag(2,3,iplan,nmagmax)
                p3(3)=bpemag(3,3,iplan,nmagmax)

                call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                if (ifail.ne.0) then
                  write(lun6,*)"*** Error 8 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &              nmagmax,iplan
                  stop
                endif

                ! does normal vector point outside?

                vsx=bpemag(1,1,iplan,nmagmax)-x0
                vsy=bpemag(2,1,iplan,nmagmax)-y0
                vsz=bpemag(3,1,iplan,nmagmax)-z0

                if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,nmagmax)=ncorn

                  do icorn=1,ncorn
                    corn1(1:3,icorn,iplan)=
     &                bpemag(1:3,icorn,iplan,nmagmax)
                  enddo

                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,nmagmax)=
     &                corn1(1:3,ncorn+1-icorn,iplan)
                  enddo

                endif

              enddo !nplan
              !} check orientation of planes

            endif !cut

          enddo !nxdiv

c          dydiv=(ydivmax-ydivmin)/nydiv

          do kdmag1=nmagmax-nxdiv+1,nmagmax

            x02(2)=bpebc(1,kdmag1)
            y02(2)=bpebc(2,kdmag1)
            z02(2)=bpebc(3,kdmag1)

            ncorn1=0
            corn1=0.0d0
            ncorn2=0
            corn2=0.0d0

            nplan=ibpeplan(kdmag1)

            ydivmin=1.0d30
            ydivmax=-1.0d30

            do iplan=1,nplan
              ncorn=ibpecorn(iplan,kdmag1)
              ncorn1(iplan)=ncorn
              do icorn=1,ncorn
                corn1(1:3,icorn,iplan)=bpemag(1:3,icorn,iplan,kdmag1)
                if (corn1(2,icorn,iplan).lt.ydivmin)
     &            ydivmin=corn1(2,icorn,iplan)
                if (corn1(2,icorn,iplan).gt.ydivmax)
     &            ydivmax=corn1(2,icorn,iplan)
              enddo
            enddo

            dydiv=(ydivmax-ydivmin)/fracsum*yfacdiv
            ydiv=bpebc(2,kdmag1)+ydivmin

cdebug iydiv 3
            do iydiv=1,nydiv-1

              if (iydiv.eq.1) then
                kdmag=kdmag1
              else
                kdmag=nmagmax
              endif

              ydiv=ydiv+dydiv
c              ydiv=ydiv-dydiv

              x02(1)=x02(2)
              y02(1)=y02(2)
              z02(1)=z02(2)

              call undumag_cut_magnet(kdmag,x02,y02,z02,  !debug 5
     &          2*nplanmax,2*ncornmax,
     &          ncorn1,corn1,ncorn2,corn2
     &          ,2,ydiv,hulltiny,ifail)
              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, iydiv, ydiv:",
     &            ifail, kdmag,iydiv,ydiv
                stop
              endif

              !kdmag is mother

c              ncutpiece=ncutpiece+1
              if (ncorn2(1).gt.0) then
                ! Magnet has been cut
                ncutpiece=ncutpiece+1

                ! First piece, replaces mother

                bpebc(8,nmagmax)=bc8
                bpebc(9,kdmag)=bc9
                bpebc(15,kdmag)=bpebc15

                mothdiv(1,kdmag)=bpebc15
                mothdiv(3,kdmag)=iydiv

                do ic=1,32
                  chmags(ic,kdmag)=chmag(ic:ic)
                  chmoths(ic,kdmag)=chmoth(ic:ic)
                enddo

                bpebc(10,kdmag)=bc10

                bpebc(1,kdmag)=x02(1)
                bpebc(2,kdmag)=y02(1)
                bpebc(3,kdmag)=z02(1)

                bpebc(4:7,kdmag)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ibpecol(kdmag)=ncol
                ibpeplan(kdmag)=nplan
                ibpeplano(kdmag)=nplan

                do iplan=1,nplan
                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,kdmag)=ncorn+1
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag(1:3,ncorn,iplan,kdmag)=
     &              corn1(1:3,1,iplan) !debug 5
                enddo

+self,if=debug.
              write(lun6,*)"ireallo, iydiv, ydiv:",ireallo,iydiv,ydiv
              open(unit=97,access='append')
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,kdmag)
                do icorn=1,ncorn
                  !w97
                  write(97,*)" 222 ",ireallo,ydiv,kdmag,iplan,icorn,
     &              sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,kdmag))
                enddo
              enddo
c              endif
              close(97)
+self.
                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                nplan=ibpeplan(kdmag)
                do iplan=1,nplan
                  ncorn=ibpecorn(iplan,kdmag)-1
                  do icorn=1,ncorn
                    i=i+1
                    x0=x0+bpemag(1,icorn,iplan,kdmag)
                    y0=y0+bpemag(2,icorn,iplan,kdmag)
                    z0=z0+bpemag(3,icorn,iplan,kdmag)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(kdmag)

                  p1(1)=bpemag(1,1,iplan,kdmag)
                  p1(2)=bpemag(2,1,iplan,kdmag)
                  p1(3)=bpemag(3,1,iplan,kdmag)

                  p2(1)=bpemag(1,2,iplan,kdmag)
                  p2(2)=bpemag(2,2,iplan,kdmag)
                  p2(3)=bpemag(3,2,iplan,kdmag)

                  p3(1)=bpemag(1,3,iplan,kdmag)
                  p3(2)=bpemag(2,3,iplan,kdmag)
                  p3(3)=bpemag(3,3,iplan,kdmag)

                  call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 9 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                kdmag,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag(1,1,iplan,kdmag)-x0
                  vsy=bpemag(2,1,iplan,kdmag)-y0
                  vsz=bpemag(3,1,iplan,kdmag)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn1(iplan)
                    ibpecorn(iplan,kdmag)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                   bpemag(1:3,icorn,iplan,kdmag)
                    enddo

                    do icorn=1,ncorn
                      bpemag(1:3,icorn,iplan,kdmag)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ! Second piece

                nmagmax=nmagmax+1
+self,if=debug.
              write(lun6,*)"Second piece:",nmagmax
+self.

                bpebc(8,nmagmax)=bc8
                bpebc(15,nmagmax)=bpebc15

                mothdiv(1,nmagmax)=bpebc15
                mothdiv(3,nmagmax)=iydiv+1

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=bc9
                bpebc(10,nmagmax)=bc10

                bpebc(1,nmagmax)=x02(2)
                bpebc(2,nmagmax)=y02(2)
                bpebc(3,nmagmax)=z02(2)

                bpebc(4:7,nmagmax)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn2(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ibpeplan(nmagmax)=nplan
                ibpeplano(nmagmax)=nplan
                ibpecol(nmagmax)=ncol

                do iplan=1,nplan
                  ncorn=ncorn2(iplan)
                  ibpecorn(iplan,nmagmax)=ncorn+1
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,nmagmax)=
     &                corn2(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag(1:3,ncorn,iplan,nmagmax)=
     &              corn2(1:3,1,iplan) !debug 5
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                nplan=ibpeplan(nmagmax)
                do iplan=1,nplan
                  ncorn=ibpecorn(iplan,nmagmax)-1
                  do icorn=1,ncorn
                    i=i+1
                    x0=x0+bpemag(1,icorn,iplan,nmagmax)
                    y0=y0+bpemag(2,icorn,iplan,nmagmax)
                    z0=z0+bpemag(3,icorn,iplan,nmagmax)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(nmagmax)

                  p1(1)=bpemag(1,1,iplan,nmagmax)
                  p1(2)=bpemag(2,1,iplan,nmagmax)
                  p1(3)=bpemag(3,1,iplan,nmagmax)

                  p2(1)=bpemag(1,2,iplan,nmagmax)
                  p2(2)=bpemag(2,2,iplan,nmagmax)
                  p2(3)=bpemag(3,2,iplan,nmagmax)

                  p3(1)=bpemag(1,3,iplan,nmagmax)
                  p3(2)=bpemag(2,3,iplan,nmagmax)
                  p3(3)=bpemag(3,3,iplan,nmagmax)

                  call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 10 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                nmagmax,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag(1,1,iplan,nmagmax)-x0
                  vsy=bpemag(2,1,iplan,nmagmax)-y0
                  vsz=bpemag(3,1,iplan,nmagmax)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn2(iplan)
                    ibpecorn(iplan,nmagmax)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag(1:3,icorn,iplan,nmagmax)
                    enddo

                    do icorn=1,ncorn
                      bpemag(1:3,icorn,iplan,nmagmax)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ncorn1=0
                corn1=0.0d0
                ncorn1=ncorn2
                corn1=corn2

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                do iplan=1,nplan
                  do icorn=1,ncorn
                    if (corn1(2,icorn,iplan).lt.ydivmin)
     &                ydivmin=corn1(2,icorn,iplan)
                    if (corn1(2,icorn,iplan).gt.ydivmax)
     &                ydivmax=corn1(2,icorn,iplan)
                  enddo
                enddo

              endif !cut

              dydiv=dydiv/yfracdiv

            enddo !nydiv

          enddo !kdmag

          dzdiv=(zdivmax-zdivmin)/nzdiv

          do kdmag1=nmagmax-nxdiv*nydiv+1,nmagmax

            x02(2)=bpebc(1,kdmag1)
            y02(2)=bpebc(2,kdmag1)
            z02(2)=bpebc(3,kdmag1)

            ncorn1=0
            corn1=0.0d0
            ncorn2=0
            corn2=0.0d0

            nplan=ibpeplan(kdmag1)

            zdivmin=1.0d30
            zdivmax=-1.0d30

            do iplan=1,nplan
              ncorn=ibpecorn(iplan,kdmag1)
              ncorn1(iplan)=ncorn
              do icorn=1,ncorn
                corn1(1:3,icorn,iplan)=bpemag(1:3,icorn,iplan,kdmag1)
                if (corn1(3,icorn,iplan).lt.zdivmin)
     &            zdivmin=corn1(3,icorn,iplan)
                if (corn1(3,icorn,iplan).gt.zdivmax)
     &            zdivmax=corn1(3,icorn,iplan)
              enddo
            enddo

            zdiv=bpebc(3,kdmag1)+zdivmin

cdebug izdiv 3
            do izdiv=1,nzdiv-1

              if (izdiv.eq.1) then
                kdmag=kdmag1
              else
                kdmag=nmagmax
              endif

              zdiv=zdiv+dzdiv

              x02(1)=x02(2)
              y02(1)=y02(2)
              z02(1)=z02(2)

c              write(lun6,*)"Vorher:",kdmag1,kdmag,nmagmax,x02,y02,z02
              call undumag_cut_magnet(kdmag,x02,y02,z02, !debug 6
     &          2*nplanmax,2*ncornmax,
     &          ncorn1,corn1,ncorn2,corn2
     &          ,3,zdiv,hulltiny,ifail)
              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, izdiv, zdiv:",
     &            ifail,kdmag,izdiv,zdiv
              endif
c              write(lun6,*)"Nachher:",z02

              !kdmag is mother

c              ncutpiece=ncutpiece+1
              if (ncorn2(1).gt.0) then
                ! Magnet has been cut
                ncutpiece=ncutpiece+1

                ! First piece, replaces mother

                bpebc(8,nmagmax)=bc8
                bpebc(15,kdmag)=bpebc15
                mothdiv(1,kdmag)=bpebc15
                mothdiv(4,kdmag)=izdiv

                do ic=1,32
                  chmags(ic,kdmag)=chmag(ic:ic)
                  chmoths(ic,kdmag)=chmoth(ic:ic)
                enddo

                bpebc(9,kdmag)=bc9
                bpebc(10,kdmag)=bc10

                bpebc(1,kdmag)=x02(1)
                bpebc(2,kdmag)=y02(1)
                bpebc(3,kdmag)=z02(1)

                bpebc(4:7,kdmag)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ibpecol(kdmag)=ncol
                ibpeplan(kdmag)=nplan
                ibpeplano(kdmag)=nplan

                do iplan=1,nplan
                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,kdmag)=ncorn+1
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag(1:3,ncorn,iplan,kdmag)=
     &              corn1(1:3,1,iplan) !debug 6
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                nplan=ibpeplan(kdmag)
                do iplan=1,nplan
                  ncorn=ibpecorn(iplan,kdmag)-1
                  do icorn=1,ncorn
                    i=i+1
                    x0=x0+bpemag(1,icorn,iplan,kdmag)
                    y0=y0+bpemag(2,icorn,iplan,kdmag)
                    z0=z0+bpemag(3,icorn,iplan,kdmag)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(kdmag)

                  p1(1)=bpemag(1,1,iplan,kdmag)
                  p1(2)=bpemag(2,1,iplan,kdmag)
                  p1(3)=bpemag(3,1,iplan,kdmag)

                  p2(1)=bpemag(1,2,iplan,kdmag)
                  p2(2)=bpemag(2,2,iplan,kdmag)
                  p2(3)=bpemag(3,2,iplan,kdmag)

                  p3(1)=bpemag(1,3,iplan,kdmag)
                  p3(2)=bpemag(2,3,iplan,kdmag)
                  p3(3)=bpemag(3,3,iplan,kdmag)

                  call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 11 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                kdmag,iplan
                    write(lun6,*)"icorn,x,y,z:"
                    do icorn=1,ibpecorn(iplan,kdmag)
                      write(lun6,*)icorn,bpemag(1:3,icorn,iplan,kdmag)
                    enddo
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag(1,1,iplan,kdmag)-x0
                  vsy=bpemag(2,1,iplan,kdmag)-y0
                  vsz=bpemag(3,1,iplan,kdmag)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn1(iplan)
                    ibpecorn(iplan,kdmag)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag(1:3,icorn,iplan,kdmag)
                    enddo

                    do icorn=1,ncorn
                      bpemag(1:3,icorn,iplan,kdmag)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ! Second piece

                nmagmax=nmagmax+1
+self,if=debug.
                write(lun6,*)"Second piece:",nmagmax
+self.

                bpebc(8,nmagmax)=bc8
                bpebc(15,nmagmax)=bpebc15

                mothdiv(1,nmagmax)=bpebc15
                mothdiv(4,nmagmax)=izdiv+1

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=bc9
                bpebc(10,nmagmax)=bc10

                bpebc(1,nmagmax)=x02(2)
                bpebc(2,nmagmax)=y02(2)
                bpebc(3,nmagmax)=z02(2)

                bpebc(4:7,nmagmax)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn2(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ibpeplan(nmagmax)=nplan
                ibpeplano(nmagmax)=nplan
                ibpecol(nmagmax)=ncol

                do iplan=1,nplan
                  ncorn=ncorn2(iplan)
                  ibpecorn(iplan,nmagmax)=ncorn+1
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,nmagmax)=
     &                corn2(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag(1:3,ncorn,iplan,nmagmax)=
     &              corn2(1:3,1,iplan) !debug 6
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                do iplan=1,ibpeplan(nmagmax)
                  do icorn=1,ibpecorn(iplan,nmagmax)-1
                    i=i+1
                    x0=x0+bpemag(1,icorn,iplan,nmagmax)
                    y0=y0+bpemag(2,icorn,iplan,nmagmax)
                    z0=z0+bpemag(3,icorn,iplan,nmagmax)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(nmagmax)

                  p1(1)=bpemag(1,1,iplan,nmagmax)
                  p1(2)=bpemag(2,1,iplan,nmagmax)
                  p1(3)=bpemag(3,1,iplan,nmagmax)

                  p2(1)=bpemag(1,2,iplan,nmagmax)
                  p2(2)=bpemag(2,2,iplan,nmagmax)
                  p2(3)=bpemag(3,2,iplan,nmagmax)

                  p3(1)=bpemag(1,3,iplan,nmagmax)
                  p3(2)=bpemag(2,3,iplan,nmagmax)
                  p3(3)=bpemag(3,3,iplan,nmagmax)

                  call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 12 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                nmagmax,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag(1,1,iplan,nmagmax)-x0
                  vsy=bpemag(2,1,iplan,nmagmax)-y0
                  vsz=bpemag(3,1,iplan,nmagmax)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn2(iplan)
                    ibpecorn(iplan,nmagmax)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag(1:3,icorn,iplan,nmagmax)
                    enddo

                    do icorn=1,ncorn
                      bpemag(1:3,icorn,iplan,nmagmax)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ncorn1=0
                corn1=0.0d0
                ncorn1=ncorn2
                corn1=corn2

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                zdivmin=1.0d30
                zdivmax=-1.0d30
                do iplan=1,nplan
                  do icorn=1,ncorn
                    if (corn1(3,icorn,iplan).lt.zdivmin)
     &                zdivmin=corn1(3,icorn,iplan)
                    if (corn1(3,icorn,iplan).gt.zdivmax)
     &                zdivmax=corn1(3,icorn,iplan)
                  enddo
                enddo

              endif !cut

            enddo !nzdiv

          enddo !kdmag

        else if (nplan.eq.-11) then

          ncorn=4
          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
          ncorn=ncorn+1

          nangmin=1+abs(angle)/(90.0d0+tiny)

          if (nang.lt.nangmin) nang=nangmin
          if (nr.lt.1) nr=1
          if (nh.lt.1) nh=1

          nmagdiv=nmagdiv+nr*nang*nh

! cyl magnet, i.e. nplan=-11{

          kcyl=kcyl+1
          magcyl(kcyl,1)=nmagmax

          if (radin.lt.tiny) radin=tiny

          x00=bpebc0(1,nmagmax)
          y00=bpebc0(2,nmagmax)
          z00=bpebc0(3,nmagmax)

          npmoth(nmoth)=8
          matmoth(nmoth)=imat
          ncolmoth(nmoth)=ibpecol(nmagmax)

          ip=0
          dphi=angle/nang*grarad1
          dr=(radout-radin)/nr
          dh=height/nh
          r=radin
          do ir=1,2
            h=-height/2.0d0
            do ih=1,2
              phi=-angle/2.0d0*grarad1
              do iphi=1,2
                ip=ip+1
                x1=r*sin(phi)
                y1=h
                z1=r*cos(phi)
                xmoth(ip,nmoth)=rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1+x00
                ymoth(ip,nmoth)=rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1+y00
                zmoth(ip,nmoth)=rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1+z00
                phi=angle/2.0d0*grarad1
              enddo
              h=height/2.0d0
            enddo
            r=radout
          enddo
cBau
          r=radin
          jplan=ibpeplano(nmagmax)

          if (ihullallo.eq.0) then
            maxpoints=8
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else
            if (maxpoints.lt.8) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
              maxpoints=8
              allocate(hull(3,maxpoints))
              allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
              allocate(khull(maxpoints))
              allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            endif
          endif

          do ir=1,nr
            h=-height/2.0d0+dh/2.0d0
            do ih=1,nh
              phi=-angle/2.0d0*grarad1+dphi/2.0d0
              do iphi=1,nang

                x0=r*sin(phi)
                y0=h
                z0=r*cos(phi)

                ri=radin
                ro=radout
                y1=y0-dh/2.0d0
                y2=y0+dh/2.0d0

                x1=ri*sin(phi-dphi/2.0d0)
                z1=ri*cos(phi-dphi/2.0d0)
                x2=ro*sin(phi-dphi/2.0d0)
                z2=ro*cos(phi-dphi/2.0d0)
                x3=ro*sin(phi+dphi/2.0d0)
                z3=ro*cos(phi+dphi/2.0d0)
                x4=ri*sin(phi+dphi/2.0d0)
                z4=ri*cos(phi+dphi/2.0d0)

                xhull(1)=rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1
                yhull(1)=rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1
                zhull(1)=rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1

                xhull(2)=rmat(1,1)*x2+rmat(1,2)*y1+rmat(1,3)*z2
                yhull(2)=rmat(2,1)*x2+rmat(2,2)*y1+rmat(2,3)*z2
                zhull(2)=rmat(3,1)*x2+rmat(3,2)*y1+rmat(3,3)*z2

                xhull(3)=rmat(1,1)*x3+rmat(1,2)*y1+rmat(1,3)*z3
                yhull(3)=rmat(2,1)*x3+rmat(2,2)*y1+rmat(2,3)*z3
                zhull(3)=rmat(3,1)*x3+rmat(3,2)*y1+rmat(3,3)*z3

                xhull(4)=rmat(1,1)*x4+rmat(1,2)*y1+rmat(1,3)*z4
                yhull(4)=rmat(2,1)*x4+rmat(2,2)*y1+rmat(2,3)*z4
                zhull(4)=rmat(3,1)*x4+rmat(3,2)*y1+rmat(3,3)*z4

                xhull(5)=rmat(1,1)*x1+rmat(1,2)*y2+rmat(1,3)*z1
                yhull(5)=rmat(2,1)*x1+rmat(2,2)*y2+rmat(2,3)*z1
                zhull(5)=rmat(3,1)*x1+rmat(3,2)*y2+rmat(3,3)*z1

                xhull(6)=rmat(1,1)*x2+rmat(1,2)*y2+rmat(1,3)*z2
                yhull(6)=rmat(2,1)*x2+rmat(2,2)*y2+rmat(2,3)*z2
                zhull(6)=rmat(3,1)*x2+rmat(3,2)*y2+rmat(3,3)*z2

                xhull(7)=rmat(1,1)*x3+rmat(1,2)*y2+rmat(1,3)*z3
                yhull(7)=rmat(2,1)*x3+rmat(2,2)*y2+rmat(2,3)*z3
                zhull(7)=rmat(3,1)*x3+rmat(3,2)*y2+rmat(3,3)*z3

                xhull(8)=rmat(1,1)*x4+rmat(1,2)*y2+rmat(1,3)*z4
                yhull(8)=rmat(2,1)*x4+rmat(2,2)*y2+rmat(2,3)*z4
                zhull(8)=rmat(3,1)*x4+rmat(3,2)*y2+rmat(3,3)*z4

                npoi=8
                call util_convex_hull_3d(npoi,xhull,yhull,zhull,
     &            khull,kedge,kface,
     &            nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
                if (ifailhull.ne.0.or.nhull.lt.4) then
                  write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &              trim(cline)
                  stop
                endif

                ibpeplano(nmagmax)=nface
                ibpeplan(nmagmax)=nface

                next=1

                gcen=0.0d0
                k=0
                do iplan=1,nface

                  ncorn=kface(next)

                  ncorn=ncorn+1
                  ibpecorn(iplan,nmagmax)=ncorn

                  do icorn=1,ncorn

                    if (icorn.lt.ncorn) then
                      ip=kface(next+icorn)
                      bpemag(1,icorn,iplan,nmagmax)=xhull(ip)+x00
                      bpemag(2,icorn,iplan,nmagmax)=yhull(ip)+y00
                      bpemag(3,icorn,iplan,nmagmax)=zhull(ip)+z00

                      k=k+1
                      gcen(1)=gcen(1)+xhull(ip)+x00
                      gcen(2)=gcen(2)+yhull(ip)+y00
                      gcen(3)=gcen(3)+zhull(ip)+z00

c                      write(99,*)nmagmax,iplan,icorn,bpemag0(1:3,icorn,iplan,nmagmax)
                    else ! icorn.lt.ncorn

                      bpemag(1,icorn,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                      bpemag(2,icorn,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                      bpemag(3,icorn,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)

                    endif ! icorn.lt.ncorn

                  enddo !icorn

                  next=next+ncorn ! here, ncorn is already increamented by 1

                enddo !nface

                gcen=gcen/k

               do iplan=1,nface
                 ncorn=ibpecorn(iplan,nmagmax)
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,nmagmax)=
     &                bpemag(1:3,icorn,iplan,nmagmax)-gcen(1:3)
                  enddo !icorn
                enddo !nface

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15

                mothdiv(2,nmagmax)=ir
                mothdiv(3,nmagmax)=iy
                mothdiv(4,nmagmax)=iphi

                c32=chmag
                write(chmags(1:32,nmagmax),'(a)')c32a(1:32)
                c32=chmoth
                write(chmoths(1:32,nmagmax),'(a)')c32a(1:32)

                bpebc(9,nmagmax)=imat
                bpebc(10,nmagmax)=0

                ibpeplano(nmagmax)=jplan

                bpebc(1:3,nmagmax)=gcen(1:3)

                x1=xm*bdum
                y1=ym*bdum
                z1=zm*bdum

                bpebc(4,nmagmax)=
     &            rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1
                bpebc(5,nmagmax)=
     &            rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1
                bpebc(6,nmagmax)=
     &            rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1

                bpebc(7,nmagmax)=bc
                bpebc(8,nmagmax)=1
                ibpeplan(nmagmax)=6
                ibpecol(nmagmax)=ncol

                phi=phi+dphi

                nspecmag=nspecmag+1
                nmagmax=nmagmax+1
              enddo
              h=h+dh
            enddo !ih
            r=r+dr
          enddo !ir

          nspecmag=nspecmag-1
          nmagmax=nmagmax-1
          magcyl(kcyl,2)=nmagmax
          ncutpiece=ncutpiece+nr*nang*nh

! cyl magnet, i.e. nplan=-11}
        else ! nplan>0

! rectangular special magnet, i.e. nplan=-6{

          call util_skip_comment_end(lunbpe,ieof)

          read(lunbpe,*)xlen,ylen,zlen, nxdiv,nydiv,nzdiv

c          imag=nmagmax+nxdiv*nydiv*nzdiv-1

          dx=xlen/nxdiv

          fracsum=0.0d0
          ! yfracdiv**(nydiv-1)=yfacdiv
          ! ln(yfracdiv)*(nydiv-1)=ln(yfacdiv)
          if (nydiv.gt.1) then
            yfracdiv=exp(log(yfacdiv)/(nydiv-1))
          else
            yfracdiv=1.0d0
          endif
          do iydiv=0,nydiv-1
            fracsum=fracsum+yfracdiv**iydiv
          enddo

          dz=zlen/nzdiv

          x0=bpebc0(1,nmagmax)-xlen/2.0d0
          y0=bpebc0(2,nmagmax)-ylen/2.0d0
          z0=bpebc0(3,nmagmax)-zlen/2.0d0

          if (bc.ne.0.0d0.and.xmin.gt.x0) xmin=x0
          if (bc.ne.0.0d0.and.ymin.gt.y0) ymin=y0
          if (bc.ne.0.0d0.and.zmin.gt.z0) zmin=z0

          x0=x0+xlen
          y0=y0+ylen
          z0=z0+zlen

          if (bc.ne.0.0d0.and.xmax.lt.x0) xmax=x0
          if (bc.ne.0.0d0.and.ymax.lt.y0) ymax=y0
          if (bc.ne.0.0d0.and.zmax.lt.z0) zmax=z0

          x00=bpebc0(1,nmagmax)-xlen/2.0d0-dx/2.0d0
          y00=bpebc0(2,nmagmax)+ylen/2.0d0
          z00=bpebc0(3,nmagmax)-zlen/2.0d0-dz/2.0d0
cdebug
          npmoth(nmoth)=8
          matmoth(nmoth)=imat
          ncolmoth(nmoth)=ibpecol(nmagmax)

          x0=x0-xlen/2.0
          y0=y0-ylen/2.0
          z0=z0-zlen/2.0
          xmoth(1,nmoth)=x0-xlen/2.0d0
          ymoth(1,nmoth)=y0-ylen/2.0d0
          zmoth(1,nmoth)=z0-zlen/2.0d0

          xmoth(2,nmoth)=x0+xlen/2.0d0
          ymoth(2,nmoth)=y0-ylen/2.0d0
          zmoth(2,nmoth)=z0-zlen/2.0d0

          xmoth(3,nmoth)=x0+xlen/2.0d0
          ymoth(3,nmoth)=y0+ylen/2.0d0
          zmoth(3,nmoth)=z0-zlen/2.0d0

          xmoth(4,nmoth)=x0-xlen/2.0d0
          ymoth(4,nmoth)=y0+ylen/2.0d0
          zmoth(4,nmoth)=z0-zlen/2.0d0

          xmoth(5,nmoth)=x0-xlen/2.0d0
          ymoth(5,nmoth)=y0-ylen/2.0d0
          zmoth(5,nmoth)=z0+zlen/2.0d0

          xmoth(6,nmoth)=x0+xlen/2.0d0
          ymoth(6,nmoth)=y0-ylen/2.0d0
          zmoth(6,nmoth)=z0+zlen/2.0d0

          xmoth(7,nmoth)=x0+xlen/2.0d0
          ymoth(7,nmoth)=y0+ylen/2.0d0
          zmoth(7,nmoth)=z0+zlen/2.0d0

          xmoth(8,nmoth)=x0-xlen/2.0d0
          ymoth(8,nmoth)=y0+ylen/2.0d0
          zmoth(8,nmoth)=z0+zlen/2.0d0

          jplan=ibpeplano(nmagmax)

          imag=nmagmax
          bpebc(15,nmagmax)=nmagmax

          mothdiv(1,nmagmax)=nmagmax

          do ic=1,32
            chmag(ic:ic)=chmags(ic,nmagmax)
            chmoth(ic:ic)=chmoths(ic,nmagmax)
          enddo

          nmagmax=nmagmax-1

          ncutpiece=ncutpiece+1
cdebug ixdiv 4
          do ixdiv=1,nxdiv
            x0=x00+dx*ixdiv
            y0=y00
            dy=ylen/fracsum
cdebug iydiv 4
            do iydiv=1,nydiv
              y0=y0-dy/2.0d0
cdebug izdiv 4
              do izdiv=1,nzdiv

                z0=z00+dz*izdiv

                nmagmax=nmagmax+1

                bpebc(1,nmagmax)=x0
                bpebc(2,nmagmax)=y0
                bpebc(3,nmagmax)=z0

                bpebc(4,nmagmax)=bpebc0(4,imag)
                bpebc(5,nmagmax)=bpebc0(5,imag)
                bpebc(6,nmagmax)=bpebc0(6,imag)

                bc=sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
                bpebc(7,nmagmax)=bc
c                write(lun6,*) nmagmax,bc

                bpebc(8,nmagmax)=bpebc0(7,imag)
                bpebc(15,nmagmax)=bpebc15

                mothdiv(1,nmagmax)=bpebc15
                mothdiv(2,nmagmax)=ixdiv
                mothdiv(3,nmagmax)=iydiv
                mothdiv(4,nmagmax)=izdiv

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=imat

                ibpeplano(nmagmax)=jplan

                bpebc0(1,nmagmax)=x0
                bpebc0(2,nmagmax)=y0
                bpebc0(3,nmagmax)=z0

                bpebc0(4,nmagmax)=xm*bdum
                bpebc0(5,nmagmax)=ym*bdum
                bpebc0(6,nmagmax)=zm*bdum

                bpebc0(7,nmagmax)=-6
                ibpeplan(nmagmax)=6
                ibpecol(nmagmax)=ncol

                iplan=1
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=2
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=3
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=4
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=5
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=6
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0

                do iplan=1,6
                  bpemag(1,5,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                  bpemag(2,5,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                  bpemag(3,5,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)
                enddo !iplan

                do iplan=1,6
                  bpemag(1,5,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                  bpemag(2,5,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                  bpemag(3,5,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)
                enddo !iplan

              enddo !nzdiv
              y0=y0-dy/2.0d0
              dy=dy*yfracdiv
            enddo !nydiv
          enddo !nxdiv
! rectangular magnet, i.e. nplan=-6}

        endif !nplan>0

      enddo !nspecmag

      do imag=kmag1,nmagmax
        if (bpebc(8,imag).eq.1.and.bpebc(7,imag).ne.0.0d0) then
          do iplan=1,ibpeplan(imag)
            do icorn=1,ibpecorn(iplan,imag)
              x0=bpemag(1,icorn,iplan,imag)+bpebc(1,imag)
              y0=bpemag(2,icorn,iplan,imag)+bpebc(2,imag)
              z0=bpemag(3,icorn,iplan,imag)+bpebc(3,imag)
              bpemag(1,icorn,iplan,imag)=x0
              bpemag(2,icorn,iplan,imag)=y0
              bpemag(3,icorn,iplan,imag)=z0
              if (x0.lt.xmin) xmin=x0
              if (x0.gt.xmax) xmax=x0
              if (y0.lt.ymin) ymin=y0
              if (y0.gt.ymax) ymax=y0
              if (z0.lt.zmin) zmin=z0
              if (z0.gt.zmax) zmax=z0
            enddo
          enddo
        endif
      enddo

      call util_skip_comment(lunbpe)
      read(lunbpe,*)x0,y0,z0

      nmag=nmagmax !includes now special magnets

      open(newunit=lunmag,file='undumag.run',status='old')
      read(lunmag,'(a)')cundutit
      close(lunmag)
      cundutit(1:1)='*'

cdebug material
      write(lun6,*)
      write(lun6,*) "Material files (material number, material type, mode, filename):"
      write(lun6,*)
      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,*) imatfile
      do kmat=1,nmatfiles
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*) imat ,lmat, mapmode, cfile
        nmatpoi=0
        bcmo=-1.0d30
        hmato=-1.0d30
        open(newunit=lunmat,file=trim(cfile),status='old')
        write(lun6,*)imat,lmat,mapmode,"      ",trim(cfile)
        nline=0

115     call util_skip_comment_end(lunmat,ieof)
        if (ieof.ne.0) goto 995
        perksi=0.0d0
        ! lmat = 1: Anisotropic magnet material with an easy axis
        !           mapmode=1: Linear material
        !           mapmode=2: Non-linear material

        if (lmat.eq.1) then

          if (mapmode.eq.1) then

            nline=nline+1

            if (nline.gt.1) then
              write(lun6,*)"*** Error in undumag_ini_old ***"
              write(lun6,*)"*** Material file for mapmode 1 must contain only one data line ***"
              write(lun6,*)"File: ,",trim(cfile)
              stop
            endif

            read(lunmat,*)bcmat(2:3,1,kmat) ! read mu=1.+parksi and perksi
            bcmat(2,1,kmat)=bcmat(2,1,kmat)-1.0d0

          else if (mapmode.eq.2) then
            read(lunmat,*)hmat,bcm,perksi
c              if (bcm.ne.bcmo.or.hmato.ne.hmat) then
c                nmatpoi=nmatpoi+1
c                bcmat(1,nmatpoi,kmat)=hmat
c                bcmat(2,nmatpoi,kmat)=bcm
c                bcmat(3,nmatpoi,kmat)=perksi
c              endif
            if (bcm.ne.bcmo) then
c                nmatpoi=nmatpoi+1
            endif
            bcmat(1,nmatpoi,kmat)=hmat
            bcmat(2,nmatpoi,kmat)=bcm
            bcmat(3,nmatpoi,kmat)=perksi
            bcmo=bcm
            hmato=hmat
          else
            write(lun6,*)"*** Bad material mode found in input file ***"
            stop
          endif
          goto 115
        else if (lmat.eq.2) then
            ! lmat = 2: Isotropic material
            if (mapmode.eq.0
     &          .or.mapmode.eq.2
     &          .or.mapmode.eq.3
     &          .or.mapmode.eq.4
     &          .or.mapmode.eq.5
     &          .or.mapmode.eq.6
     &          .or.mapmode.eq.7
     &          .or.mapmode.eq.8
     &          ) then
              read(lunmat,*)hmat,bcm
            else
              write(lun6,*)"*** Bad material mode found in input file ***"
              stop
            endif
c            if (bcm.ne.bcmo.or.hmato.ne.hmat) then
            if (bcm.ne.bcmo) then
              nmatpoi=nmatpoi+1
            endif
            bcmat(1,nmatpoi,kmat)=hmat
            bcmat(2,nmatpoi,kmat)=bcm
            bcmat(3,nmatpoi,kmat)=perksi
            if (
     &          mapmode.eq.2
     &          .or.mapmode.eq.3
     &          .or.mapmode.eq.4
     &          .or.mapmode.eq.5
     &          .or.mapmode.eq.6
     &          .or.mapmode.eq.7
     &          .or.mapmode.eq.8
     &          ) then
              if (mapmode.eq.3.and.hmat.eq.0.0d0) hmat=1.0d-30
              if (mapmode.eq.3.and.bcm.eq.0.0d0) bcm=1.0d-30
              feh1(nmatpoi)=hmat
              fem1(nmatpoi)=bcm
              bcmo=bcm
              hmato=hmat
            endif
c            endif
            goto 115
          else
            write(lun6,*)"*** Bad material type found in input file ***"
            write(lun6,*)"*** Must be 1 for anisotropic or 2 for isotropic material ***"
            stop
          endif !lmat

995     continue

        matmaps(1,kmat)=imat
        matmaps(2,kmat)=lmat
        matmaps(3,kmat)=mapmode
        matmaps(4,kmat)=nmatpoi

        close(lunmat)

        if (mapmode.gt.1.and.nmatpoi.lt.2) then
          write(lun6,*)"*** Error in undumag_ini_old ***"
          write(lun6,*)"*** Material file for mapmode > 1 must contain more then one data line ***"
          write(lun6,*)"File: ,",trim(cfile)
          stop
        endif
        if (lmat.eq.2.and.isplinefm.ne.0) call util_spline_coef(feh1,fem1,nmatpoi,
     &    0.0d0,0.0d0,fespl1,fewspl1,fewspl2,fewspl3,fewspl4)

      enddo !nmatfiles

      call util_skip_comment_end(lunbpe,ieof)
      if (ieof.ne.0) goto 9977

      read(lunbpe,'(a)')cline

      xcwmin=1.0e30
      xcwmax=-1.0e30

      if (cline.eq.'Coils') then

        nlines=0
777     read(lunbpe,'(a)')cline

        if (cline.ne.'EndCoils') then
          nlines=nlines+1
          goto 777
        endif

        if (nlines.gt.0) then

          do i=1,nlines+1
            backspace(lunbpe)
          enddo

          ncwires=0
          nrace=0
          nwind=0
          ncrace=0
          narc=0
          ncarc=0
          nrbar=0
          nthwir=0

          do i=1,nlines+1

            call util_skip_comment_end(lunbpe,ieof)
            read(lunbpe,'(a)')cline

            if (cline.eq.'EndCoils') then
              exit
            else if (cline.eq.'Filaments') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)ncfila
              if (ncfila.gt.0) then
                luncoi=lunbpe
              else
                ncfila=0
                open(newunit=luncoi,file=cline)
                call util_skip_comment_end(lunbpe,ieof)
                do while(ieof.eq.0)
                  read(luncoi,*)curr,x1,y1,z1,x2,y2,z2
                  ncfila=ncfila+1
                  call util_skip_comment_end(lunbpe,ieof)
                enddo
                rewind(luncoi)
              endif
              do k=1,ncfila
                call util_skip_comment_end(luncoi,ieof)
                read(luncoi,*)curr,x1,y1,z1,x2,y2,z2
                if (((x2-x1)**2+(y2-y1)**2+(z2-z1)**2)*curr.ne.0.0d0) then
                  ncwires=ncwires+1
                  if (x1.lt.xcwmin) xcwmin=x1
                  if (x2.lt.xcwmin) xcwmin=x2
                  if (x1.gt.xcwmax) xcwmax=x1
                  if (x2.gt.xcwmax) xcwmax=x2
                endif
                if (luncoi.ne.lunbpe) close(luncoi)
              enddo !ncfila
            else if (cline.eq.'RectWindings') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)wind19
              nwind=nwind+1
            else if (cline.eq.'Rectangular') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr,x,y,z,vx,vy,vz,phi,xlen
              nrace=nrace+1
            else if (cline.eq.'RectangCirc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              if (curr.ne.0.0d0) ncrace=ncrace+1
            else if (cline.eq.'RectArc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)dum
              if (curr.ne.0.0d0) narc=narc+1
            else if (cline.eq.'CircArc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)dum
              if (curr.ne.0.0d0) ncarc=ncarc+1
            else if (cline.eq.'RectBar') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              if (curr.ne.0.0d0) nrbar=nrbar+1
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)dum
            else if (cline.eq.'ThickWire') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              if (curr.ne.0.0d0) nthwir=nthwir+1
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)dum
            endif !key
          enddo !nlines

          if (ncwires.gt.0) then
            allocate(wire(nwitems,ncwires))
            wire=0.0d0
          endif

          if (nrace.gt.0) then
            allocate(race(17,nrace))
            race=0.0d0
          endif

          if (nwind.gt.0) then
            allocate(wind(19,nwind))
            wind=0.0d0
          endif

          if (ncrace.gt.0) then
            allocate(crace(17,ncrace))
            crace=0.0d0
          endif

          if (narc.gt.0) then
            allocate(arc(21,narc))
            arc=0.0d0
          endif

          if (ncarc.gt.0) then
            allocate(carc(20,ncarc))
            carc=0.0d0
          endif

          if (nrbar.gt.0) then
            allocate(rectbar(19,nrbar))
            rectbar=0.0d0
          endif

          if (nthwir.gt.0) then
            allocate(thickwire(18,nthwir))
            thickwire=0.0d0
          endif

          do i=1,nlines+1
            backspace(lunbpe)
          enddo

          ncwires=0
          nrace=0
          nwind=0
          ncrace=0
          narc=0
          ncarc=0
          nrbar=0
          nthwir=0
          ncoil=0

          do i=1,nlines+1

            call util_skip_comment_end(lunbpe,ieof)
            read(lunbpe,'(a)')cline

            if (cline.eq.'EndCoils') then
              exit
            else if (cline.eq.'Filaments') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)ncfila
              do k=1,ncfila
                call util_skip_comment_end(lunbpe,ieof)
                read(lunbpe,*)curr,x1,y1,z1,x2,y2,z2,kolor
                if (((x2-x1)**2+(y2-y1)**2+(z2-z1)**2)*curr.ne.0.0d0) then
                  ncwires=ncwires+1
                  wire(1,ncwires)=1
                  wire(2,ncwires)=curr
                  wire(3,ncwires)=x1
                  wire(4,ncwires)=y1
                  wire(5,ncwires)=z1
                  wire(6,ncwires)=x2
                  wire(7,ncwires)=y2
                  wire(8,ncwires)=z2
                  wire(9,ncwires)=kolor
                endif
              enddo
            else if (cline.eq.'RectWindings') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) wind19
              if (wind19(1).ne.0.0d0) then
                nwind=nwind+1
                wind(1,nwind)=wind19(1)
                wind(2:17,nwind)=wind19(4:19)
                wind(18:19,nwind)=wind19(2:3)
              endif
            else if (cline.eq.'Rectangular') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) race17
              if (race17(1).ne.0.0d0) then
                nrace=nrace+1
                race(1:17,nrace)=race17
              endif
            else if (cline.eq.'RectangCirc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) race17
              if (race17(1).ne.0.0d0) then
                ncrace=ncrace+1
                crace(:,ncrace)=race17
              endif
            else if (cline.eq.'RectArc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) arc21(1:12)
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) arc21(13:21)
              if (arc21(1).ne.0.0d0) then
                narc=narc+1
                arc(1:21,narc)=arc21
              endif
            else if (cline.eq.'CircArc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) arc21(1:11)
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) arc21(12:20)
              if (arc21(1).ne.0.0d0) then
                ncarc=ncarc+1
                carc(1:20,ncarc)=arc21(1:20)
              endif
            else if (cline.eq.'RectBar') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)arc21(1:10)
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)arc21(11:19)
              if (arc21(1).ne.0.0d0) then
                nrbar=nrbar+1
                rectbar(1:19,nrbar)=arc21(1:19)
              endif
            else if (cline.eq.'ThickWire') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)arc21(1:9)
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)arc21(10:18)
              if (arc21(1).ne.0.0d0) then
                nthwir=nthwir+1
                thickwire(1:18,nthwir)=arc21(1:18)
              endif
            endif
          enddo !nlines
        endif !nlines

        call undumag_bcoils(0.0d0,0.0d0,0.0d0,bx,by,bz,istat)

        if (ncoil.gt.0) then
          open(newunit=lunfil,file='undumag.fil',status='old')
          do while (.true.)
            call util_skip_comment_end(lunfil,ieof)
            if (ieof.ne.0) exit
            read(lunfil,*) itype,curr,x1,y1,z1,x2,y2,z2,icol,num
            if (x1.lt.xcwmin) xcwmin=x1
            if (x1.gt.xcwmax) xcwmax=x1
            if (x2.lt.xcwmin) xcwmin=x2
            if (x2.gt.xcwmax) xcwmax=x2
          enddo
          close(lunfil)
        endif

      endif !Coils

9977  write(lun6,*)

991   close(lunbpe)

      if (ixsymo.lt.0.or.iysymo.lt.0.or.izsymo.lt.0) then
        call undumag_duplicate_mags
        nmagmax=nmag
        if (ixsymo.lt.0) then
          ixsym=0
          nmoth=2*nmoth
        endif
        if (iysymo.lt.0) then
          iysym=0
          nmoth=2*nmoth
        endif
        if (izsymo.lt.0) then
          izsym=0
          nmoth=2*nmoth
        endif
      else
        bpebc(17,1:nmag)=-9999.0d0
      endif

      do imag=1,nmag
        write(chmoth,'(32a)')chmoths(1:32,imag)
        motho=nint(bpebc(15,imag))
        do kmag=imag+1,nmag
          write(chmoth1,'(32a)')chmoths(1:32,kmag)
          if (chmoth.eq.chmoth1) then
            bpebc(15,kmag)=motho
            mothdiv(1,kmag)=mothdiv(1,imag)
          endif
        enddo
      enddo
c      do imag=1,nmag
c        write(lun6,*)"0 Info:",imag,bpebc(15,imag),chmags(1:32,imag),chmoths(1:32,imag)
c      enddo
      write(lun6,*)"----------------------------------------------------"

      do imag=1,nmag
c center of magnet in lab

        rmag(1)=bpebc(1,imag)
        rmag(2)=bpebc(2,imag)
        rmag(3)=bpebc(3,imag)

c magnetization vector in lab

        vmaglab(1)=bpebc(4,imag)
        vmaglab(2)=bpebc(5,imag)
        vmaglab(3)=bpebc(6,imag)

        bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)

c        write(lun6,*)"imag,rmag:",imag,rmag

        nplan=ibpeplan(imag)
        do iplan=1,nplan

c three points defining plane (lab.-system)

          p1(1)=bpemag(1,1,iplan,imag)
          p1(2)=bpemag(2,1,iplan,imag)
          p1(3)=bpemag(3,1,iplan,imag)

          p2(1)=bpemag(1,2,iplan,imag)
          p2(2)=bpemag(2,2,iplan,imag)
          p2(3)=bpemag(3,2,iplan,imag)

          p3(1)=bpemag(1,3,iplan,imag)
          p3(2)=bpemag(2,3,iplan,imag)
          p3(3)=bpemag(3,3,iplan,imag)

c          write(lun6,*)"imag,iplan,p1:",imag,iplan,p1
c          write(lun6,*)"imag,iplan,p1:",imag,iplan,p2
c          write(lun6,*)"imag,iplan,p1:",imag,iplan,p3

          call undumag_bpen(imag,iplan,p1,p2,p3,vnormlab,ifail)
          if (ifail.ne.0) then
            write(lun6,*)"*** Error 13 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &        imag,iplan
            stop
          endif

c check if normal vector is perpendicular to magnetization vector
c if mag. vector is parallel, skip plane

          if (bc.ne.0.0d0) then
            dum=abs(
     &        (vnormlab(1)*vmaglab(1)+vnormlab(2)*vmaglab(2)+
     &        vnormlab(3)*vmaglab(3))
     &        /bc
     &        )
          else
            dum=0.0d0
          endif

c Removed, since magnetization can change during relaxation
c          if (dum.lt.1.0d-20.and.bpebc(8,imag).ne.-6) then
c            ibpecorn(iplan,imag)=-ibpecorn(iplan,imag)
c          endif

c            bpetm(1,8,iplan,imag)=vnormlab(1)
c            bpetm(2,8,iplan,imag)=vnormlab(2)
c            bpetm(3,8,iplan,imag)=vnormlab(3)
c
c          else

            bpetm(1,7,iplan,imag)=
     &        vmaglab(1)*vnormlab(1)+
     &        vmaglab(2)*vnormlab(2)+
     &        vmaglab(3)*vnormlab(3)
            bpetm(1,8,iplan,imag)=vnormlab(1)
            bpetm(2,8,iplan,imag)=vnormlab(2)
            bpetm(3,8,iplan,imag)=vnormlab(3)

c get matrices ts and tsinv. Ts transforms vnormlab to (0,0,1)

            call undumag_bpet(vnormlab,ts,tsinv)

            if (bpebc(8,imag).eq.-6) then

c for rectangular magnets, we rotate the plans such, that the edges coinside
c with the axis of the coord.-system.

c All planes are rotated to the system of the
c first plane

              if (iplan.eq.1) then
                ts1=ts
                ts1inv=tsinv
              else
                ts=ts1
                tsinv=ts1inv
              endif !(iplan.eq.1)

              do icorn=1,5

                r1lab(1)=bpemag(1,icorn,iplan,imag)
                r1lab(2)=bpemag(2,icorn,iplan,imag)
                r1lab(3)=bpemag(3,icorn,iplan,imag)

                r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
                r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
                r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

                bperot(1,icorn,iplan,imag)=r1(1)
                bperot(2,icorn,iplan,imag)=r1(2)
                bperot(3,icorn,iplan,imag)=r1(3)

              enddo !icorn=1,ncorn

              vx=bperot(1,2,iplan,imag)-bperot(1,1,iplan,imag)
              vy=bperot(2,2,iplan,imag)-bperot(2,1,iplan,imag)
              vn=sqrt(vx*vx+vy*vy)

              sa=vy/vn
              ca=vx/vn

              tz=ts

              ts(1,1)=ca
              ts(1,2)=sa
              ts(1,3)=0.0d0

              ts(2,1)=-sa
              ts(2,2)=ca
              ts(2,3)=0.0d0

              ts(3,1)=0.0d0
              ts(3,2)=0.0d0
              ts(3,3)=1.0d0

c              write(lun6,*)iplan,ca,sa

c              if (iplan.eq.1) then
c                do i=1,3
c                  write(lun6,*)"vorher:",tz(i,1:3)
c                enddo
c              endif
              call util_matrix_multiplication(3,3,3,ts,tz,ts,ws)

              do i=1,3
                do j=1,3
                  tsinv(i,j)=ts(j,i)
                enddo
              enddo

            endif ! if (bpebc(8,imag).eq.-6)

            do i=1,3
              do j=1,3
                bpetm(i,j,iplan,imag)=ts(i,j)
                bpetm(i,j+3,iplan,imag)=tsinv(i,j)
              enddo
c              if (iplan.eq.1) then
c                write(lun6,*)"nachher:",ts(i,1:3)
c              endif
            enddo

c          endif !check if normal vector is perpendicular to magnetization vector

c            write(lun6,*)imag,iplan,bpetm(1,7,iplan,imag)
c            write(lun6,*)imag,iplan,bpetm(1:3,8,iplan,imag)

        enddo !iplan

      enddo !imag

c      write(lun6,*)"Ende"
c      stop
!debug
+self,if=debug.
      do imag=1,nmag
        do iplan=1,ibpeplan(imag)
          do icorn=1,ibpecorn(iplan,imag)
            write(99,*)imag,iplan,icorn,
     &        bpemag(1:3,icorn,iplan,imag)
          enddo
        enddo
      enddo
      write(lun6,*) "fort.99!"
+self.,if=debug.
      do imag=1,nmag

c check, if all flanges appear twice, i.e. volume is closed

        iwarn=0
        nflange=0
        nplan=ibpeplan(imag)
        if (kudebug.eq.9) then
          if(imag.eq.1) then
            open(unit=99,file="debug_edges.dat")
          else
            open(unit=99,file="debug_edges.dat",access="append")
          endif
        endif

        do iplan=1,nplan
          ncorn=ibpecorn(iplan,imag)-1
          if (kudebug.eq.9) then
            write(lun6,*)"imag,nplan,ncorn",imag,nplan,ncorn
          endif
          do icorn=1,ncorn
            nflange=nflange+1
            ip1=icorn
            ip2=ip1+1
            bflange(1,nflange)=bpemag(1,ip1,iplan,imag)
            bflange(2,nflange)=bpemag(2,ip1,iplan,imag)
            bflange(3,nflange)=bpemag(3,ip1,iplan,imag)
            bflange(4,nflange)=bpemag(1,ip2,iplan,imag)
            bflange(5,nflange)=bpemag(2,ip2,iplan,imag)
            bflange(6,nflange)=bpemag(3,ip2,iplan,imag)
            if (kudebug.eq.9) then
              write(lun6,*)"iedge, i1, i2:",nflange,ip1,ip2
              write(lun6,*)"x1,y1,z1:",bflange(1:3,nflange)
              write(lun6,*)"x2,y2,z2:",bflange(4:6,nflange)
              write(99,*)imag,iplan,nflange,ip1,ip2,bflange(1:6,nflange)
            endif
          enddo ! icorn
        enddo !iplan
        if (kudebug.eq.9) then
          close(99)
        endif

        do iflange=1,nflange
          bflange(7,iflange)=1.0d0
        enddo

        rtiny=sqrt((xmax-xmin)**2+(ymax-ymin)**2+(zmax-zmin)**2)*1.0d-12

        do iflange=1,nflange

          do i=iflange+1,nflange

            if (
     &          abs(bflange(1,i)-bflange(1,iflange)).lt.rtiny .and.
     &          abs(bflange(2,i)-bflange(2,iflange)).lt.rtiny .and.
     &          abs(bflange(3,i)-bflange(3,iflange)).lt.rtiny .and.
     &          abs(bflange(4,i)-bflange(4,iflange)).lt.rtiny .and.
     &          abs(bflange(5,i)-bflange(5,iflange)).lt.rtiny .and.
     &          abs(bflange(6,i)-bflange(6,iflange)).lt.rtiny
     &          .or.
     &          abs(bflange(4,i)-bflange(1,iflange)).lt.rtiny .and.
     &          abs(bflange(5,i)-bflange(2,iflange)).lt.rtiny .and.
     &          abs(bflange(6,i)-bflange(3,iflange)).lt.rtiny .and.
     &          abs(bflange(1,i)-bflange(4,iflange)).lt.rtiny .and.
     &          abs(bflange(2,i)-bflange(5,iflange)).lt.rtiny .and.
     &          abs(bflange(3,i)-bflange(6,iflange)).lt.rtiny
     &          ) then

              bflange(7,iflange)=bflange(7,iflange)+1.0d0
              bflange(7,i)=bflange(7,i)+1.0d0

            endif !hit

          enddo !i

          if (bflange(7,iflange).ne.2.0d0.and.iwarn.eq.0
     &        .and.bpebc(7,imag).ne.0.0d0.and.bpebc(9,imag).ne.0) then
c            iwarn=1
            write(lun6,*)
     &        '*** Error in undumag_ini_old: Magnet ',chmoths(1:32,imag),' is not a closed volume'
            write(lun6,*)'magnet, edge, hits: ',imag,iflange,bflange(7,iflange)
            write(lun6,*)
            stop
          endif

        enddo !iflange

c center of gravity is a point inside the magnet since shape is convex

        x0=0.0d0
        y0=0.0d0
        z0=0.0d0

        i=0
        do iplan=1,ibpeplan(imag)
          do icorn=1,ibpecorn(iplan,imag)-1
            i=i+1
            x0=x0+bpemag(1,icorn,iplan,imag)
            y0=y0+bpemag(2,icorn,iplan,imag)
            z0=z0+bpemag(3,icorn,iplan,imag)
c            write(lun6,*)iplan,icorn,sngl(bpemag(1:3,icorn,iplan,imag))
          enddo ! icorn
        enddo !iplan

        x0=x0/i
        y0=y0/i
        z0=z0/i

c        write(lun6,*)"imag,x0,y0,z0",imag,x0,y0,z0

        do iplan=1,ibpeplan(imag)

          vnormlab(1)=bpetm(1,8,iplan,imag)
          vnormlab(2)=bpetm(2,8,iplan,imag)
          vnormlab(3)=bpetm(3,8,iplan,imag)

c does normal vector point outside?

          vsx=bpemag(1,1,iplan,imag)-x0
          vsy=bpemag(2,1,iplan,imag)-y0
          vsz=bpemag(3,1,iplan,imag)-z0

c          write(lun6,*)iplan
c          write(lun6,*)vnormlab
c          write(lun6,*)vsx,vsy,vsz

          if ( vsx*vnormlab(1) + vsy*vnormlab(2) + vsz*vnormlab(3)
     &        .lt. 0.0d0 ) then
            write(lun6,*)
            write(lun6,*)
     &        '*** Error in undumag_ini_old: Normal vector is not pointing outside'
            write(lun6,*)'magnet, plane: ',imag,iplan
            write(lun6,*)
c            stop
          endif

          do icorn=3,ibpecorn(iplan,imag)-1

            ip1=icorn-2
            ip2=icorn-1

            v1x=bpemag(1,ip2,iplan,imag)-bpemag(1,ip1,iplan,imag)
            v1y=bpemag(2,ip2,iplan,imag)-bpemag(2,ip1,iplan,imag)
            v1z=bpemag(3,ip2,iplan,imag)-bpemag(3,ip1,iplan,imag)

            v2x=bpemag(1,icorn,iplan,imag)-bpemag(1,ip2,iplan,imag)
            v2y=bpemag(2,icorn,iplan,imag)-bpemag(2,ip2,iplan,imag)
            v2z=bpemag(3,icorn,iplan,imag)-bpemag(3,ip2,iplan,imag)

            vsx=v1y*v2z-v1z*v2y
            vsy=v1z*v2x-v1x*v2z
            vsz=v1x*v2y-v1y*v2x

            if ( abs(v2x*vnormlab(1)+ v2y*vnormlab(2)+ v2z*vnormlab(3))
     &          .gt.tiny ) then
              write(lun6,*)
              write(lun6,*)'*** Error in undumag_ini_old: Points not in a plane'
              write(lun6,*)'magnet, plane, point: ',imag,iplan,icorn
              write(lun6,*)
              stop
            endif

            if ( vsx*vnormlab(1) + vsy*vnormlab(2) + vsz*vnormlab(3)
     &          .lt. 0.0d0 ) then
              write(lun6,*)
              write(lun6,*)'*** Error in undumag_ini_old: Direction of rotation not unique'
              write(lun6,*)'magnet, plane, point ',imag,iplan,icorn
              write(lun6,*)
              stop
            endif

          enddo !icorn=1,ncorn

        enddo ! iplan=1,nplan

      enddo ! imag=1,nmag

c transform everything to the nz=(0,0,1) system

      do imag=1,nmag

        qsign=0.0d0

        do iplan=1,ibpeplan(imag)

c          if (ibpecorn(iplan,imag).gt.0) then

            do i=1,3
              do j=1,3
                ts(i,j)=bpetm(i,j,iplan,imag)
              enddo
            enddo

            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

            do icorn=1,ibpecorn(iplan,imag)

              r1lab(1)=bpemag(1,icorn,iplan,imag)
              r1lab(2)=bpemag(2,icorn,iplan,imag)
              r1lab(3)=bpemag(3,icorn,iplan,imag)

              r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
              r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
              r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

              bperot(1,icorn,iplan,imag)=r1(1)
              bperot(2,icorn,iplan,imag)=r1(2)
              bperot(3,icorn,iplan,imag)=r1(3)

            enddo !icorn=1,ncorn

            do icorn=1,ibpecorn(iplan,imag)-1

              ip2=icorn+1

              r1(1)=bperot(1,icorn,iplan,imag)
              r1(2)=bperot(2,icorn,iplan,imag)
              r1(3)=bperot(3,icorn,iplan,imag)

              r2(1)=bperot(1,ip2,iplan,imag)
              r2(2)=bperot(2,ip2,iplan,imag)
              r2(3)=bperot(3,ip2,iplan,imag)

c              write(lun6,*)imag,iplan,icorn,r1(1)-r2(1)
c              if (abs(r1(1)-r2(1)).gt.tiny) then
              if (r1(1)-r2(1).ne.0.0d0) then

                a=(r2(2)-r1(2))/(r2(1)-r1(1))
                b=r1(2)-a*r1(1)

              else

                a=0.0d0
                b=r1(2)

              endif !(abs(r1(1)-r2(1)).gt.tiny)

              q=-((a*r1(1)+ a*r2(1) + 2*b)*(r1(1) - r2(1)))/2.d0

              qsign=qsign+q*(
     &           vnormlab(1)*bpebc(4,imag)
     &          +vnormlab(2)*bpebc(5,imag)
     &          +vnormlab(3)*bpebc(6,imag))

            enddo ! icorn

c          endif !(ibpecorn(iplan,imag).gt.0) then

        enddo ! iplan=1,nplan

        if (abs(qsign/bpebc(7,imag)).gt.1.d-9.and.bpebc(8,imag).ne.-6) then
c not checked for rectangular magnets since ibpecorn not negative for
c planes with normal vector parallel to surface. Then they are not skipped
c for while calculation qsign
          write(lun6,*)
          write(lun6,*)
     &      '*** Error in undumag_ini_old: Sum of magnetic charge not zero ***'
          write(lun6,*)'magnet: ',imag
          write(lun6,*)
          stop
        endif

      enddo ! imag=1,nmag

c Check if all magnets are zero

      nmag=0
      do imag=1,nmagmax
        if (bpebc(7,imag).ne.0.0d0) then
          nmag=nmagmax
          goto 109
        endif
      enddo

109   continue

      nmagmax=nmag

      if (nmatfiles.le.0.and.nmag.gt.0) then
        write(lun6,*)"*** Error in undumag_ini_old: No data files for materials found ***"
        stop
      endif

      allocate(bcrec(20,nmagmax))
      allocate(ibpeplanrec(nmagmax))
      allocate(ibpecolrec(nmagmax))
      allocate(ibpecornrec(nplanmax,nmagmax))
      allocate(bmagrec(3,ncornmax,nplanmax,nmagmax))
      allocate(brotrec(3,ncornmax,nplanmax,nmagmax))
      allocate(bpetmrec(3,8,nplanmax,nmagmax))

      allocate(bciron(20,nmagmax),bc0rec(7,nmagmax),bc0iron(7,nmagmax))
      allocate(ibpeplaniron(nmagmax))
      allocate(ibpecoliron(nmagmax))
      allocate(ibpecorniron(nplanmax,nmagmax))
      allocate(bmagiron(3,ncornmax,nplanmax,nmagmax))
      allocate(brotiron(3,ncornmax,nplanmax,nmagmax))
      allocate(bpetmiron(3,8,nplanmax,nmagmax))

      nrec=0
      niron=0

      if (irecrepl.eq.0) goto 666

      do imag=1,nmag

        if (bpebc(8,imag).ne.-6.and.ibpeplan(imag).eq.6) then

          ix1=0
          ix2=0
          iy1=0
          iy2=0
          iz1=0
          iz2=0

          do iplan=1,nplan

            ncorn=ibpecorn(iplan,imag)
            if (ncorn.ne.5) exit

c            write(lun6,*)imag,iplan,bpemag(3,1:5,iplan,imag)
            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

c            write(lun6,*)imag,vnormlab

            if (vnormlab(1).lt.-0.999999d0) then
              ix2=ix2+1
              xxmin=bpemag(1,1,iplan,imag)
            else if (vnormlab(1).gt.0.999999d0) then
              ix1=ix1+1
              xxmax=bpemag(1,1,iplan,imag)
            else if (vnormlab(2).lt.-0.999999d0) then
              iy2=iy2+1
              yymin=bpemag(2,1,iplan,imag)
            else if (vnormlab(2).gt.0.999999d0) then
              iy1=iy1+1
              yymax=bpemag(2,1,iplan,imag)
            else if (vnormlab(3).lt.-0.999999d0) then
              iz2=iz2+1
              zzmin=bpemag(3,1,iplan,imag)
            else if (vnormlab(3).gt.0.999999d0) then
              iz1=iz1+1
              zzmax=bpemag(3,1,iplan,imag)
            endif
          enddo

          if (
     &      ix1.ne.1.or.ix2.ne.1.or.
     &      iy1.ne.1.or.iy2.ne.1.or.
     &      iz1.ne.1.or.iz2.ne.1) cycle

          xcen=(xxmax+xxmin)/2.0d0
          ycen=(yymax+yymin)/2.0d0
          zcen=(zzmax+zzmin)/2.0d0

          bpebc(1,imag)=xcen
          bpebc(2,imag)=ycen
          bpebc(3,imag)=zcen

          bpebc(8,imag)=-6

          dx=xxmax-xxmin
          dy=yymax-yymin
          dz=zzmax-zzmin

          iplan=1
          ibpecorn(iplan,imag)=5
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=2
          ibpecorn(iplan,imag)=5
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=3
          ibpecorn(iplan,imag)=5
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=4
          ibpecorn(iplan,imag)=5
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=5
          ibpecorn(iplan,imag)=5
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=6
          ibpecorn(iplan,imag)=5
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0

          do iplan=1,6
            bpemag(1,5,iplan,imag)=bpemag(1,1,iplan,imag)
            bpemag(2,5,iplan,imag)=bpemag(2,1,iplan,imag)
            bpemag(3,5,iplan,imag)=bpemag(3,1,iplan,imag)
          enddo !iplan

c center of magnet in lab

          rmag(1)=bpebc(1,imag)
          rmag(2)=bpebc(2,imag)
          rmag(3)=bpebc(3,imag)

c magnetization vector in lab

          vmaglab(1)=bpebc(4,imag)
          vmaglab(2)=bpebc(5,imag)
          vmaglab(3)=bpebc(6,imag)

          bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)

c        write(lun6,*)"imag,rmag:",imag,rmag

          do iplan=1,ibpeplan(imag)

c three points defining plane (lab.-system)

c          write(lun6,*)"imag,iplan,p1:",imag,iplan,p1

            p1(1)=bpemag(1,1,iplan,imag)
            p1(2)=bpemag(2,1,iplan,imag)
            p1(3)=bpemag(3,1,iplan,imag)

            p2(1)=bpemag(1,2,iplan,imag)
            p2(2)=bpemag(2,2,iplan,imag)
            p2(3)=bpemag(3,2,iplan,imag)

            p3(1)=bpemag(1,3,iplan,imag)
            p3(2)=bpemag(2,3,iplan,imag)
            p3(3)=bpemag(3,3,iplan,imag)

            call undumag_bpen(imag,iplan,p1,p2,p3,vnormlab,ifail)

            if (ifail.ne.0) then
              write(lun6,*)"*** Error 13 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &          imag,iplan
              stop
            endif

c check if normal vector is perpendicular to magnetization vector
c if mag. vector is parallel, skip plane

            if (bc.ne.0.0d0) then
              dum=abs(
     &          (vnormlab(1)*vmaglab(1)+vnormlab(2)*vmaglab(2)+
     &          vnormlab(3)*vmaglab(3))
     &          /bc
     &          )
            else
              dum=0.0d0
            endif

            bpetm(1,7,iplan,imag)=
     &        vmaglab(1)*vnormlab(1)+
     &        vmaglab(2)*vnormlab(2)+
     &        vmaglab(3)*vnormlab(3)

            bpetm(1,8,iplan,imag)=vnormlab(1)
            bpetm(2,8,iplan,imag)=vnormlab(2)
            bpetm(3,8,iplan,imag)=vnormlab(3)

c get matrices ts and tsinv

            call undumag_bpet(vnormlab,ts,tsinv)

c for rectangular magnets, we rotate plan such, that the flanges coinside with
c the axis of the coord.-system.

c All planes are rotated to the system of the
c first plane

            if (iplan.eq.1) then
              ts1=ts
              ts1inv=tsinv
            else
              ts=ts1
              tsinv=ts1inv
            endif !(iplan.eq.1)

            do icorn=1,5

              r1lab(1)=bpemag(1,icorn,iplan,imag)
              r1lab(2)=bpemag(2,icorn,iplan,imag)
              r1lab(3)=bpemag(3,icorn,iplan,imag)

              r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
              r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
              r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

              bperot(1,icorn,iplan,imag)=r1(1)
              bperot(2,icorn,iplan,imag)=r1(2)
              bperot(3,icorn,iplan,imag)=r1(3)

            enddo !icorn=1,ncorn

            vx=bperot(1,2,iplan,imag)-bperot(1,1,iplan,imag)
            vy=bperot(2,2,iplan,imag)-bperot(2,1,iplan,imag)
            vn=sqrt(vx*vx+vy*vy)

            sa=vy/vn
            ca=vx/vn

            tz=ts

            ts(1,1)=ca
            ts(1,2)=sa
            ts(1,3)=0.0d0

            ts(2,1)=-sa
            ts(2,2)=ca
            ts(2,3)=0.0d0

            ts(3,1)=0.0d0
            ts(3,2)=0.0d0
            ts(3,3)=1.0d0

            call util_matrix_multiplication(3,3,3,ts,tz,ts,ws)

            do i=1,3
              do j=1,3
                tsinv(i,j)=ts(j,i)
              enddo
            enddo

            do i=1,3
              do j=1,3
                bpetm(i,j,iplan,imag)=ts(i,j)
                bpetm(i,j+3,iplan,imag)=tsinv(i,j)
              enddo
            enddo

          enddo !iplan

        endif !(bpebc(8,imag).ne.-6.and.ibpeplan(imag).eq.6) then

      enddo !imag

chier
666   continue

      if (killbadmag.eq.-9999) then
        bpebc(16,1:nmag)=1.0d0
      else
        bpebc(16,1:nmag)=0.0d0
      endif

      if (killbadmag.gt.0.or.killbadmag.eq.-9999) then
        write(lun6,*)
        write(lun6,*)"Killing all voxel, but"
        open(newunit=lunkill,file="undumag.kll")
        do while (.true.)
          call util_read_line(lunkill,cline,last)
          if (last.le.0) exit
          read(cline,*)kmag,kill
          if (kmag.gt.nmag) then
            write(lun6,*)"*** Error in undumag_proc: Non existing magnet ",kmag," on undumag.kll ***"
            stop
          endif
          if (killbadmag.ne.-9999) then
            bpebc(16,kmag)=kill
            write(lun6,*)"Killing magnet ",kmag," due to flag killbadmag"
          else
            write(lun6,*)kmag
            bpebc(16,kmag)=0.0d0
          endif
        enddo
        close(lunkill)
        write(lun6,*)
      endif

      do imag=1,nmag

        mat=nint(bpebc(9,imag))

c        if (mat.lt.0) then
c          mat=nint(bcpre(2,1,-mat))
c        endif

        if (mat.eq.0) goto 9 !skip

        if (mat.gt.nmatfiles) then
          write(lun6,*)"*** Warning in undumag_proc: Material index out of range ***"
          write(lun6,*)"Skipping magnet",imag
          iwarnsum=1
          goto 9
        endif

        lmat=matmaps(2,mat)
        bn=sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)

        if ((killbadmag.gt.0.or.killbadmag.eq.-9999).and.bpebc(16,imag).ne.0.0d0) then
          lmat=0
        endif

        if (lmat.eq.1) then
          if (bn.ne.0.0d0.and.bpebc(9,imag).ne.0.0d0) then
            if (bpebc(17,imag).ne.0.0d0.and.bpebc(17,imag).ne.-9999.0d0) cycle
            nrec=nrec+1
            bcrec(1:20,nrec)=bpebc(1:20,imag)
            bc0rec(1:3,nrec)=bpebc0(1:3,imag)
            chmagsm(1:32,nrec)=chmags(1:32,imag)
            chmothsm(1:32,nrec)=chmoths(1:32,imag)
            bmagrec(1:3,1:ncornmax,1:nplanmax,nrec)=
     &        bpemag(1:3,1:ncornmax,1:nplanmax,imag)
            brotrec(1:3,1:ncornmax,1:nplanmax,nrec)=
     &        bperot(1:3,1:ncornmax,1:nplanmax,imag)
            bpetmrec(1:3,1:8,1:nplanmax,nrec)=
     &        bpetm(1:3,1:8,1:nplanmax,imag)
            ibpeplanrec(nrec)=ibpeplan(imag)
            ibpecolrec(nrec)=ibpecol(imag)
            ibpecornrec(1:nplanmax,nrec)=ibpecorn(1:nplanmax,imag)
          endif !bn
        else if (lmat.eq.2) then
          if (bpebc(17,imag).ne.0.0d0.and.bpebc(17,imag).ne.-9999.0d0) cycle
          niron=niron+1
          bciron(1:20,niron)=bpebc(1:20,imag)
          bc0iron(1:7,niron)=bpebc0(1:7,imag)
          chmagsi(1:32,niron)=chmags(1:32,imag)
          chmothsi(1:32,niron)=chmoths(1:32,imag)
          bmagiron(1:3,1:ncornmax,1:nplanmax,niron)=
     &      bpemag(1:3,1:ncornmax,1:nplanmax,imag)
          brotiron(1:3,1:ncornmax,1:nplanmax,niron)=
     &      bperot(1:3,1:ncornmax,1:nplanmax,imag)
          bpetmiron(1:3,1:8,1:nplanmax,niron)=
     &      bpetm(1:3,1:8,1:nplanmax,imag)
          ibpeplaniron(niron)=ibpeplan(imag)
          ibpecoliron(niron)=ibpecol(imag)
          ibpecorniron(1:nplanmax,niron)=
     &      ibpecorn(1:nplanmax,imag)
        else if (lmat.ne.0) then
          write(lun6,*)
     &      "*** Error in undumag_ini_old: Unknown material index",lmat
          stop
        endif
 9    continue

      enddo !nmag

      if (nmag.gt.nspecmag) deallocate(bpemag0)
      deallocate(shuffle)

      deallocate(idamp8,bpebc,bpemag,bperot,bpetm,ibpeplan,ibpecorn,ibpecol)

      nmag=nrec+niron
      nsmag=nmag

      allocate(bpebc(20,nsmag),idamp8(nsmag))
      bpebc=0.0d0
      allocate(bpemag(3,ncornmax,nplanmax,nsmag))
      allocate(bperot(3,ncornmax,nplanmax,nsmag))
      allocate(bpetm(3,8,nplanmax,nsmag))
      allocate(ibpeplan(nsmag))
      allocate(ibpecol(nsmag))
      allocate(ibpecorn(nplanmax,nsmag))

      bpebc(1:20,1:nrec)=bcrec(1:20,1:nrec)
      bpebc0(1:3,1:nrec)=bc0rec(1:3,1:nrec)
      chmags(1:32,1:nrec)=chmagsm(1:32,1:nrec)
      chmoths(1:32,1:nrec)=chmothsm(1:32,1:nrec)
      bpemag(1:3,1:ncornmax,1:nplanmax,1:nrec)=
     &  bmagrec(1:3,1:ncornmax,1:nplanmax,1:nrec)
      bperot(1:3,1:ncornmax,1:nplanmax,1:nrec)=
     &  brotrec(1:3,1:ncornmax,1:nplanmax,1:nrec)
      bpetm(1:3,1:8,1:nplanmax,1:nrec)=
     &  bpetmrec(1:3,1:8,1:nplanmax,1:nrec)
      ibpeplan(1:nrec)=ibpeplanrec(1:nrec)
      ibpecol(1:nrec)=ibpecolrec(1:nrec)
      ibpecorn(1:nplanmax,1:nrec)=ibpecornrec(1:nplanmax,1:nrec)

      if (niron.gt.0) then

        iron1=nrec+1
        iron2=nrec+niron

        bpebc(1:20,iron1:iron2)=bciron(1:20,1:niron)

        bpebc0(1:3,iron1:iron2)=bc0iron(1:3,1:niron)
        chmags(1:32,iron1:iron2)=chmagsi(1:32,1:niron)
        chmoths(1:32,iron1:iron2)=chmothsi(1:32,1:niron)
        bpemag(1:3,1:ncornmax,1:nplanmax,iron1:iron2)=
     &    bmagiron(1:3,1:ncornmax,1:nplanmax,1:niron)
        bperot(1:3,1:ncornmax,1:nplanmax,iron1:iron2)=
     &    brotiron(1:3,1:ncornmax,1:nplanmax,1:niron)
        bpetm(1:3,1:8,1:nplanmax,iron1:iron2)=
     &    bpetmiron(1:3,1:8,1:nplanmax,1:niron)
        ibpeplan(iron1:iron2)=ibpeplaniron(1:niron)
        ibpecorn(1:nplanmax,iron1:iron2)=ibpecorniron(1:nplanmax,1:niron)

        bpebc(1:10,iron2+1:nmag)=0.0d0
        bpemag(1:3,1:ncornmax,1:nplanmax,iron2+1:nmag)=0.0d0
        bperot(1:3,1:ncornmax,1:nplanmax,iron2+1:nmag)=0.0d0
        bpetm(1:3,1:8,1:nplanmax,iron2+1:nmag)=0.0d0
        ibpeplan(iron2+1:nmag)=0
        ibpecorn(1:nplanmax,iron2+1:nmag)=0
        ibpecol(iron1:iron2)=ibpecoliron(1:niron)
        ibpecol(iron2+1:nmag)=0

      endif !iron

      kmag=0
      npol=0
      do imoth=1,nmoth
        if (matmoth(imoth).eq.1) then
          kmag=kmag+1
          xmothm(1:maxpoints,kmag)=xmoth(1:maxpoints,imoth)
          ymothm(1:maxpoints,kmag)=ymoth(1:maxpoints,imoth)
          zmothm(1:maxpoints,kmag)=zmoth(1:maxpoints,imoth)
          npmothm(kmag)=npmoth(imoth)
          matmothm(kmag)=matmoth(imoth)
          ncolmothm(kmag)=ncolmoth(imoth)
        else if (matmoth(imoth).eq.2) then
          npol=npol+1
          xmothi(1:maxpoints,npol)=xmoth(1:maxpoints,imoth)
          ymothi(1:maxpoints,npol)=ymoth(1:maxpoints,imoth)
          zmothi(1:maxpoints,npol)=zmoth(1:maxpoints,imoth)
          npmothi(npol)=npmoth(imoth)
          matmothi(npol)=matmoth(imoth)
          ncolmothi(npol)=ncolmoth(imoth)
        endif
      enddo

      xmoth(1:maxpoints,1:kmag)=xmothm(1:maxpoints,1:kmag)
      ymoth(1:maxpoints,1:kmag)=ymothm(1:maxpoints,1:kmag)
      zmoth(1:maxpoints,1:kmag)=zmothm(1:maxpoints,1:kmag)
      npmoth(1:kmag)=npmothm(1:kmag)
      matmoth(1:kmag)=matmothm(1:kmag)
      ncolmoth(1:kmag)=ncolmothm(1:kmag)

      xmoth(1:maxpoints,kmag+1:kmag+npol)=xmothi(1:maxpoints,1:npol)
      ymoth(1:maxpoints,kmag+1:kmag+npol)=ymothi(1:maxpoints,1:npol)
      zmoth(1:maxpoints,kmag+1:kmag+npol)=zmothi(1:maxpoints,1:npol)
      npmoth(kmag+1:kmag+npol)=npmothi(1:npol)
      matmoth(kmag+1:kmag+npol)=matmothi(1:npol)
      ncolmoth(kmag+1:kmag+npol)=ncolmothi(1:npol)

      dx0=dx

      xmaxinf = xmax

      xmin=1.0d30
      xmax=-1.0d30
      do imag=1,nmag
        if (bpebc(9,imag).ne.0) then
          do iplan=1,ibpeplan(imag)
            do icorn=1,ibpecorn(iplan,imag)
              vcorn(1)=bpemag(1,icorn,iplan,imag)
              if (vcorn(1).lt.xmin) xmin=vcorn(1)
              if (vcorn(1).gt.xmax) xmax=vcorn(1)
            enddo !icorn
          enddo !iplan
        endif

        if (kpreset.eq.0) then
          bpebc(11:14,imag)=bpebc(4:7,imag)
          bpebc(11:13,imag)=bpebc(11:13,imag)/bpebc(14,imag)
        endif

      enddo !imag

      xmin = min(xmin,xcwmin)
      xmax = max(xmax,xcwmax)

      if (kxcenter.ne.0) then

        if (ixsym.eq.0) then
          dx=xcenter-(xmax+xmin)/2.0d0
        else
          dx=xcenter-xsymmm
        endif

        xmin=xmin+dx
        xmax=xmax+dx

        dxfb=dx
        if (iforce.ne.9999) then
          ubfcenx=ubfcenx+dx
          bfcenxmm=ubfcenx
          utorqcenx=utorqcenx+dx
          if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
          bfcenx=ubfcenx/1000.0d0
          torqcenxmm=utorqcenx
          torqcenx=utorqcenx/1000.0d0
        endif

        forxpl=forxpl+dx

        xcentershift=dx

        write(lun6,*)
        write(lun6,*) "xcenter, shift:",xcenter,dx
        write(lun6,*)

        do moth=1,nmoth
          xmoth(1:npmoth(moth),moth)=xmoth(1:npmoth(moth),moth)+dx
        enddo

        do imag=1,nmag
          bpebc(1,imag)=bpebc(1,imag)+dx
          do iplan=1,ibpeplan(imag)

            do i=1,3
              do j=1,3
                ts(i,j)=bpetm(i,j,iplan,imag)
              enddo
            enddo

            do icorn=1,ibpecorn(iplan,imag)

              bpemag(1,icorn,iplan,imag)=bpemag(1,icorn,iplan,imag)+dx

              r1lab(1)=bpemag(1,icorn,iplan,imag)
              r1lab(2)=bpemag(2,icorn,iplan,imag)
              r1lab(3)=bpemag(3,icorn,iplan,imag)

              r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
              r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
              r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

              bperot(1,icorn,iplan,imag)=r1(1)
              bperot(2,icorn,iplan,imag)=r1(2)
              bperot(3,icorn,iplan,imag)=r1(3)

            enddo !icorn
          enddo !iplan
        enddo !imag

      endif !kxcenter.ne.0

      g=0.0

      if (nmag.eq.0.or.(nxconv.eq.0.and.dxconv.eq.0.0d0)) then
        nxconv=1
        xconv(1)=0.0d0
        goto 1234
      endif

      nxconv=abs(nxconv)

      if (xconvmin.eq.9999.0d0) then
        xconvmin=xmin+mod(xmin,perlen)-1.0d0*perlen
        if (xconvmin.gt.xcwmin) xconvmin=xcwmin
      endif !(xconvmin.eq.9999.0d0) then

      if (xconvmax.eq.9999.0d0) then
        if (kxcenter.ne.0) then
          xconvmax=xcenter
        else
          xconvmax=xmax-mod(xmax,perlen)+2.0d0*perlen
        endif
        if (xconvmax.lt.xcwmax) xconvmax=xcwmax
      endif !(xconvmax.eq.9999.0d0) then

      if (xconvmax.le.xconvmin) xconvmin=xconvmax-perlen/2.0d0

      if (nxconv.eq.9999) then
        nxconv=(xconvmax-xconvmin)/perlen*2+1
      endif

      if (dxconv.eq.9999.0d0) dxconv=perlen/2.0d0

      if (abs(dxconv).gt.0.0d0) then
        nxconv=(xconvmax-xconvmin)/dxconv+1
        if (nxconv.gt.100) then
          write(lun6,*)"*** Warning in undmag_ini: dxconv changed to limit nxconv to 100 ***"
          nxconv=100
        endif
        dxconv=(xconvmax-xconvmin)/max(1,nxconv-1)
      else
        if (nxconv.gt.100) then
          write(lun6,*)"*** Warning in undmag_ini: nxconv limited to 100 ***"
          nxconv=100
        endif
        dxconv=(xconvmax-xconvmin)/max(1,nxconv-1)
      endif

      if (dxconv.lt.0.0d0) then
        dxcon(1)=0.0d0
        dx=1.0d0
        do i=2,nxconv
          dxcon(i)=dxcon(i-1) + dx
          dx=dx*abs(dxconv)
        enddo
        xlen=dxcon(nxconv)
        do i=2,nxconv
          xconv(i)=xconv(i-1) + (dxcon(i)-dxcon(i-1))*(xconvmax-xconvmin)/xlen
        enddo
      else
        do i=1,nxconv
          xconv(i)=xconvmin+dxconv*(i-1)
        enddo
      endif !(dxconv.lt.0.0d0) then

      do i=1,nxconv
        ! to avoid boundary effects:
        call util_random(2,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        xconv(i)=(xconv(i)+g(1)*randoxa)/1000.0d0
      enddo

      yconv=yconv/1000.0d0

      if (abs(g(2)).lt.randoz10) then
        if (g(2).gt.0.0d0) then
          g(2)=g(2)+randoz10
        else
          g(2)=g(2)-randoz10
        endif
      endif

      if (zconv.eq.0.0d0) then
        if (randoza.gt.0.0d0) then
          zconv=(zconv+g(2)*randoza)/1000.0d0
        else
          zconv=(zconv+randoza)/1000.0d0
        endif
      else
        zconv=zconv/1000.0d0
      endif

1234  continue

      nspecmag=0
      do imag=1,nmag
        if (bpebc(10,imag).ne.0) then
          nspecmag=nspecmag+1
        endif
      enddo

      if (nspecmag.gt.0) then
        allocate(kspecmag(nspecmag))
        nspecmag=0
        do imag=1,nmag
          if (bpebc(10,imag).ne.0) then
            nspecmag=nspecmag+1
            kspecmag(nspecmag)=imag
          endif
        enddo
      endif

c      xmin=xmin-dx0
c      xmax=xmax+dx0

      deallocate(ibpecornrec)
      deallocate(ibpeplanrec)
      deallocate(bpetmrec)
      deallocate(brotrec)
      deallocate(bmagrec)
      deallocate(bcrec)
      deallocate(ibpecolrec)

      deallocate(ibpecorniron)
      deallocate(ibpeplaniron)
      deallocate(bpetmiron)
      deallocate(brotiron)
      deallocate(bmagiron)
      deallocate(bciron,bc0rec,bc0iron)
      deallocate(ibpecoliron)

      if (ixsym.gt.0) then
        if (xmin.lt.xsymmm-tiny2.and.xmax.gt.xsymmm+tiny2) then
          write(lun6,*)"*** Error in input: Option ixsym is set, but not all x-values are on the same side of xsymm!"
          write(lun6,*)"*** Program undumag aborted ***"
          stop
        endif
        dx=xsymmm-xmin
        xmax=xsymmm+dx
        xsym=xsymmm/1000.0d0
      endif

      if (iysym.gt.0) then
        if (ymin.lt.-tiny2.and.ymax.gt.tiny2) then
          write(lun6,*)"*** Error in input: Option iysym is set, but not all y-values have the same sign!"
          if (iysymo.gt.0) then
            write(lun6,*)"*** Program undumag aborted ***"
            stop
          endif
        endif
        ymax=max(abs(ymax),abs(ymin))
        ymin=-ymax
      endif

      if (izsym.ne.0) then
        if (zmin.lt.-tiny2.and.zmax.gt.tiny2) then
          if (izsymo.gt.0) then
            write(lun6,*)"*** Error in input: Option izsym is set, but not all z-values have the same sign!"
            write(lun6,*)"*** Program undumag aborted ***"
            stop
          else if (izsymo.lt.0) then
            write(lun6,*)"*** Warning in input: Option izsym is set, but not all z-values have the same sign!"
          endif
        endif
        zmax=max(abs(zmax),abs(zmin))
        zmin=-zmax
      endif

      do imag=1,nmag

c        write(lun6,*)"1 Info:",imag,bpebc(15,imag),chmags(1:32,imag),chmoths(1:32,imag)
        write(chmoth,'(32a)')chmoths(1:32,imag)

        if (kdisplace.ne.0) then
          do idisp=1,ndisp
            if (chmoth.eq.chdisp(idisp)) then

              cosphi=cos(displace(6,idisp))
              sinphi=sin(displace(6,idisp))

              bpebc(1:3,imag)=bpebc(1:3,imag)+displace(1:3,idisp)

              y00=bpebc(2,imag)-displace(4,idisp)
              z00=bpebc(3,imag)-displace(5,idisp)
              bpebc(2,imag)= -sinphi*z00 + cosphi*y00
     &              +displace(4,idisp)
              bpebc(3,imag)=  cosphi*z00 + sinphi*y00
     &          +displace(5,idisp)

              bpebc(4:6,imag)=bpebc(4:6,imag)+displace(7:9,idisp)

              bcy=bpebc(5,imag)
              bcz=bpebc(6,imag)
              bpebc(5,imag)= -sinphi*bcz + cosphi*bcy
              bpebc(6,imag)=  cosphi*bcz + sinphi*bcy

              nplan=ibpeplan(imag)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,imag)
                do icorn=1,ncorn

                  x00=bpemag(1,icorn,iplan,imag)+displace(1,idisp)
                  bpemag(1,icorn,iplan,imag)= x00

                  y00=bpemag(2,icorn,iplan,imag)+displace(2,idisp)
     &              -displace(4,idisp)
                  z00=bpemag(3,icorn,iplan,imag)+displace(3,idisp)
     &              -displace(5,idisp)
                  bpemag(2,icorn,iplan,imag)= -sinphi*z00 + cosphi*y00
     &              +displace(4,idisp)
                  bpemag(3,icorn,iplan,imag)=  cosphi*z00 + sinphi*y00
     &              +displace(5,idisp)
                enddo
              enddo
            endif
          enddo
        endif

c        write(lun6,*)imag,moth,chmoth,chmoths(1:32,imag)
      enddo

      if (kdisplace.ne.0) then
        write(lun6,*)
        write(lun6,*)
        write(lun6,*)"Displacement and change of magnetization activated:"
        write(lun6,*)
        do idisp=1,ndisp
          write(lun6,*)idisp,trim(chdisp(idisp)),sngl(displace(1:9,idisp))
        enddo
        write(lun6,*)
        write(lun6,*)
        write(lun6,*)
      endif

      open(newunit=lunmag,file='undumag.mag',form='formatted',status='unknown')

      write(lunmag,'(a)')trim(cundutit)

      do imag=1,nmag

        do iplan=1,ibpeplan(imag)
          do icorn=1,ibpecorn(iplan,imag)

            htup(1)=bpebc(15,imag)
            htup(2)=imag
            htup(3)=ibpecol(imag)
            htup(4)=iplan
            htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
            htup(6)=bpemag(1,icorn,iplan,imag)
            htup(7)=bpemag(2,icorn,iplan,imag)
            htup(8)=bpemag(3,icorn,iplan,imag)
            htup(9)=bpebc(4,imag)
            htup(10)=bpebc(5,imag)
            htup(11)=bpebc(6,imag)
            htup(12)=bpebc(9,imag)

            vmaglab(1)=bpebc(4,imag)
            vmaglab(2)=bpebc(5,imag)
            vmaglab(3)=bpebc(6,imag)

            bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
            bpebc(7,imag)=bc

            if (bc.ne.0.0d0) then
              do i=5,10
                if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
              enddo
              write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
              chmoth1a=chmoths(1:32,imag)
              c32a=chmags(1:32,imag)
              cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
              write(lunmag,'(a)') trim(cline)
            endif !BC

          enddo !ncorn
        enddo !nplan
      enddo !nmag

      if (kplsym.eq.0) then
        if (ixsymo.ne.0) then
          dx=xmax-xmin
          xmax=xmax-dx/2.
        endif
        if (iysymo.ne.0) then
          dy=ymax-ymin
          ymax=ymax-dy/2.
        endif
        if (izsymo.ne.0) then
          dz=zmax-zmin
          zmax=zmax-dz/2.
        endif
        goto 19
      endif

      if (ixsym.eq.0) then
        if (iysym.ne.0.and.izsym.eq.0) then
          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (izsym.ne.0.and.iysym.eq.0) then

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (izsym.ne.0.and.iysym.ne.0) then

          do imag=1,nmag !izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+2*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym and izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+3*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        endif !(izsym.ne.) then

      else !:ixsym.eq.0

        if (iysym.eq.0.and.izsym.eq.0) then

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=xsymmm+(xsymmm-bpemag(1,icorn,iplan,imag))
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (iysym.ne.0.and.izsym.eq.0) then

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+2*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+3*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (izsym.ne.0.and.iysym.eq.0) then

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x1y1z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x2y1z1
                htup(1)=bpebc(15,imag)
                htup(2)=imag+2*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=xsymmm+(xsymmm-bpemag(1,icorn,iplan,imag))
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x2y1z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+3*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=xsymmm+(xsymmm-bpemag(1,icorn,iplan,imag))
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (izsym.ne.0.and.iysym.ne.0) then

          do imag=1,nmag !izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x1y1z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x1y2z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+2*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym and izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x1y2z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+3*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x2y1z1
                htup(1)=bpebc(15,imag)
                htup(2)=imag+4*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+5*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym and izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+6*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+7*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        endif !(izsym.ne.) then

      endif !(ixsym.eq.0) then

19    close(lunmag)
      close(lun76)

      deallocate(corn1,corn2,ncorn1,ncorn2)

+self,if=chmagpols.
      if (nmag.gt.0) then
        nmagpols=1
        chmagpols(1:32,nmagpols)=chmoths(1:32,1)
      endif

      do imag=2,nmag
        do imp=1,nmagpols
          ifound=1
          do ic=1,32
            if (chmoths(ic,imag).ne.chmagpols(ic,imp)) then
              ifound=0
              exit
            endif
          enddo
          if (ifound.eq.0) then
            nmagpols=nmagpols+1
            chmagpols(1:32,nmagpols)=chmoths(1:32,imag)
            exit
          endif
        enddo
      enddo

      do imag=1,nmag
        do imp=1,nmagpols
          ifound=1
          do ic=1,32
            if (chmoths(ic,imag).ne.chmagpols(ic,imp)) then
              ifound=0
              exit
            endif
          enddo
          if (ifound.eq.1) then
            bpebc(15,imag)=imp
            exit
          endif
        enddo
      enddo
+self.,if=chmagpols.

      kforcemag=0

      if (iforce.eq.9999.or.iforcedip.ne.0) then

        if (chforcemag.eq.'') then
          write(lun6,*)"*** iforce=9999, but chforcemag is an empty string ***"
          write(lun6,*)
          stop
        endif

        write(lun6,*)""
        write(lun6,*)"      chforcemag: ",trim(chforcemag)
        do imag=1,nmag
          do ic=1,32
            chmoth(ic:ic)=chmoths(ic,imag)
          enddo
          if (chmoth.eq.chforcemag) then
            kforcemag=imag
            exit
          endif
        enddo

c        call undumag_magpol_index(chforcemag,kforcemag)
        if (kforcemag.eq.0) then
          write(lun6,*)"*** Magnet ",trim(chforcemag),"  for force calculations not found ***"
          write(lun6,*)"*** Check undumag_magnets.lis ***"
          stop
        endif

        if (chforcemag.eq.'') then
          chforcemag='None'
        endif

      endif !iforce, iforcedip

      if (iforce.eq.9999) then

        moth=nint(bpebc(15,kforcemag))

        xminfb=1.0d30
        xmaxfb=-1.0d30
        yminfb=1.0d30
        ymaxfb=-1.0d30
        zminfb=1.0d30
        zmaxfb=-1.0d30

        do imag=1,nmag
          gcen=bpebc(1:3,imag)
          bpebc15=bpebc(15,imag)
          if (nint(bpebc15).ne.moth) cycle
          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              x=bpemag(1,icorn,iplan,imag)
              y=bpemag(2,icorn,iplan,imag)
              z=bpemag(3,icorn,iplan,imag)
              if (x.lt.xminfb) xminfb=x
              if (x.gt.xmaxfb) xmaxfb=x
              if (y.lt.yminfb) yminfb=y
              if (y.gt.ymaxfb) ymaxfb=y
              if (z.lt.zminfb) zminfb=z
              if (z.gt.zmaxfb) zmaxfb=z
            enddo !icorn
          enddo !iplan
        enddo

        ubfcenx=(xmaxfb+xminfb)/2.0d0
        ubflenx=(xmaxfb-xminfb)
        if (ixsym.ne.0.and.(xmin.le.xsym.or.xmax.ge.xsym)) then
          ubfcenz=xsym
          ubflenz=2.0d0*ubflenz
        endif

        ubfceny=(ymaxfb+yminfb)/2.0d0
        ubfleny=(ymaxfb-yminfb)

        ubfcenz=(zmaxfb+zminfb)/2.0d0
        ubflenz=(zmaxfb-zminfb)
        if (izsym.ne.0) then
          ubfcenz=0.0d0
          ubflenz=2.0d0*ubflenz
        endif

        ubflenx=ubflenx+dedgefb
        ubfleny=ubfleny+dedgefb
        ubflenz=ubflenz+dedgefb

        if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
        if (utorqceny.eq.9999.0d0) utorqceny=ubfceny
        if (utorqcenz.eq.9999.0d0) utorqcenz=ubfcenz

        bfcenxmm=ubfcenx
        bfcenymm=ubfceny
        bfcenzmm=ubfcenz
        bflenxmm=ubflenx
        bflenymm=ubfleny
        bflenzmm=ubflenz
        torqcenxmm=utorqcenx
        torqcenymm=utorqceny
        torqcenzmm=utorqcenz
        bfcenx=ubfcenx/1000.0d0
        bfceny=ubfceny/1000.0d0
        bfcenz=ubfcenz/1000.0d0
        bflenx=ubflenx/1000.0d0
        bfleny=ubfleny/1000.0d0
        bflenz=ubflenz/1000.0d0
        torqcenx=utorqcenx/1000.0d0
        torqceny=utorqceny/1000.0d0
        torqcenz=utorqcenz/1000.0d0
        jplforce=iplforce
        if (iforce.eq.0) then
          mbforcex=0
          mbforcey=0
          mbforcez=0
        endif
        nbforcx=mbforcex
        nbforcy=mbforcey
        nbforcz=mbforcez
        iforcol=mfcolor
        forcol=iforcol
        forxpl(1)=bfcenxmm-bflenxmm/2.
        forxpl(2)=bfcenxmm+bflenxmm/2.
        forypl(1)=bfcenymm-bflenymm/2.
        forypl(2)=bfcenymm+bflenymm/2.
        forzpl(1)=bfcenzmm-bflenzmm/2.
        forzpl(2)=bfcenzmm+bflenzmm/2.

      endif !(iforce.eq.9999) then

      if (mbforcex*mbforcey*mbforcez.gt.0) then
        outbox(1,1)=ubfcenx-ubflenx/2.
        outbox(2,1)=ubfcenx+ubflenx/2.
        outbox(1,2)=ubfceny-ubfleny/2.
        outbox(2,2)=ubfceny+ubfleny/2.
        outbox(1,3)=ubfcenz-ubflenz/2.
        outbox(2,3)=ubfcenz+ubflenz/2.
      else
        outbox(1,1)=+1.0d30
        outbox(2,1)=-1.0d30
        outbox(1,2)=+1.0d30
        outbox(2,2)=-1.0d30
        outbox(1,3)=+1.0d30
        outbox(2,3)=-1.0d30
      endif

      do i=1,ncwires
        wire(3,i)=wire(3,i)+xcentershift
        wire(6,i)=wire(6,i)+xcentershift
      enddo

      if (nmag.eq.0) then
        xmin=1.0d30
        xmax=-1.0d30
        ymin=1.0d30
        ymax=-1.0d30
        zmin=1.0d30
        zmax=-1.0d30
      endif

      do i=1,ncwires
        if (wire(3,i).lt.xmin) xmin=wire(3,i)
        if (wire(3,i).gt.xmax) xmax=wire(3,i)
        if (wire(6,i).lt.xmin) xmin=wire(6,i)
        if (wire(6,i).gt.xmax) xmax=wire(6,i)
        if (wire(4,i).lt.ymin) ymin=wire(4,i)
        if (wire(4,i).gt.ymax) ymax=wire(4,i)
        if (wire(7,i).lt.ymin) ymin=wire(7,i)
        if (wire(7,i).gt.ymax) ymax=wire(7,i)
        if (wire(5,i).lt.zmin) zmin=wire(5,i)
        if (wire(5,i).gt.zmax) zmax=wire(5,i)
        if (wire(8,i).lt.zmin) zmin=wire(8,i)
        if (wire(8,i).gt.zmax) zmax=wire(8,i)
      enddo

      if (xmapmin.eq.9999.0d0) then
        xmapmin=xmin+mod(xmin,perlen)-9.0d0*perlen
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      else if (xmapmin.eq.9000.0d0) then
        xmapmin=xcenter-perlen/2.0d0
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      else if (xmapmin.eq.-9000.0d0) then
        xmapmin=xcenter-perlen/4.0d0
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      endif

      if (xmapmax.eq.9999.0d0) then
        xmapmax=xmax-mod(xmax,perlen)+10.0d0*perlen
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      else if (xmapmax.eq.9000.0d0) then
        xmapmax=xcenter+perlen/2.0d0
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      else if (xmapmax.eq.-9000.0d0) then
        xmapmax=xcenter+perlen/4.0d0
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      endif

      if (iplot.ne.0.and.nmag+ncwires.ne.0) then
        xplmin=xminpl
        xplmax=xmaxpl
        yplmin=yminpl
        yplmax=ymaxpl
        zplmin=zminpl
        zplmax=zmaxpl
        if (xminpl.eq.9999.0d0) xplmin=xmin-(xmax-xmin)*0.1
        if (xmaxpl.eq.9999.0d0) xplmax=xmax+(xmax-xmin)*0.1
        if (yminpl.eq.9999.0d0) yplmin=ymin-(ymax-ymin)*0.1
        if (ymaxpl.eq.9999.0d0) yplmax=ymax+(ymax-ymin)*0.1
        if (zminpl.eq.9999.0d0) zplmin=zmin-(zmax-zmin)*0.1
        if (zmaxpl.eq.9999.0d0) zplmax=zmax+(zmax-zmin)*0.1
        call undumag_bpolyplot_old(iplot,xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &    theta,pphi,nwitems,ncwires,wire)
      endif !iplot

      if (dxmap.eq.0.0d0.and.nxmap.eq.0.0d0) then
        nxmap=1
      endif

      if (dxmap.eq.9999.0d0) then
        if (nxbeff.gt.1) then
          dxmap=perlen/(nxbeff-1)
        else
          dxmap=perlen
        endif
      endif
      if (dxmap.ne.0.0d0) nxmap=nint((xmapmax-xmapmin)/dxmap)+1
      if (nxmap.le.0) then
        write(lun6,*)"*** Warning in undumag_ini_old: nxmap.le.0 ***"
      endif

      if (nymap.le.0) nymap=1
      if (nzmap.le.0) nzmap=1

cdebug
      if (nmag.le.0.and.ncwires.eq.0) goto 9999

      if (kpreset.ne.0) then

        maxplan=0

        open(newunit=lunpre,file='undumag.pre',status='old')
        npre=0
12      continue
        read(lunpre,*,end=92)nplan
        if (nplan.gt.maxplan) maxplan=nplan
        do iplan=1,nplan
          read(lunpre,*,end=92)xx
        enddo
        npre=npre+1
        goto 12
92      rewind(lunpre)

        allocate(bcpre(6,maxplan,npre),bpre16(16,npre))

        do ipre=1,npre
          read(lunpre,*)nplan,bpre16(1:15,ipre)
          bpre16(16,ipre)=nplan
          do iplan=1,nplan
            read(lunpre,*)bcpre(1:6,iplan,ipre)
c            write(33,*),ipre,iplan,bcpre(1:6,iplan,ipre)
          enddo
        enddo

        close(lunpre)

        do imag=1,nmag

          xx=bpebc(1,imag)
          yy=bpebc(2,imag)
          zz=bpebc(3,imag)

          ifound=0

          do ipre=1,npre

            nplan=nint(bpre16(16,ipre))

            do iplan=1,nplan

              dlab(1)=xx-bcpre(1,iplan,ipre)
              dlab(2)=yy-bcpre(2,iplan,ipre)
              dlab(3)=zz-bcpre(3,iplan,ipre)

              vnormlab(1)=bcpre(4,iplan,ipre)
              vnormlab(2)=bcpre(5,iplan,ipre)
              vnormlab(3)=bcpre(6,iplan,ipre)

              if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &            dlab(3)*vnormlab(3).gt.0.0d0) then
                goto 99
              endif

            enddo !iplan

            ifound=ipre

            lmat=matmaps(2,nint(bpebc(9,imag)))

            bpebc(1:15,imag)=bpre16(1:15,ipre)
            bpebc(16,imag)=0.0d0

            if (lmat.eq.2) then
              bpebc(14,imag)=bpre16(7,ipre)
              bpebc(11:13,imag)=bpre16(4:6,ipre)/bpre16(7,ipre)
            else if (lmat.eq.1.and.maxiterrec.gt.0) then
              bn=bpre16(14,ipre)
              bpebc(4:6,imag)=bpre16(11:13,ipre)*bn
              bpebc(7,imag)=bn
            endif

            goto 999
99          continue

          enddo !npre
999       continue

          if (ifound.eq.0) then
            write(lun6,*)"*** Warning in undumag_ini_old: No preset values found for magnet:",imag,xx,yy,zz
            bpebc(4:7,imag)=0.0d0
          endif

        enddo !imag

        deallocate(bcpre,bpre16)

      endif !kpreset

      if (iundugeo.ne.0) then

        write(lun6,*)
        write(lun6,*)'Writing geometry to undumag.geo'
        write(lun6,*)

        open(newunit=lunvox,file="undumag.geo")

        write(lunvox,'(a)')
     &    "* mag type xcen ycen zcen mother ixdiv iydiv izdiv mate color bcx bcy bcz bc plane corn x y z"

        if (nmag.gt.0) then
          moth=1
          do ic=1,32
            chmag(ic:ic)=chmags(ic,moth)
          enddo
        endif

        do imag=1,nmag

          gcen=bpebc(1:3,imag)
          nplan=ibpeplan(imag)
          moth=bpebc(15,imag)

          if(moth.ne.motho) then

            do ic=1,32
              chmag(ic:ic)=chmags(ic,imag)
            enddo

            write(cline,*)"* ",trim(chmag),moth
            write(lunvox,'(a)')cline(2:len_trim(cline))

            motho=moth

          endif

          imat=bpebc(9,imag)
          ispec=bpebc(10,imag)
          bx=bpebc(11,imag)
          by=bpebc(12,imag)
          bz=bpebc(13,imag)
          bc=bpebc(14,imag)
          ncol=ibpecol(imag)
          itype=bpebc(8,imag)
          mothdiv(1,imag)=moth
          motho=0

          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              x=bpemag(1,icorn,iplan,imag)
              y=bpemag(2,icorn,iplan,imag)
              z=bpemag(3,icorn,iplan,imag)
              write(lunvox,*)imag,itype,
     &          sngl(gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &          ,mothdiv(1:4,imag),imat,ncol
     &          ,sngl(bx),sngl(by),sngl(bz),sngl(bc)
     &          ,iplan,icorn
     &          ,sngl(x),sngl(y),sngl(z)
     &          ,chmags(:,imag),chmoths(:,imag)
              if (kplsym.ne.0) then
                if (ixsym.ne.0.and.iysym.ne.0.and.izsym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)2*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)3*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)4*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)5*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)6*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)7*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(-gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(-y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (ixsym.ne.0.and.iysym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)2*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)3*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (ixsym.ne.0.and.izsym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)2*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(bz),sngl(-bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)3*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (iysym.ne.0.and.izsym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)2*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(bz),sngl(-bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)3*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (ixsym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (iysym.ne.0.) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (izsym.ne.0.) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                endif !syms
              endif !(kplsym.ne.0) then
            enddo
          enddo
        enddo !nmag

        do i=1,ncwires
          mag=i
          itype=wire(1,i)
          moth=wire(10,i)
          icol=wire(9,i)
          x1=wire(3,i)
          y1=wire(4,i)
          z1=wire(5,i)
          ix=1
          iy=1
          iz=1
          mat=-1
          icol=wire(9,i)
          x2=wire(6,i)
          y2=wire(7,i)
          z2=wire(8,i)
          xc=(x2+x1)/2.0
          yc=(y2+y1)/2.0
          zc=(z2+z1)/2.0
          x21=(x2-x1)
          y21=(y2-y1)
          z21=(z2-z1)
          cw=wire(2,i)
          iplan=0
          icorn=0
          write(lunvox,*)mag,itype,xc,yc,zc,moth,ix,iy,iz,mat,icol,dx,dy,dz,cw,
     &      iplan,icorn,x1,y1,z1," wire", " wire"
        enddo !ncwires

        write(lun6,*)
        write(lun6,*)'Done'
        write(lun6,*)

        close(lunvox)

        if (iundugeo.lt.0) then
          open(newunit=lun,file="undumag.stat")
          write(lun,*)"0"
          flush(lun)
          close(lun)
          open(newunit=lun,file="undumag.sta")
          write(lun,*)'UNDUMAG finished due to iundugeo<0'
          flush(lun)
          close(lun)
          stop
        endif

      endif !(iundugeo.ne.0) then

      if (kseg.eq.1) then
+self,if=trace.
      print*,"-trace-: Leaving undumag_ini_old "
+self.
        return
      endif

      maxpoints=ncornmax*nplanmax

      if (ihullallo.ne.0) then
        deallocate(hull,khull,kface,kedge,xhull,yhull,zhull)
      endif

      allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
      allocate(khull(maxpoints))
      allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))

cdebug
      if (ivrml.ne.0) then

        write(lun6,*)
        write(lun6,*)'Writing geometry to CAD file undumag.wrl'
        write(lun6,*)

        allocate(khullmoth(maxpoints,nmoth),
     &    kfacemoth(maxpoints,nmoth),nplanmoth(nmoth))

        open(newunit=lunvrml,file="undumag.wrl")

        write(lunvrml,'(a)')"#VRML V2.0 utf8"
        write(lunvrml,*)
        write(cline,*)"# UNDUMAG: ",kundurun,trim(usercom),' ',
     &    dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
        write(lunvrml,*)cline(2:len_trim(cline))
        write(lunvrml,*)" "

        if (ivrml.eq.1.or.ivrml.eq.2) then

          do moth=1,nmoth

            do ic=1,32
              chmag(ic:ic)=chmags(ic,moth)
            enddo

            write(lunvrml,*)" "
            write(lunvrml,*)"# --- ",chmag
            write(lunvrml,*)" "

            korn=npmoth(moth)
            xhull(1:korn)=xmoth(1:korn,moth)
            yhull(1:korn)=ymoth(1:korn,moth)
            zhull(1:korn)=zmoth(1:korn,moth)

            call util_weed_points(korn,xhull,yhull,zhull,tiny)

            call util_convex_hull_3d(korn,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for "
              write(lun6,*)"*** writing of VRML-File"
              stop
            endif

            khullmoth(1:nhull,moth)=khull(1:nhull)
            kfacemoth(1:kfacelast,moth)=kface(1:kfacelast)
            nplanmoth(moth)=nface

! Magnet is represented by faces

            write(lunvrml,*)"Shape{"
            write(lunvrml,*)" "
            write(lunvrml,*)"  appearance Appearance{"
            write(lunvrml,*)"    material Material{"
            color(1)=1
            color(2)=1
            color(3)=1
            if (ncolmoth(moth).eq.1) then !black
              color(1)=0
              color(2)=0
              color(3)=0
            else if (ncolmoth(moth).eq.2) then !red
              color(1)=1
              color(2)=0
              color(3)=0
            else if (ncolmoth(moth).eq.3) then !bright green
              color(1)=0
              color(2)=1
              color(3)=0
            else if (matmoth(moth).eq.4) then !blue
              color(1)=0
              color(2)=0
              color(3)=1
            else if (ncolmoth(moth).eq.5) then !gelb
              color(1)=1.
              color(2)=1.
              color(3)=0
            else if (ncolmoth(moth).eq.6) then !magenta
              color(1)=1
              color(2)=0
              color(3)=1
            else if (ncolmoth(moth).eq.7) then !light blau
              color(1)=0
              color(2)=1
              color(3)=1
            else if (ncolmoth(moth).eq.8) then ! green
              color(1)=0.35
              color(2)=0.83
              color(3)=0.33
            else if (ncolmoth(moth).eq.9) then !dark blue
              color(1)=0.35
              color(2)=0.33
              color(3)=0.85
            endif

            write(lunvrml,*)"      diffuseColor", color
            write(lunvrml,*)"    } # End of Material"
            write(lunvrml,*)"  } # End of Appearance"
            write(lunvrml,*)" "
            write(lunvrml,*)"  geometry IndexedFaceSet {"
            write(lunvrml,*)
            write(lunvrml,*)"      coord Coordinate{"

            write(lunvrml,*)"         point ["

            do korn=1,nhull
              x=xhull(korn)
              y=yhull(korn)
              z=zhull(korn)
              write(lunvrml,*)"          ",sngl(x),sngl(y),sngl(z),","
            enddo !nhull
            write(lunvrml,*)"         ] # End of point"

            write(lunvrml,*)"      } # End of Coordinate"
            write(lunvrml,*)
            write(lunvrml,*)"       coordIndex ["

cdebug
            korn=1
            do iplan=1,nface
              ncorn=kface(korn)
              do icorn=1,ncorn
                korn=korn+1
                ipoi=kface(korn)-1
                if (icorn.eq.1) i=ipoi
                write(lunvrml,*)"              ",ipoi,","
              enddo
              write(lunvrml,*)"                 ",i,"-1,"
              korn=korn+1
            enddo !nplan

            write(lunvrml,*)"       ] # End of coordIndex"
            write(lunvrml,*)"  } # End of Geometry"
            write(lunvrml,*)"} # End of Shape"
            write(lunvrml,*)" "

            if (kplsym.ne.0) then
              if (ixsym.ne.0.and.iysym.ne.0.and.izsym.ne.0) then
              else if (ixsym.ne.0.and.iysym.ne.0) then
              else if (ixsym.ne.0.and.izsym.ne.0) then
              else if (iysym.ne.0.and.izsym.ne.0) then
              else if (ixsym.ne.0) then
              else if (iysym.ne.0.) then
              else if (izsym.ne.0.) then
              endif !syms
            endif !(kplsym.ne.0) then

          enddo !nmoth

        endif !ivrml.eq.1

! Magnets is represented by lines to visualize the segmentation

        if (ivrml.eq.2) then

          do moth=1,nmoth

            do imag=1,nmag

              npoi=0
              nplan=ibpeplan(imag)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,imag)
                do icorn=1,ncorn
                  npoi=npoi+1
                  xhull(npoi)=bpemag(1,icorn,iplan,imag)
                  yhull(npoi)=bpemag(2,icorn,iplan,imag)
                  zhull(npoi)=bpemag(3,icorn,iplan,imag)
                enddo
              enddo

              call util_weed_points(npoi,xhull,yhull,zhull,tiny)

              call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &          nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

              if (ifailhull.ne.0.or.nhull.lt.4) then
                write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for "
                write(lun6,*)"*** writing of VRML-File"
                stop
              endif

              do ic=1,32
                chmag(ic:ic)=chmags(ic,imag)
              enddo

              write(lunvrml,*)" "
              write(lunvrml,*)"# ",chmag
              write(lunvrml,*)" "

              write(lunvrml,*)"Shape{"
              write(lunvrml,*)" "
              write(lunvrml,*)"  geometry IndexedLineSet {"
              write(lunvrml,*)
              write(lunvrml,*)"      coord Coordinate{"

              write(lunvrml,*)"         point ["

              do korn=1,npoi
                x=xhull(korn)
                y=yhull(korn)
                z=zhull(korn)
                write(lunvrml,*)"          ",sngl(x),sngl(y),sngl(z),","
              enddo !nhull

              write(lunvrml,*)"         ] # End of point"

              write(lunvrml,*)"      } # End of Coordinate"
              write(lunvrml,*)

              write(lunvrml,*)
              write(lunvrml,*)"       coordIndex ["

              korn=1
              do iplan=1,nface
                ncorn=kface(korn)
                gcen=0.0d0
                do icorn=1,ncorn
                  korn=korn+1
                  ipoi=kface(korn)
                  x=xhull(ipoi)
                  y=yhull(ipoi)
                  z=zhull(ipoi)
                  gcen(1)=gcen(1)+x
                  gcen(2)=gcen(2)+y
                  gcen(3)=gcen(3)+z
                enddo
                gcen=gcen/ncorn
                korn=korn+1
                kornmoth=1
                ifound=0
                do kplan=1,nplanmoth(moth)
                  npoimoth=kfacemoth(kornmoth,moth)
                  ipoimoth=kfacemoth(kornmoth+1,moth)
                  p1(1)=xmoth(ipoimoth,moth)
                  p1(2)=ymoth(ipoimoth,moth)
                  p1(3)=zmoth(ipoimoth,moth)
                  ipoimoth=kfacemoth(kornmoth+2,moth)
                  p2(1)=xmoth(ipoimoth,moth)
                  p2(2)=ymoth(ipoimoth,moth)
                  p2(3)=zmoth(ipoimoth,moth)
                  ipoimoth=kfacemoth(kornmoth+3,moth)
                  p3(1)=xmoth(ipoimoth,moth)
                  p3(2)=ymoth(ipoimoth,moth)
                  p3(3)=zmoth(ipoimoth,moth)
                  kornmoth=kornmoth+npoimoth+1
                  call util_plane(p1,p2,p3,gcen,vnor,dist,iover,istat)
                  if (abs(dist).lt.tiny) then
                    ifound=kplan
                    exit
                  endif
                enddo !kplan
                if (ifound.ne.0) then
                  korn=korn-ncorn-1
                  do icorn=1,ncorn
                    korn=korn+1
                    ipoi=kface(korn)-1
                    if (icorn.eq.1) i=ipoi
                    write(lunvrml,*)"              ",ipoi,","
                  enddo
                  korn=korn+1
                  write(lunvrml,*)"                 ",i,"-1,"
                endif
              enddo !nplan

              write(lunvrml,*)"       ] # End of coordIndex"

              write(lunvrml,*)"  } # End of Geometry"
              write(lunvrml,*)"} # End of Shape"
              write(lunvrml,*)" "

            enddo !nmag

          enddo !nmoth

        endif !vrml.eq.2

        if (ivrml.eq.-1) then

          do imag=1,nmag

            npoi=0
            nplan=ibpeplan(imag)
            ncol=ibpecol(imag)

            color(1)=1
            color(2)=1
            color(3)=1

            if (ncol.eq.1) then !black
              color(1)=0
              color(2)=0
              color(3)=0
            else if (ncol.eq.2) then !red
              color(1)=1
              color(2)=0
              color(3)=0
            else if (ncol.eq.3) then !bright green
              color(1)=0
              color(2)=1
              color(3)=0
            else if (ncol.eq.4) then !blue
              color(1)=0
              color(2)=0
              color(3)=1
            else if (ncol.eq.5) then !gelb
              color(1)=1.
              color(2)=1.
              color(3)=0
            else if (ncol.eq.6) then !magenta
              color(1)=1
              color(2)=0
              color(3)=1
            else if (ncol.eq.7) then !light blau
              color(1)=0
              color(2)=1
              color(3)=1
            else if (ncol.eq.8) then ! green
              color(1)=0.35
              color(2)=0.83
              color(3)=0.33
            else if (ncol.eq.9) then !dark blue
              color(1)=0.35
              color(2)=0.33
              color(3)=0.85
            endif

            do iplan=1,nplan
              ncorn=ibpecorn(iplan,imag)
              do icorn=1,ncorn
                npoi=npoi+1
                xhull(npoi)=bpemag(1,icorn,iplan,imag)
                yhull(npoi)=bpemag(2,icorn,iplan,imag)
                zhull(npoi)=bpemag(3,icorn,iplan,imag)
              enddo
            enddo

            call util_weed_points(npoi,xhull,yhull,zhull,tiny)

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for "
              write(lun6,*)"*** writing of VRML-File"
              stop
            endif

            do ic=1,32
              chmag(ic:ic)=chmags(ic,imag)
            enddo

            write(lunvrml,*)" "
            write(lunvrml,*)"# ",chmag
            write(lunvrml,*)" "

            write(lunvrml,*)"Shape{"
            write(lunvrml,*)" "
            write(lunvrml,*)"  geometry IndexedLineSet {"
            write(lunvrml,*)
            write(lunvrml,*)"      coord Coordinate{"

            write(lunvrml,*)"         point ["

            do korn=1,npoi
              x=xhull(korn)
              y=yhull(korn)
              z=zhull(korn)
              write(lunvrml,*)"          ",sngl(x),sngl(y),sngl(z),","
            enddo !nhull

            write(lunvrml,*)"         ] # End of point"

            write(lunvrml,*)"      } # End of Coordinate"
            write(lunvrml,*)

            write(lunvrml,*)"       color Color {"
            write(lunvrml,*)"         color [", color," ] # End of color"
            write(lunvrml,*)"       } # End of color Color"
            write(lunvrml,*)
            write(lunvrml,*)"       coordIndex ["

            korn=1
            nedge=0
            do iplan=1,nface
              ncorn=kface(korn)
              do icorn=1,ncorn
                nedge=nedge+1
                korn=korn+1
                ipoi=kface(korn)-1
                if (icorn.eq.1) i=ipoi
                write(lunvrml,*)"              ",ipoi,","
              enddo
              korn=korn+1
              write(lunvrml,*)"                 ",i,"-1,"
            enddo !nplan

            write(lunvrml,*)"       ] # End of coordIndex"
            write(lunvrml,*)

            write(lunvrml,*)"       colorIndex ["
            do iedge=1,nedge
              write(lunvrml,*)"       0, 0,"
            enddo
            write(lunvrml,*)"       ] # End of colorIndex"
            write(lunvrml,*)
            write(lunvrml,*)"  } # End of Geometry"
            write(lunvrml,*)"} # End of Shape"
            write(lunvrml,*)" "

          enddo !nmag

        endif !vrml.eq.-1

        write(lunvrml,*)
        write(lunvrml,*)"# Coils"
        write(lunvrml,*)

        do i=1,ncwires
          xp1=wire(3,i)
          yp1=wire(4,i)
          zp1=wire(5,i)
          xp2=wire(6,i)
          yp2=wire(7,i)
          zp2=wire(8,i)
          if (((xp2-xp1)**2+(yp2-yp1)**2+(zp2-zp1)**2)*abs(wire(2,i)).lt.1.0d-12)
     &      cycle
          write(lunvrml,*)"Shape{"
          write(lunvrml,*)" "
          write(lunvrml,*)"  geometry IndexedLineSet {"
          write(lunvrml,*)
          write(lunvrml,*)"      coord Coordinate{"
          write(lunvrml,*)"         point ["
          write(lunvrml,*)"          ",xp1,yp1,zp1,","
          write(lunvrml,*)"          ",xp2,yp2,zp2,","
          write(lunvrml,*)"         ] # End of point"
          write(lunvrml,*)"      } # End of Coordinate"
          write(lunvrml,*)
          write(lunvrml,*)
          write(lunvrml,*)"       coordIndex ["
          write(lunvrml,*)"                 0,"
          write(lunvrml,*)"                 1, -1,"
          write(lunvrml,*)"       ] # End of coordIndex"

          write(lunvrml,*)"  } # End of Geometry"
          write(lunvrml,*)"} # End of Shape"
          write(lunvrml,*)" "

        enddo !ncwires

        write(lunvrml,*)
        write(lunvrml,*)"# End of Coils"
        write(lunvrml,*)

        close(lunvrml)

        write(lun6,*)
        write(lun6,*)'Done'
        write(lun6,*)

        deallocate(khullmoth,kfacemoth,nplanmoth)
      endif !ivrml.ne.0

      bpebc(17,1:nmag)=0.0d0
      if (intmaglis.ne.0) then
        ifound=0
        write(lun6,*)
        write(lun6,*)" --- Due to flag intmaglis, only magnets on file undumag_magmap.lis do contribute to field map ---"
        write(lun6,*)
        open(newunit=lunlis,file="undumag_magmap.lis")
        do while (.true.)
          call util_skip_comment_end(lunlis,ieof)
          if (ieof.ne.0) exit
          read(lunlis,*)chsel,bpe17
          do imag=1,nmag
            write(chmoth,'(32a)')chmoths(1:32,imag)
            if (chmoth.eq.chsel) then
              if (bpe17.gt.0.0d0) then
                bpebc(17,imag)=1.0d0
              else if (bpe17.lt.0.0d0) then
                bpebc(17,imag)=2.0d0
              endif
              ifound=1
            endif
          enddo
        enddo
        close(lunlis)
      endif !intmaglis

      open(newunit=lun,file='undumag_magnets.lis')
      do imag=1,nmag
c        write(lun6,*)imag,chmags(1:32,imag),nint(bpebc(15,imag)),
c     &    chmoths(1:32,imag)
        write(lun,*)imag,chmags(1:32,imag),chmoths(1:32,imag),
     &    sngl(bpebc(1,imag)),sngl(bpebc(2,imag)),sngl(bpebc(3,imag))
      enddo

      close(lun)

      open(newunit=lun,file='undumag_mother_magnets.lis')

      npoi=0
      ncount=0
      if (nmag.gt.0) motho=nint(bpebc(15,1))
      maxpoints=0

      do imag=1,nmag

        moth=nint(bpebc(15,imag))
c        write(lun6,*)"2 Info:",imag,moth,chmags(1:32,imag),chmoths(1:32,imag),npoi,maxpoints

        if (moth.eq.motho) then

          nplan=ibpeplan(imag)

          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              npoi=npoi+1
            enddo
          enddo

          if (npoi.gt.maxpoints) maxpoints=npoi

        else if (moth.ne.motho.or.imag.eq.nmag) then

          motho=moth
          if (npoi.gt.maxpoints) maxpoints=npoi
          npoi=0
          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              npoi=npoi+1
            enddo
          enddo

        endif !moth.eq.motho

      enddo !nmag

      deallocate(xhull,yhull,zhull,khull,kedge,kface)
      allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints),
     &  khull(maxpoints),kedge(4,2*maxpoints-2),
     &  kface((maxpoints+1)*maxpoints),stat=ierr)
      if (ierr.ne.0) then
        write(lun6,*)"*** Error while allocating xhull, yhull, zhull... Try less magnets...***"
        write(lun6,*)"*** Skipping writing undumag_mother_magnets.lis ***"
        goto 877
      endif

      npoi=0
      imag=1
      if (nmag.gt.0) motho=nint(bpebc(15,imag))

      do imag=1,nmag

        moth=nint(bpebc(15,imag))
        write(chmoth,'(32a)')chmoths(1:32,imag)
c        write(lun6,*)"3 Info:",imag,moth,chmags(1:32,imag),chmoths(1:32,imag)
c        write(lun6,*)imag,moth,chmoth

        if (moth.eq.motho) then
          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              npoi=npoi+1
              xhull(npoi)=bpemag(1,icorn,iplan,imag)
              yhull(npoi)=bpemag(2,icorn,iplan,imag)
              zhull(npoi)=bpemag(3,icorn,iplan,imag)
            enddo
          enddo

        else if (moth.ne.motho.or.imag.eq.nmag) then

          xmin=1.0d30
          xmax=-1.0d30
          ymin=1.0d30
          ymax=-1.0d30
          zmin=1.0d30
          zmax=-1.0d30
          do ipoi=1,npoi
            if (xhull(ipoi).lt.xmin) xmin=xhull(ipoi)
            if (xhull(ipoi).gt.xmax) xmax=xhull(ipoi)
            if (yhull(ipoi).lt.ymin) ymin=yhull(ipoi)
            if (yhull(ipoi).gt.ymax) ymax=yhull(ipoi)
            if (zhull(ipoi).lt.zmin) zmin=xhull(ipoi)
            if (zhull(ipoi).gt.zmax) zmax=xhull(ipoi)
          enddo

          dx=xmax-xmin
          dy=ymax-ymin
          dz=zmax-zmin

          if (dy.gt.dx) dx=dy
          if (dz.gt.dx) dx=dz

          call util_weed_points(npoi,xhull,yhull,zhull,tiny)
!hull
          call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &      nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

          if (ifailhull.ne.0.or.nhull.lt.4) then
            write(lun6,*)"*** Error ",ifailhull," in undumag_ini_old: Subroutine util_convex_hull_3d failed for "
            write(lun6,*)"*** writing of undumag_mother_magnets.lis"
            write(lun6,*)"*** Date written to util_convex_hull_3d.dat ***"
            open(newunit=lunf,file='util_convex_hull_3d.dat')
            do i=1,npoi
              write(lunf,*)xhull(i),yhull(i),zhull(i),i
            enddo
            close(lunf)
            nhull=npoi
            do icorn=1,nhull
              khull(icorn)=icorn
            enddo
c            stop
          endif

          gcen=0.0d0
          do icorn=1,nhull
            ipoi=khull(icorn)
            x=xhull(ipoi)
            y=yhull(ipoi)
            z=zhull(ipoi)
            gcen(1)=gcen(1)+x
            gcen(2)=gcen(2)+y
            gcen(3)=gcen(3)+z
c            write(lun6,*)chmoth1,motho,moth,imag,x,y,z
          enddo

          gcen=gcen/nhull
c          write(lun6,*)nhull,gcen

          ncount=ncount+1
c          write(lun6,*)"4 Info:",ncount,chmoth1,gcen
          write(lun,*) ncount,chmoth1,gcen

          motho=moth
          gcen=0.0d0
          npoi=0

          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              npoi=npoi+1
              xhull(npoi)=bpemag(1,icorn,iplan,imag)
              yhull(npoi)=bpemag(2,icorn,iplan,imag)
              zhull(npoi)=bpemag(3,icorn,iplan,imag)
            enddo
          enddo

        endif !moth.eq.motho

        chmoth1=chmoth

      enddo !nmag

877   flush(lun)
      close(lun)

      deallocate(xhull,yhull,zhull,khull,kedge,kface)

      call undumag_to_radia_old(kundurun,xsymmm,bpemag,ncornmax,nplanmax,nmag)

9999  deallocate(bpebc0,mothdiv,ncolmoth,
     &  xmoth,ymoth,zmoth,
     &  xmothm,ymothm,zmothm,
     &  xmothi,ymothi,zmothi,chmagsi,chmagsm,chmothsi,chmothsm,
     &  )

      if (nrec.eq.0) maxiterrec=1
      if (nrec.eq.0.and.ncwires.eq.0) then
        maxiteriron=1
        maxiter=1
      endif

      if (ncwires.ne.0.and.iforce.lt.0) then
        write(lun6,*)"*** Error in undumag_ini_old: Iforce<0 not yet implemented for coils and wires ***"
        write(lun6,*)"*** PROGRAM UNDUMAG ABORTED ***"
        stop
      endif

+self,if=randos.
      allocate(xyzsmear(3,nmag))
      do i=1,nmag
        call util_random(3,g)
        xyzsmear(1,i)=randos*g(1)
        xyzsmear(2,i)=randos*g(2)
        xyzsmear(3,i)=randos*g(3)
        bpebc(1:3,i)=bpebc(1:3,i)+xyzsmear(1:3,i)
      enddo
+self.

      zminprof=zplmin
      zmaxprof=zplmax

      if (iunduplot.lt.0) then
        open(newunit=lunst,file="undumag.stat")
        write(lunst,*)"0"
        flush(lunst)
        close(lunst)
        stop "--- Programm UNDUMAG terminated due to iunduplot < 0 ---"
      endif

+self,if=trace.
      print*,"-trace-: Leaving undumag_ini_old "
+self.
      end
+DECK,undumag_ini_magnets.
*CMZ :  2.05/01 02/10/2023  16.19.49  by  Michael Scheer
*CMZ :  2.04/13 04/09/2023  10.23.44  by  Michael Scheer
*CMZ :  2.04/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/00 25/02/2023  14.36.37  by  Michael Scheer
*CMZ :  2.02/02 02/03/2022  13.26.45  by  Michael Scheer
*CMZ :  2.02/01 11/02/2022  09.49.54  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine undumag_ini_magnets(kseg)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      integer:: kseg,itrace=0
+self,if=debcm.
      integer i,l,imag,n,ipoi,iplan
+self.

c      print*," "
c      print*," "
c      print*,"Baustellen:"
c      print*,"bpebc(18:20),corrtiny, dedgefb, simpson-file, chicut und andere Variablen aus undumag_ini_old.Randommechnismus, spez. mit Blick auf 1. Integral"
      print*," "

      ! Evaluate buffer of coils
      call clccoil_to_coils

      if (kseg.eq.2) return

      call undumag_read_modules

      ! Treat concave shapes
      if (nconcave_t.gt.0) then
        call clc_concave_to_convex
      endif

      ! Evaluate buffer of magnets and poles
      if (itrace.ne.0) print*,"calling clcbuff_to_magnets"
      call clcbuff_to_magnets

+self,if=debcm.
      do imag=1,nmag_t+nspecmag_t
        l=0
        do iplan=1,t_magnets(imag)%nface
          l=l+1
          n=t_magnets(imag)%kface(l)
          do i=1,n
            l=l+1
            ipoi=t_magnets(imag)%kface(l)
            write(902,*)imag,iplan,i,l,ipoi,
     &        t_magnets(imag)%xhull0(ipoi),
     &        t_magnets(imag)%yhull0(ipoi),
     &        t_magnets(imag)%zhull0(ipoi)
          enddo
        enddo
      enddo
+self.
      ! Apply translations, rotations, and copying of magnets and poles
      if (ntransrotcop.ne.0) call clctransrotcop

      ! Drop zero magnets , after the call, xhull, yhull, zhull refer to gcen
      if (itrace.ne.0) print*,"calling clcmag_drop_zero_magnets"
      call clcmag_drop_zero_magnets

      ! Coating of magnets
      if (itrace.ne.0) print*,"calling clcmag_shrink_magnets"
      call clcmag_shrink_magnets

      ! Calculate center and normals of faces
      if (itrace.ne.0) print*,"calling clcmag_faces"
      call util_zeit_kommentar(lun6,"Calculating faces of magnets")
      call clcmag_faces
      call util_zeit_kommentar(lun6,"Done")

      ! Mothers
      call clcmag_mothers

      ! inhomogenities of magnets
      call clcmag_inhom

      ! Evaluate modules
      call clcmag_copy_magnets

      ! Apply longitudinal symmetry and center set-up
      call clcmag_sym

      ! segmentation of magnets
      if (itrace.ne.0) print*,"calling clcmag_cut"
      call clcmag_cut

      if (kseg.ne.0) then
        if (itrace.ne.0) print*,"leaving undumag_ini_magnets"
        call util_zeit_kommentar(lun6,"Leaving undumag_ini_magnets")
        return
      endif

      ! convert to internal arrays for undumag_proc and undumag_end
      call util_zeit_kommentar(lun6,"Preparing magnet structure for relaxation")
      if (itrace.ne.0) print*,"calling clcmag_to_bpe"
      call clcmag_to_bpe
      if (itrace.ne.0) print*,"calling clcmag_ini_bpetm"
      call undumag_ini_bpetm
      call util_zeit_kommentar(lun6,"Done")


      ! write set-up to lists
      if (itrace.ne.0) print*,"calling clcmag_magnets_list"
      call clcmag_magnets_list

      call clcmag_ini_force
      if (itrace.ne.0) print*,"leaving undumag_ini_magnets"

      return
      end
+DECK,undumag_greeter.
*CMZ :  2.02/01 23/10/2023  14.26.43  by  Michael Scheer
*-- Author :    Michael Scheer   19/10/2021
      subroutine undumag_greeter
      use undumagf90m
      use commandlinef90m
      implicit none
+seq,unduver.
      return
      end
+DECK,clcmag_to_msh_radia.
*CMZ :  2.04/28 30/09/2023  08.41.15  by  Michael Scheer
*CMZ :  2.04/22 22/09/2023  12.32.06  by  Michael Scheer
*CMZ :  2.04/21 21/09/2023  16.03.24  by  Michael Scheer
*CMZ :  2.04/20 21/09/2023  10.10.06  by  Michael Scheer
*CMZ :  2.04/19 18/09/2023  10.41.10  by  Michael Scheer
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 09/02/2022  19.36.16  by  Michael Scheer
*CMZ :  2.02/00 09/01/2021  12.08.32  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  12.47.44  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  15.45.12  by  Michael Scheer
*CMZ :  1.25/04 04/04/2018  11.40.25  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.27.59  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.25.43  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  09.00.40  by  Michael Scheer
*CMZ :  1.23/02 11/09/2017  15.35.11  by  Michael Scheer
*CMZ :  1.18/01 08/06/2017  14.20.17  by  Michael Scheer
*CMZ :  1.15/10 11/04/2017  11.14.47  by  Michael Scheer
*CMZ :  1.15/00 24/03/2017  10.28.46  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  17.33.35  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  10.15.10  by  Michael Scheer
*CMZ :  1.11/03 13/01/2017  15.10.38  by  Michael Scheer
*CMZ :  1.11/00 03/01/2017  16.16.45  by  Michael Scheer
*-- Author :    Michael Scheer   12/12/2016
      subroutine clcmag_to_msh_radia

      use undumagf90m
      use bpolyederf90m
      use commandlinef90m
      use magnets_structure

! Interface to RADIA under Python, using mshradia.py

! Isotropic materials must have a magnetization less then 0.01
!
! RADIA coordinate system: y is longitudinal, z is vertical
! UNDUMAG: x is longitudinal, y is vertical

      implicit none

+seq,phyconparam.

      double precision, dimension (:), allocatable :: x,y,z,brrec

      integer, dimension (:), allocatable :: khull,imatrec,imatiron,
     &  imatmagpol

      double precision :: gcen(3)

      real :: hfe,bfe

      integer ::
     &  nsymx,nsymy,nsymz,npoi,nmatfe,nlast,nfirst,nface,ncyl,ncolor,mater
     &  ,lunrad,lunfe,lmat,kproto,kpoi,k,ironmode,iron,imp,ipoi,imag,imat
     &  ,ifound,i,iface,ieof,nbr,nUnduMag,nUnduPol,nMagPolTot,lenout,lunproc,
     &  istat=0,ivox,kmagnet,kvoxel,ixdiv,iydiv,izdiv

      character(2048) cline,cbuff(10),cout,clunrad
      character(64) chmat,cnam
      character(32) c32,c32x,c32y,c32z
      character(17) chtime

      ncyl=0

      maxpoints=max(maxpoints,ncornmax*nplanmax)

      allocate(x(maxpoints),y(maxpoints),z(maxpoints),khull(maxpoints))
      allocate(brrec(nmagtot_t),imatrec(nmagtot_t),
     &  imatiron(nmagtot_t),imatmagpol(nmagtot_t))

      nbr=0
      nmatfe=0
      brrec=0.0d0
      imatrec=0

      do imag=1,nmagtot_t
        kproto=t_magcopy(imag)%kproto
        ifound=0
        if (t_magnets(kproto)%ispole.ne.0) then
          do i=1,nmatfe
            if (t_magnets(kproto)%imat.eq.imatiron(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) then
            cycle
          endif
          nmatfe=nmatfe+1
          imatiron(nmatfe)=t_magnets(kproto)%imat
          imatmagpol(imag)=nmatfe
        else
          do i=1,nbr
            if (brrec(i).eq.t_magcopy(imag)%brn.and.
     &          t_magnets(kproto)%imat.eq.imatrec(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) cycle
          nbr=nbr+1
          brrec(nbr)=t_magcopy(imag)%brn
          imatrec(nbr)=t_magnets(kproto)%imat
          imatmagpol(imag)=nbr
        endif
      enddo

      nsymx=1
      nsymy=1
      nsymz=1

      if (ixsymo.lt.0) nsymx=nsymx*2
      if (iysymo.lt.0) nsymy=nsymy*2
      if (izsymo.lt.0) nsymz=nsymz*2

      open(newunit=lunrad,file='undumag_msh_radia.py')

      write(lunrad,'(a)')'#-- Begin of lines generated by UNDUMAG --'
      write(lunrad,'(a)')'#-- Version ' // trim(chuvers) // ' --'
      write(lunrad,'(a)')' '
      write(lunrad,'(a)')'from __future__ import print_function #Python 2.7 compatibility'
      write(lunrad,'(a)') 'import radia as rad'
      write(lunrad,'(a)') 'import numpy as np'
      write(lunrad,'(a)') 'import time, os, sys, platform'
      write(lunrad,'(a)') 'from numpy import *'
      write(lunrad,'(a)') 'import mshradia as msh'
      write(lunrad,'(a)') 'from mshradia import *'
      write(lunrad,'(a)') 'from pyhull import qconvex'
      write(lunrad,'(a)')' '
      write(lunrad,'(a)') 'NL = "\n"'
      write(lunrad,'(a)')' '
      write(lunrad,'(a)')"print('\nRADIA Library Version:', rad.UtiVer(), '\n')"
      write(lunrad,'(a)')

      write(c32x,*) kundurun
      call util_time_and_date(chtime)
      write(lunrad,'(a)')'# Run: ' // trim(c32x) // ' ' // chtime

      write(lunrad,'(a)')" "
      write(lunrad,'(a)')"# Comment: "//trim(unducomment)
      write(lunrad,'(a)')
      write(lunrad,'(a)')'comment = "' // trim(unducomment) // '"'
      write(lunrad,'(a)')

      write(lunrad,'(a)')'# --- Variables of undumag.nam ---'
      write(clunrad,*)

      write(c32x,*)ixsymo
      write(lunrad,'(a)')'iUnduXsym = ' // c32x
      write(c32x,*)iysymo
      write(lunrad,'(a)')'iUnduYsym = ' // c32x
      write(c32x,*)izsymo
      write(lunrad,'(a)')'iUnduZsym = ' // c32x

      write(c32x,*)
     &  xsym
      write(lunrad,'(a)')'UnduSymX = ' // c32x
      write(c32x,*)
     &  iunduplot
      write(lunrad,'(a)')"kDraw = " // c32x
      write(c32x,*)
     &  unduplot_theta
      write(lunrad,'(a)')"unduplot_theta = " // c32x
      write(c32x,*)
     &  unduplot_phi
      write(lunrad,'(a)')"unduplot_phi = " // c32x

      write(c32x,*)xcenter
      write(lunrad,'(a)')"UnduXCenter = " // c32x

      write(c32x,*)iforce
      write(lunrad,'(a)')'iUnduForce = ' // c32x
      write(lunrad,'(a)')

      write(c32x,*)xcentershift
      write(lunrad,'(a)')"UnduXCenterShift = " // c32x
      write(c32x,*)utorqcenx
      write(lunrad,'(a)')"UnduTorqCenX = " // c32x
      write(c32x,*)utorqceny
      write(lunrad,'(a)')"UnduTorqCenY = " // c32x
      write(c32x,*)utorqcenz
      write(lunrad,'(a)')"UnduTorqCenZ = " // c32x

      write(lunrad,'(a)')
      write(c32x,*)xmapmin
      write(lunrad,'(a)')"UnduXMapMin = " // c32x
      write(c32x,*)xmapmax
      write(lunrad,'(a)')"UnduXMapMax = " // c32x
      write(c32x,*) nxmap
      write(lunrad,'(a)')"nUnduXMap = " // c32x

      write(lunrad,'(a)')
      write(c32x,*) ymapmin
      write(lunrad,'(a)')"UnduYMapMin = " // c32x
      write(c32x,*) ymapmax
      write(lunrad,'(a)')"UnduYMapMax = " // c32x
      write(c32x,*) nymap
      write(lunrad,'(a)')"nUnduYMap = " // c32x

      write(lunrad,'(a)')
      write(c32x,*)zmapmin
      write(lunrad,'(a)')"UnduZMapMin = " // c32x
      write(c32x,*)zmapmax
      write(lunrad,'(a)')"UnduZMapMax = " // c32x
      write(c32x,*) nzmap
      write(lunrad,'(a)')"nUnduZMap = " // c32x

      write(lunrad,'(a)')
      write(c32x,*)
     &  knopolmap
      write(lunrad,'(a)')"nUnduNoPolMap = " // c32x
      write(c32x,*)
     &  knomagmap
      write(lunrad,'(a)')"nUnduNoMagMap = " // c32x
      write(lunrad,'(a)')

      write(lunrad,'(a)')
      write(lunrad,'(a)')'# --- Variables of undumag.clc ---'
      write(lunrad,'(a)')

      do i=1,nvar_t
        write(clunrad,*) trim(t_variables(i)%cname),' = ',t_variables(i)%val
        write(lunrad,'(a)') trim(adjustl(clunrad))
      enddo !nvar_t

      write(lunrad,'(a)')
      write(lunrad,'(a)')'# --- Materials of undumag.clc ---'
      write(lunrad,'(a)')

      write(lunrad,'(a)')'UmatREC = []'
      do i=1,nbr
        imat=imatrec(i)
        if (imat.eq.0) cycle
        if (matmaps(1,imat).eq.1) then
          if (matmaps(2,imat).eq.1) then
            write(c32x,'(f6.4)')bcmat(2,1,imat) !-1.0d0
            write(c32y,'(f6.4)')bcmat(3,1,imat) !-1.0d0
            write(c32z,'(g12.5)')brrec(i)
            write(clunrad,'(a)')
     &        "UmatREC.append(rad.MatLin([" //
     &        trim(adjustl(c32x)) // "," //
     &        trim(adjustl(c32y)) //
     &        "]," // trim(adjustl(c32z)) // "))"
            write(lunrad,'(a)') trim(clunrad)
          else
            print*,"*** Error in clcmag_to_msh_radia: mode",
     &        matmaps(2,imat), " not yet implemented for REC material ",imat
            print*,""
            !stop "--- UNDUMAG aborted ---"
          endif
        else
          print*,"*** Error in clcmag_to_msh_radia: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          !stop "--- UNDUMAG aborted ---"
        endif
      enddo

      write(lunrad,'(a)')'UmatIron = []'
      do i=1,nmatfe
        imat=imatiron(i)
        if (imat.eq.0) cycle
        if (matmaps(1,imat).eq.2) then
          write(lunrad,'(a)')
     &      "UmatIron.append(rad.MatSatIsoTab([ \"
          do k=2,nclcmat
            read(clcmat(k),*)iron,lmat,ironmode,cbuff(1)
            if (iron.eq.imat) then
              open(newunit=lunfe,file=trim(cbuff(1)),status='old')
              ieof=0
              do while (ieof.eq.0)
                call util_skip_comment_end(lunfe,ieof)
                if (ieof.ne.0) exit
                read(lunfe,*) hfe,bfe
                write(clunrad,*)"[",hfe,",",bfe,"],"
                write(lunrad,'(a)') trim(clunrad)
              enddo
              backspace(lunrad)
              write(clunrad,*)"[",hfe,",",bfe,"]]))"
              write(lunrad,'(a)') trim(clunrad)
              close(lunfe)
            endif
          enddo
        else
          print*,"*** Error in clcmag_to_msh_radia: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          !stop "--- UNDUMAG aborted ---"
        endif
      enddo

      write(lunrad,'(a)')
      write(lunrad,'(a)')'# --- Poles and magnets of undumag.clc ---'
      write(lunrad,'(a)')

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        ! radObjPolyhdr[
        ! [
        !   [x1,y1,z1], ..., [xn,yn,zn] Corners
        ! ],
        ! [
        !   [f1n1,f1n2,...], ...., [f2n1,f2n2,...] Faces
        ! ],
        ! [mx,my,mz]:[0,0,0]]

        if(t_magnets(kproto)%ctype.ne.'Cylinder') then

          nface=t_magnets(kproto)%nface
          ncolor=t_magnets(kproto)%icol

          gcen=t_magcopy(imp)%gcen

          write(lunrad,'(a)')"vertices = np.array([ \"

          do kpoi=1,t_magnets(kproto)%nhull

            write(c32x,*)sngl(t_magnets(kproto)%xhull(kpoi)+gcen(1))
            write(c32y,*)sngl(t_magnets(kproto)%yhull(kpoi)+gcen(2))
            write(c32z,*)sngl(t_magnets(kproto)%zhull(kpoi)+gcen(3))

            if (kpoi.lt.t_magnets(kproto)%nhull) then
              write(clunrad,*)
     &          "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"],"
              write(lunrad,'(a)') trim(clunrad)
            else
              write(clunrad,*)
     &          "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"]])"
              write(lunrad,'(a)') trim(clunrad)
              write(lunrad,'(a)') ''
            endif
          enddo !kpoi

          write(lunrad,'(a)')"vertices,ifaces,faces,bounds = mshhull3d(vertices)"
          write(lunrad,'(a)') ''

          cnam=t_magcopy(imp)%cnam

          if (t_magnets(kproto)%IsPole.eq.0) then
            write(c32x,*)t_magcopy(imp)%br(1)*t_magcopy(imp)%brn
            write(c32y,*)t_magcopy(imp)%br(2)*t_magcopy(imp)%brn
            write(c32z,*)t_magcopy(imp)%br(3)*t_magcopy(imp)%brn
            write(lunrad,'(a)')"Br = [" // trim(c32z) // "," // trim(c32x) // "," // trim(c32y) // "]"
          else
            write(lunrad,'(a)')"Br = [0.0,0.0,0.0]"
          endif !Pole/Mag

          c32=''

          if (ncolor.eq.0) then
            c32='white'
          else if (ncolor.eq.1) then
            c32='black'
          else if (ncolor.eq.2) then
            c32='red'
          else if (ncolor.eq.3) then
            c32='green'
          else if (ncolor.eq.4) then
            c32='blue'
          else if (ncolor.eq.5) then
            c32='yellow'
          else if (ncolor.eq.6) then
            c32='magenta'
          else if (ncolor.eq.7) then
            c32='cyan'
          else if (ncolor.eq.7) then
            c32='green'
          else if (ncolor.eq.8) then
            c32='gray'
          endif

          write(lunrad,'(a)')
     &      trim(cnam) // " = mshObjPolyhdr(vertices,ifaces,faces,bounds,Br,'" // trim(cnam) // "','" // trim(c32) // "')"
          write(lunrad,'(a)') ''

          if (t_magnets(kproto)%IsPole.eq.0) then
            mater = imatmagpol(imp)
            write(chmat,*)mater-1
            call util_string_trim(chmat,nfirst,nlast)
            chmat="UmatREC["//chmat(nfirst:nlast)//"]"
          else
            mater = imatmagpol(imp)
            write(chmat,*)mater-1
            call util_string_trim(chmat,nfirst,nlast)
            chmat="UmatIron["//chmat(nfirst:nlast)//"]"
          endif !Pole/Mag

          if (t_magnets(kproto)%nzdiv*t_magnets(kproto)%nydiv*t_magnets(kproto)%nxdiv.gt.1) then
            write(lunrad,'(a)')
            write(cline,*)
     &        "rad.ObjDivMag("//trim(adjustl(t_magcopy(imp)%cnam))//", [[",
     &        t_magnets(kproto)%nzdiv,",",
     &        sngl(t_magnets(kproto)%zfracdiv),"],",t_magnets(kproto)%nxdiv,
     &        ",[",t_magnets(kproto)%nydiv,",",
     &        sngl(t_magnets(kproto)%yfracdiv),"]],'kxkykz->Numb')"
            call util_remove_double_blanks(cline,cout,lenout)
            write(lunrad,'(a)') cout(2:lenout)
            write(lunrad,'(a)')
          endif

          write(lunrad,'(a)')
          write(lunrad,'(a)')"rad.MatApl("//trim(adjustl(t_magcopy(imp)%cnam))//","//
     &      trim(chmat)//")"

        else !cylinder:

          do ivox=1,nvoxcopy_t

            kproto=t_voxcopy(ivox)%kproto
            if (t_magnets(kproto)%ctype.ne.'Cylinder') cycle

            kmagnet=t_voxcopy(ivox)%kmagnet
            kvoxel=t_voxcopy(ivox)%kvoxel

            cline=adjustl(t_magcopy(imp)%cnam)
            call util_string_append(cline,'_',nfirst,nlast)
            ixdiv=t_magnets(kproto)%t_voxels(kvoxel)%ixdiv
            call util_string_append_num(cline,ixdiv,nfirst,nlast)
            call util_string_append(cline,'_',nfirst,nlast)
            iydiv=t_magnets(kproto)%t_voxels(kvoxel)%iydiv
            call util_string_append_num(cline,iydiv,nfirst,nlast)
            call util_string_append(cline,'_',nfirst,nlast)
            izdiv=t_magnets(kproto)%t_voxels(kvoxel)%izdiv
            call util_string_append_num(cline,izdiv,nfirst,nlast)
            cnam=trim(cline)
            call util_string_append(cline," = rad.ObjPolyhdr([ \",nfirst,nlast)

            write(lunrad,'(a)') trim(cline)

            gcen=t_voxcopy(ivox)%gcen

            npoi=t_magnets(kproto)%t_voxels(kvoxel)%nhull
            do ipoi=1,npoi

              write(c32x,*)sngl(t_magnets(kproto)%t_voxels(kvoxel)%xhull(ipoi)+
     &          gcen(1))
              write(c32y,*)sngl(t_magnets(kproto)%t_voxels(kvoxel)%yhull(ipoi)+
     &          gcen(2))
              write(c32z,*)sngl(t_magnets(kproto)%t_voxels(kvoxel)%zhull(ipoi)+
     &          gcen(3))

              if (ipoi.lt.npoi) then
                write(clunrad,*)
     &            "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"],"
                write(lunrad,'(a)') trim(clunrad)
              else
                write(clunrad,*)
     &            "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"]],[ \"
                write(lunrad,'(a)') trim(clunrad)
              endif

            enddo !ipoi

            nface=t_magnets(kproto)%t_voxels(kvoxel)%nface
            do iface=1,t_magnets(kproto)%t_voxels(kvoxel)%nface

              k=t_magnets(kproto)%t_voxels(kvoxel)%lface(iface)
              npoi=t_magnets(kproto)%t_voxels(kvoxel)%kface(k)

              cline="         ["

              do ipoi=1,npoi
                call util_string_append_num(cline,
     &            t_magnets(kproto)%t_voxels(kvoxel)%kface(k+ipoi),nfirst,nlast)
                if (ipoi.lt.npoi) then
                  call util_string_append(cline,',',nfirst,nlast)
                else
                  call util_string_append(cline,'],',nfirst,nlast)
                endif
              enddo !ipoi

              if (iface.lt.nface) then
                write(lunrad,'(a)')cline(1:nlast)
c                call util_string_append(cline,'],',nfirst,nlast)
              else
                write(lunrad,'(a)')cline(1:nlast-1) // '], \'
              endif

            enddo !nface

            if (t_magnets(kproto)%IsPole.eq.0) then
              write(c32x,*)t_voxcopy(kvoxel)%br(1)
              write(c32y,*)t_voxcopy(kvoxel)%br(2)
              write(c32z,*)t_voxcopy(kvoxel)%br(3)
              write(clunrad,*)"         [",trim(c32z),",",trim(c32x),",",trim(c32y),"])"
              write(lunrad,'(a)') trim(clunrad)
              mater = imatmagpol(imp)
              write(chmat,*)mater-1
              call util_string_trim(chmat,nfirst,nlast)
              chmat="UmatREC["//chmat(nfirst:nlast)//"]"
            else
              write(lunrad,'(a)')"[0,0,0])"
              mater = imatmagpol(imp)
              write(chmat,*)mater-1
              call util_string_trim(chmat,nfirst,nlast)
              chmat="UmatIron["//chmat(nfirst:nlast)//"]"
            endif !Pole/Mag

            write(lunrad,'(a)')
            write(lunrad,'(a)')"rad.MatApl("//trim(cnam)//","//
     &        trim(chmat)//")"

          enddo !nvoxcopy_t

        endif !(t_magnets(kproto)%ctype.ne.'Cylinder') then

      enddo !imp=1,nmagtot_t

      write(lunrad,'(a)')"UnduMag = mshObjCnt('UnduMag')"
      write(lunrad,'(a)')"UnduPol = mshObjCnt('UnduPol')"
      write(lunrad,'(a)')"AllMagPols = mshObjCnt('AllMagPols')"

      nUnduMag = 0
      nUnduPol = 0
      nMagPolTot = 0

      write(lunrad,'(a)')"nUnduMag = 0"
      write(lunrad,'(a)')"nUnduPol = 0"
      write(lunrad,'(a)')"nMagPolTot = 0"

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        if(t_magnets(kproto)%ctype.ne.'Cylinder') then

          if (t_magnets(kproto)%IsPole.eq.0) then

            nUnduMag=nUnduMag+1

            write(c32,*)nUnduMag
            write(lunrad,'(a)')"nUnduMag = " // trim(adjustl(c32))
            write(lunrad,'(a)')"mshObjAddToCnt(UnduMag," //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"

            nMagPolTot=nMagPolTot+1

            write(c32,*)nMagPolTot
            write(lunrad,'(a)')"nMagPolTot = " // trim(adjustl(c32))
            write(lunrad,'(a)')"mshObjAddToCnt(AllMagPols," //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"
            write(lunrad,'(a)')

            if (t_magcopy(imp)%cnam.eq.chforcemag) then
              write(lunrad,'(a)')
              write(lunrad,'(a)')"iForceTyp = 1"
              write(lunrad,'(a)') trim(clunrad)
              write(c32,*)nUnduMag
              write(lunrad,'(a)')"nForce = " // trim(adjustl(c32))
              write(lunrad,'(a)')
            endif

          else ! IsPole

            nUnduPol=nUnduPol+1

            write(c32,*)nUnduPol
            write(lunrad,'(a)')"nUnduPol = " // trim(adjustl(c32))
            write(lunrad,'(a)')"mshObjAddToCnt(UnduPol," //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"

            nMagPolTot=nMagPolTot+1

            write(c32,*)nMagPolTot
            write(lunrad,'(a)')"nMagPolTot = " // trim(adjustl(c32))
            write(lunrad,'(a)')"mshObjAddToCnt(AllMagPols," //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"
            write(lunrad,'(a)')

            if (t_magcopy(imp)%cnam.eq.chforcemag) then
              write(lunrad,'(a)')
              write(lunrad,'(a)')"iForceTyp = 1"
              write(lunrad,'(a)') trim(clunrad)
              write(c32,*)nUnduPol
              write(lunrad,'(a)')"nForce = " // trim(adjustl(c32))
              write(lunrad,'(a)')
            endif

          endif !IsPole

        else ! Cylinder

          do ivox=1,nvoxcopy_t

            if (t_magnets(kproto)%ctype.ne.'Cylinder') cycle

            if (t_magnets(kproto)%IsPole.eq.0) then

              kmagnet=t_voxcopy(ivox)%kmagnet
              kvoxel=t_voxcopy(ivox)%kvoxel

              nUnduMag=nUnduMag+1

              cline=adjustl(t_magcopy(imp)%cnam)
              call util_string_append(cline,'_',nfirst,nlast)
              ixdiv=t_magnets(kproto)%t_voxels(kvoxel)%ixdiv
              call util_string_append_num(cline,ixdiv,nfirst,nlast)
              call util_string_append(cline,'_',nfirst,nlast)
              iydiv=t_magnets(kproto)%t_voxels(kvoxel)%iydiv
              call util_string_append_num(cline,iydiv,nfirst,nlast)
              call util_string_append(cline,'_',nfirst,nlast)
              izdiv=t_magnets(kproto)%t_voxels(kvoxel)%izdiv
              call util_string_append_num(cline,izdiv,nfirst,nlast)
              cnam=trim(cline)

              write(c32,*)nUnduMag
              write(lunrad,'(a)')"nUnduMag = " // trim(adjustl(c32))
              write(lunrad,'(a)')"mshObjAddToCnt(UnduMag," //
     &          trim(adjustl(t_magcopy(imp)%cnam)) // ")"

              nMagPolTot=nMagPolTot+1

              write(c32,*)nMagPolTot
              write(lunrad,'(a)')"nMagPolTot = " // trim(adjustl(c32))
              write(lunrad,'(a)')"mshObjAddToCnt(AllMagMags," //
     &          trim(adjustl(t_magcopy(imp)%cnam)) // ")"
              write(lunrad,'(a)')

              if (t_magcopy(imp)%cnam.eq.chforcemag) then
                write(lunrad,'(a)')' '
                write(lunrad,'(a)')"iForceTyp = 1"
                write(c32,*)nUnduMag
                write(lunrad,'(a)')"nForce = " // trim(adjustl(c32))
                write(lunrad,'(a)')
                print*,"*** Warning in clcmag_to_msh_radia: Force calculations for cylinders not yet tested..."
              endif

            else !IsPole

              kmagnet=t_voxcopy(ivox)%kmagnet
              kvoxel=t_voxcopy(ivox)%kvoxel

              nUnduPol=nUnduPol+1

              cline=adjustl(t_magcopy(imp)%cnam)
              call util_string_append(cline,'_',nfirst,nlast)
              ixdiv=t_magnets(kproto)%t_voxels(kvoxel)%ixdiv
              call util_string_append_num(cline,ixdiv,nfirst,nlast)
              call util_string_append(cline,'_',nfirst,nlast)
              iydiv=t_magnets(kproto)%t_voxels(kvoxel)%iydiv
              call util_string_append_num(cline,iydiv,nfirst,nlast)
              call util_string_append(cline,'_',nfirst,nlast)
              izdiv=t_magnets(kproto)%t_voxels(kvoxel)%izdiv
              call util_string_append_num(cline,izdiv,nfirst,nlast)
              cnam=trim(cline)

              write(c32,*)nUnduPol
              write(lunrad,'(a)')"nUnduPol = " // trim(adjustl(c32))
              write(lunrad,'(a)')"mshObjAddToCnt(UnduPol," //
     &          trim(adjustl(t_magcopy(imp)%cnam)) // ")"

              nMagPolTot=nMagPolTot+1

              write(c32,*)nMagPolTot
              write(lunrad,'(a)')"nMagPolTot = " // trim(adjustl(c32))
              write(lunrad,'(a)')"mshObjAddToCnt(AllMagPols," //
     &          trim(adjustl(t_magcopy(imp)%cnam)) // ")"
              write(lunrad,'(a)')

              if (t_magcopy(imp)%cnam.eq.chforcemag) then
                write(lunrad,'(a)')' '
                write(lunrad,'(a)')"iForceTyp = 1"
                write(c32,*)nUnduPol
                write(lunrad,'(a)')"nForce = " // trim(adjustl(c32))
                write(lunrad,'(a)')
                print*,"*** Warning in clcmag_to_msh_radia: Force calculations for cylinders not yet tested..."
              endif

            endif !IsPole

          enddo !nvox

        endif !(t_magnets(kproto)%ctype.ne.'Cylinder') then

      enddo !imp=1,nmagtot_t

      deallocate(brrec)

      write(c32,*) ncwires
      write(lunrad,'(a)')'nUnduFilaments = ' // trim(adjustl(c32))

      if (iunduplot.lt.0.or.iundugeo.lt.0.or.ivrml.lt.0) then
        write(lunrad,'(a)')'iSolve = 0'
      else
        write(lunrad,'(a)')'iSolve = 1'
      endif

      write(lunrad,'(a)')
      write(lunrad,'(a)')'#-- End of lines generated by UNDUMAG --'
      write(lunrad,'(a)')

      write(lunrad,'(a)')
      write(lunrad,'(a)')'#-- Reading undumag_proc_msh_radia.py and appending to undumag_radia.py --'
      write(lunrad,'(a)')

      open(newunit=lunproc,file='undumag_proc_msh_radia.py',status='old', iostat=istat)

      if (istat.ne.0) then

        write(lun6,*)"*** Error in clcmag_to_msh_radia: File undumag_proc_msh_radia.py not found ***"

      else

        ieof=0
        cline=''

        do while (ieof.eq.0)
          read(lunproc,'(a)',iostat=ieof) cline
          if (ieof.eq.0) write(lunrad,'(a)') trim(cline)
        enddo
        close(lunproc)

      endif

      flush(lunrad)
      close(lunrad)

      return
      end
+DECK,clc_concave_to_convex.
*CMZ :  2.05/01 11/10/2023  17.25.06  by  Michael Scheer
*-- Author :    Michael Scheer   02/10/2023
      subroutine clc_concave_to_convex

      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use utilmod

      implicit none

      character(512), dimension(:), allocatable :: cbuff
      character(512) cline,cfile
      character(128) ckey

      double precision, dimension (:), allocatable :: xp,yp,zp,
     &  xcuts,ycuts,zcuts

      double precision x,y,z

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface,
     &  lconcave,ibuff

      integer i,iconcave,nconcave,l,ipoi,npoi,luni,nplan,iplan,nline,
     &  nverts,nbuff,nface,nedge,nhull,kfacelast,kfail,kcut

+seq,hulldim.

      integer :: ipos(2,1000),nwords,istat,nallo=1000,nfacemax,npoimax

      Type(T_Concave) tc1,tc2

      allocate(lconcave(nconcave_t/5))
      allocate(xp(nallo),yp(nallo),zp(nallo),cbuff(nallo),ibuff(nallo),
     &  xcuts(nallo),ycuts(nallo),zcuts(nallo))
      allocate(khull(nallo),kface(nallo),kedge(4,nallo))
      lenhull=nallo
      lenedge=nallo
      lenface=nallo
      nverhullmax=nallo

      nconcave=0
      do i=1,nconcave_t
        cline=clcconcave(i)
        call util_string_split(cline,1000,nwords,ipos,istat)
        if (cline(1:1).eq.'&') then
          nconcave=nconcave+1
          lconcave(nconcave)=i
        endif
      enddo

      nconcave_t=nconcave

      allocate(t_concaves(nconcave_t))

      do iconcave=1,nconcave_t

        i=lconcave(iconcave)

        cline=clcconcave(i)
        call util_string_split(cline,1000,nwords,ipos,istat)

        if (cline(1:1).eq.'&') then

          tc1%ispole=0
          tc1%isspecial=1
          ckey=cline(ipos(1,2):ipos(2,2))
          call util_lower_case(ckey)

          if (ckey.eq.'special_convex_magnet'.or.
     &      ckey.eq.'special_convex_pole') tc1%isspecial=1

          if (ckey.eq.'convex_pole'.or.
     &      ckey.eq.'special_convex_pole') tc1%ispole=1

          cline=clcconcave(i+1)
          call util_string_split(cline,1000,nwords,ipos,istat)
          ckey=cline(ipos(1,1):ipos(2,1))
          call util_lower_case(ckey)

          if (ckey.ne.'file') then
            print*,"*** Error in CLC_CONCAVE_TO_CONVEX: Concave items must be read from file ***"
            stop "UNDUMAG aborted"
          endif

          nfacemax=0
          nplanmax=0

          cline=clcconcave(i+5)
          call util_string_split(cline,1000,nwords,ipos,istat)
          cfile=cline(ipos(1,1):ipos(2,1))
          nline=0
          open(newunit=luni,file=cfile,status='old')

          do while (.true.)
            read(luni,'(a)',iostat=istat) cline
            if (istat.eq.0) then
              nline=nline+1
              if (nline.gt.nallo) then
                deallocate(xp,yp,zp,cbuff,ibuff,kface,kedge,khull)
                nallo=nline*2
                allocate(xp(nallo),yp(nallo),zp(nallo),cbuff(nallo),
     &            ibuff(nallo))
                allocate(khull(nallo),kface(nallo),kedge(4,nallo))
                lenhull=nallo
                lenedge=nallo
                lenface=nallo
                nverhullmax=nallo
              endif
              cbuff(nline)=cline
            else
              exit
            endif
          enddo
          close(luni)

          i=1
          read(cbuff(i),*)nverts
          tc1%nverts=nverts

          allocate(tc1%verts(3,nverts))

          do ipoi=1,nverts
            i=i+1
            read(cbuff(i),*) x,y,z
            tc1%verts(:,ipoi)=[x,y,z]
          enddo

          i=i+1
          read(cbuff(i),*)nplan
          tc1%nface=nplan

          allocate(tc1%lifaces(nplan),tc1%npois(nplan))
          npoimax=0

          do iplan=1,nplan
            i=i+1
            read(cbuff(i),*)npoi
            if(npoi.gt.npoimax) npoimax=npoi
            i=i+1
            tc1%lifaces(iplan)=i
            tc1%npois(iplan)=npoi
          enddo

          tc1%npoimax=npoimax
          allocate(tc1%ifaces(npoimax,nplan))

          nbuff=0
          do iplan=1,nplan
            l=tc1%lifaces(iplan)
            npoi=tc1%npois(iplan)
            read(cbuff(l),*) tc1%ifaces(1:npoi,iplan)
            read(cbuff(l),*) ibuff(nbuff+1:nbuff+npoi)
            nbuff=nbuff+npoi
          enddo

          xp(1:nverts)=tc1%verts(1,1:nverts)
          yp(1:nverts)=tc1%verts(2,1:nverts)
          zp(1:nverts)=tc1%verts(3,1:nverts)

          if (nbuff*2*npoimax.gt.nallo) then
            nallo=nbuff*2*npoimax*2
            deallocate(xp,yp,zp,cbuff,ibuff,kface,kedge,khull)
            allocate(xp(nallo),yp(nallo),zp(nallo),cbuff(nallo),ibuff(nallo))
            allocate(khull(nallo),kface(nallo),kedge(4,nallo))
            lenhull=nallo
            lenedge=nallo
            lenface=nallo
            nverhullmax=nallo
          endif

          call util_hull_check_convex(
     &      nverts,tc1%verts(:,1:nverts),khull,kedge,kface,
     &      nhull,nedge,nface,kfacelast,nbuff,ibuff,hulltiny,kfail)

          allocate(tc1%kface(kfacelast),tc1%kedge(4,nedge))

          tc1%IsConvex=1
          tc1%nconcave=0

          if (nhull.ne.nverts) then
            tc1%nconcave=nbuff
            allocate(tc1%Kconcave(nbuff))
            do i=1,nbuff
              if (ibuff(i).gt.0) then
                tc1%IsConvex=0
                exit
              endif
            enddo
            tc1%kconcave(1:nbuff)=ibuff(1:nbuff)
          endif

          if (tc1%IsConvex.ne.0) then
            t_concaves(iconcave)=tc1
            cycle
          endif

          call clc_cut_concave(tc1,tc2,kcut)

          t_concaves(iconcave)=tc1
        endif !&

      enddo !iconcave

      deallocate(lconcave,xp,yp,zp,cbuff,ibuff,xcuts,ycuts,zcuts,
     &  khull,kface,kedge)

      return
      end
+DECK,clc_cut_concave.
*CMZ :  2.05/01 11/10/2023  17.22.07  by  Michael Scheer
*-- Author :    Michael Scheer   02/10/2023
      subroutine clc_cut_concave(tc1,tc2,kcut)

      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use utilmod

      implicit none

      double precision, dimension(:,:), allocatable :: verts,verts1,verts2,
     &  vwork,verts2d
      double precision, dimension(:), allocatable :: xb,yb,zb

      integer, dimension(:,:), allocatable :: ifaces1,ifaces2,ifaces
      integer, dimension(:), allocatable :: npois1,npois2,npois,
     &  lifaces,lifaces1,lifaces2,khull,ivera2d

      double precision ymin,ymax,
     &  pcut(3),p1(3),p2(3),p3(3),vnor(3),dot,pcen(3),rotmat(3,3),pcenrot(3),
     &  rotinv(3,3),x1,x2,y1,y2,z1,z2,xc(2),zc(2),cut,dy,p(3),q(3)
c      double precision u33(3,3),w33(3,3)

      integer :: kpoicut,kcut,iplan,ipoi,npoi,kplancut,isig,isigo,
     &  i,istatus,nallo=-32,npoimax,npoimax1,npoimax2,nface,nface1,nface2,n1,n2,
     &  nverts1,nverts2,nverts,ic,lcut(2),icut(2),ifound,mfaces,k,
     &  ntri,itri,idebug=0,iscutplan

+seq,hulldim.

      Type(T_Concave) tc1,tc2

      save nallo

      if (nallo.lt.0) then
        nallo=-nallo
        allocate(xb(nallo),yb(nallo),zb(nallo),
     &    vwork(3,nallo),verts(3,nallo),verts2d(2,nallo),
     &    ifaces(nallo,nallo),ifaces1(nallo,nallo),ifaces2(nallo,nallo),
     &    lifaces(nallo),lifaces1(nallo),lifaces2(nallo),
     &    npois(nallo),npois1(nallo),npois2(nallo),khull(nallo),ivera2d(nallo))
      endif

      if (nallo.lt.max(npoimax,nface)**2) then
        deallocate(xb,yb,zb,verts,ifaces1,ifaces2,npois1,npois2,khull,
     &    verts2d,ivera2d)
        nallo=2*max(npoimax,nface)**2
        allocate(xb(nallo),yb(nallo),zb(nallo),verts2d(2,nallo),
     &    vwork(3,nallo),verts(3,nallo),
     &    ifaces(nallo,nallo),ifaces1(nallo,nallo),ifaces2(nallo,nallo),
     &    lifaces(nallo),lifaces1(nallo),lifaces2(nallo),
     &    npois(nallo),npois1(nallo),npois2(nallo),khull(nallo),ivera2d(nallo))
      endif

      npoimax=tc1%npoimax
      nface=tc1%nface
      ifaces(1:npoimax,1:nface)=tc1%ifaces(1:npoimax,1:nface)
      npois(1:nface)=tc1%npois(1:nface)
      lifaces(1:nface)=tc1%lifaces(1:nface)
      nverts=tc1%nverts
      verts=tc1%verts

      kcut=0
      if (tc1%isconvex.ne.0.or.tc1%nconcave.eq.0) return

      !call util_break

      ! Triangulation

      mfaces=nface
      do iplan=1,mfaces

        npoi=npois(iplan)
        khull(1:npoi)=ifaces(1:npoi,iplan)
        xb(1:npoi)=verts(1,ifaces(1:npoi,iplan))
        yb(1:npoi)=verts(2,ifaces(1:npoi,iplan))
        zb(1:npoi)=verts(3,ifaces(1:npoi,iplan))

        p=[xb(2)-xb(1),yb(2)-yb(1),zb(2)-zb(1)]
        q=[xb(3)-xb(2),yb(3)-yb(2),zb(3)-zb(2)]

        call util_vcross(p,q,vnor)
        vnor=abs(vnor)/norm2(vnor)

        if (vnor(1).gt.0.1d0) then
          verts2d(1,1:npoi)=yb(1:npoi)
          verts2d(2,1:npoi)=zb(1:npoi)
        else if (vnor(2).gt.0.1d0) then
          verts2d(1,1:npoi)=xb(1:npoi)
          verts2d(2,1:npoi)=zb(1:npoi)
        else
          verts2d(1,1:npoi)=xb(1:npoi)
          verts2d(2,1:npoi)=yb(1:npoi)
        endif

        call  util_triangu_2d(npoi,verts2d,ivera2d,ntri,tiny,istatus)

        ifaces(1:3,iplan)=khull(ivera2d(1:3))
        npois(iplan)=3

        do itri=2,ntri
          nface=nface+1
          ifaces(1:3,nface)=khull(ivera2d((itri-1)*3+1:(itri-1)*3+3))
          npois(nface)=3
        enddo

      enddo !nface

      kpoicut=tc1%kconcave(1)
      pcut=verts(:,kpoicut)

      kplancut=0
      do iplan=1,nface
        npoi=npois(iplan)
        do ipoi=1,npoi
          if(ifaces(ipoi,iplan).eq.kpoicut) then
            kplancut=iplan
            exit
          endif
        enddo
        if (kplancut.gt.0) then
          isigo=0
          p1=verts(:,ifaces(1,kplancut))
          p2=verts(:,ifaces(2,kplancut))
          p3=verts(:,ifaces(3,kplancut))
          pcen=(p1+p2+p3)/3.0d0
          call util_vcross(p2-p1,p3-p2,vnor)
          vnor=vnor/norm2(vnor)
          do i=1,nverts
            dot=dot_product(verts(:,i)-pcen,vnor)
            if (dot.gt.hulltiny) then
              isig=1
            else if (dot.lt.-hulltiny) then
              isig=-1
            else
              isig=0
            endif
            if (isigo.eq.0.and.isig.ne.0) isigo=isig
            if (isig.ne.0.and.isig.ne.isigo) then
              kplancut=-kplancut
              exit
            endif
          enddo
        endif
        if (kplancut.lt.0) then
          exit
        else
          kplancut=0
        endif
      enddo

      if (kplancut.gt.0) then
        kcut=-1
        return
      endif

      kplancut=-kplancut
      kcut=1

      call util_rotate_vector_to_y_axis(vnor,rotmat,istatus)
      rotinv=transpose(rotmat)

c      call util_matrix_multiplication(3,3,3,rotmat,rotinv,u33,w33)
c      do i=1,3
c        print*,u33(i,1:3)
c      enddo
c      stop
      call util_mat_mul_vec_3x3(rotmat,pcen,pcenrot)
      do i=1,nverts
        call util_mat_mul_vec_3x3(rotmat,verts(:,i),vwork(:,i))
        write(88,*)sngl(verts(:,i)),sngl(vwork(:,i)),i
        flush(88)
      enddo
      verts=vwork

      write(80,*)nverts
      do i=1,nverts
        write(80,*)verts(:,i)
      enddo
      write(80,*)nface
      do iplan=1,nface
        npoi=npois(iplan)
        write(80,*)npoi
        write(80,*)ifaces(1:npoi,iplan)
      enddo
      flush(80)

      cut=pcenrot(2)

      nface1=0
      nface2=0
      npoimax1=0
      npoimax2=0
      nverts1=nverts
      nverts2=nverts

      verts1=verts
      verts2=verts

      if (idebug.ne.0) call util_break
      !print*,cut
      do iplan=1,nface

        ic=0
        icut=0
        npoi=npois(iplan)

        do ipoi=1,npoi
          xb(ipoi)=verts(1,ifaces(ipoi,iplan))
          yb(ipoi)=verts(2,ifaces(ipoi,iplan))
          zb(ipoi)=verts(3,ifaces(ipoi,iplan))
          if (idebug.ne.0) then
            write(89,*)xb(ipoi),yb(ipoi),zb(ipoi),ipoi,iplan
            flush(89)
          endif
        enddo

        xb(npoi+1)=xb(1)
        yb(npoi+1)=yb(1)
        zb(npoi+1)=zb(1)

        ymin=minval(yb(1:npoi))
        ymax=maxval(yb(1:npoi))

c        print*,iplan,ymin,ymax

        if (abs(ymax-ymin).lt.hulltiny.and.abs(ymax-cut).lt.hulltiny) then
          iscutplan=1
        else
          iscutplan=0
        endif

        if(iscutplan.eq.0.and.ymax.le.cut+hulltiny) then
          nface1=nface1+1
          ifaces1(1:npoi,nface1)=ifaces(1:npoi,iplan)
          npois1(nface1)=npoi
        else if(ymin.ge.cut-hulltiny) then
          nface2=nface2+1
          ifaces2(1:npoi,nface2)=ifaces(1:npoi,iplan)
          npois2(nface2)=npoi
        else
          do ipoi=1,npoi
            x1=xb(ipoi)
            x2=xb(ipoi+1)
            y1=yb(ipoi)
            y2=yb(ipoi+1)
            z1=zb(ipoi)
            z2=zb(ipoi+1)
            if (y1.lt.cut-hulltiny.and.y2.gt.cut+hulltiny
     &          .or.
     &          y1.gt.cut+hulltiny.and.y2.lt.cut-hulltiny) then
c              print*,iplan,cut
c              print*,x1,y1,z1
c              print*,x2,y2,z2
              dy=(cut-y1)/(y2-y1)
c              print*,dy
              ic=ic+1
              if (ic.gt.2) then
                stop "*** Schneidefehler!"
              endif
              icut(ic)=ipoi
              xc(ic)=x1+(x2-x1)*dy
              zc(ic)=z1+(z2-z1)*dy
c              print*,xc(ic),zc(ic)
            endif !cut it
          enddo
        endif

        if (ic.ne.0) then

c          call util_break

          do i=1,ic
            ifound=0
            p1=[xc(i),cut,zc(i)]
            do ipoi=1,nverts
              if(norm2(p1-verts(:,ipoi)).lt.hulltiny) then
                ifound=1
                exit
              endif
            enddo
            if (ifound.eq.0) then
              nverts=nverts+1
              lcut(i)=nverts
              verts(:,nverts)=p1
              npois(iplan)=npois(iplan)+1
              ifaces(npois(iplan),iplan)=nverts
              xb(npois(iplan))=p1(1)
              yb(npois(iplan))=p1(2)
              zb(npois(iplan))=p1(3)
            else
              npois(iplan)=npois(iplan)+1
              ifaces(npois(iplan),iplan)=ipoi
              lcut(i)=icut(i)
              xb(npois(iplan))=p1(1)
              yb(npois(iplan))=p1(2)
              zb(npois(iplan))=p1(3)
            endif
          enddo

          nface1=nface1+1
          nface2=nface2+1

          n1=0
          n2=0

          do i=1,npois(iplan)
            k=ifaces(i,iplan)
            if(abs(yb(i)-cut).le.hulltiny) then
c              if (k.eq.lcut(1).or.k.eq.lcut(2)) then
                n1=n1+1
                ifaces1(n1,nface1)=k
                n2=n2+1
                ifaces2(n2,nface2)=k
c              else
c                n1=n1+1
c                ifaces1(n1,nface1)=ifaces(i,iplan)
c                n2=n2+1
c                ifaces2(n2,nface2)=ifaces(i,iplan)
c              endif
            else if(yb(i).le.cut+hulltiny) then
c              if (k.eq.lcut(1).or.k.eq.lcut(2)) then
                n1=n1+1
                ifaces1(n1,nface1)=k
c              else
c                n1=n1+1
c                ifaces1(n1,nface1)=ifaces(i,iplan)
c              endif
            else if(yb(i).ge.cut-hulltiny) then
c              if (k.eq.lcut(1).or.k.eq.lcut(2)) then
                n2=n2+1
                ifaces2(n2,nface2)=k
c              else
c                n2=n2+1
c                ifaces2(n2,nface2)=ifaces(i,iplan)
c              endif
            endif
          enddo
          npois1(nface1)=n1
          npois2(nface2)=n2
        endif
      enddo !nface

      do i=1,nverts
        call util_mat_mul_vec_3x3(rotinv,verts(:,i),vwork(:,i))
      enddo
      verts=vwork

      n1=0
      npoimax=0
      do iplan=1,nface1
        npoi=npois1(iplan)
        if (npoi.gt.npoimax) npoimax=npoi
        do ipoi=1,npoi
          n1=n1+1
          i=ifaces1(ipoi,iplan)
          xb(n1)=verts(1,i)
          yb(n1)=verts(2,i)
          zb(n1)=verts(3,i)
        enddo
      enddo

      call util_weed_points(n1,xb,yb,zb,hulltiny**2)

      if (n1.gt.tc1%nverts) then
        allocate(tc1%verts(3,n1))
        deallocate(tc1%verts)
      endif
      tc1%nverts=n1

      do ipoi=1,n1
        if (idebug.ne.0) then
          write(81,*)xb(ipoi),yb(ipoi),zb(ipoi),ipoi
          flush(81)
        endif
        tc1%verts(:,ipoi)=[xb(ipoi),yb(ipoi),zb(ipoi)]
      enddo

      if (nface1.gt.tc1%nface.or.npoimax.gt.tc1%npoimax) then
        deallocate(tc1%ifaces)
        allocate(tc1%ifaces(npoimax,nface1))
        deallocate(tc1%lifaces,tc1%npois)
        allocate(tc1%lifaces(nface1),tc1%npois(nface1))
      endif
      tc1%nface=nface1
      tc1%npoimax=npoimax

      n1=1
      do iplan=1,nface1
        npoi=npois1(iplan)
        tc1%npois(iplan)=npoi
        tc1%ifaces(1:npoi,iplan)=ifaces1(1:npoi,iplan)
        lifaces(iplan)=n1
        n1=n1+npoi
      enddo

      n2=0
      npoimax=0
      do iplan=1,nface2
        npoi=npois2(iplan)
        if (npoi.gt.npoimax) npoimax=npoi
        do ipoi=1,npoi
          n2=n2+1
          i=ifaces2(ipoi,iplan)
          xb(n2)=verts(1,i)
          yb(n2)=verts(2,i)
          zb(n2)=verts(3,i)
        enddo
      enddo

      call util_weed_points(n2,xb,yb,zb,hulltiny**2)

      if (n2.gt.tc2%nverts) then
        allocate(tc2%verts(3,n2))
        deallocate(tc2%verts)
      endif
      tc2%nverts=n2

      do ipoi=1,n2
        if (idebug.ne.0) then
          write(82,*)xb(ipoi),yb(ipoi),zb(ipoi),ipoi
          flush(82)
        endif
        tc2%verts(:,ipoi)=[xb(ipoi),yb(ipoi),zb(ipoi)]
      enddo

      if (nface2.gt.tc2%nface.or.npoimax.gt.tc2%npoimax) then
        deallocate(tc2%ifaces)
        allocate(tc2%ifaces(npoimax,nface2))
        deallocate(tc2%lifaces,tc2%npois)
        allocate(tc2%lifaces(nface2),tc2%npois(nface2))
      endif
      tc2%nface=nface2
      tc2%npoimax=npoimax

      n2=1
      do iplan=1,nface2
        npoi=npois2(iplan)
        tc2%npois(iplan)=npoi
        tc2%ifaces(1:npoi,iplan)=ifaces2(1:npoi,iplan)
        lifaces(iplan)=n2
        n2=n2+npoi
      enddo

      return
      end
+PATCH,KUMAC,T=KUMAC.
*CMZ :  0.00/00 20/04/2016  13.01.38  by  Michael Scheer
+DECK,out,T=KUMAC.
*CMZ :  2.05/01 22/10/2023  11.47.02  by  Michael Scheer
*CMZ :  1.11/00 06/12/2016  14.42.42  by  Michael Scheer
*CMZ :  1.17/02 03/10/2014  11.31.31  by  Michael Scheer
*CMZ :  1.17/01 03/10/2014  10.49.36  by  Michael Scheer
*CMZ :  1.17/00 25/08/2014  15.26.02  by  Michael Scheer
*CMZ :  1.16/04 17/04/2014  12.22.05  by  Michael Scheer
*CMZ :  1.16/01 14/03/2014  10.19.54  by  Michael Scheer
*CMZ :  1.15/02 30/04/2008  13.28.31  by  Michael Scheer
*CMZ :  1.15/01 24/04/2008  11.30.03  by  Michael Scheer
*CMZ :  1.12/16 04/06/2007  06.18.51  by  Michael Scheer
*CMZ :  1.12/15 21/05/2007  15.22.52  by  Michael Scheer
*CMZ :  1.12/05 02/07/2006  12.51.11  by  Michael Scheer
*-- Author :    Michael Scheer   02/07/2006
macro out d1='bpolyplot' d2='bpolypl2' d3='!' d4='!'

mess 'Besser cmake, wenn doch uout_omp!'
*exec uout_omp
exitm

* +PATCH,//POLYMAG/KUMAC
* +DECK,out,T=KUMAC.

she rm -f polymag.exe

*exec dmplot
*cmake
* exec dcc
*exec dmshplt
*cmake

exec dpoly
cmake
*exec dgfor

set polymag.f -f
*cx /main/polymag_loop_int /for
*cx /main/henry_freund /for
*cx /main/polymag /for/bpolyplot /for/bpolypl2 /util /mcern /mplot
*cx /main/polymag /for/bpolyplot /for/bpolypl2

+self,if=-allmsh.
if [d4].ne.'!' then
  cx /main/polymag [d1] [d2] [d3] [d4]
elseif [d3].ne.'!' then
  cx /main/polymag [d1] [d2] [d3]
elseif [d2].ne.'!' then
  cx /main/polymag [d1] [d2]
elseif [d1].ne.'!' then
  cx /main/polymag [d1]
endif
+self.
+self,if=allmsh.
if [d4].ne.'!' then
  cx /main/polymag [d1] [d2] [d3] [d4] //mshplt/for //mshplt/util //mshplt/mplot
elseif [d3].ne.'!' then
  cx /main/polymag [d1] [d2] [d3] //mshplt/for //mshplt/util //mshplt/mplot
elseif [d2].ne.'!' then
  cx /main/polymag [d1] [d2] //mshplt/for //mshplt/util //mshplt/mplot
elseif [d1].ne.'!' then
  cx /main/polymag [d1] //mshplt/for //mshplt/util //mshplt/mplot
endif
+self.

exitm
+DECK,outpy,T=KUMAC.
*CMZ :  2.05/01 22/10/2023  16.33.19  by  Michael Scheer
*CMZ :  2.02/00 02/02/2021  19.07.52  by  Michael Scheer
*-- Author :    Michael Scheer   12/10/2020
macro outpy

* +PATCH,//UNDUMAG/KUMAC
* +DECK,outpy,T=KUMAC.

cd //undumag

seq .

exec dpython

cx undugui
cx undumag_plot

exitm
+PATCH,SYSTEM,T=KUMAC.
*CMZ :  0.00/00 20/04/2016  13.01.46  by  Michael Scheer
+DECK,cmzsymbols, T=KUMAC.
*CMZ :  2.05/01 22/10/2023  14.32.24  by  Michael Scheer
*CMZ :  2.04/13 02/09/2023  08.28.49  by  Michael Scheer
*CMZ :  2.04/06 13/07/2023  14.08.35  by  Michael Scheer
*CMZ :  2.04/05 15/03/2023  13.14.33  by  Michael Scheer
*CMZ :  2.03/00 26/08/2022  11.02.19  by  Michael Scheer
*CMZ :  2.02/02 27/02/2022  17.51.38  by  Michael Scheer
*CMZ :  2.02/01 06/02/2022  11.20.59  by  Michael Scheer
*CMZ :  2.02/00 01/04/2021  07.16.16  by  Michael Scheer
*CMZ :  2.01/08 14/08/2020  07.28.59  by  Michael Scheer
*CMZ :  2.01/05 07/07/2020  09.50.20  by  Michael Scheer
*CMZ :  2.01/03 30/04/2019  15.27.29  by  Michael Scheer
*CMZ :  1.25/00 12/02/2018  12.56.09  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  12.25.35  by  Michael Scheer
*CMZ :  1.23/04 27/09/2017  11.40.04  by  Michael Scheer
*CMZ :  1.23/02 30/08/2017  14.51.27  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  08.26.04  by  Michael Scheer
*CMZ :  1.20/00 20/06/2017  13.29.34  by  Michael Scheer
*CMZ :  1.18/00 02/06/2017  12.05.50  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  11.42.01  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  16.31.47  by  Michael Scheer
*CMZ :  1.13/01 06/03/2017  20.37.49  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  10.14.18  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  09.54.39  by  Michael Scheer
*CMZ :  1.10/01 21/11/2016  12.17.20  by  Michael Scheer
*CMZ :  1.10/00 07/11/2016  12.19.31  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  09.19.25  by  Michael Scheer
*CMZ :  1.04/00 13/09/2016  14.38.54  by  Michael Scheer
*CMZ :  1.02/01 06/09/2016  09.49.12  by  Michael Scheer
*CMZ :  0.00/13 15/08/2016  08.45.03  by  Michael Scheer
*CMZ :  0.00/11 14/07/2016  15.41.42  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.25.39  by  Michael Scheer
*CMZ :  0.00/07 22/06/2016  14.22.29  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  11.36.32  by  Michael Scheer
*CMZ :  0.00/04 12/05/2016  08.24.51  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.49.54  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.24.38  by  Michael Scheer
*CMZ :  1.17/15 13/04/2016  13.05.57  by  Michael Scheer
*CMZ :  1.17/14 11/04/2016  16.22.06  by  Michael Scheer
*CMZ :  1.17/13 08/04/2016  08.54.59  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.43.16  by  Michael Scheer
*CMZ :  1.17/06 31/03/2016  13.13.00  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  08.04.41  by  Michael Scheer
*CMZ :  1.17/04 22/03/2016  16.34.31  by  Michael Scheer
*CMZ :  1.17/03 22/03/2016  08.05.59  by  Michael Scheer
*CMZ :  1.17/02 11/03/2016  15.25.33  by  Michael Scheer
*CMZ :  1.17/01 03/10/2014  08.35.16  by  Michael Scheer
*CMZ :  1.17/00 23/05/2014  16.02.09  by  Michael Scheer
*CMZ :  1.16/01 15/04/2009  13.41.52  by  Michael Scheer
*CMZ :  1.15/02 09/05/2008  09.24.22  by  Michael Scheer
*CMZ :  1.15/01 09/04/2008  15.36.25  by  Michael Scheer
*CMZ :  1.13/00 11/10/2007  12.15.15  by  Michael Scheer
*CMZ :  1.12/18 12/07/2007  16.22.39  by  Michael Scheer
*CMZ :  1.12/13 27/04/2007  09.53.17  by  Michael Scheer
*CMZ :  1.12/09 03/04/2007  13.17.21  by  Michael Scheer
*CMZ :  1.12/05 13/07/2006  13.12.49  by  Michael Scheer
*CMZ :  1.02/00 28/07/2004  14.41.55  by  Michael Scheer
*CMZ :  1.01/01 21/07/2004  14.10.58  by  Michael Scheer
*CMZ :  0.99/12 26/02/2004  11.08.11  by  Michael Scheer
*CMZ :  0.99/00 28/01/2004  15.21.34  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  12.58.00  by  Michael Scheer
*CMZ :  0.00/06 16/01/2004  10.23.28  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  15.45.45  by  Michael Scheer
*CMZ :  0.00/04 19/12/2003  16.59.32  by  Michael Scheer
*CMZ :  0.00/03 18/12/2003  11.19.58  by  Michael Scheer
*CMZ :  0.00/02 11/12/2003  08.27.10  by  Michael Scheer
*CMZ :  0.00/01 05/12/2003  15.49.03  by  Michael Scheer
*CMZ :  0.00/00 09/01/2003  11.47.07  by  Michael Scheer
*-- Author :    Michael Scheer   19/05/98
MACRO CMZSYMBOLS

ali/cre resti 'she  perl ~/perl/restorejed.pl undumag.in' c

ali/cre export_undumag 'exec undumag_export' c
ali/cre uexport 'exec undumag_export' c
ali/cre uexportwindows 'exec undumag_export_windows' c
ali/cre uexp 'exec undumag_export' c
ali/cre uexpw 'exec undumag_export_windows' c

ali/cre ei 'kedi undumag.in' c
ali/cre enam 'kedi undumag.nam' c
ali/cre ss 'exec cmzsymbols' c
ali/cre rd1 'she cd ~/undu/stage1 && bash ~/com/ddd.sh ~/undu/bin/undumag_omp.exe'
ali/cre rd2 'she cd ~/undu/stage2 && bash ~/com/ddd.sh ~/undu/bin/undumag_omp.exe'
ali/cre romp 'she cd ~/undu/stage && time ~/undu/bin/undumag_omp.exe'
*ali/cre rd 'she cd ~/undu/stage && bash ~/com/ddd.sh ~/undu/bin/undumag_omp.exe'
*ali/cre rd 'she cd ~/undu/stage && bash ~/com/ddd.sh ~/undu/bin/undumag.exe'
ali/cre rd 'she cd ~/undu/stage && bash ~/com/ddd.sh ~/undu/bin/undumag.exe'
ali/cre rdo 'she cd ~/undu/stage && bash ~/com/ddd.sh ~/undu/bin/undumag.exe'
*ali/cre rf 'she rm -f fel-undulator.paw && rm -f fel-undulator.polymag && ./fel-undulator.exe' c
ali/cre rf 'exec fprog' c
ali/cre rfo 'she rm -f fel-undulator.paw && rm -f fel-undulator.polymag && mv -f run.out run.out.bck && ./fel-undulator.exe > run.out' c
ali/cre rfd 'she rm -f fel-undulator.paw && rm -f fel-undulator.polymag && ddd --debugger idb -dbx -geometry +100 fel-undulator.exe &' c
ali/cre j 'exec job' c
ali/cre jd 'exec jobd' c
ali/cre jd1 'exec jobd 1' c
ali/cre jd2 'exec jobd 2' c
ali/cre j2 'j 2' c
ali/cre jo 'exec jobomp' c
ali/cre jos 'exec jobomp_static' c
ali/cre jdo 'exec jobompd' c
ali/cre pa 'she pawX11' c
ali/cre ero 'k/edi run.out &' c
ali/cre eoutu 'k/edi outu &' c
ali/cre dio 'she diff run.out run.out.bck' c
ali/cre efi 'k/edi fel-undulator.in' c
ali/cre eubq 'edi undumag_bpeq' c
ali/cre eui 'edi undumag_ini' c
ali/cre euio 'edi undumag_ini_old' c
ali/cre euim 'edi undumag_ini_magnets' c
ali/cre euimo 'edi undumag_ini_modules' c
ali/cre euin 'edi undumag_ini_new' c
ali/cre euir 'edi undumag_ini_rest' c
ali/cre eurc 'edi undumag_read_clc' c
ali/cre euiin 'edi undumag_ini undumag_ini_new' c
ali/cre eup 'edi undumag_proc' c
ali/cre euri0 'edi undumag_relax_iron0' c
ali/cre euri1 'edi undumag_relax_iron1' c
ali/cre euri2 'edi undumag_relax_iron2' c
ali/cre euri3 'edi undumag_relax_iron3' c
ali/cre euri4 'edi undumag_relax_iron4' c
ali/cre euri 'edi undumag_relax_iron' c
ali/cre eurr 'edi undumag_relax_rec' c
ali/cre eurim 'edi undumag_relax_iron_matrix' c
ali/cre eurrm 'edi undumag_relax_rec_matrix' c
ali/cre euseq 'edi /seq/$undumagf90m' c
ali/cre eufo 'edi undumag_force' c
ali/cre eue 'edi undumag_end' c
ali/cre euf 'edi undumag_field' c
ali/cre eufs 'edi undumag_bpolyeder_single' c
ali/cre ebs 'edi undumag_bpolyeder_single' c
ali/cre eucm 'edi undumag_cut_magnet' c
ali/cre eucp 'edi undumag_cut_plane' c
ali/cre eubp 'edi undumag_bpolyeder' c
ali/cre eubpi 'edi undumag_bpolyint' c
ali/cre euii 'edi undumag_bintinf' c
ali/cre eubp1 'edi undumag_bpolyeder1' c
ali/cre eubpv1 'edi undumag_bpolyeder_v1' c
ali/cre eubpm 'edi undumag_bpolyeder_matrix' c
ali/cre ebp2 'edi bpolypl2' c
ali/cre uflo 'she . ~/undu/shell/uflomp.sh' c
ali/cre uflod 'she . ~/undu/shell/uflompd.sh' c
ali/cre ufld 'she . ~/undu/shell/uflompd.sh' c
ali/cre uflcross 'she . ~/undu/shell/ufl_cross_win32.sh' c
ali/cre uflw 'she . ~/undu/shell/ufl_cross_win32.sh' c
ali/cre ufl 'she . ~/undu/shell/uflomp.sh' c
*ali/cre r 'she cd ~/undu/stage && ~/undu/bin/undumag_omp.exe && cat inf' c
ali/cre r2 'she cd ~/undu/stage2 && time ~/undu/bin/undumag_omp.exe && cat undumag.rad' c
ali/cre r 'cd $UNDUMAG/stage && . ../shell/undumag_run.sh' c
ali/cre rnol 'she cd ~/undu/stage && . shell/rnolog.sh' c
ali/cre ei 'kedi ~/undu/stage/undumag.clc' c
ali/cre en 'kedi ~/undu/stage/undumag.nam' c
ali/cre rom 'she cd ~/undu/stage && bash ~/com/root.sh map'
ali/cre estart 'kedi ../stage/startup.ddd' c
ali/cre eseq 'exec ecmn' c
ali/cre cxu15 'cx cpmu15' c
ali/cre cxu15f 'cx cpmu15full' c
ali/cre eu15 'edi cpmu15' c
ali/cre eu15f 'edi cpmu15full' c
*ali/cre eu15p 'edi $cpmu15par' c
ali/cre eu15p 'exec edicpmu15par' c
ali/cre eu15s 'edi $cpmu15spec' c
*ali/cre cxu17 'cx cpmu17' c
ali/cre eu17 'edi cpmu17' c
*ali/cre eu17p 'edi $cpmu17par' c
ali/cre eu17p 'exec edicpmu17par' c
ali/cre eu17s 'exec edicpmu17spec' c
ali/cre eurad 'edi undumag_to_radia' c
ali/cre eufd 'edi undumag_force_dipoles' c
ali/cre eufdn 'edi undumag_force_dipoles_nos' c
ali/cre eudf 'edi undumag_dipole_field' c
ali/cre eud 'edi undumag_dipoles_field' c
ali/cre uflompd 'she ../shell/uflompd.sh' c
ali/cre ess 'e $sesame_special' c
ali/cre ese 'e sesame' c
*ali/cre eupl 'edi $undumagplotglobal $undumagplot undumag_plot' c
ali/cre eupl 'edi $undumagplotglobal $undumagplot' c
ali/cre egui 'e $ugui' c
ali/cre etb 'e $topbar' c
ali/cre eloi 'e msh_ipylogon' c
ali/cre upl1 'she cd ~/undu/stage && ipython3 --profile undumag -i .empty.py -- geo 1' c
ali/cre uplm1 'she cd ~/undu/stage && ipython3 --profile undumag -i .empty.py -- geo -1' c
ali/cre upl 'she cd ~/undu/stage && . ./plot.sh' c
ali/cre dwav 'cd //wave/python' c
ali/cre dwaves 'cd //waves/python' c
ali/cre ent 'edi //ntupplot/python/$ntupini' c
ali/cre dntup 'cd //ntupplot/python' c
ali/cre ehm 'e //waves/python/$m_hbook' c
ali/cre wout 'exec ~/undu/cmz/wavesout' c
ali/cre dundu 'exec dundupy' c
ali/cre eugg 'edi $uguiglobals $uguiglobind' c
ali/cre egeo 'edi $uguiglobals $uguiglobind $mgeometry' c
ali/cre egeo 'edi $mgeometry' c
*ali/cre elm 'edi $uguiglobals $uguiglobind $listmags' c
ali/cre elma 'edi $listmags' c
ali/cre elco 'edi $listcoils' c
ali/cre elmo 'edi $listmods' c
ali/cre evar 'edi $uguiglobals $uguiglobind $mlistvars' c
ali/cre esg 'edi $uguiglobals $uguiglobind $showgeo' c
ali/cre esg 'edi $showgeo' c
*ali/cre eplg 'edi $uguiglobals $uguiglobind $unduplgeo' c
ali/cre eplg 'exec eplg.kumac' c
ali/cre emat 'edi $uguiglobals $uguiglobind $mmaterial' c
*ali/cre erc 'edi $uguiglobals $uguiglobind $ureadclc' c
ali/cre erc 'edi $ureadclc' c
ali/cre ewc 'edi $uguiglobals $uguiglobind $uwriteclc' c
ali/cre erwc 'edi $uguiglobals $uguiglobind $ureadclc $uwriteclc' c
ali/cre ewc 'edi $uwriteclc' c
ali/cre edrop 'edi undumag_drop_zero_magnets' c
ali/cre econ 'edi $uguicontrol' c
ali/cre ecalc 'edi undumag_calc' c
ali/cre ebc 'edi undumag_bcoils' c
ali/cre ee 'edi eds_undulator' c
ali/cre ees 'edi eds_six' c
ali/cre cxes 'cx eds_six' c
ali/cre eee 'edi $eds_endpole' c
ali/cre ee12s 'edi $eds_param_six $eds_1234_six' c
ali/cre ee12 'edi $eds_param $eds_1234' c
ali/cre ee68 'edi $eds_param $eds_681012' c
ali/cre ee57 'edi $eds_param $eds_57911' c
ali/cre ehm 'edi //waves/python/$m_hbook' c
ali/cre r 'exec rundupy' c
ali/cre outpy 'exec outpy' c
ali/cre op 'exec outpy' c
ali/cre outpyi 'exec outpy_incl' c
ali/cre ecm 'edit /seq/$magnet_struct /for/clcmag_to_magnets /for/clcmag_cut /for/clcmag_xcut /for/clcmag_ycut /for/clcmag_zcut' c
ali/cre est 'edit /seq/$magnet_struct' c
ali/cre ectm 'e clcmag_to_magnets' c
ali/cre estm 'e clcspec_to_magnets' c
ali/cre ectc 'e clccoil_to_coils' c
ali/cre ecc 'e clcmag_cut' c
ali/cre eccx 'e clcmag_xcut' c
ali/cre eccy 'e clcmag_ycut' c
ali/cre eccz 'e clcmag_zcut' c
ali/cre eccv 'e clcmag_voxels' c
ali/cre eus 'e clcmag_sym' c
ali/cre ecccv 'e clcmag_copy_voxels' c
ali/cre eubeff 'e undumag_beff' c
ali/cre eubeffyz 'e undumag_beffy_beffz' c
ali/cre eub 'e undumag_beff' c
ali/cre eubyz 'e undumag_beffy_beffz' c
ali/cre erad 'e undumag_to_radia clcmag_to_radia' c
* ali/cre o 'exec uout_omp' c
ali/cre eu 'edi $uconvertclc' c
*ali/cre o 'cx unduconvertclc' c
ali/cre o 'exec out' c
*ali/cre o 'exec uout_omp' c
*ali/cre op 'exec outpy' c
ali/cre etrc 'edi $utransrotcop $ureadclc' c
ali/cre outi 'exec uout_incl'
ali/cre outg 'exec uout_git'
ali/cre outgh 'exec uout_github'
ali/cre eugeo 'e undumag_geo'
EXITM
+deck,dcc,T=kumac.
*CMZ :  2.05/01 04/10/2023  15.55.55  by  Michael Scheer
*CMZ :  2.01/05 26/05/2020  16.56.34  by  Michael Scheer
*CMZ :  1.17/00 03/05/2014  08.42.05  by  Michael Scheer
*CMZ :  1.10/03 23/08/2004  09.19.08  by  Michael Scheer
*CMZ :  0.00/00 09/01/2003  11.47.07  by  Michael Scheer
*-- Author :    Michael Scheer   14/08/2001
macro dCC
CD CC
she cp -f ~/cmz/cmzlan.cc .cmzlan			
SET C++ -lan
SET *.cc -F
SET cmzedit.cc -E
SET libundumagcc.a -L
SET 'g++ -c $COMPFILE' -C C++
+self,if=mswave2,mswave3,lena.
SET 'g++ -c -I/usr/include/root $COMPFILE' -C C++
+self.
exec lastdir cc
lmod * last
EXITM
+deck,dseq, T=kumac.
*CMZ :  2.05/01 04/10/2023  15.55.55  by  Michael Scheer
*CMZ :  1.12/05 02/07/2006  13.19.23  by  Michael Scheer
*CMZ :  1.10/03 22/10/2004  12.55.39  by  Michael Scheer
*CMZ :  1.02/03 11/08/2004  16.00.50  by  Michael Scheer
*CMZ :  1.02/01 05/08/2004  16.06.42  by  Michael Scheer
*CMZ :  0.00/01 02/12/2003  12.46.53  by  Michael Scheer
*CMZ :  0.00/00 09/01/2003  11.47.07  by  Michael Scheer
*-- Author :    Michael Scheer   19/05/98
macro dseq

CD seq

+SELF,IF=VMS.
      SET F77 -lan
      SET cmzedit.for -E
      SET *.for -F
      SET libundumag.olb -L
+SELF,IF=-VMS.
      SET cmzedit.f -E
      SET F77 -lan
      SET *.f -F
+SELF.

lmod * last

EXITM

+DECK,dford,T=KUMAC.
*CMZ :  2.05/01 04/10/2023  15.55.55  by  Michael Scheer
*CMZ :  1.09/01 05/10/2016  11.16.10  by  Michael Scheer
*CMZ :  1.17/00 06/05/2014  19.27.42  by  Michael Scheer
*CMZ :  1.16/04 16/04/2014  13.48.35  by  Michael Scheer
*-- Author :    Michael Scheer   16/04/2014
macro dford
CD for

sel gfortran

      she cp -f ~/cmz/cmzlan.f77 .cmzlan			
      SET cmzedit.f -E
      SET F77 -lan
      SET *.f -F
      SET libundumag.a -L
      ali/cre ef 'exec fedit' c
      ali/cre efb 'exec feditb' c
      ali/cre efbt 'exec feditbt' c

set '/usr/bin/ifort  -g -c -fpe0 -traceback -vms -w95 -warn all -132 -save -implicitnone -warn alignments -align all -align rec8byte -c $compfile' -C F77

set 'gfortran -g -c -Wno-align-commons -fno-automatic -ffixed-line-length-none -funroll-loops $compfile' -C F77

lmod * last
exec lastdir for
EXITM
+DECK,dgfor,T=KUMAC.
*CMZ :  2.05/01 04/10/2023  15.55.01  by  Michael Scheer
*CMZ :  2.04/06 02/08/2023  09.12.49  by  Michael Scheer
*CMZ :  2.02/00 09/01/2021  09.53.23  by  Michael Scheer
*CMZ :  1.17/00 19/08/2014  11.45.00  by  Michael Scheer
*CMZ :  1.16/04 16/04/2014  13.48.35  by  Michael Scheer
*-- Author :    Michael Scheer   16/04/2014
macro dgfor

exec dforincl
exitm

CD for

exec cmzsymbols

sel gfortran

      she cp -f ~/cmz/cmzlan.f77 .cmzlan			
      SET cmzedit.f -E
      SET F77 -lan
      SET *.f -F
      SET libutil.a -L
      ali/cre ef 'exec fedit' c
      ali/cre efb 'exec feditb' c
      ali/cre efbt 'exec feditbt' c
      ali/cre emain 'e /main/undumag_main' c

set '~/polymag/shell/gfor.sh $compfile' -C F77

lmod * last
exec lastdir gfor
EXITM
+deck,dccd,T=kumac.
*CMZ :  2.05/01 04/10/2023  15.55.55  by  Michael Scheer
*CMZ :  2.01/05 26/05/2020  16.56.34  by  Michael Scheer
*CMZ :  1.17/00 03/05/2014  08.42.05  by  Michael Scheer
*CMZ :  1.10/03 23/08/2004  09.19.08  by  Michael Scheer
*CMZ :  0.00/00 09/01/2003  11.47.07  by  Michael Scheer
*-- Author :    Michael Scheer   14/08/2001
macro dCC
CD CC
she cp -f ~/cmz/cmzlan.cc .cmzlan			
SET C++ -lan
SET *.cc -F
SET cmzedit.cc -E
SET libundumagcc.a -L
SET 'g++ -c $COMPFILE' -C C++
+self,if=mswave2,mswave3,lena.
SET 'g++ -c -g -I/usr/include/root $COMPFILE' -C C++
+self.
exec lastdir cc
lmod * last
EXITM
+DECK,dgford,T=KUMAC.
*CMZ :  2.05/01 04/10/2023  15.55.55  by  Michael Scheer
*CMZ :  1.09/01 05/10/2016  11.18.16  by  Michael Scheer
*CMZ :  1.17/00 06/05/2014  19.27.42  by  Michael Scheer
*CMZ :  1.16/04 16/04/2014  13.48.35  by  Michael Scheer
*-- Author :    Michael Scheer   16/04/2014
macro dgford
CD for

sel gfortran

      she cp -f ~/cmz/cmzlan.f77 .cmzlan
      SET cmzedit.f -E
      SET F77 -lan
      SET *.f -F
      SET libundumag.a -L
      ali/cre ef 'exec fedit' c
      ali/cre efb 'exec feditb' c
      ali/cre efbt 'exec feditbt' c

set '/usr/bin/ifort  -g -c -fpe0 -traceback -vms -w95 -warn all -132 -save -implicitnone -warn alignments -align all -align rec8byte -c $compfile' -C F77

set 'gfortran -g -c -Wno-align-commons -fno-automatic -ffixed-line-length-none -funroll-loops $compfile' -C F77

lmod * last
exec lastdir for
EXITM
+DECK,dforincl,T=KUMAC.
*CMZ :  2.05/01 05/10/2023  14.59.23  by  Michael Scheer
*CMZ :  2.04/22 22/09/2023  12.30.51  by  Michael Scheer
*CMZ :  2.04/06 07/07/2023  14.34.30  by  Michael Scheer
*CMZ :  2.02/01 15/01/2022  13.21.49  by  Michael Scheer
*CMZ :  2.02/00 20/10/2020  09.34.53  by  Michael Scheer
*CMZ :  2.01/08 29/07/2020  07.35.28  by  Michael Scheer
*CMZ :  1.09/01 05/10/2016  11.57.38  by  Michael Scheer
*CMZ :  1.02/01 06/09/2016  09.49.12  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  11.51.11  by  Michael Scheer
*CMZ :  1.17/06 31/03/2016  15.38.11  by  Michael Scheer
*CMZ :  1.17/00 26/05/2014  10.24.16  by  Michael Scheer
*CMZ :  1.16/04 16/04/2014  13.48.35  by  Michael Scheer
*-- Author :    Michael Scheer   16/04/2014
macro dforincl

exec cmzsymbols

CD //undumag/for
tabs -off

sel gfortran

      she cp -f ~/cmz/cmzlan.f77 .cmzlan

      SET F77 -lan

      SET cmzedit.f -E

      SET $UNDUMAG_INCL/for/*.f -F
      SET ~/undu/lib/libundumag.a -L

      ali/cre ef 'exec fedit' c
      ali/cre efb 'exec feditb' c
      ali/cre efbt 'exec feditbt' c
      ali/cre emain 'e /main/undumag_main' c

set '~/undu/shell/gford.sh $compfile' -C F77

ali/cre r 'cd ~/undu/stage && source ../shell/undumag_run.sh' c

lmod * last
exec lastdir gfor
EXITM
+PATCH,SEQ.
*CMZ :  0.00/00 20/04/2016  13.03.34  by  Michael Scheer
+KEEP,unduver.
*CMZ :  2.05/01 23/10/2023  14.26.31  by  Michael Scheer
*CMZ :  2.05/00 30/09/2023  10.59.27  by  Michael Scheer
*CMZ :  2.04/28 30/09/2023  10.58.07  by  Michael Scheer
*CMZ :  2.04/27 28/09/2023  14.24.47  by  Michael Scheer
*CMZ :  2.04/26 28/09/2023  13.25.52  by  Michael Scheer
*CMZ :  2.04/25 28/09/2023  08.31.19  by  Michael Scheer
*CMZ :  2.04/24 27/09/2023  16.46.53  by  Michael Scheer
*CMZ :  2.04/23 27/09/2023  09.40.54  by  Michael Scheer
*CMZ :  2.04/22 26/09/2023  21.34.56  by  Michael Scheer
*CMZ :  2.04/21 22/09/2023  09.06.23  by  Michael Scheer
*CMZ :  2.04/20 21/09/2023  10.28.15  by  Michael Scheer
*CMZ :  2.04/19 18/09/2023  11.33.14  by  Michael Scheer
*CMZ :  2.04/18 14/09/2023  07.39.08  by  Michael Scheer
*CMZ :  2.04/17 13/09/2023  16.15.26  by  Michael Scheer
*CMZ :  2.04/16 11/09/2023  11.57.47  by  Michael Scheer
*CMZ :  2.04/15 06/09/2023  08.20.46  by  Michael Scheer
*CMZ :  2.04/13 04/09/2023  12.06.16  by  Michael Scheer
*CMZ :  2.04/12 31/08/2023  06.57.59  by  Michael Scheer
*CMZ :  2.04/11 29/08/2023  15.03.24  by  Michael Scheer
*CMZ :  2.04/10 23/08/2023  16.14.31  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.16.48  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.57.08  by  Michael Scheer
*CMZ :  2.04/07 10/08/2023  09.14.02  by  Michael Scheer
*CMZ :  2.04/06 07/08/2023  10.05.29  by  Michael Scheer
*CMZ :  2.04/05 15/03/2023  13.22.48  by  Michael Scheer
*CMZ :  2.04/04 14/03/2023  11.22.26  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.38.01  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.57.20  by  Michael Scheer
*CMZ :  2.04/01 17/01/2023  13.16.06  by  Michael Scheer
*CMZ :  2.04/00 02/09/2022  07.23.21  by  Michael Scheer
*CMZ :  2.03/00 26/07/2022  07.27.06  by  Michael Scheer
*CMZ :  2.02/02 11/02/2022  10.16.30  by  Michael Scheer
*CMZ :  2.02/00 06/04/2021  15.55.28  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.40.43  by  Michael Scheer
*CMZ :  2.01/07 28/07/2020  10.27.15  by  Michael Scheer
*CMZ :  2.01/06 27/07/2020  12.07.59  by  Michael Scheer
*CMZ :  2.01/05 27/07/2020  10.28.00  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.36.59  by  Michael Scheer
*CMZ :  2.01/02 02/05/2018  14.22.15  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.18.04  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  15.17.18  by  Michael Scheer
*CMZ :  2.00/03 24/04/2018  13.33.50  by  Michael Scheer
*CMZ :  2.00/02 17/04/2018  13.44.53  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  15.48.23  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.51.26  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.30.01  by  Michael Scheer
*CMZ :  1.25/04 05/04/2018  16.14.01  by  Michael Scheer
*CMZ :  1.25/03 03/04/2018  08.32.34  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  15.10.45  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.23.14  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  15.06.30  by  Michael Scheer
*CMZ :  1.24/01 17/10/2017  10.11.38  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  15.01.01  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.31.17  by  Michael Scheer
*CMZ :  1.23/06 06/10/2017  14.22.02  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  12.51.05  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.36.30  by  Michael Scheer
*CMZ :  1.23/03 27/09/2017  09.39.17  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.33.46  by  Michael Scheer
*CMZ :  1.23/01 09/08/2017  08.38.14  by  Michael Scheer
*CMZ :  1.23/00 04/08/2017  09.35.04  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  15.02.00  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.36.01  by  Michael Scheer
*CMZ :  1.21/00 29/06/2017  16.12.16  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  16.11.17  by  Michael Scheer
*CMZ :  1.20/02 23/06/2017  14.23.56  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  14.46.47  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  11.27.31  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.34.58  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  11.29.53  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  15.11.00  by  Michael Scheer
*CMZ :  1.18/01 09/06/2017  08.54.59  by  Michael Scheer
*CMZ :  1.18/00 06/06/2017  14.48.14  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.29.12  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  13.12.04  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  14.25.54  by  Michael Scheer
*CMZ :  1.17/05 18/05/2017  12.07.07  by  Michael Scheer
*CMZ :  1.17/04 12/05/2017  13.52.43  by  Michael Scheer
*CMZ :  1.17/03 09/05/2017  13.37.52  by  Michael Scheer
*CMZ :  1.17/02 09/05/2017  13.11.36  by  Michael Scheer
*CMZ :  1.17/01 08/05/2017  20.51.09  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  16.57.03  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  14.11.11  by  Michael Scheer
*CMZ :  1.15/13 05/05/2017  10.21.44  by  Michael Scheer
*CMZ :  1.15/11 03/05/2017  09.26.17  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.48.35  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  15.00.04  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  15.01.20  by  Michael Scheer
*CMZ :  1.15/07 05/04/2017  16.02.20  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.33.09  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.48.22  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  13.12.53  by  Michael Scheer
*CMZ :  1.15/03 03/04/2017  11.00.07  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.46.32  by  Michael Scheer
*CMZ :  1.15/01 30/03/2017  11.37.22  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  12.03.00  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  12.54.38  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  17.18.19  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.35.51  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  17.07.42  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  17.04.56  by  Michael Scheer
*CMZ :  1.12/00 27/02/2017  15.49.37  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.25.07  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.48.56  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  16.08.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.58.21  by  Michael Scheer
*CMZ :  1.11/03 18/01/2017  09.43.51  by  Michael Scheer
*CMZ :  1.11/02 10/01/2017  10.20.14  by  Michael Scheer
*CMZ :  1.11/01 09/01/2017  13.56.32  by  Michael Scheer
*CMZ :  1.11/00 05/01/2017  09.37.44  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  16.30.30  by  Michael Scheer
*CMZ :  1.10/02 01/12/2016  13.35.11  by  Michael Scheer
*CMZ :  1.10/01 21/11/2016  13.02.21  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.20.28  by  Michael Scheer
*CMZ :  1.09/01 10/10/2016  10.18.30  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  12.55.22  by  Michael Scheer
*CMZ :  1.08/00 30/09/2016  13.55.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  19.17.35  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.41.46  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.51.16  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  15.02.55  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.52.28  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.46  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.38.28  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.33.46  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.26.25  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  13.37.05  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  14.36.16  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.55.27  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.34.04  by  Michael Scheer
*CMZ :  1.02/00 30/08/2016  13.27.12  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.52.29  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.47.41  by  Michael Scheer
*CMZ :  0.00/14 19/08/2016  14.37.09  by  Michael Scheer
*CMZ :  0.00/13 19/08/2016  14.12.39  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.27.38  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.30.10  by  Michael Scheer
*CMZ :  0.00/10 14/07/2016  14.01.01  by  Michael Scheer
*CMZ :  0.00/09 06/07/2016  08.51.18  by  Michael Scheer
*CMZ :  0.00/08 23/06/2016  15.45.45  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  14.00.43  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.56.01  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.51.39  by  Michael Scheer
*CMZ :  0.00/03 04/05/2016  11.43.21  by  Michael Scheer
*CMZ :  0.00/02 02/05/2016  10.24.12  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  16.04.05  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.51.37  by  Michael Scheer
*-- Author :    Michael Scheer   12/02/2004
      print *
      print *
      print *
      write(lun6,*)'     **********************************************************'
      write(lun6,*)'     *                                                        *'
      write(lun6,*)'     *                       UNDUMAG                          *'
      write(lun6,*)'     *                                                        *'
      write(lun6,*)'     *                    Version 2.05/01                     *'
      write(lun6,*)'     *                       23.10.2023                       *'
      write(lun6,*)'     *                                                        *'
      write(lun6,*)'     *                     Michael Scheer                     *'
      write(lun6,*)'     *                       HZB/BESSY                        *'
      write(lun6,*)'     *                                                        *'
      write(lun6,*)'     **********************************************************'

      print *
      print *
      print *

      call util_zeit_kommentar(lun6,"")

      open(unit=999,file="undumag.ver")
      chuvers="2.05/01"
      write(999,*)chuvers
      close(999)

+KEEP,inputver.
*CMZ :  2.05/01 23/10/2023  14.26.31  by  Michael Scheer
*CMZ :  2.04/28 30/09/2023  10.58.07  by  Michael Scheer
*CMZ :  2.04/27 28/09/2023  14.24.47  by  Michael Scheer
*CMZ :  2.04/26 28/09/2023  13.25.52  by  Michael Scheer
*CMZ :  2.04/25 28/09/2023  08.31.19  by  Michael Scheer
*CMZ :  2.04/24 27/09/2023  16.46.53  by  Michael Scheer
*CMZ :  2.04/23 27/09/2023  09.40.54  by  Michael Scheer
*CMZ :  2.04/22 26/09/2023  21.34.56  by  Michael Scheer
*CMZ :  2.04/21 22/09/2023  09.06.23  by  Michael Scheer
*CMZ :  2.04/20 21/09/2023  10.28.15  by  Michael Scheer
*CMZ :  2.04/19 18/09/2023  11.33.14  by  Michael Scheer
*CMZ :  2.04/18 14/09/2023  07.39.08  by  Michael Scheer
*CMZ :  2.04/17 13/09/2023  16.15.26  by  Michael Scheer
*CMZ :  2.04/16 11/09/2023  11.57.47  by  Michael Scheer
*CMZ :  2.04/15 06/09/2023  08.20.46  by  Michael Scheer
*CMZ :  2.04/13 04/09/2023  12.06.16  by  Michael Scheer
*CMZ :  2.04/12 31/08/2023  06.57.59  by  Michael Scheer
*CMZ :  2.04/11 29/08/2023  15.03.24  by  Michael Scheer
*CMZ :  2.04/10 23/08/2023  16.14.31  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.16.48  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.57.08  by  Michael Scheer
*CMZ :  2.04/07 10/08/2023  09.14.02  by  Michael Scheer
*CMZ :  2.04/06 07/08/2023  10.05.29  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.38.01  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.57.20  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  14.22.34  by  Michael Scheer
*CMZ :  2.04/00 02/09/2022  07.23.44  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.40.43  by  Michael Scheer
*CMZ :  2.01/07 28/07/2020  10.27.15  by  Michael Scheer
*CMZ :  2.01/02 02/05/2018  14.22.15  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.18.04  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  15.17.18  by  Michael Scheer
*CMZ :  2.00/03 24/04/2018  13.33.50  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.51.26  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.30.01  by  Michael Scheer
*CMZ :  1.25/04 05/04/2018  16.14.01  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  15.10.45  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  15.07.26  by  Michael Scheer
*CMZ :  1.24/01 17/10/2017  10.11.38  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  15.01.01  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.31.17  by  Michael Scheer
*CMZ :  1.23/06 06/10/2017  14.22.02  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  12.51.05  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.36.30  by  Michael Scheer
*CMZ :  1.23/03 27/09/2017  09.39.17  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.33.46  by  Michael Scheer
*CMZ :  1.23/01 09/08/2017  08.38.14  by  Michael Scheer
*CMZ :  1.23/00 04/08/2017  09.35.04  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  15.02.00  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.36.01  by  Michael Scheer
*CMZ :  1.21/00 29/06/2017  16.12.16  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  16.11.17  by  Michael Scheer
*CMZ :  1.20/02 23/06/2017  14.23.56  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  14.46.47  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  11.27.31  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.34.58  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  11.29.53  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  15.11.00  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.29.12  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  13.12.04  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  14.25.54  by  Michael Scheer
*CMZ :  1.17/05 18/05/2017  12.07.07  by  Michael Scheer
*CMZ :  1.17/04 12/05/2017  13.52.43  by  Michael Scheer
*CMZ :  1.17/03 09/05/2017  13.37.52  by  Michael Scheer
*CMZ :  1.17/02 09/05/2017  13.11.36  by  Michael Scheer
*CMZ :  1.17/01 08/05/2017  20.51.09  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  16.57.03  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  14.11.11  by  Michael Scheer
*CMZ :  1.15/13 05/05/2017  10.21.44  by  Michael Scheer
*CMZ :  1.15/11 03/05/2017  09.26.17  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.48.35  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  15.00.04  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  15.01.20  by  Michael Scheer
*CMZ :  1.15/07 05/04/2017  16.02.20  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.33.09  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.48.22  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  13.12.53  by  Michael Scheer
*CMZ :  1.15/03 03/04/2017  11.00.07  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.46.32  by  Michael Scheer
*CMZ :  1.15/01 30/03/2017  11.37.22  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  12.54.38  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  17.18.19  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.35.51  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  17.07.42  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  17.04.56  by  Michael Scheer
*CMZ :  1.12/00 27/02/2017  15.49.37  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.25.07  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.48.56  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  16.08.44  by  Michael Scheer
*CMZ :  1.10/01 21/11/2016  13.02.21  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.20.28  by  Michael Scheer
*CMZ :  1.09/01 10/10/2016  10.18.30  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  12.55.22  by  Michael Scheer
*CMZ :  1.08/00 30/09/2016  13.55.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  19.17.35  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.41.46  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.51.16  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  15.02.55  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.52.28  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.46  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.39.52  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.38.28  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.33.46  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.26.25  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  13.37.05  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  14.36.16  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.55.27  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.34.04  by  Michael Scheer
*CMZ :  1.02/00 30/08/2016  13.27.12  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.52.29  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.47.41  by  Michael Scheer
*CMZ :  0.00/14 19/08/2016  14.37.09  by  Michael Scheer
*CMZ :  0.00/13 19/08/2016  14.12.39  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.27.38  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.30.10  by  Michael Scheer
*CMZ :  0.00/10 14/07/2016  14.01.01  by  Michael Scheer
*CMZ :  0.00/09 06/07/2016  08.51.18  by  Michael Scheer
*CMZ :  0.00/08 23/06/2016  15.45.45  by  Michael Scheer
*CMZ :  0.00/07 23/06/2016  15.45.22  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  14.00.43  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.56.01  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.51.39  by  Michael Scheer
*CMZ :  0.00/03 04/05/2016  11.43.21  by  Michael Scheer
*CMZ :  0.00/02 02/05/2016  10.24.12  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  16.04.05  by  Michael Scheer
*-- Author :    Michael Scheer   27/02/2004
* Version 2.05/01
+PATCH,$VERSION.
*CMZ :  0.00/00 20/04/2016  13.04.28  by  Michael Scheer
+DECK,V2_05.
*CMZ :  2.05/01 23/10/2023  14.26.31  by  Michael Scheer
*CMZ :  2.05/00 30/09/2023  10.59.27  by  Michael Scheer
*-- Author :    Michael Scheer   30/09/2023
*________________________________________________________________________
*
*::>          VERSION  2.05/01   23/10/2023 14.26.31
*
* Plotting improved
*________________________________________________________________________
*
*::>          VERSION  2.05/00   30/09/2023 10.59.27
*
* Python-Radia improved
*
+DECK,V2_04.
*CMZ :  2.04/28 30/09/2023  10.58.07  by  Michael Scheer
*CMZ :  2.04/27 28/09/2023  14.24.47  by  Michael Scheer
*CMZ :  2.04/26 28/09/2023  13.25.52  by  Michael Scheer
*CMZ :  2.04/25 28/09/2023  08.31.19  by  Michael Scheer
*CMZ :  2.04/24 27/09/2023  16.46.53  by  Michael Scheer
*CMZ :  2.04/23 27/09/2023  09.40.54  by  Michael Scheer
*CMZ :  2.04/22 26/09/2023  21.34.56  by  Michael Scheer
*CMZ :  2.04/21 22/09/2023  09.06.23  by  Michael Scheer
*CMZ :  2.04/20 21/09/2023  10.28.15  by  Michael Scheer
*CMZ :  2.04/19 18/09/2023  11.33.14  by  Michael Scheer
*CMZ :  2.04/18 14/09/2023  07.39.08  by  Michael Scheer
*CMZ :  2.04/17 13/09/2023  16.15.26  by  Michael Scheer
*CMZ :  2.04/16 11/09/2023  11.57.47  by  Michael Scheer
*CMZ :  2.04/15 06/09/2023  08.20.46  by  Michael Scheer
*CMZ :  2.04/14 06/09/2023  07.42.07  by  Michael Scheer
*CMZ :  2.04/13 04/09/2023  12.06.16  by  Michael Scheer
*CMZ :  2.04/12 31/08/2023  06.57.59  by  Michael Scheer
*CMZ :  2.04/11 29/08/2023  15.03.24  by  Michael Scheer
*CMZ :  2.04/10 23/08/2023  16.14.31  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.16.48  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.57.08  by  Michael Scheer
*CMZ :  2.04/07 10/08/2023  09.14.03  by  Michael Scheer
*CMZ :  2.04/06 07/08/2023  10.05.29  by  Michael Scheer
*CMZ :  2.04/05 15/03/2023  13.22.48  by  Michael Scheer
*CMZ :  2.04/04 14/03/2023  11.22.26  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.38.01  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.57.20  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  14.22.34  by  Michael Scheer
*CMZ :  2.04/00 17/01/2023  13.14.13  by  Michael Scheer
*-- Author :    Michael Scheer   17/01/2023
*________________________________________________________________________
*
*::>          VERSION  2.04/28   30/09/2023 10.58.07
*
*________________________________________________________________________
*
*::>          VERSION  2.04/27   28/09/2023 14.24.47
*
* Bug removed from clcmag_copy_voxels
*________________________________________________________________________
*
*::>          VERSION  2.04/26   28/09/2023 13.25.52
*
* Bug removed from util_convex_hull_3d_overwrite
*________________________________________________________________________
*
*::>          VERSION  2.04/25   28/09/2023 08.31.19
*
* Allocation for util_convex_hull_3d improved, nvertmax in undumag.nam now
*________________________________________________________________________
*
*::>          VERSION  2.04/24   27/09/2023 16.46.53
*
* Allocation for util_convex_hull_3d improved
*________________________________________________________________________
*
*::>          VERSION  2.04/23   27/09/2023 09.40.54
*
* Bug removed from util_convex_hull_3d_overwrite
*________________________________________________________________________
*
*::>          VERSION  2.04/22   26/09/2023 21.34.56
*
* Bug removed from util_convex_hull_3d_simp
*________________________________________________________________________
*
*::>          VERSION  2.04/21   22/09/2023 09.06.23
*
* Interface for RADIA under Python now includes filaments
*________________________________________________________________________
*
*::>          VERSION  2.04/20   21/09/2023 10.28.15
*
* Interface for RADIA under Python now includes cylinders
* Bugs in treatment of cylinders fixed
*________________________________________________________________________
*
*::>          VERSION  2.04/19   18/09/2023 11.33.14
*
* Interface for RADIA under Python
*________________________________________________________________________
*
*::>          VERSION  2.04/18   14/09/2023 07.39.08
*
* Bug removed from util_shrink_blockchamf
*________________________________________________________________________
*
*::>          VERSION  2.04/17   13/09/2023 16.15.26
*
* Bug removed from clcmag_magnet_facet
*________________________________________________________________________
*
*::>          VERSION  2.04/16   11/09/2023 11.57.47
*
* Calculation problems for convex hull solved
* Bugs removed
*________________________________________________________________________
*
*::>          VERSION  2.04/15   06/09/2023 08.20.46
*
* Facets for undugui.py
*________________________________________________________________________
*
*::>          VERSION  2.04/14   06/09/2023 07.42.07
*
*________________________________________________________________________
*
*::>          VERSION  2.04/13   04/09/2023 12.06.16
*
* Facets file implemented, segmentation speeded up
*________________________________________________________________________
*
*::>          VERSION  2.04/12   31/08/2023 06.57.59
*
* Bugs for plotting of coils removed from undugui.py
*________________________________________________________________________
*
*::>          VERSION  2.04/11   29/08/2023 15.03.24
*
* Bug from undumag_read_clc for cylinders removed
* Graphics in undugui improved, bugs removed
*________________________________________________________________________
*
*::>          VERSION  2.04/10   23/08/2023 16.14.31
*
* Postscript 3d graphic improved, bug in undumag_drop_zero_magnets removed
*________________________________________________________________________
*
*::>          VERSION  2.04/09   18/08/2023 19.16.48
*
* Bugs in undugui.py
*________________________________________________________________________
*
*::>          VERSION  2.04/08   11/08/2023 14.57.08
*
* Treatment of cylinders implemented for new syntax
*
*________________________________________________________________________
*
*::>          VERSION  2.04/07   10/08/2023 09.14.03
*
* Bug in CLCTRANSROTCOP removed. Check for rectangular block improved.
* Check for size of interaction matrix implemented
*________________________________________________________________________
*
*::>          VERSION  2.04/06   07/08/2023 10.05.29
*
* Bugs... Variables for translations etc., translations etc. in GUI
*
*________________________________________________________________________
*
*::>          VERSION  2.04/05   15/03/2023 13.22.48
*
* First GITLAB-Version
*________________________________________________________________________
*
*::>          VERSION  2.04/04   14/03/2023 11.22.26
*
* Before GITLAB-Version
*________________________________________________________________________
*
*::>          VERSION  2.04/03   05/03/2023 16.38.01
*
* Bugs of segmentation removed
*________________________________________________________________________
*
*::>          VERSION  2.04/02   27/02/2023 20.57.20
*
* Bugs of segmentation removed
*________________________________________________________________________
*
*::>          VERSION  2.04/01   13/02/2023 14.22.34
*
* Bugs of segmentation removed
*________________________________________________________________________
*
*::>          VERSION  2.04/00   17/01/2023 13.14.13
*
* Inhomogenities, bugs removed
*
+PATCH,UTIL,T=F77.
*CMZ :  1.25/00 31/01/2018  16.03.22  by  Michael Scheer
+DECK,util_convex_hull_3d,T=F77.
*CMZ :  2.05/01 03/10/2023  16.58.27  by  Michael Scheer
*CMZ :  2.04/24 27/09/2023  16.44.14  by  Michael Scheer
*CMZ :  2.04/22 26/09/2023  21.29.40  by  Michael Scheer
*CMZ :  2.04/09 16/08/2023  07.59.23  by  Michael Scheer
*CMZ :  2.04/04 06/03/2023  09.45.40  by  Michael Scheer
*CMZ :  2.04/03 03/03/2023  11.50.12  by  Michael Scheer
*CMZ :  2.03/00 30/08/2022  21.37.01  by  Michael Scheer
*CMZ :  2.02/02 05/07/2022  11.16.26  by  Michael Scheer
*CMZ :  2.02/01 03/11/2021  13.16.39  by  Michael Scheer
*CMZ :  2.02/00 17/09/2020  13.46.21  by  Michael Scheer
*CMZ :  2.01/03 28/05/2019  15.59.50  by  Michael Scheer
*CMZ :  2.00/03 24/04/2018  09.24.03  by  Michael Scheer
*CMZ :  1.23/04 02/10/2017  11.25.14  by  Michael Scheer
*CMZ : 00.00/21 13/03/2017  11.19.41  by  Michael Scheer
*CMZ : 00.00/20 12/03/2017  13.22.16  by  Michael Scheer
*CMZ :  1.11/05 20/02/2017  22.15.13  by  Michael Scheer
*CMZ :  1.11/04 21/01/2017  17.14.54  by  Michael Scheer
*-- Author :    Michael Scheer   22/11/2016
      subroutine util_convex_hull_3d(nin,xin,yin,zin,khull,kedge,kface,
     &  nhull,nedge,nface,kfacelast,tinyin,
     &  kfail)

      ! Calculates the convex hull for the points (x,y,z)

      ! Input:

      ! nin: Number of points
      ! x(1:nin),y(1:nin),z(1:nin): coordinates of the points

      ! Dimensions: The arrays must have at least the size of
      ! Euler: Nvertices + Nfaces - Nedges = 2


      ! khull(nin)
      ! kedge(4,nin*nin-2)

      ! kface(2*(nin+1)*nin)

      ! Output:

      ! khull(1:nhull) is the array of indices of the points belonging to the
      ! convex hull

      ! kedge(1:4,1:nedge) contains the indices of the edges of the hull
      ! kedge(1,iedge) is the first point of the edge iedge
      ! kedge(2,iedge) is the second point of the edge iedge
      ! kedge(3,iedge) is the index of the first face having this edge
      ! kedge(4,iedge) is the index of the second face having this edge

      ! kface contains a list of indices describing the faces of the hull
      ! kface(1) is the number of points of the first face
      ! kface(1+1:1+kface(1)) are the indices of these points
      ! Let lpoi(iface) = kface(k), then kface(k+1:k+lpoi) are the lpoi
      ! indices of the points belonging to this face, and kface(k+nin+1) is
      ! then nin(iface+1).
      ! kfacelast is the used length of kface, i.e. the index of last entry

      ! Example:
      ! iface=1, kface(1)=4, kface(2:5) are the indices of the 4 points of
      ! the first face, and kface(6) are the number of points of the second
      ! face, and so on.

      implicit none

+seq,hulldim.

      double precision xin(*),yin(*),zin(*),
     &  zmin,zmax,ymin,ymax,xmin,xmax,xsc,ysc,zsc,zmin1,zmin2,
     &  cosphi,sinphi,qn,cosmax,cosqpv,ex(3),ey(3),ez(3),q(3),
     &  p1(3),p2(3),p3(3),pt1(3),pt2(3),pt3(3),
     &  p21(3),vnor(3),dist,pt1r(3),pn,
     &  gcen(3),gceno(3),tinyin,tiny,tiny2,rotmat(3,3),rotg(3,3),rotm(3,3),
     &  rotws(3,3),gcenin(3),pcen(3)

      double precision, dimension (:), allocatable ::  x2,y2,z2,x,y,z

      integer, dimension (:,:), allocatable ::  kedgebuff
      integer, dimension (:,:), allocatable ::  iplans
+self,if=debug3d.
+seq,debugutil.
      double precision vnortest(3)
      integer :: idebug=0,k1,k2
+self.
      integer, dimension (:), allocatable ::  ibuff,ibuffp,ibuffm,kbuff,
     &  kedgeheap,kfaceheap,istore,iveto,kveto

      integer khull(lenhull),kedge(4,lenedge),kface(lenface),
     &  ifail,i,kzmin,nhull,nedge,nface,
     &  mface,lface,nin,npoi,ifound,iedge,ifirst,isecond,ithird,ipoi,kpoi,
     &  ledge,medge,jpoi,iover,istat,nh2d,nedgeheap,nbuff,iface,nfpoi,kfail,
     &  kfacelast,k,ib1,ib2

      integer :: idimfail=0,ical=0

      character(128) cerror

      data ex/1.0d0,0.0d0,0.0d0/
      data ey/0.0d0,1.0d0,0.0d0/
      data ez/0.0d0,0.0d0,1.0d0/

      ical=ical+1

      if (nverhullmax.le.0) then
        kfail=-1
        print*,"*** Error in util_convex_hull_3d: Common block uhullc not correctly initialized ***"
        nhull=0
        nedge=0
        nface=0
        return
      endif

c+self,if=debug3d.
c      print*,"hull_3d, ical:",ical
c      if (ical.eq.195) then
c        !call util_break
c      endif
c+self.
      idimfail=0
      ifirst=0
      isecond=0
      ithird=0
      nface=0
+self,if=debug3d.
c      call system("rm fort.99*")
c      open(unit=990,file='fort.990',status='new')
c      open(unit=991,file='fort.991',status='new')
c      open(unit=994,file='fort.994',status='new')
c      open(unit=996,file='fort.996',status='new')
+self.
c 1.3.2023      tiny2=tiny**2
      tiny=tinyin
      if (tiny.le.0.0d0) tiny=1.0d-12
      tiny2=tiny

      npoi=nin

      allocate(kfaceheap(lenface))
      allocate(kedgeheap(lenedge))
      allocate(ibuff(npoi),ibuffp(npoi),ibuffm(npoi),kbuff(lenface))
      allocate(iplans(2*npoi,2*npoi),istore(npoi),iveto(npoi),kveto(npoi))
      allocate(x(npoi),y(npoi),z(npoi),x2(npoi),y2(npoi),z2(npoi))

      ibuff=0
      kbuff=0
      ibuffm=0
      ibuffp=0
      iplans=0
      iveto=0
      kveto=0

      kface(1:lenface)=0
      kedgeheap(1:lenedge)=0
      kedge(1:4,1:lenedge)=0
      kfaceheap(1:lenface)=0

      x(1:npoi)=xin(1:npoi)
      y(1:npoi)=yin(1:npoi)
      z(1:npoi)=zin(1:npoi)

+self,if=debug3d.
        do i=1,npoi
          write(990,*)x(i),y(i),z(i),i
        enddo
        flush(990)
        close(990)
+self.

      call util_weed_points(npoi,x,y,z,tiny) !essential...

+self,if=debug3d.
      do i=1,npoi
        write(991,*)x(i),y(i),z(i),i
      enddo
      flush(991)
      close(991)
+self.

      if (npoi.eq.0) then
        kfail=100
        cerror="*** Error in util_convex_hull_3d: Number of points is zero ***"
        nhull=0
        nedge=0
        nface=0
        goto 9999
      else if (npoi.eq.1) then
        cerror="*** Error in util_convex_hull_3d: Number of points is one ***"
        kfail=100
        nhull=1
        nedge=0
        nface=0
        goto 9999
      else if (npoi.eq.2) then
        cerror="*** Error in util_convex_hull_3d: Number of points is two ***"
        nhull=2
        nedge=1
        nface=0
        kfail=100
        goto 9999
      else if (npoi.eq.3) then
        p1(1)=x(1)
        p1(2)=y(1)
        p1(3)=z(1)
        p2(1)=x(2)
        p2(2)=y(2)
        p2(3)=z(2)
        p21=p2-p1
        p2(1)=x(3)
        p2(2)=y(3)
        p2(3)=z(3)
        p3=p2-p1
        q(1)=p21(2)*p3(3)-p21(3)*p3(2)
        q(2)=p21(3)*p3(1)-p21(1)*p3(3)
        q(3)=p21(1)*p3(2)-p21(2)*p3(1)
        qn=sqrt(q(1)**2+q(2)**2+q(3)**2)
        if (abs(qn).lt.tiny) then
          kfail=100
          cerror="*** Error in util_convex_hull_3d: Flat polyeder ***"
          goto 9999
        endif
      endif

      xmin=1.0d30
      xmax=-1.0d30
      ymin=1.0d30
      ymax=-1.0d30
      zmin=1.0d30
      zmax=-1.0d30

      gcen=0.0d0
      do i=1,npoi
        if (z(i).lt.zmin) zmin=z(i)
        if (z(i).gt.zmax) zmax=z(i)
        if (y(i).lt.ymin) ymin=y(i)
        if (y(i).gt.ymax) ymax=y(i)
        if (x(i).lt.xmin) xmin=x(i)
        if (x(i).gt.xmax) xmax=x(i)
        gcen(1)=gcen(1)+x(i)
        gcen(2)=gcen(2)+y(i)
        gcen(3)=gcen(3)+z(i)
        ibuff(i)=i
      enddo

      gcen=gcen/npoi
      gcenin=gcen

      ! All points in a plane?{

      p1(1)=x(1)
      p1(2)=y(1)
      p1(3)=z(1)

      p2(1)=x(2)
      p2(2)=y(2)
      p2(3)=z(2)

      kfail=1

      do ipoi=3,npoi

        q(1)=x(ipoi)
        q(2)=y(ipoi)
        q(3)=z(ipoi)

        call util_plane(p1,p2,gcen,q,vnor,dist,iover,istat)

        if (istat.eq.0.and.abs(dist).gt.tiny) then
          kfail=0
          exit
        endif

      enddo

      if (kfail.ne.0) then

        if (abs(zmax-zmin).gt.tiny) then
          call util_convex_hull_2d(npoi,x,y,nh2d,kbuff,tiny2,ifail)
        else if (abs(xmax-xmin).gt.tiny) then
          call util_convex_hull_2d(npoi,z,y,nh2d,kbuff,tiny2,ifail)
        else if (abs(ymax-ymin).gt.tiny) then
          call util_convex_hull_2d(npoi,x,z,nh2d,kbuff,tiny2,ifail)
        endif

        if (ifail.ne.0) then
          kfail=-11
          cerror="*** Error in util_convex_hull_3d: Bad return from util_convex_hull_2d ***"
          goto 9999
        endif

        nh2d=nh2d-1

        kface(1)=nh2d
        nhull=nh2d
        nface=1

        if (nh2d.gt.2) then
          nedge=nh2d
        else
          nedge=1
        endif

        do ipoi=1,nh2d
          kpoi=ibuff(kbuff(ipoi))
          jpoi=ibuff(kbuff(ipoi+1))
          khull(ipoi)=kpoi
          kface(1+ipoi)=kpoi
          kedge(1,ipoi)=kpoi
          kedge(2,ipoi)=jpoi
          kedge(3:4,ipoi)=1
        enddo
        kfail=0
        goto 9999
      endif

      ! All points in a plane?}

      if (xmin.eq.xmax) then
        kfail=1
        cerror="*** Error in util_convex_hull_3d: Xmin = Xmax ***"
        goto 9999
      endif
      if (ymin.eq.ymax) then
        kfail=1
        cerror="*** Error in util_convex_hull_3d: Ymin = Ymax ***"
        goto 9999
      endif
      if (zmin.eq.zmax) then
        kfail=1
        cerror="*** Error in util_convex_hull_3d: Zmin = Zmax ***"
        goto 9999
      endif

      ! due to weeding
      istore=0
      do k=1,npoi
        do i=1,nin
          if (
     &        xin(i).eq.x(k).and.yin(i).eq.y(k).and.zin(i).eq.z(k)
     &        ) then
            istore(k)=i
            exit
          endif
        enddo
      enddo

      nedge=0
      nface=0
      nhull=0
      kedge(1:4,lenedge)=0
      khull(1:lenhull)=0
      kface(1:lenface)=0

      xsc=1.0d0/(xmax-xmin)
      ysc=1.0d0/(ymax-ymin)
      zsc=1.0d0/(zmax-zmin)

      do i=1,npoi
        x(i)=(x(i)-xmin)*xsc
        y(i)=(y(i)-ymin)*ysc
        z(i)=(z(i)-zmin)*zsc
      enddo

      xmax=(xmax-xmin)*xsc
      xmin=0.0d0
      ymax=(ymax-ymin)*ysc
      ymin=0.0d0
      zmax=(zmax-zmin)*zsc
      zmin=0.0d0

+self,if=debug3d.
      do i=1,npoi
        write(993,*) x(i),y(i),z(i),i
      enddo
      flush(993)
      close(993)
      !!call util_break
+self.
      gcen=0.0d0
      kzmin=0
      do i=1,npoi
        gcen(1)=gcen(1)+x(i)
        gcen(2)=gcen(2)+y(i)
        gcen(3)=gcen(3)+z(i)
        if (abs(z(i)-zmin).lt.tiny) then
          kzmin=kzmin+1
          ibuffm(kzmin)=i
          if (kzmin.eq.1) then
            ifirst=i
          else if (kzmin.eq.2) then
            isecond=i
          endif
          ibuffm(kzmin)=i
        endif
      enddo

      if (kzmin.gt.2) then

        do ipoi=1,kzmin
          kpoi=ibuffm(ipoi)
          x2(ipoi)=x(kpoi)
          y2(ipoi)=y(kpoi)
          z2(ipoi)=z(kpoi)
        enddo

        call util_convex_hull_2d(kzmin,x2,y2,nh2d,khull,tiny,kfail)

        if (nh2d.eq.3) then
          ibuff=ibuffm
          ! all points on a line
          kveto(ibuffm(1:3))=1
          ibuff(1:2)=ibuffm(khull(1:2))
          kveto(ibuff(1:2))=0
          ibuffm=0
          ibuffm(1:2)=ibuff(1:2)
          ifirst=ibuffm(1)
          isecond=ibuffm(2)
          kzmin=2
        endif

      endif

      gcen=gcen/npoi
      gceno=gcen

      zmin1=1.0d30
      zmin2=1.0d30

      p1(1)=x(ifirst)
      p1(2)=y(ifirst)
      p1(3)=z(ifirst)

      if (kzmin.eq.1) then

        do i=1,npoi
          if (i.eq.ifirst) cycle
          p21(1)=x(i)-p1(1)
          p21(2)=y(i)-p1(2)
          p21(3)=z(i)-p1(3)
c18Feb2020          pn=sqrt(p21(1)**2+p21(2)**2+p21(3)**2)
          pn=sqrt(p21(1)**2+p21(3)**2)
          if (pn.lt.tiny) then
            cycle
          endif
          p21=p21/pn
          if (p21(3).lt.zmin1) then
            isecond=i
            zmin1=p21(3)
            ibuffm(2)=i
          endif
        enddo

      endif

      p21(1)=x(isecond)-x(ifirst)
      p21(2)=y(isecond)-y(ifirst)
      p21(3)=z(isecond)-z(ifirst)

      ithird=0
      do i=1,npoi

        if (i.eq.ifirst.or.i.eq.isecond.or.kveto(i).ne.0) cycle

c16.8.2023        p3(1)=x(i)-p21(1)
c16.8.2023        p3(2)=y(i)-p21(2)
c16.8.2023        p3(3)=z(i)-p21(3)
        p3(1)=x(i)-p1(1)
        p3(2)=y(i)-p1(2)
        p3(3)=z(i)-p1(3)
        pn=sqrt(p3(1)**2+p3(3)**2)
c18Feb2020        pn=sqrt(p3(1)**2+p3(2)**2+p3(3)**2)
        if (pn.lt.tiny) then
          cycle
        endif

        p3=p3/pn

        if (p3(3).le.zmin1) then
c 2.3.2023          q(1)=p21(2)*p3(3)-p21(3)*p3(2)
c 2.3.2023          q(2)=p21(3)*p3(1)-p21(1)*p3(3)
c 2.3.2023          q(3)=p21(1)*p3(2)-p21(2)*p3(1)
c 2.3.2023          qn=sqrt(q(1)**2+q(2)**2+q(3)**2)
c 2.3.2023          if (abs(qn).gt.tiny) then
c 2.3.2023   points on the line are eleminated later
            ithird=i
            ibuffm(3)=i
            zmin1=p3(3)
c 2.3.2023          endif
        endif
      enddo

      if (ithird.eq.0) then
        zmin2=1.0d30
        do i=1,npoi
          if (i.eq.ifirst.or.i.eq.isecond) cycle
          p21(1)=x(i)-p1(1)
          p21(2)=y(i)-p1(2)
          p21(3)=z(i)-p1(3)
c15Feb2020          pn=sqrt(p21(1)**2+p21(2)**2+p21(3)**2)
          pn=sqrt(p21(1)**2+p21(3)**2)
          if (pn.lt.tiny) cycle
          p21=p21/pn
          if (p21(3).gt.zmin1.and.p21(3).lt.zmin2) then
            ithird=i
            zmin2=p21(3)
            ibuffm(3)=i
          endif
        enddo
      endif

      !Find all points of first plane

      ifirst=ibuffm(1)
      isecond=ibuffm(2)
      ithird=ibuffm(3)

+self,if=debug3d.
      write(992,*)x(ifirst),y(ifirst),z(ifirst),ifirst
      write(992,*)x(isecond),y(isecond),z(isecond),isecond
      write(992,*)x(ithird),y(ithird),z(ithird),ithird
      flush(992)
      close(992)
      !!call util_break
+self.
      ifirst=ibuffm(1)
      isecond=ibuffm(2)
      ithird=ibuffm(3)

      ibuff(1:3)=ibuffm(1:3)
      iplans(1:3,1)=ibuff(1:3)

      nbuff=3

      ipoi=ithird

      gcen=gceno

      p1(1)=x(ifirst)
      p1(2)=y(ifirst)
      p1(3)=z(ifirst)

      p2(1)=x(isecond)
      p2(2)=y(isecond)
      p2(3)=z(isecond)

      p3(1)=x(ipoi)
      p3(2)=y(ipoi)
      p3(3)=z(ipoi)

      do jpoi=1,npoi

        if (jpoi.eq.ipoi.or.jpoi.eq.ifirst.or.jpoi.eq.isecond) cycle

        q(1)=x(jpoi)
        q(2)=y(jpoi)
        q(3)=z(jpoi)

        call util_plane(p1,p2,p3,q,vnor,dist,iover,istat)

        if (istat.ne.0) then
          kfail=-8
          cerror="*** Error in util_convex_hull_3d: Bad return from util_plane ***"
          goto 9999
        endif

        if (abs(dist).lt.tiny) then
          nbuff=nbuff+1
          iplans(nbuff,1)=jpoi
          ibuff(nbuff)=jpoi
        endif

      enddo !jpoi

      do ipoi=1,nbuff
        kpoi=ibuff(ipoi)
        x2(ipoi)=x(kpoi)
        y2(ipoi)=y(kpoi)
        z2(ipoi)=z(kpoi)
+self,if=debug3d.
        write(996,*)"1 ",kpoi,x(kpoi),y(kpoi),z(kpoi)
+self.
      enddo
+self,if=debug3d.
      flush(996)
      !!call util_break
+self.
      q=gcen-p1

      call util_plane(p1,p2,p3,q,vnor,dist,iover,istat)
+self,if=debug3d.
      if (idebug.ne.0) then
        call util_vcross(p2-p1,p3-p2,vnortest)
        print*,"Test:",dot_product(vnor,vnortest)/norm2(vnortest)
      endif
+self.
      if (istat.ne.0) then
        kfail=-8
        cerror="*** Error in util_convex_hull_3d: Bad return from util_plane ***"
        goto 9999
      endif

      if (
     &    abs(vnor(1)).ge.abs(vnor(2)).and.abs(vnor(1)).ge.abs(vnor(3))) then
        call util_convex_hull_2d(nbuff,y2,z2,nh2d,kbuff,tiny2,ifail)
      else if (
     &    abs(vnor(2)).ge.abs(vnor(1)).and.abs(vnor(2)).ge.abs(vnor(3))) then
        call util_convex_hull_2d(nbuff,x2,z2,nh2d,kbuff,tiny2,ifail)
      else
        call util_convex_hull_2d(nbuff,x2,y2,nh2d,kbuff,tiny2,ifail)
      endif

      kfail=kfail+iabs(ifail)

      do ipoi=1,nbuff
        ifound=0
        do i=1,nh2d
          if (ipoi.eq.kbuff(i)) then
            ifound=1
            exit
          endif
        enddo
        if (ifound.eq.0) then
          kveto(ibuff(ipoi))=1
        endif
      enddo

      ibuff=0
      ibuff(1:nh2d)=iplans(kbuff(1:nh2d),1) ! must be a closed polygon

      k=ibuff(1)
      p1(1)=x(k)
      p1(2)=y(k)
      p1(3)=z(k)

      k=ibuff(2)
      p2(1)=x(k)
      p2(2)=y(k)
      p2(3)=z(k)

      k=ibuff(3)
      p3(1)=x(k)
      p3(2)=y(k)
      p3(3)=z(k)

      ! get normal vector vnor
      call util_plane(p1,p2,p3,p3,vnor,dist,iover,istat)
+self,if=debug3d.
      if (idebug.ne.0) then
        call util_vcross(p2-p1,p3-p2,vnortest)
        print*,"Test:",dot_product(vnor,vnortest)/norm2(vnortest)
      endif
+self.
      if (istat.ne.0) then
        kfail=-8
        cerror="*** Error in util_convex_hull_3d: Bad return from util_plane ***"
        goto 9999
      endif

      q=gcen-p1

      ! check orientation of plane

+self,if=debug3d.
      !!call util_break
+self.
      if (q(1)*vnor(1)+q(2)*vnor(2)+q(3)*vnor(3).gt.0.0d0) then

        k=nh2d-1

        ibuffp(1:k)=ibuff(1:k)

        if (nh2d.gt.lenface) then
          cerror="*** Error in util_convex_hull_3d: Boundary for kbuff exceeded ***"
          kfail=9
          goto 9999
        endif

        do ipoi=1,k
          kpoi=ibuffp(k-ipoi+1)
          ibuff(ipoi)=kpoi
        enddo

        ibuff(nh2d)=ibuff(1) ! must be a closed polygon

        vnor=-vnor

      endif

      nh2d=nh2d-1

+self,if=debug3d.
      !!call util_break
+self.

      ! First plane found
      nface=1
      nedge=nh2d
      nedgeheap=nedge
      lface=1
      kfaceheap(nface)=lface

      do iedge=1,nedge
        ib1=ibuff(iedge)
        ib2=ibuff(iedge+1)
        if (ib1.lt.ib2) then
          kedge(1,iedge)=ib1
          kedge(2,iedge)=ib2
        else
          kedge(1,iedge)=ib2
          kedge(2,iedge)=ib1
        endif
        kedge(3,iedge)=nface
        kedgeheap(iedge)=iedge
        k=ibuff(iedge)
        kface(lface+iedge)=k
+self,if=debug3d.
        k1=kedge(1,iedge)
        k2=kedge(2,iedge)
        write(995,*)
     &    nface,ib1,ib2,iedge,kedge(1:4,iedge),x(k1),y(k1),z(k1)
        write(995,*)
     &    nface,ib1,ib2,iedge,kedge(1:4,iedge),x(k2),y(k2),z(k2)
        flush(995)
+self.
      enddo

      kface(lface)=nh2d
+self,if=debug3d.
      ipoi=kface(1)
      do i=1,ipoi
        k=kface(1+i)
        write(994,*)"1 ",k,x(k),y(k),z(k)
      enddo
      flush(994)
      if (idebug.eq.1) then
        i_debug=nface
        !call util_break
      endif
+self.

      do while (nedgeheap.gt.0)

        medge=kedgeheap(nedgeheap)
        mface=kedge(3,medge)

        if (mface.le.0.or.kedge(4,medge).ne.0) then
          cerror="*** Bad pointer of face or bad edge in util_convex_hull_3d ***"
          kfail=20
          !!call util_break
          goto 9999
        endif

        lface=kfaceheap(mface)

        !Three pt1, pt2, and pt3 define current plane
        ifirst=kedge(1,medge)

        k=ifirst
        pt1(1)=x(k)
        pt1(2)=y(k)
        pt1(3)=z(k)

        isecond=kedge(2,medge)

        k=isecond
        pt2(1)=x(k)
        pt2(2)=y(k)
        pt2(3)=z(k)

        iveto=kveto
        do i=1,npoi
          k=iplans(i,mface)
          if (k.eq.0) exit
          iveto(k)=1
        enddo

        ithird=0
        do i=1,kface(lface)
          k=kface(lface+i)
          if (k.eq.ifirst.or.k.eq.isecond) cycle
          pt3(1)=x(k)
          pt3(2)=y(k)
          pt3(3)=z(k)
          exit
        enddo

c        print*,"mface,medge,ifirst,isecond,ithird:",mface,medge,ifirst,isecond,k

        p1=pt2-pt1
        p2=pt3-pt1

        vnor(1)=p1(2)*p2(3)-p1(3)*p2(2)
        vnor(2)=p1(3)*p2(1)-p1(1)*p2(3)
        vnor(3)=p1(1)*p2(2)-p1(2)*p2(1)

c        p3=gcen-pt1

c        if (vnor(1)*p3(1)+vnor(2)*p3(2)+vnor(3)*p3(3).lt.0.0d0) then
c          vnor=-vnor
c        endif

        !Rotate normal vector to z-axis

        call util_matrix_to_rot_vec_to_z(vnor,rotmat,ifail)

        q(1)=rotmat(1,1)*p1(1)+rotmat(1,2)*p1(2)+rotmat(1,3)*p1(3)
        q(2)=rotmat(2,1)*p1(1)+rotmat(2,2)*p1(2)+rotmat(2,3)*p1(3)
        q(3)=rotmat(3,1)*p1(1)+rotmat(3,2)*p1(2)+rotmat(3,3)*p1(3)

        qn=sqrt(q(1)**2+q(2)**2) !normalize x-y component

        if (qn.ne.qn.or.qn.lt.tiny) then
          kfail=77
          cerror="*** Error in util_convex_hull_3d: Problems with rotation to z-axis ***"
          goto 9999
        endif
        q=q/qn

        !Rotate edge to x-axis

        cosphi=q(1)
        sinphi=q(2)

        rotg(1,1)=cosphi
        rotg(1,2)=sinphi
        rotg(1,3)=0.0d0
        rotg(2,1)=-sinphi
        rotg(2,2)=cosphi
        rotg(2,3)=0.0d0
        rotg(3,1)=0.0d0
        rotg(3,2)=0.0d0
        rotg(3,3)=1.0d0

        call util_matrix_multiplication(3,3,3,rotg,rotmat,rotm,rotws)

c        q(1)=rotm(1,1)*p1(1)+rotm(1,2)*p1(2)+rotm(1,3)*p1(3)
c        q(2)=rotm(2,1)*p1(1)+rotm(2,2)*p1(2)+rotm(2,3)*p1(3)
c        q(3)=rotm(3,1)*p1(1)+rotm(3,2)*p1(2)+rotm(3,3)*p1(3)
c        print*,q

        cosmax=-2.0d0

        ! Look for new plane, starting from current edge

        pt1r(1)=rotm(1,1)*pt1(1)+rotm(1,2)*pt1(2)+rotm(1,3)*pt1(3)
        pt1r(2)=rotm(2,1)*pt1(1)+rotm(2,2)*pt1(2)+rotm(2,3)*pt1(3)
        pt1r(3)=rotm(3,1)*pt1(1)+rotm(3,2)*pt1(2)+rotm(3,3)*pt1(3)

        do ipoi=1,npoi

          if (iveto(ipoi).ne.0.or.kveto(ipoi).ne.0) cycle

          p3(1)=x(ipoi)
          p3(2)=y(ipoi)
          p3(3)=z(ipoi)

          q(1)=rotm(1,1)*p3(1)+rotm(1,2)*p3(2)+rotm(1,3)*p3(3)
          q(2)=rotm(2,1)*p3(1)+rotm(2,2)*p3(2)+rotm(2,3)*p3(3)
          q(3)=rotm(3,1)*p3(1)+rotm(3,2)*p3(2)+rotm(3,3)*p3(3)

          q=q-pt1r

          qn=sqrt(q(2)**2+q(3)**2)
          q=q/qn

          cosqpv=-q(2)

          if (cosqpv.gt.cosmax) then
            cosmax=cosqpv
            ibuff(3)=ipoi
          endif

        enddo

        ibuff(1)=ifirst
        ibuff(2)=isecond
        nbuff=3

        !p1, p2, and p3 define candidate for a new plane
        p1(1)=x(ibuff(1))
        p1(2)=y(ibuff(1))
        p1(3)=z(ibuff(1))

        p2(1)=x(ibuff(2))
        p2(2)=y(ibuff(2))
        p2(3)=z(ibuff(2))

        p3(1)=x(ibuff(3))
        p3(2)=y(ibuff(3))
        p3(3)=z(ibuff(3))

        !Collect all points belonging to the candidate plane

        iveto=kveto
        iveto(ibuff(1:3))=1

        do ipoi=1,npoi
          if (iveto(ipoi).ne.0.or.kveto(ipoi).ne.0.or.
     &      ipoi.eq.ibuff(1).or.ipoi.eq.ibuff(2).or.ipoi.eq.ibuff(3)) cycle
          q(1)=x(ipoi)
          q(2)=y(ipoi)
          q(3)=z(ipoi)
          call util_plane(p1,p2,p3,q,vnor,dist,iover,istat)
+self,if=debug3d
          if (idebug.ne.0) then
            call util_vcross(p2-p1,p3-p2,vnortest)
            print*,"Test:",dot_product(vnor,vnortest)/norm2(vnortest)
          endif
+self.
          if (istat.eq.0.and.abs(dist).lt.tiny) then
            nbuff=nbuff+1
            if (nbuff.gt.lenface) then
              kfail=-4
              cerror="*** Error in util_convex_hull_3d: Buffer exceeded ***"
              goto 9999
            endif
            ibuff(nbuff)=ipoi
          endif
        enddo

        do ipoi=1,nbuff
          kpoi=ibuff(ipoi)
          x2(ipoi)=x(kpoi)
          y2(ipoi)=y(kpoi)
          z2(ipoi)=z(kpoi)
          iplans(ipoi,nface+1)=kpoi !nface is incremented later
+self,if=debug3d.
          write(996,*)nface+1,ipoi,x(kpoi),y(kpoi),z(kpoi)
+self.
        enddo
+self,if=debug3d.
        flush(996)
        !!call util_break
+self.
        if (
     &      abs(vnor(1)).ge.abs(vnor(2)).and.abs(vnor(1)).ge.abs(vnor(3))) then
          call util_convex_hull_2d(nbuff,y2,z2,nh2d,kbuff,tiny2,ifail)
        else if (
     &      abs(vnor(2)).ge.abs(vnor(1)).and.abs(vnor(2)).ge.abs(vnor(3))) then
          call util_convex_hull_2d(nbuff,x2,z2,nh2d,kbuff,tiny2,ifail)
        else
          call util_convex_hull_2d(nbuff,x2,y2,nh2d,kbuff,tiny2,ifail)
        endif

        kfail=kfail+iabs(ifail)

        do ipoi=1,nbuff
          ifound=0
          do i=1,nh2d
            if (ipoi.eq.kbuff(i)) then
              ifound=1
              exit
            endif
          enddo
          if (ifound.eq.0) then
            kveto(ibuff(ipoi))=1
          endif
        enddo

        k=ibuff(kbuff(1))
        p1(1)=x(k)
        p1(2)=y(k)
        p1(3)=z(k)

        k=ibuff(kbuff(2))
        p2(1)=x(k)
        p2(2)=y(k)
        p2(3)=z(k)

        k=ibuff(kbuff(3))
        p3(1)=x(k)
        p3(2)=y(k)
        p3(3)=z(k)

        call util_plane(p1,p2,p3,p3,vnor,dist,iover,istat)
+self,if=debug3d.
        if (idebug.ne.0) then
          call util_vcross(p2-p1,p3-p2,vnortest)
          print*,"Test:",dot_product(vnor,vnortest)/norm2(vnortest)
        endif
+self.
        if (istat.ne.0) then
          kfail=-8
          cerror="*** Error in util_convex_hull_3d: Bad return from util_plane ***"
          goto 9999
        endif

        q=gcen-p1

        ! check orientation of plane

        if (q(1)*vnor(1)+q(2)*vnor(2)+q(3)*vnor(3).gt.0.0d0) then

          ibuffp(1:nh2d)=kbuff(1:nh2d)

          if (nh2d.gt.lenface) then
            cerror="*** Error in util_convex_hull_3d: Boundary for kbuff exceeded ***"
            kfail=9
            goto 9999
          endif

          do ipoi=1,nh2d
            kbuff(ipoi)=ibuffp(nh2d-ipoi+1)
          enddo

        endif

        nh2d=nh2d-1
        nfpoi=nh2d

        !New face found!
        lface=kfaceheap(nface)
        lface=lface+kface(lface)+1

        nface=nface+1
        kfaceheap(nface)=lface

        kface(lface)=nfpoi
        do ipoi=1,nfpoi
          k=ibuff(kbuff(ipoi))
          kface(lface+ipoi)=k
        enddo
+self,if=debug3d.
          ipoi=kface(lface)
          do i=1,ipoi
            k=kface(lface+i)
            write(994,*)nface,k,x(k),y(k),z(k)
          enddo
          flush(994)
          if (idebug.eq.1) then
            i_debug=nface
            !call util_break
          endif
+self.

        kedge(4,medge)=nface

        !Check for new edges

        ifound=0

        iedge=nedge
        do ipoi=1,nfpoi
          ib1=ibuff(kbuff(ipoi))
          ib2=ibuff(kbuff(ipoi+1))
          if (ib1.gt.ib2) then
            ib2=ibuff(kbuff(ipoi))
            ib1=ibuff(kbuff(ipoi+1))
          endif
          ifound=0
+self,if=debug3d.
        k1=kedge(1,nedge)
        k2=kedge(2,nedge)
        write(995,*)
     &    nface,ib1,ib2,nedge,kedge(1:4,nedge),x(k1),y(k1),z(k1)
        write(995,*)
     &    nface,ib1,ib2,nedge,kedge(1:4,nedge),x(k2),y(k2),z(k2)
          flush(995)
+self.
          do ledge=1,iedge
            if (
     &          ib1.eq.kedge(1,ledge).and.
     &          ib2.eq.kedge(2,ledge)
     &          ) then
              ifound=1
              if (kedge(3,ledge).eq.0) then
                cerror="*** Error in util_convex_hull_3d: Bad edge ***"
                !!call util_break
                kfail=kfail+1
              endif
              if (kedge(4,ledge).eq.0) then
                kedge(4,ledge)=nface
              endif
              exit
            endif
          enddo

          if (ifound.eq.0) then
            nedge=nedge+1
            if (nedge.gt.lenedge) then
              cerror='*** util_convex_hull_3d: Dimension lenedge exceeded'
              kfail=81
              goto 9999
            endif
            kedge(1,nedge)=ib1
            kedge(2,nedge)=ib2
            kedge(3,nedge)=nface
          endif
        enddo !iedge=1,nfpoi

        nedgeheap=0
        do iedge=1,nedge
          if (kedge(4,iedge).eq.0) then
            nedgeheap=nedgeheap+1
            if (nedgeheap.gt.2*npoi-2) then
              kfail=82
              goto 9999
            endif
            kedgeheap(nedgeheap)=iedge
          endif
        enddo

      enddo !while (nedgeheap.gt.0)

89    continue

      nhull=0

      do iedge=1,nedge
        kpoi=kedge(1,iedge)
        if (kpoi.le.0) then
          write(6,*)
          write(6,*)"*** Error in util_convex_hull_3d: Bad edges ***"
          write(6,*)
          !!call util_break
          kfail=86
        endif
        ifound=0
        do ipoi=1,nhull
          if (kpoi.eq.khull(ipoi)) then
            ifound=1
            exit
          endif
        enddo
        if (ifound.eq.0) then
          nhull=nhull+1
          if (nhull.gt.npoi) then
            kfail=83
            goto 91
          endif
          khull(nhull)=kpoi
        endif
        kpoi=kedge(2,iedge)
        ifound=0
        do ipoi=1,nhull
          if (kpoi.eq.khull(ipoi)) then
            ifound=1
            exit
          endif
        enddo
        if (ifound.eq.0) then
          nhull=nhull+1
          if (nhull.gt.npoi) then
            kfail=84
            goto 9999
          endif
          khull(nhull)=kpoi
        endif
      enddo !nedge

91    if (kfail.eq.0) then

        allocate(kedgebuff(2,nedge))

        kbuff(1:nhull)=khull(1:nhull)
        do i=1,nhull
          khull(i)=istore(kbuff(i))
        enddo

        kedgebuff(1:2,1:nedge)=kedge(1:2,1:nedge)
        do i=1,nedge
          kedge(1,i)=istore(kedgebuff(1,i))
          kedge(2,i)=istore(kedgebuff(2,i))
        enddo

        do kfacelast=1,lenface
          if (kface(kfacelast).eq.0) then
            exit
          endif
          if (kfacelast.gt.lenface) then
            cerror="*** Error in util_convex_hull_3d: Boundary lenface exceeded ***"
            kfail=9
            deallocate(kedgebuff)
            goto 9999
          endif
          kbuff(kfacelast)=kface(kfacelast)
        enddo
        kfacelast=kfacelast-1

        lface=1
        do iface=1,nface
          nfpoi=kbuff(lface)
          do i=1,nfpoi
            if (lface+i.gt.lenface) then
              cerror="*** Error in util_convex_hull_3d: Boundary for kbuff exceeded ***"
              kfail=9
              deallocate(kedgebuff)
              goto 9999
            endif
            kface(lface+i)=istore(kbuff(lface+i))
          enddo
          lface=lface+nfpoi+1
        enddo

        if (lface-1.ne.kfacelast) then
          kfail=kfail+1
          cerror="*** Error in util_convex_hull_3d: Bad kfacelast ***"
        endif

        deallocate(kedgebuff)

      endif !kfail

+self,if=debug3d.
      do k=1,nhull
        i=khull(k)
        write(997,*) x(i),y(i),z(i),i
      enddo
      flush(997)
      close(997)
+self.

9999  continue

c      if (ical.eq.195) then
c        !call util_break
c      endif

      deallocate(kfaceheap,kedgeheap,ibuff,ibuffp,ibuffm,kbuff,iplans,istore,
     &  iveto,kveto,x,y,z,x2,y2,z2)

c      if (ical.eq.195) then
c        !call util_break
c      endif

      if (idimfail.ne.0) then
        kfail=idimfail
      endif

      if (kfail.ne.0.and.kfail.ne.100) then
        write(6,*)trim(cerror)
        write(6,*)"*** Error in util_convex_hull3d: kfail.ne.0 .and. kfail.ne.100, ical:",ical
      endif

      if (kfail.eq.0.and.nface+nhull-nedge.ne.2) then
        write(6,*)"Error in util_convex_hull3d: Euler's formula not fullfilled"
        kfail=-99
      endif

+self,if=debug3d.
      close(991)
      close(992)
      close(993)
      close(994)
      close(995)
      close(996)
      !print*,"--- Leaving util_convex_hull_3d ---"
+self.
+self,if=p.
      k=0
      iface=0
      do i=1,kfacelast
        k=k+1
        if (k.gt.kfacelast) exit
        iface=iface+1
        nfpoi=kface(k)
        do ipoi=1,nfpoi
          k=k+1
          kpoi=kface(k)
          if(ipoi.eq.1) then
            p1=[xin(kpoi),yin(kpoi),zin(kpoi)]
          else if(ipoi.eq.2) then
            p2=[xin(kpoi),yin(kpoi),zin(kpoi)]
          else if(ipoi.eq.3) then
            p3=[xin(kpoi),yin(kpoi),zin(kpoi)]
          else
            p1=p2
            p2=p3
            p3=[xin(kpoi),yin(kpoi),zin(kpoi)]
          endif
          if (ipoi.lt.3) cycle
          pcen=(p1+p2+p3)/dble(3)
          call util_vcross(p2-p1,p3-p2,vnor)
          vnor=vnor/norm2(vnor)
          call util_break
          print*,iface,dot_product(gcenin-pcen,vnor)
        enddo
      enddo
c      stop
+self.
      return
      end
+DECK,util_solve_3x3.
*CMZ :  2.05/01 06/10/2023  11.46.25  by  Michael Scheer
*CMZ : 00.00/16 20/07/2015  09.58.29  by  Michael Scheer
*-- Author :    Michael Scheer   20/07/2015
      subroutine util_solve_3x3(a,x,ifail)

      implicit none

      real*8 a(3,3),x(3),det,dws,ws(3,3),xs(3)

      integer ifail,i

      call util_determinante_3(a,det)
      if (det.eq.0.0d0) then
        ifail=-1
        return
      endif

      xs=x

      do i=1,3
        ws(1:3,1:3)=a(1:3,1:3)
        ws(1:3,i)=xs
        call util_determinante_3(ws,dws)
        x(i)=dws/det
      enddo

      ifail=0

      return
      end
+DECK,util_weed_integer_list.
*CMZ :  2.05/01 03/10/2023  10.48.16  by  Michael Scheer
*CMZ :  1.11/04 21/01/2017  16.50.32  by  Michael Scheer
*-- Author :    Michael Scheer   20/01/2017
      subroutine util_weed_integer_list(npoi,ipois)

      implicit none

      integer npoi,ipois(npoi),nweed,ipoi,ifound,i,k

      nweed=1
      do ipoi=1,npoi
        do i=nweed+1,npoi
          ifound=0
          do k=1,nweed
            if(ipois(k).eq.ipois(i)) then
              ifound=1
              exit
            endif
          enddo
          if (ifound.eq.0) then
            nweed=nweed+1
            ipois(nweed)=ipois(i)
          endif
        enddo
      enddo

      npoi=nweed

      return
      end
+DECK,util_hull_check_convex.
*CMZ :  2.05/01 11/10/2023  17.11.14  by  Michael Scheer
*-- Author :    Michael Scheer   02/10/2023
      subroutine util_hull_check_convex(nverts,verts,
     &  khull,kedge,kface,nhull,nedge,nface,kfacelast,
     &  nconcave,lconcave,hulltiny,kfail)

      implicit none

      double precision, dimension (:), allocatable :: xp,yp,zp

      double precision verts(3,nverts),hulltiny,p1(3),p2(3),p3(3),q(3),dist,
     &  vnor(3)

      integer i,nconcave,nverts,nface,nedge,nhull,lconcave(nverts),kfail,
     &  kfacelast,khull(nverts),kedge(4,*),kface(*),l,iover

+seq,hulldim.

      integer :: nallo=1000,kloc(3),iface,k,ipoi,npoi

      nconcave=0
      nallo=2*(nverts+1)*nverts

      allocate(xp(nallo),yp(nallo),zp(nallo))

      lenhull=nallo
      lenedge=nallo
      lenface=nallo
      nverhullmax=nallo

      xp(1:nverts)=verts(1,1:nverts)
      yp(1:nverts)=verts(2,1:nverts)
      zp(1:nverts)=verts(3,1:nverts)

      call util_convex_hull_3d(
     &  nverts,xp,yp,zp,khull,kedge,kface,
     &  nhull,nedge,nface,kfacelast,hulltiny,kfail)

      if (nhull.eq.nverts) return

      do i=1,nverts
        kloc=findloc(khull,i,1)
        if (kloc(1).eq.0) then
          nconcave=nconcave+1
          lconcave(nconcave)=i
        endif
      enddo

      k=0
      do iface=1,nface
        k=k+1
        if (k.gt.kfacelast) exit
        npoi=kface(k)
        do ipoi=1,npoi
          k=k+1
          p1=[xp(ipoi),yp(ipoi),zp(ipoi)]
          k=k+1
          p2=[xp(ipoi),yp(ipoi),zp(ipoi)]
          k=k+1
          p3=[xp(ipoi),yp(ipoi),zp(ipoi)]
        enddo
        do l=1,nconcave
          ipoi=lconcave(l)
          q=[xp(ipoi),yp(ipoi),zp(ipoi)]
          call util_plane_tiny(p1,p2,p3,q,vnor,dist,hulltiny,iover,kfail)
          if(abs(dist).ne.hulltiny) then
            lconcave(l)=-lconcave(l)
          endif
        enddo
      enddo

      deallocate(xp,yp,zp)

      return
      end
+DECK,util_invert_matrix_3x3.
*CMZ :  2.05/01 06/10/2023  12.18.53  by  Michael Scheer
*-- Author :    Michael Scheer   10/01/2018
      subroutine util_invert_matrix_3x3(a,ainv,ifail)

c +PATCH,//UTIL/UTIL
c +DECK,util_invert_matrix_3x3.

      ! Calcutate

      implicit none

      double precision a(3,3),ainv(3,3),uni(3,3)
      integer :: ifail

      data uni/1.0d0,0.0d0,0.0d0,0.0d0,1.0d0,0.0d0,0.0d0,0.0d0,1.0d0/

      call util_solve_matrix_3x3(a,uni,ainv,ifail)

      return
      end
+DECK,util_solve_matrix_3x3.
*CMZ :  2.05/01 06/10/2023  12.12.36  by  Michael Scheer
*-- Author :    Michael Scheer   15/08/2018
      subroutine util_solve_matrix_3x3(a,b,x,ifail)

c +PATCH,//UTIL/UTIL
c +DECK,util_solve_matrix_3x3.

      ! Calculate matrix x, such that b=x*a

      implicit none

      double precision x(3,3),a(3,3),b(3,3),det,v(3)
      integer :: ifail,i

      ifail=0
      call util_determinante_3(a,det)
      if (abs(det).lt.1.0d-30) then
        ifail=-1
        return
      endif

      do i=1,3
        v=b(1:3,i)
        call util_solve_3x3(a,v,ifail)
        if (ifail.ne.0) return
        x(1:3,i)=v
      enddo

      return
      end
+DECK,util_hull_check_convex_2d.
*CMZ :  2.05/01 10/10/2023  10.34.41  by  Michael Scheer
*-- Author :    Michael Scheer   02/10/2023
      subroutine util_hull_check_convex_2d(nverts,verts,khull,nhull,
     &  nconcave,lconcave,tiny,kfail)

      implicit none


      double precision, dimension (:), allocatable :: xp,yp

      double precision verts(2,nverts),tiny

      integer i,nconcave,nverts,nhull,lconcave(*),kfail,khull(*)

      integer :: nallo=1000,kloc(3)

      nconcave=0
      nallo=2*(nverts+1)*nverts

      allocate(xp(nallo),yp(nallo))

      xp(1:nverts)=verts(1,1:nverts)
      yp(1:nverts)=verts(2,1:nverts)

      call util_convex_hull_2d(nverts,xp,yp,nhull,khull,tiny,kfail)

      khull(nhull)=0
      nhull=nhull-1

      if (nhull.eq.nverts) goto 9999

      do i=1,nverts
        kloc=findloc(khull(1:nhull),i,1)
        if (kloc(1).eq.0) then
          nconcave=nconcave+1
          lconcave(nconcave)=i
        endif
      enddo

9999  deallocate(xp,yp)

      return
      end
+DECK,util_concave_2d.
*CMZ :  2.05/01 10/10/2023  10.33.44  by  Michael Scheer
*-- Author :    Michael Scheer   07/10/2023
      subroutine util_concave_2d(nverts,verts,ivera,nparts,nvera,tiny,kfail)

      implicit none

      double precision, dimension(:,:), allocatable :: work
      integer, dimension(:), allocatable :: khull,lconcave,kveto

      double precision :: verts(2,nverts),tiny
      integer :: ivera(nverts*nverts)

      integer nverts,nhull,nconcave,kfail,l,i,n2,nparts,nvera(nverts),nv

      allocate(work(2,nverts),khull(nverts),kveto(nverts),lconcave(nverts))

      call util_hull_check_convex_2d(nverts,verts,khull,nhull,
     &  nconcave,lconcave,tiny,kfail)

      nparts=1
      kfail=0

      if (nconcave.eq.0) then
        nparts=1
        do i=1,nverts
          ivera(i)=i
          nvera(1)=nverts
        enddo
        goto 9999
      endif

      nv=0
      kveto=0
      do while(nconcave.gt.0)

        l=lconcave(nconcave)

        nv=nv+1
        ivera(nv)=l
        l=l+1
        if (l.gt.nverts) l=1
        do while(kveto(l).ne.0)
          l=l+1
        enddo
        nv=nv+1
        ivera(nv)=l
        kveto(l)=1
        l=l+1
        if (l.gt.nverts) l=1
        do while(kveto(l).ne.0)
          l=l+1
        enddo
        nv=nv+1
        ivera(nv)=l
        nvera(nparts)=3

        nparts=nparts+1
        n2=0
        do i=1,nverts
          if(kveto(i).ne.0) cycle
          n2=n2+1
          nv=nv+1
          ivera(nv)=i
          work(:,n2)=verts(:,i)
        enddo

        call util_hull_check_convex_2d(n2,work,khull,nhull,
     &    nconcave,lconcave,tiny,kfail)

        nv=nv-n2

      enddo

      nvera(nparts)=n2

9999  deallocate(work,khull,kveto,lconcave)

      return
      end
+DECK,util_triangu_2d.
*CMZ :  2.05/01 10/10/2023  09.23.41  by  Michael Scheer
*-- Author :    Michael Scheer   07/10/2023
      subroutine util_triangu_2d(nverts,verts,ivera,ntri,tiny,kfail)

      implicit none

      double precision :: verts(2,nverts),tiny
      integer ivera(nverts*nverts)
      integer, dimension(:), allocatable :: nvera,iwera

      integer nverts,kfail,ipart,nparts,ntri,nv,mparts,i1,i2,i,nw

      allocate(nvera(nverts))
      call util_concave_2d(nverts,verts,ivera,nparts,nvera,tiny,kfail)
      allocate(iwera(nverts*nverts))

      iwera=ivera

      ntri=0
      nw=0
      nv=0
      mparts=nparts
      do ipart=1,mparts
        if (nvera(ipart).eq.3) then
          ntri=ntri+1
          nv=nv+1
          nw=nw+1
          ivera(nv)=iwera(nw)
          nv=nv+1
          nw=nw+1
          ivera(nv)=iwera(nw)
          nv=nv+1
          nw=nw+1
          ivera(nv)=iwera(nw)
        else
          ntri=ntri+1
          nv=nv+1
          nw=nw+1
          ivera(nv)=iwera(nw)
          i1=nw
          nv=nv+1
          nw=nw+1
          ivera(nv)=iwera(nw)
          nv=nv+1
          nw=nw+1
          i2=nw
          ivera(nv)=iwera(nw)
          do i=4,nvera(ipart)
            ntri=ntri+1
            nv=nv+1
            ivera(nv)=iwera(i1)
            nv=nv+1
            ivera(nv)=iwera(i2)
            nv=nv+1
            nw=nw+1
            ivera(nv)=iwera(nw)
            i2=nw
          enddo
        endif
      enddo

      deallocate(nvera,iwera)

      return
      end
+PATCH,TEX,T=LATEX.
*CMZ :  1.02/01 05/09/2016  08.18.58  by  Michael Scheer
+KEEP,udocvers,T=LATEX.
*CMZ :  2.05/01 23/10/2023  14.26.31  by  Michael Scheer
*CMZ :  2.04/28 30/09/2023  10.58.07  by  Michael Scheer
*CMZ :  2.04/27 28/09/2023  14.24.47  by  Michael Scheer
*CMZ :  2.04/26 28/09/2023  13.25.52  by  Michael Scheer
*CMZ :  2.04/25 28/09/2023  08.31.19  by  Michael Scheer
*CMZ :  2.04/24 27/09/2023  16.46.53  by  Michael Scheer
*CMZ :  2.04/23 27/09/2023  09.40.54  by  Michael Scheer
*CMZ :  2.04/22 26/09/2023  21.34.56  by  Michael Scheer
*CMZ :  2.04/21 22/09/2023  09.06.23  by  Michael Scheer
*CMZ :  2.04/20 21/09/2023  10.28.15  by  Michael Scheer
*CMZ :  2.04/19 18/09/2023  11.33.14  by  Michael Scheer
*CMZ :  2.04/18 14/09/2023  07.39.08  by  Michael Scheer
*CMZ :  2.04/17 13/09/2023  16.15.26  by  Michael Scheer
*CMZ :  2.04/16 11/09/2023  11.57.47  by  Michael Scheer
*CMZ :  2.04/15 06/09/2023  08.20.46  by  Michael Scheer
*CMZ :  2.04/12 31/08/2023  06.57.59  by  Michael Scheer
*CMZ :  2.04/11 29/08/2023  15.03.24  by  Michael Scheer
*CMZ :  2.04/10 23/08/2023  16.14.31  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.16.48  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.57.08  by  Michael Scheer
*CMZ :  2.04/07 10/08/2023  09.14.02  by  Michael Scheer
*CMZ :  2.04/06 07/08/2023  10.05.29  by  Michael Scheer
*CMZ :  2.04/04 14/03/2023  11.22.26  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.38.01  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.57.20  by  Michael Scheer
*CMZ :  2.04/00 17/01/2023  13.14.13  by  Michael Scheer
*CMZ :  2.03/00 02/09/2022  07.21.32  by  Michael Scheer
*CMZ :  2.02/02 07/07/2022  18.13.06  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.40.43  by  Michael Scheer
*CMZ :  2.01/07 28/07/2020  10.27.15  by  Michael Scheer
*CMZ :  2.01/06 27/07/2020  12.07.59  by  Michael Scheer
*CMZ :  2.01/05 27/07/2020  10.28.00  by  Michael Scheer
*CMZ :  2.01/04 29/07/2019  12.06.40  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  15.17.18  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.51.26  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  15.06.30  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  15.01.01  by  Michael Scheer
*CMZ :  1.23/00 04/08/2017  09.35.04  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.36.01  by  Michael Scheer
*CMZ :  1.21/00 29/06/2017  16.12.16  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  11.27.31  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.34.58  by  Michael Scheer
*CMZ :  1.18/00 06/06/2017  14.48.14  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  16.57.03  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  14.11.11  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  12.03.00  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  12.54.38  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  17.04.56  by  Michael Scheer
*CMZ :  1.12/00 27/02/2017  15.49.37  by  Michael Scheer
*CMZ :  1.11/00 05/01/2017  09.37.44  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.20.28  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  12.55.22  by  Michael Scheer
*CMZ :  1.08/00 30/09/2016  13.55.02  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  15.02.55  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  18.55.37  by  Michael Scheer
*CMZ :  1.02/01 05/09/2016  08.41.09  by  Michael Scheer
*-- Author :    Michael Scheer   05/09/2016
Version 2.05/01
+PATCH,TEXT,T=TEXT.
*CMZ :  1.10/03 01/12/2016  14.13.38  by  Michael Scheer
+DECK,undumag_plot,T=TEXT.
*CMZ :  2.05/01 23/10/2023  14.24.44  by  Michael Scheer
*-- Author :    Michael Scheer   23/10/2023

There are two ways to plot UNDUMAG in- and output:

From the GUI: py -i $UNDUMAG/python/undugui.py

or from the commandline:

{
Set up the environment first:

  install ipython3
  create ~/.ipython

  cd $UNDUMAG/stage

  touch .empty.py
  ipython3 --profile undu -i .empty.py # Leave with Ctrl D
  cp $UNDUMAG/python/ipylogon.py .

  cd ~/.ipylogon/profile_undu/startup
  ln -s $UNDUMAG/stage/ipylogon.py .

  cd $UNDUMAG/stage
  cp ../shell/plot.sh .

} end of set-up

To plot something from UNDUMAG:

. ./plot.sh [arguments]

The arguments are stored in ipylogon.arg. These arguments are used if
plot.sh is executed next time without arguments.

Check ipylogon.py for possible arguments. A good starting point is:

. ./plot.sh load

This loads the outputs of UNDUMAG mainly as pandas data frames (Python
module pandas), here called n-tuples.

Some useful commands to handle data of n-tuples:

List n-tuples
nlist()

Show summary of n-tuple nmap
ninfo(nmap)

Lowest absolute y- and z-value:
ymina = abs(nmap.y).min()
zmina = abs(nmap.z).min()

select = "y == " + str(ymina) + " and z == " + str(zmina)

npl(nmap,"x:By",select,plopt='line',color='r')
npl(nmap,"x:Bz",select,plopt='sameline',color='b')

This plots the vertical and horizontal fields on or closest to the
x-axis.

To learn more about the plotting of n-tuples, check undumag_plot.py and look for
"def nplot("... OR get used to the plotting of pandas data frames with
matplotlib.

+PATCH,PYTHON,T=PYTHON.
*CMZ :  2.01/05 26/02/2020  09.19.37  by  Michael Scheer
+KEEP,undumagseq,T=PYTHON.
*CMZ :  2.05/01 21/10/2023  14.57.01  by  Michael Scheer
*CMZ :  2.04/13 01/09/2023  08.30.05  by  Michael Scheer
*CMZ :  2.04/11 25/08/2023  08.21.45  by  Michael Scheer
*CMZ :  2.04/00 07/09/2022  16.32.24  by  Michael Scheer
*CMZ :  2.03/00 22/08/2022  11.27.45  by  Michael Scheer
*-- Author :    Michael Scheer   22/08/2022
def _undumag(callkey=''):

+seq,uguiglobind.

  print("Executing\nundumag.exe",Rmodus)

  if len(Rmodus):
    if Rmodus.split()[0] == 'FILAMENTS':
      print('to update undumag.fil\n')
    elif Rmodus.split()[0] == 'SEGMENTATION':
      print('to perform segmentation, i.e. updating undumag.geo etc..\n')
    #endif
  #endif
+self,if=trace.
  debug("\ntrace::_undumag:",callkey + " " + str(Rmodus))
+self.

  if IUNDUMAGisRunning:
    wError("UNDUNMAG IS RUNNING!")
+self,if=trace.
    debug(NL,"trace:: Leaving _undumag due to  error")
+self.
    return
  #endif IUNDUMAGisRunning

  if NMagPolTot <= 0 and NCoil <= 0:
    wError("No magnetic items set-up so far...!")
+self,if=trace.
    debug(NL,"trace:: Leaving _undumag due to  error")
+self.
  #endif IUNDUMAGisRunning

  if type(Rmodus) == str and len(Rmodus) and NCoil > 0:
    ureadfil("_undumag")
+self,if=trace.
    debug(NL,"trace:: Leaving _undumag after call to ureadfil")
+self.
    return
    #Quit("Ende in _undumag")

  Fnam = 'undumag.nam'
  Fclc = 'undumag.clc'

  #if MustWriteCLC:

  uwriteclc('UNDUMAG')
  uwritenam('UNDUMAG')

  uwait = Toplevel()
  uwait.title('Waiting for UNDUMAG to finish')

  x,y = Umaster.winfo_pointerxy()
  sgeo = '+' + str(x) + '+' + str(y)

  uwait.geometry(sgeo)
  uwait.attributes('-topmost', 1)

  lwarn = Label(uwait,text="   Be patient and check terminal...\n Plotting may also take some time ...  ",font=MyFont)
  lwarn.pack(fill=X)
  uwait.update()

  if len(Rmodus) == 0:

    IUNDUMAGisRunning = 1
    ifail = os.system(RunUndu)
    uwait.destroy()

    if ifail:
      IUNDUMAGisRunning = 0
      wError("\n*** UNDUMAG run failed ***")
+self,if=trace.
      debug(NL,"trace:: Leaving _undumag due to  error")
+self.
      return
    #endif

    undu_get_runnumber()
    nreloadupl()
    undu_overview()

    IUNDUMAGisRunning = 0

    ifail = 1
    itry = 0
    cline = '1'
    while itry < 10:
      try:
        Fsta = open("undumag.stat","r")
        cline = Fsta.readline().strip()
        break
      except:
        itry += 1
        sleep(3)
      #endtry
    #endwhile

    if cline == '0': ifail = 0
    if ifail: wError("\n*** UNDUMAG run failed ***")

  elif Rmodus.split()[0] == 'SEGMENTATION':

    IUNDUMAGisRunning = 1
    os.system(RunUndu + " " + Rmodus)
    uwait.destroy()
    IUNDUMAGisRunning = 0

    undu_get_runnumber()
    nreloadupl()

    try:
      Fsta = open("undumag.sta","r")
      cline = Fsta.readline().strip()
      cline = Fsta.readline().strip()
      if cline != 'Segmentation finished':
        wError("\n*** UNDUMAG run for segmentation failed ***")
      #endif trim(cline) != ' Segmentation finished'
    except:
      wError("\n*** UNDUMAG run for segmentation failed ***")
+self,if=trace.
      debug(NL,"trace:: Leaving _undumag due to  error")
      return
+self.
    #endtry

  #endif len(Rmodus) == 0
+self,if=trace.
    debug(NL,"trace:: Leaving _undumag")
+self.

#enddef _undumag()

def _runundumag(callkey='',modus=''):

+seq,uguiglobind.

+self,if=trace.
  debug(NL,"trace::_runundumag:",callkey,modus)
+self.

  Rmodus = modus
  _undumag('_rundunmag')

#enddef
+KEEP,uwriteclc,T=PYTHON.
*CMZ :  2.05/01 21/10/2023  16.14.11  by  Michael Scheer
*CMZ :  2.04/13 01/09/2023  10.25.29  by  Michael Scheer
*CMZ :  2.04/06 10/07/2023  10.00.28  by  Michael Scheer
*CMZ :  2.04/00 07/09/2022  09.21.13  by  Michael Scheer
*CMZ :  2.03/00 31/08/2022  11.28.07  by  Michael Scheer
*CMZ :  2.02/02 08/03/2022  12.05.08  by  Michael Scheer
*CMZ :  2.02/01 30/04/2021  14.53.27  by  Michael Scheer
*CMZ :  2.02/00 30/03/2021  12.54.31  by  Michael Scheer
*CMZ :  2.01/08 30/07/2020  10.49.14  by  Michael Scheer
*CMZ :  1.32/11 14/04/2020  16.26.11  by  Michael Scheer
*CMZ :  1.32/05 25/10/2019  14.13.42  by  Michael Scheer
*-- Author :    Michael Scheer   09/10/2019
+seq,writetrc.
def write_variables(Fclc):

+seq,uguiglobind.

  if not '$Mcoating' in Variables and not '$Mcoating' in Pars:
    Fclc.write("$Mcoating = 0.0 ! Coating of magnets \n")
  #endif not '$PerLen' in Variables

  if not '$PerLen' in Variables and not '$PerLen' in Pars:
    Fclc.write("$PerLen = 0.0 ! Dummy for period-length\n")
  #endif not '$PerLen' in Variables

  for p in Pars:
    ps = p[1:] # strip $
    if '$' + ps in Variables: continue
    Fclc.write("$" + ps + "=" + str(Pars[p]) + "\n")
  #endfor p in Pars

  for vnam in Variables:
    if vnam in DictCalcs: continue
    vcom = DictVcomments[vnam]
    if len(vcom): vcom = ' ! ' + vcom
    Fclc.write("$" + vnam[1:] + "=" + str(Variables[vnam]) + vcom + "\n")
  #endfor p in Pars
  Fclc.write("\n")

  for c in DictUnduColors:
    if c[0] != '$': sc = '$' + c
    else: sc = c
    if sc in Pars or sc in Variables: continue
    s = "$" + c + "=" + str(DictUnduColors[c])
    Fclc.write(s+"\n")
  #endfor c in UnduColors

  for calc in Calcs:
    com = DictVcomments[calc[0]]
    if len(com.strip()): com = '! ' + com
    Fclc.write(calc[0] + " = " + calc[1] + com + "\n")
  #endfor calc

#enddef write_variables

def write_coils(coils,Fclc,kcoil=-1):

  #print("write_coils:",coils,kcoil)
  iexplain = 0

  Fclc.write(NL)

  icoil = -1
  for coil in coils:

    #if calc_var(coil[1][0]) == 0.0: continue

    icoil += 1
    if kcoil > -1 and kcoil != icoil: continue

    key = coil[0][0].upper()

    Fclc.write("\n& Coil\n")
    Fclc.write(coil[0][0] + " " + coil[0][1] + "\n")

    if key == 'RECTWINDINGS':

      if iexplain == 0:
        iexplain = 1
        Fclc.write("* RectWindings:\n")
        Fclc.write("* Current per winding, filling factor, number of windings, center, normal vector, rotation-angle, total length,\n")
        Fclc.write("* inner width, outer width, inner radius, height, vert/hori/rad divisions, color-index\n")
      #endif

      scoil = ''
      for s in coil[1]:
        scoil = scoil + ' ' + s
      #endfor s in coil[1]
      Fclc.write(scoil + "\n")

    elif key == 'FILAMENTS':

      Fclc.write(coil[1] + "\n")
      for i in range(int(coil[1])):
        atom = ''
        for dat in coil[2][i]:
          atom += dat + " "
      #endfor
      Fclc.write(atom + "\n")

    elif key == 'FILE':
      Fclc.write(coil[1] + "\n")

    elif key == 'RECTARC' or key == 'RECTBAR' or \
    key == 'THICKWIRE' or key == 'CIRCARC':

      for i in range(2):
        atom = ''
        for dat in coil[1][i]:
          atom += dat + " "
        #endfor
        Fclc.write(atom + "\n")
      #endfor
    #endfor

    else:

      atom = ''
      for dat in coil[1]:
        atom += dat + " "
      #endfor
      Fclc.write(atom + "\n")

    #endif key

  #endfor coil in coils

#enddef write_coils(coils,fileclc)

def write_coils_old(coils,Fclc):

  Fclc = open(Fclc,'a')

  Fclc.write("************\n")
  Fclc.write("\n")
  Fclc.write("Coils\n")

  iexplain = 0

  for coil in coils:

   if iexplain == 0 and coil[0][0].upper() == 'RECTWINDINGS':
     iexplain = 1
     Fclc.write("\n* RectWindings:\n")
     Fclc.write("\n* Current per winding, filling factor, number of windings, center, normal vector, rotation-angle, total length,\n")
     Fclc.write("* inner width, outer width, inner radius, height, vert/hori/rad divisions, color-index\n*")
   #endif

   Fclc.write(coil[0] + "\n")
   scoil = ''
   for s in coil[1]:
     scoil = scoil + ' ' + s
   #endfor s in coil[1]
   Fclc.write(scoil + "\n")
  #endfor coil in coils

  Fclc.write("EndCoils\n")
  Fclc.write("************\n")

  Fclc.close()

#enddef write_coils_old(coils,fileclc)

def uwriteclc(callkey=''):
+seq,uguiglobind.

+self,if=trace.
  print("\n\ntrace: uwriteclc:callkey:",callkey)
  print("AppleII_Mode,Hybrid_Mode:",AppleII_Mode,Hybrid_Mode)
+self.

  if yesno(S_IzSym.get()) == 'yes': izsym = 1
  else: izsym = 0
  if yesno(S_IySym.get()) == 'yes': iysym = 1
  else: iysym = 0
  if yesno(S_IxSym.get()) == 'yes': ixsym = 1
  else: ixsym = 0

  blanks = "                                                                                                      "

  mpperi = deepcopy(MagPols)
  mpspec = deepcopy(SpecMagPols)

  Npar = len(Pars)
  Nvar = len(Variables)

  mats = deepcopy(Materials)

  for m in mats:
    if m[1] == 'REC': m[1] = 1
    elif m[1] == 'Iron': m[1] = 2
  #endfor

  Mode = 'Unknown'

  if callkey == 'UNDUMAG':
  #if callkey != "clWfclc":
    if int(AppleII_Mode) > 0:
      Mode = 'AppleII'
      AppleII_Mode = 0
    elif int(Hybrid_Mode) == 1:
      Mode = 'Hybrid'
      Hybrid_Mode = 0
    elif int(Hybrid_Mode) == 2:
      Mode = 'Mirror'
      Hybrid_Mode = 0
  #endif

+self,if=trace.
  debug("trace: uwriteclc:Mode",Mode)
+self.

  if int(AppleII_Mode) > 0:

    FileCLC = "undumag.clc"

    Flast = open("unduclc.lst","w")
    Flast.write(FileCLC+NL)
    Flast.close()

    Fmu = open(FileMu,'w')
    Fmu.write(S_Mu_AppleII.get() + " " + S_KsiPerp_AppleII.get() + " ! mu_Par and ksi_Per\n")
    Fmu.close()

    Fclc = open(FileCLC,'w')

    Fclc.write("\n")
    Fclc.write("*! Lines written by undugui.py\n")
    Fclc.write("Mode AppleII\n")
    #Fclc.write("*! AppleII\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("\n& User_Comment\n")
    comm = "Apple II Undulator"
    Fclc.write(comm + "\n")
    S_Ucomment.set(comm)

    Fsav = open("appleii.lst",'w')
    for par in AppleII: Fsav.write(par + " " + str(AppleII[par])+"\n")
    Fsav.close()

    Fclc.write("\n*------ Variables\n\n")

    Fclc.write("$nPeriods=" + S_nPer_AppleII.get() + "\n")
    Fclc.write("$LxMag=" + S_Xlen_AppleII.get() + "\n")
    Fclc.write("$LyMag=" + S_Ylen_AppleII.get() + "\n")
    Fclc.write("$LzMag=" + S_Zlen_AppleII.get() + "\n")
    Fclc.write("$AirGap=" + S_AirGap_AppleII.get() + "\n")
    Fclc.write("$Mcoating=" + S_DeadCoat_AppleII.get() + "\n")
    Fclc.write("$FullGap=" + S_FullGap_AppleII.get() + "\n")
    Fclc.write("$matrec=1\n")
    Fclc.write("$mat4=2\n")
    Fclc.write("$mat34=3\n")
    Fclc.write("$Br=" + S_Br_AppleII.get() + "\n")
    Fclc.write("$Mu=" + S_Mu_AppleII.get() + "\n")
    Fclc.write("$KsiPerp=" + S_KsiPerp_AppleII.get() + "\n")
    Fclc.write("$S2Shift=" + S_S2Shift_AppleII.get() + "\n")
    Fclc.write("$S3Shift=" + S_S3Shift_AppleII.get() + "\n")
    Fclc.write("$zSlit=" + S_HorSlit_AppleII.get() + "\n")
    Fclc.write("$xMagCen=" + str(AppleII['xMagCen']) + "\n")
    Fclc.write("$nMagDivX=" + S_NdivX_AppleII.get() + "\n")
    Fclc.write("$nHalfMagDivX=" + S_NdivXHalf_AppleII.get() + "\n")
    Fclc.write("$nMagDivY=" + S_NdivY_AppleII.get() + "\n")
    Fclc.write("$nMagDivZ=" + S_NdivZ_AppleII.get() + "\n")

    Fclc.write("\n")
    Fclc.write("$CurrentByCoil = 0.0\n")
    Fclc.write("$FullGapByCoil = 20.\n")
    Fclc.write("\n")
    Fclc.write("$zCoilByCoil = 0.0\n")
    Fclc.write("\n")
    Fclc.write("$xLenOutByCoil = 60.\n")
    Fclc.write("$zLenInByCoil = 40.\n")
    Fclc.write("$zLenOutByCoil = 50.\n")
    Fclc.write("$HeightByCoil = 30.\n")
    Fclc.write("\n")
    Fclc.write("$CurrentBzCoil = 0.0\n")
    Fclc.write("$FullGapBzCoil = 20.\n")
    Fclc.write("\n")
    Fclc.write("$yCoilBzCoil = 0.0\n")
    Fclc.write("\n")
    Fclc.write("$xLenOutBzCoil = 60.\n")
    Fclc.write("$zLenInBzCoil = 40.   ! Consider rotation!!\n")
    Fclc.write("$zLenOutBzCoil = 50.  ! Consider rotation!!\n")
    Fclc.write("$HeightBzCoil = 30.   ! Consider rotation!!\n")
    Fclc.write("\n")

    Fclc.write("$nDivHeightCoil = 1\n")
    Fclc.write("$nDivWindCoil = 1\n")
    Fclc.write("$nDivArcCoil = 6\n")

    Fclc.write("$FillingCoil = 0.5\n\n")

    for c in DictUnduColors:
      s = "$" + c
      if not s in Variables:
        s = "$" + c + "=" + str(DictUnduColors[c])
        Fclc.write(s+"\n")
      #endif
    #endfor c in UnduColors

    Fclc.write("\n$E1Br = $Br / 4.\n")
    Fclc.write("$E2Br = - $Br * 3. / 4.\n")
    Fclc.write("$PerLen = 4. * ( $LxMag + $AirGap )\n")
    Fclc.write("$HalfGap = $FullGap / 2.\n")
    Fclc.write("$HalfPerLen = $PerLen / 2.\n")
    Fclc.write("$LxHalfMag = $LxMag / 2.\n")
    Fclc.write("$yMagCen = - $HalfGap - $LyMag / 2.\n")
    Fclc.write("$zMagCen = - $LzMag / 2. - $zSlit / 2.\n")
    Fclc.write("$hS3Shift = $S3Shift / 2.\n")
    Fclc.write("$hS2Shift = $S2Shift / 2.\n")

    Fclc.write("$x1LRMagCen = $xMagCen + $LxHalfMag / 2. - $hS3Shift - $hS2Shift\n")
    Fclc.write("$x2LRMagCen = $x1LRMagCen + $LxHalfMag / 2. + $AirGap + $LxMag / 2.\n")
    Fclc.write("$x3LRMagCen = $x2LRMagCen + $LxHalfMag + $AirGap + $LxHalfMag / 2.\n")
    Fclc.write("$x4LRMagCen = $x3LRMagCen + $LxHalfMag\n")
    Fclc.write("$x5LRMagCen = $x4LRMagCen + $LxHalfMag / 2. + $AirGap + $LxMag / 2.\n")
    Fclc.write("$x6LRMagCen = $x5LRMagCen + $LxMag / 2. + $AirGap + $LxHalfMag / 2.\n")

    Fclc.write("$x1LLMagCen = $x1LRMagCen + $S3Shift + $S2Shift\n")
    Fclc.write("$x2LLMagCen = $x2LRMagCen + $S3Shift + $S2Shift\n")
    Fclc.write("$x3LLMagCen = $x3LRMagCen + $S3Shift + $S2Shift\n")
    Fclc.write("$x4LLMagCen = $x4LRMagCen + $S3Shift + $S2Shift\n")
    Fclc.write("$x5LLMagCen = $x5LRMagCen + $S3Shift + $S2Shift\n")
    Fclc.write("$x6LLMagCen = $x6LRMagCen + $S3Shift + $S2Shift\n")

    Fclc.write("$x1ULMagCen = $x1LRMagCen\n")
    Fclc.write("$x2ULMagCen = $x2LRMagCen\n")
    Fclc.write("$x3ULMagCen = $x3LRMagCen\n")
    Fclc.write("$x4ULMagCen = $x4LRMagCen\n")
    Fclc.write("$x5ULMagCen = $x5LRMagCen\n")
    Fclc.write("$x6ULMagCen = $x6LRMagCen\n")

    Fclc.write("$x1URMagCen = $x1LLMagCen - $S2Shift * 2.\n")
    Fclc.write("$x2URMagCen = $x2LLMagCen - $S2Shift * 2.\n")
    Fclc.write("$x3URMagCen = $x3LLMagCen - $S2Shift * 2.\n")
    Fclc.write("$x4URMagCen = $x4LLMagCen - $S2Shift * 2.\n")
    Fclc.write("$x5URMagCen = $x5LLMagCen - $S2Shift * 2.\n")
    Fclc.write("$x6URMagCen = $x6LLMagCen - $S2Shift * 2.\n")

    Fclc.write("$yUMagCen = - $yMagCen\n")

    Fclc.write("$zLLMagCen = - $zMagCen\n")
    Fclc.write("$zULMagCen = - $zMagCen\n")

    Fclc.write("$yModCen = - 2. * $yMagCen\n")
    Fclc.write("$zModCen = - 2. * $zMagCen\n")

    Fclc.write("\n* Upstream endpoles\n\n")

    Fclc.write("$x1E1LLMagCen = $x1LLMagCen - $PerLen\n")
    Fclc.write("$x2E1LLMagCen = $x2LLMagCen - $PerLen\n")
    Fclc.write("$x3E1LLMagCen = $x3LLMagCen - $PerLen\n")

    Fclc.write("$x1E1ULMagCen = $x1ULMagCen - $PerLen\n")
    Fclc.write("$x2E1ULMagCen = $x2ULMagCen - $PerLen\n")
    Fclc.write("$x3E1ULMagCen = $x3ULMagCen - $PerLen\n")

    Fclc.write("$x1E1LRMagCen = $x1LRMagCen - $PerLen\n")
    Fclc.write("$x2E1LRMagCen = $x2LRMagCen - $PerLen\n")
    Fclc.write("$x3E1LRMagCen = $x3LRMagCen - $PerLen\n")

    Fclc.write("$x1E1URMagCen = $x1URMagCen - $PerLen\n")
    Fclc.write("$x2E1URMagCen = $x2URMagCen - $PerLen\n")
    Fclc.write("$x3E1URMagCen = $x3URMagCen - $PerLen\n")

    Fclc.write("$x1E2LLMagCen = $x1LLMagCen - $HalfPerLen\n")
    Fclc.write("$x2E2LLMagCen = $x2LLMagCen - $HalfPerLen\n")
    Fclc.write("$x3E2LLMagCen = $x3LLMagCen - $HalfPerLen\n")

    Fclc.write("$x1E2ULMagCen = $x1ULMagCen - $HalfPerLen\n")
    Fclc.write("$x2E2ULMagCen = $x2ULMagCen - $HalfPerLen\n")
    Fclc.write("$x3E2ULMagCen = $x3ULMagCen - $HalfPerLen\n")

    Fclc.write("$x1E2LRMagCen = $x1LRMagCen - $HalfPerLen\n")
    Fclc.write("$x2E2LRMagCen = $x2LRMagCen - $HalfPerLen\n")
    Fclc.write("$x3E2LRMagCen = $x3LRMagCen - $HalfPerLen\n")

    Fclc.write("$x1E2URMagCen = $x1URMagCen - $HalfPerLen\n")
    Fclc.write("$x2E2URMagCen = $x2URMagCen - $HalfPerLen\n")
    Fclc.write("$x3E2URMagCen = $x3URMagCen - $HalfPerLen\n")

    Fclc.write("\n* Downstream endpoles\n\n")

    Fclc.write("$dxED0 = ( $nPeriods + 1.0 ) * $PerLen\n")
    Fclc.write("$dxED1 = ( $nPeriods + 2.0 ) * $PerLen\n")
    Fclc.write("$dxED2 = ( $nPeriods + 1.5 ) * $PerLen\n")

    Fclc.write("$x1D0LLMagCen = $x1E1LLMagCen + $dxED0\n")
    Fclc.write("$x2D0LLMagCen = $x2E1LLMagCen + $dxED0\n")
    Fclc.write("$x3D0LLMagCen = $x3E1LLMagCen + $dxED0\n")

    Fclc.write("$x1D0LRMagCen = $x1E1LRMagCen + $dxED0\n")
    Fclc.write("$x2D0LRMagCen = $x2E1LRMagCen + $dxED0\n")
    Fclc.write("$x3D0LRMagCen = $x3E1LRMagCen + $dxED0\n")

    Fclc.write("$x1D0ULMagCen = $x1E1ULMagCen + $dxED0\n")
    Fclc.write("$x2D0ULMagCen = $x2E1ULMagCen + $dxED0\n")
    Fclc.write("$x3D0ULMagCen = $x3E1ULMagCen + $dxED0\n")

    Fclc.write("$x1D0URMagCen = $x1E1URMagCen + $dxED0\n")
    Fclc.write("$x2D0URMagCen = $x2E1URMagCen + $dxED0\n")
    Fclc.write("$x3D0URMagCen = $x3E1URMagCen + $dxED0\n")

    Fclc.write("$x1D1LLMagCen = $x1E1LLMagCen + $dxED1\n")
    Fclc.write("$x2D1LLMagCen = $x2E1LLMagCen + $dxED1\n")
    Fclc.write("$x3D1LLMagCen = $x3E1LLMagCen + $dxED1\n")

    Fclc.write("$x1D1LRMagCen = $x1E1LRMagCen + $dxED1\n")
    Fclc.write("$x2D1LRMagCen = $x2E1LRMagCen + $dxED1\n")
    Fclc.write("$x3D1LRMagCen = $x3E1LRMagCen + $dxED1\n")

    Fclc.write("$x1D1ULMagCen = $x1E1ULMagCen + $dxED1\n")
    Fclc.write("$x2D1ULMagCen = $x2E1ULMagCen + $dxED1\n")
    Fclc.write("$x3D1ULMagCen = $x3E1ULMagCen + $dxED1\n")

    Fclc.write("$x1D1URMagCen = $x1E1URMagCen + $dxED1\n")
    Fclc.write("$x2D1URMagCen = $x2E1URMagCen + $dxED1\n")
    Fclc.write("$x3D1URMagCen = $x3E1URMagCen + $dxED1\n")

    Fclc.write("$x1D2LLMagCen = $x1E1LLMagCen + $dxED2\n")
    Fclc.write("$x2D2LLMagCen = $x2E1LLMagCen + $dxED2\n")
    Fclc.write("$x3D2LLMagCen = $x3E1LLMagCen + $dxED2\n")

    Fclc.write("$x1D2LRMagCen = $x1E1LRMagCen + $dxED2\n")
    Fclc.write("$x2D2LRMagCen = $x2E1LRMagCen + $dxED2\n")
    Fclc.write("$x3D2LRMagCen = $x3E1LRMagCen + $dxED2\n")

    Fclc.write("$x1D2ULMagCen = $x1E1ULMagCen + $dxED2\n")
    Fclc.write("$x2D2ULMagCen = $x2E1ULMagCen + $dxED2\n")
    Fclc.write("$x3D2ULMagCen = $x3E1ULMagCen + $dxED2\n")

    Fclc.write("$x1D2URMagCen = $x1E1URMagCen + $dxED2\n")
    Fclc.write("$x2D2URMagCen = $x2E1URMagCen + $dxED2\n")
    Fclc.write("$x3D2URMagCen = $x3E1URMagCen + $dxED2\n")

    Fclc.write("$colormag = $red\n")
    Fclc.write("$e1colormag = $magenta\n")
    Fclc.write("$e2colormag = $green\n")

    Fclc.write("\n")
    Fclc.write("$RectRiByCoil = $zLenOutByCoil - $zLenInByCoil\n")
    Fclc.write("$nWindingByCoil = ( $zLenOutByCoil - $zLenInByCoil ) * $HeightByCoil\n")
    Fclc.write("$xCoilByCoilDS = ( $nPeriods + 2. ) * $PerLen + $xLenOutByCoil\n")
    Fclc.write("$xCoilByCoilUS = - $xCoilByCoilDS\n")
    Fclc.write("$yCoilTop = ( $FullGapByCoil + $HeightByCoil ) / 2.\n")
    Fclc.write("$yCoilBottom = - $yCoilTop\n")
    Fclc.write("$RectRiBzCoil = $zLenOutBzCoil - $zLenInBzCoil\n")
    Fclc.write("$nWindingBzCoil = ( $zLenOutBzCoil - $zLenInBzCoil ) * $HeightBzCoil\n")
    Fclc.write("$xCoilBzCoilDS = $xCoilByCoilDS + $xLenOutByCoil + $xLenOutBzCoil\n")
    Fclc.write("$xCoilBzCoilUS = - $xCoilBzCoilDS\n")
    Fclc.write("$zBzCoilRight = ( $FullGapBzCoil + $HeightBzCoil ) / 2.\n")
    Fclc.write("$zBzCoilLeft = - $zBzCoilRight\n")
    Fclc.write("$nCoilColor = $red\n")

    if Nvar > 0:
      Fclc.write("\n")
      Fclc.write("* Additional variables\n")
      Fclc.write("\n")
      for v in Variables:
        vnd = v.split('$')[1]
        if not v in VAppleII and not vnd in AppleII and not vnd in Pars:
          Fclc.write(v + " = " + str(Variables[v]) + "\n")
        #if not v in VAppleII
      #endfor p in Pars
    #endif Npar > 0

    Fclc.write("\n")
    Fclc.write("*---------- Magnets\n")
    Fclc.write("\n")
    Fclc.write("\n")
    Fclc.write("* Lower right girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Magnet\n")
    Fclc.write("Block mag1 HMag1 $colormag                 !key, name, mother, color\n")
    Fclc.write("$x1LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag2 Mag2 $colormag                  !key, name, mother, color\n")
    Fclc.write("$x2LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag3 HMag3 $colormag                 !key, name, mother, color\n")
    Fclc.write("$x3LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag4 HMag4 $colormag                 !key, name, mother, color\n")
    Fclc.write("$x4LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag5 Mag5 $colormag                  !key, name, mother, color\n")
    Fclc.write("$x5LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag6 HMag6 $colormag                 !key, name, mother, color\n")
    Fclc.write("$x6LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("\n")
    Fclc.write("* Upper right girder\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag7 HMag7 $colormag                 !key, name, mother, color\n")
    Fclc.write("$x1URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag8 Mag8 $colormag                  !key, name, mother, color\n")
    Fclc.write("$x2URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag9 HMag9 $colormag                 !key, name, mother, color\n")
    Fclc.write("$x3URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag10 HMag10 $colormag               !key, name, mother, color\n")
    Fclc.write("$x4URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag11 Mag11 $colormag                !key, name, mother, color\n")
    Fclc.write("$x5URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag12 HMag12 $colormag               !key, name, mother, color\n")
    Fclc.write("$x6URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower left girder\n")
    Fclc.write("\n")

    Fclc.write("& Magnet\n")
    Fclc.write("Block mag13 HMag13 $colormag               !key, name, mother, color\n")
    Fclc.write("$x1LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag14 Mag14 $colormag                !key, name, mother, color\n")
    Fclc.write("$x2LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag15 HMag15 $colormag               !key, name, mother, color\n")
    Fclc.write("$x3LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag16 HMag16 $colormag               !key, name, mother, color\n")
    Fclc.write("$x4LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag17 Mag17 $colormag                !key, name, mother, color\n")
    Fclc.write("$x5LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag18 HMag18 $colormag               !key, name, mother, color\n")
    Fclc.write("$x6LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Upper right girder\n")
    Fclc.write("\n")

    Fclc.write("& Magnet\n")
    Fclc.write("Block mag19 HMag19 $colormag               !key, name, mother, color\n")
    Fclc.write("$x1LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag20 Mag20 $colormag                !key, name, mother, color\n")
    Fclc.write("$x2LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$Br 0.0 1.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag21 HMag21 $colormag               !key, name, mother, color\n")
    Fclc.write("$x3LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag22 HMag22 $colormag               !key, name, mother, color\n")
    Fclc.write("$x4LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag23 Mag23 $colormag                !key, name, mother, color\n")
    Fclc.write("$x5LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$Br 0.0 -1.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Magnet\n")
    Fclc.write("Block mag24 HMag24 $colormag               !key, name, mother, color\n")
    Fclc.write("$x6LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower right girder\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag25 Mag25 $e1colormag              !key, name, mother, color\n")
    Fclc.write("$x1E1LRMagCen $yMagCen $zMagCen            !position\n")
    Fclc.write("$E1Br 1.0 0.0 0.0 $mat4                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag26 Mag26 $e1colormag              !key, name, mother, color\n")
    Fclc.write("$x2E1LRMagCen $yMagCen $zMagCen            !position\n")
    Fclc.write("$E1Br 0.0 1.0 0.0 $mat4                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag27 HMag27 $e1colormag             !key, name, mother, color\n")
    Fclc.write("$x3E1LRMagCen $yMagCen $zMagCen            !position\n")
    Fclc.write("$E1Br -1.0 0.0 0.0 $mat4                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Upper right girder\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag28 HMag28 $e1colormag             !key, name, mother, color\n")
    Fclc.write("$x1E1URMagCen $yUMagCen $zMagCen           !position\n")
    Fclc.write("$E1Br -1.0 0.0 0.0 $mat4                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag29 Mag29 $e1colormag              !key, name, mother, color\n")
    Fclc.write("$x2E1URMagCen $yUMagCen $zMagCen           !position\n")
    Fclc.write("$E1Br 0.0 1.0 0.0 $mat4                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                       !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.        !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag30 HMag30 $e1colormag             !key, name, mother, color\n")
    Fclc.write("$x3E1URMagCen $yUMagCen $zMagCen           !position\n")
    Fclc.write("$E1Br 1.0 0.0 0.0 $mat4                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                   !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.    !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower left girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag31 HMag31 $e1colormag              !key, name, mother, color\n")
    Fclc.write("$x1E1LLMagCen $yMagCen $zLLMagCen           !position\n")
    Fclc.write("$E1Br 1.0 0.0 0.0 $mat4                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag32 Mag32 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x2E1LLMagCen $yMagCen $zLLMagCen           !position\n")
    Fclc.write("$E1Br 0.0 1.0 0.0 $mat4                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                        !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag33 HMag33 $e1colormag              !key, name, mother, color\n")
    Fclc.write("$x3E1LLMagCen $yMagCen $zLLMagCen           !position\n")
    Fclc.write("$E1Br -1.0 0.0 0.0 $mat4                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower right girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag34 HMag34 $e1colormag              !key, name, mother, color\n")
    Fclc.write("$x1E1LRMagCen $yUMagCen $zULMagCen          !position\n")
    Fclc.write("$E1Br -1.0 0.0 0.0 $mat4                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag35 Mag35 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x2E1LRMagCen $yUMagCen $zULMagCen          !position\n")
    Fclc.write("$E1Br 0.0 1.0 0.0 $mat4                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                        !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag36 HMag36 $e1colormag              !key, name, mother, color\n")
    Fclc.write("$x3E1LRMagCen $yUMagCen $zULMagCen          !position\n")
    Fclc.write("$E1Br 1.0 0.0 0.0 $mat4                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag37 HMag37 $e2colormag              !key, name, mother, color\n")
    Fclc.write("$x1E2LRMagCen $yMagCen $zMagCen             !position\n")
    Fclc.write("$E2Br 1.0 0.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag38 Mag38 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x2E2LRMagCen $yMagCen $zMagCen             !position\n")
    Fclc.write("$E2Br 0.0 1.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                        !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag39 HMag39 $e2colormag              !key, name, mother, color\n")
    Fclc.write("$x3E2LRMagCen $yMagCen $zMagCen             !position\n")
    Fclc.write("$E2Br -1.0 0.0 0.0 $mat34                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Upper right girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag40 HMag40 $e2colormag              !key, name, mother, color\n")
    Fclc.write("$x1E2URMagCen $yUMagCen $zMagCen            !position\n")
    Fclc.write("$E2Br -1.0 0.0 0.0 $mat34                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag41 Mag41 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x2E2URMagCen $yUMagCen $zMagCen            !position\n")
    Fclc.write("$E2Br 0.0 1.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                        !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag42 HMag42 $e2colormag              !key, name, mother, color\n")
    Fclc.write("$x3E2URMagCen $yUMagCen $zMagCen            !position\n")
    Fclc.write("$E2Br 1.0 0.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower left girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag43 HMag43 $e2colormag              !key, name, mother, color\n")
    Fclc.write("$x1E2LLMagCen $yMagCen $zLLMagCen           !position\n")
    Fclc.write("$E2Br 1.0 0.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag44 Mag44 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x2E2LLMagCen $yMagCen $zLLMagCen           !position\n")
    Fclc.write("$E2Br 0.0 1.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                        !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.         !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag45 HMag45 $e2colormag              !key, name, mother, color\n")
    Fclc.write("$x3E2LLMagCen $yMagCen $zLLMagCen           !position\n")
    Fclc.write("$E2Br -1.0 0.0 0.0 $mat34                   !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                    !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.     !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower right girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag46 HMag46 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x1E2LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$E2Br -1.0 0.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag47 Mag47 $e2colormag                !key, name, mother, color\n")
    Fclc.write("$x2E2LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$E2Br 0.0 1.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag48 HMag48 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x3E2LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$E2Br 1.0 0.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag49 HMag49 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x1D0LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag50 Mag50 $e2colormag                !key, name, mother, color\n")
    Fclc.write("$x2D0LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag51 HMag51 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x3D0LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag52 HMag52 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x1D1LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$E1Br 1.0 0.0 0.0 $mat4                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag53 Mag53 $e1colormag                !key, name, mother, color\n")
    Fclc.write("$x2D1LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$E1Br 0.0 1.0 0.0 $mat4                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag54 HMag54 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x3D1LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$E1Br -1.0 0.0 0.0 $mat4                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Upper right girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag55 HMag55 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x1D0URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag56 Mag56 $e2colormag                !key, name, mother, color\n")
    Fclc.write("$x2D0URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag57 HMag57 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x3D0URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag58 HMag58 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x1D1URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$E1Br -1.0 0.0 0.0 $mat4                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag59 Mag59 $e1colormag                !key, name, mother, color\n")
    Fclc.write("$x2D1URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$E1Br 0.0 1.0 0.0 $mat4                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag60 HMag60 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x3D1URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$E1Br 1.0 0.0 0.0 $mat4                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower left girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag61 HMag61 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x1D0LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag62 Mag62 $e2colormag                !key, name, mother, color\n")
    Fclc.write("$x2D0LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag63 HMag63 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x3D0LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag64 HMag64 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x1D1LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$E1Br 1.0 0.0 0.0 $mat4                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag65 Mag65 $e1colormag                !key, name, mother, color\n")
    Fclc.write("$x2D1LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$E1Br 0.0 1.0 0.0 $mat4                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag66 HMag66 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x3D1LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$E1Br -1.0 0.0 0.0 $mat4                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Upper left girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag67 HMag67 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x1D0ULMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$Br -1.0 0.0 0.0 $matrec                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag68 Mag68 $e2colormag                !key, name, mother, color\n")
    Fclc.write("$x2D0ULMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$Br 0.0 1.0 0.0 $matrec                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag69 HMag69 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x3D0ULMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$Br 1.0 0.0 0.0 $matrec                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower right girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag70 HMag70 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x1D1LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$E1Br -1.0 0.0 0.0 $mat4                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag71 Mag71 $e1colormag                !key, name, mother, color\n")
    Fclc.write("$x2D1LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$E1Br 0.0 1.0 0.0 $mat4                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag72 HMag72 $e1colormag               !key, name, mother, color\n")
    Fclc.write("$x3D1LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$E1Br 1.0 0.0 0.0 $mat4                      !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag73 HMag73 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x1D2LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$E2Br 1.0 0.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag74 Mag74 $e2colormag                !key, name, mother, color\n")
    Fclc.write("$x2D2LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$E2Br 0.0 1.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag75 HMag75 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x3D2LRMagCen $yMagCen $zMagCen              !position\n")
    Fclc.write("$E2Br -1.0 0.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Upper right girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag76 HMag76 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x1D2URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$E2Br -1.0 0.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag77 Mag77 $e2colormag                !key, name, mother, color\n")
    Fclc.write("$x2D2URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$E2Br 0.0 1.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag78 HMag78 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x3D2URMagCen $yUMagCen $zMagCen             !position\n")
    Fclc.write("$E2Br 1.0 0.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower left girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag79 HMag79 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x1D2LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$E2Br 1.0 0.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag80 Mag80 $e2colormag                !key, name, mother, color\n")
    Fclc.write("$x2D2LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$E2Br 0.0 1.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag81 HMag81 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x3D2LLMagCen $yMagCen $zLLMagCen            !position\n")
    Fclc.write("$E2Br -1.0 0.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("* Lower right girder\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag82 HMag82 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x1D2LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$E2Br -1.0 0.0 0.0 $mat34                    !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag83 Mag83 $e2colormag                !key, name, mother, color\n")
    Fclc.write("$x2D2LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$E2Br 0.0 1.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxMag $LyMag $LzMag                         !dimension\n")
    Fclc.write("$nMagDivX $nMagDivY $nMagDivZ 1. 1.          !segmention\n")
    Fclc.write("\n")
    Fclc.write("& Special_Magnet\n")
    Fclc.write("Block mag84 HMag84 $e2colormag               !key, name, mother, color\n")
    Fclc.write("$x3D2LRMagCen $yUMagCen $zULMagCen           !position\n")
    Fclc.write("$E2Br 1.0 0.0 0.0 $mat34                     !length bc and components of mag. vector, material index\n")
    Fclc.write("$LxHalfMag $LyMag $LzMag                     !dimension\n")
    Fclc.write("$nHalfMagDivX $nMagDivY $nMagDivZ 1. 1.      !segmention\n")
    Fclc.write("\n")

    Fclc.write("& Module\n")
    Fclc.write("0. 0. 0.            !offset of module\n")
    Fclc.write("$nPeriods           !number of arrays within module\n")
    Fclc.write("$PerLen 1. 0. 0. 0. !spacing and direction of arrangement, rotation angle\n")
    Fclc.write("1. 1. 1.            !scaling and symmetry of magnetization vector\n")
    Fclc.write(" \n")

    Fclc.write(" \n")
    Fclc.write("& Materials\n")
    Fclc.write("3                       ! number of material files\n")
    Fclc.write("1 1 1 undumag_mu.dat    ! number, type, mode, and filename\n")
    Fclc.write("2 1 1 undumag_mu.dat    ! number, type, mode, and filename\n")
    Fclc.write("3 1 1 undumag_mu.dat    ! number, type, mode, and filename\n")
    Fclc.write(" \n")

    Fclc.write("\n")
    Fclc.write("Coils\n*\n")
    Fclc.write("* Current per winding, filling factor, number of windings, center, normal vector, rotation-angle, total length,\n")
    Fclc.write("* inner width, outer width, inner radius, height, vert/hori/rad\n")
    Fclc.write("* divisions, color-index\n")

    Fclc.write("\n")
    Fclc.write("& Coil\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentByCoil $nWindingByCoil $FillingCoil "
    scoil += "$xCoilByCoilUS $yCoilTop $zCoilByCoil 0. 1. 0. 0. "
    scoil += "$xLenOutByCoil $zLenInByCoil $zLenOutByCoil $RectRiByCoil "
    scoil += "$HeightByCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("& Coil\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentByCoil $nWindingByCoil $FillingCoil "
    scoil += "$xCoilByCoilDS $yCoilTop $zCoilByCoil 0. 1. 0. 0. "
    scoil += "$xLenOutByCoil $zLenInByCoil $zLenOutByCoil $RectRiByCoil "
    scoil += "$HeightByCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("& Coil\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentByCoil $nWindingByCoil $FillingCoil "
    scoil += "$xCoilByCoilUS $yCoilBottom $zCoilByCoil 0. 1. 0. 0. "
    scoil += "$xLenOutByCoil $zLenInByCoil $zLenOutByCoil $RectRiByCoil "
    scoil += "$HeightByCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("& Coil\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentByCoil $nWindingByCoil $FillingCoil "
    scoil += "$xCoilByCoilDS $yCoilBottom $zCoilByCoil 0. 1. 0. 0. "
    scoil += "$xLenOutByCoil $zLenInByCoil $zLenOutByCoil $RectRiByCoil "
    scoil += "$HeightByCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("& Coil\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentBzCoil $nWindingBzCoil $FillingCoil "
    scoil += "$xCoilBzCoilUS $yCoilBzCoil $zBzCoilRight 0. 0. 1. 0. "
    scoil += "$xLenOutBzCoil $zLenInBzCoil $zLenOutBzCoil $RectRiBzCoil "
    scoil += "$HeightBzCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("& Coil\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentBzCoil $nWindingBzCoil $FillingCoil "
    scoil += "$xCoilBzCoilDS $yCoilBzCoil $zBzCoilRight 0. 0. 1. 0. "
    scoil += "$xLenOutBzCoil $zLenInBzCoil $zLenOutBzCoil $RectRiBzCoil "
    scoil += "$HeightBzCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("& Coil\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentBzCoil $nWindingBzCoil $FillingCoil "
    scoil += "$xCoilBzCoilUS $yCoilBzCoil $zBzCoilLeft 0. 0. 1. 0. "
    scoil += "$xLenOutBzCoil $zLenInBzCoil $zLenOutBzCoil $RectRiBzCoil "
    scoil += "$HeightBzCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("& Coil\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentBzCoil $nWindingBzCoil $FillingCoil "
    scoil += "$xCoilBzCoilDS $yCoilBzCoil $zBzCoilLeft 0. 0. 1. 0. "
    scoil += "$xLenOutBzCoil $zLenInBzCoil $zLenOutBzCoil $RectRiBzCoil "
    scoil += "$HeightBzCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.close()

    shutil.copyfile(FileCLC,"undumag_AppleII.clc")
    print("\n--- ",FileCLC," written and copyied to undumag_AppleII.clc ---")

  elif int(Hybrid_Mode) == 2:

    FileCLC = "undumag.clc"

    Flast = open("unduclc.lst","w")
    Flast.write(FileCLC+NL)
    Flast.close()

    Fclc = open(FileCLC,'w')
    Fsav = open('mirror.lst','w')

    Fclc.write("\n")
    Fclc.write("* Lines written by undugui.py\n")
    Fclc.write("Mode Mirror\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("\n& User_Comment\n")
    comm = "Planar Hybrid Undulator (Simulated Infinite Length)"
    Fclc.write(comm + "\n")
    S_Ucomment.set(comm)

    Fclc.write("\n*------ Variables\n\n")

    Fclc.write("\n")

    Fclc.write("$PerLen = " + str(eval(Mirror["PerLen_Mirror"])) + "\n")
    Fclc.write("$Mcoating=" + str(Mirror["Mcoating_Mirror"]) + " ! coating of REC magnets\n")
    Fclc.write("\n")

    for par in Mirror:

      Fsav.write(par + " " + str(Mirror[par])+"\n")

      if par == "Mat_Mirror": continue
      if par == "MatPol_Mirror": continue
      if par == "Mcoating_Mirror": continue
      if par == "PerLen_Mirror": continue

      if len(str(Mirror[par]).split()) > 1:
        sline = "$" + par + " = '" + str(Mirror[par]) + "'\n"
      else:
        sline = "$" + par + " = " + str(Mirror[par]) + NL
      #endif
      Fclc.write(sline)

    #endfor par in Mirror

    Fsav.close()

    Fclc.write("\n")

    sline = "$PerLen_Mirror = $PerLen" + NL
    Fclc.write(sline)
    sline = "$Mcoating_Mirror = $Mcoating" + NL
    Fclc.write(sline)

    Fclc.write("\n")
    Fclc.write("\n$ixSym="+str(ixsym))
    Fclc.write("\n$iySym="+str(iysym))
    Fclc.write("\n$izSym="+str(izsym))
    Fclc.write("\n")

    Fclc.write("\n")
    for c in DictUnduColors:
      s = "$" + c + "=" + str(DictUnduColors[c])
      Fclc.write(s+"\n")
    #endfor c in UnduColors

    Fclc.write("\n")
    for var in VMirror:
      svar = str(VMirror[var])
      if svar == '$nPeriods_Mirror' or \
      svar == '$Mcoating_Mirror' or \
      svar == '$PerLen_Mirror': continue
      else:
        sline = var + " = " + svar + NL
      #endif
      Fclc.write(sline)
    #endfor var in VMirror

    Fclc.write("\n")
    Fclc.write("*------ Magnets and Poles\n")
    Fclc.write("\n")

    Fclc.write("& Magnet\n")
    Fclc.write("BlockDsChamf mag Mag $ColorMag                                                                   !key, name, mother, color\n")
    Fclc.write("$xMagHalf $yMag $zMagHalf                                                                        !position\n")
    Fclc.write("$Br_Mirror 1. 0. 0. $RECIndex_Mirror                                                             !length bc and comp. of magnetization, material index\n")
    Fclc.write("$LxMagHalf $LyMag_Mirror $LzMagHalf $ChamfMag_Mirror                                             !dimensions \n")
    Fclc.write("$nDivX_MagHalf $nDivY_Mag_Mirror $nDivZ_MagHalf_Mirror $FracDivY_Mag_Mirror $FracDivZ_Mag_Mirror !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Pole\n")
    Fclc.write("BlockUsChamf pol Pol $ColorPol                                                                   !key, name, mother, color\n")
    Fclc.write("$xPolHalf $yPol $zPolHalf                                                                        !position\n")
    Fclc.write("$IronIndex_Hybrid                                                                                !material index\n")
    Fclc.write("$LxPolHalf $LyPol $LzPolHalf $ChamfPol_Mirror                                                    !dimensions \n")
    Fclc.write("$nDivX_PolHalf $nDivY_Pol_Mirror $nDivZ_PolHalf_Mirror $FracDivY_Pol_Mirror $FracDivZ_Pol_Mirror !segmentation\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("*------ Mirror\n")
    Fclc.write("\n")

    Fclc.write("& Pole\n")
    Fclc.write("Block mirror Mirror $ColorMir                                                                   !key, name, mother, color\n")
    Fclc.write("$xMirror $yMirrorHalf $zMirrorHalf                                                                        !position\n")
    Fclc.write("$IronIndex_Mirror                                                                                !material index\n")
    Fclc.write("$LxMirror $LyMirrorHalf $LzMirrorHalf                                                   !dimensions \n")
    Fclc.write("$nMirDivX $nMirDivY $nMirDivZ $FracDivMirY $FracDivMirZ !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Module\n")
    Fclc.write("0. 0. 0.                   !offset of module\n")
    Fclc.write("1                          !number of arrays within module\n")
    Fclc.write("$PerLen_Mirror 1. 0. 0. 0. !spacing and direction of arrangement, rotation angle\n")
    Fclc.write("1. 1. 1.                   !scaling and symmetry of magnetization vector\n")
    Fclc.write(" \n")
    Fclc.write(" \n")

    Fclc.write(" \n")
    Fclc.write("& Materials\n")
    Fclc.write(str(Nmat) + "            ! number of material files\n")

    for imat in range(Nmat):
      mat = mats[imat]
      if imat == int(Mirror["RECIndex_Mirror"]) - 1:
        mat[4] = str(Mirror["mu_Mirror"]) + " " + str(Mirror["KsiPerp_Mirror"]) + "  ! mu_Par and ksi_Perp\n"
      #endif
      Fclc.write(str(mat[0]) + " " + str(mat[1]) + " " + str(mat[2]) + " " + mat[3] + "\n")
      if mat[2] == '1':
        Fmat = open(str(mat[3]),'w')
        for line in mat[4]: Fmat.write(line)
        Fmat.close()
      #endif mat[2] == '1'
    #endfor imat in range(Nmat)

    Fclc.close()

    try:
      stat = shutil.copyfile(FileCLC,"undumag_Mirror.clc")
      print("\n--- ",FileCLC," written and copyied to undumag_Mirror.clc ---")
    except:
      print("\n--- ",FileCLC," written, but not copied to  undumag_Mirror.clc! Is it a link?  ---")
    #endif

  elif int(Hybrid_Mode) > 0:

    FileCLC = "undumag.clc"

    Flast = open("unduclc.lst","w")
    Flast.write(FileCLC+NL)
    Flast.close()

    Fclc = open(FileCLC,'w')

    Fclc.write("\n")
    Fclc.write("* Lines written by undugui.py\n")
    Fclc.write("Mode Hybrid\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("\n& User_Comment\n")
    comm = "Planar Hybrid Undulator"
    Fclc.write(comm + "\n")
    S_Ucomment.set(comm)

    Fsav = open("hybrid.lst",'w')
    for par in Hybrid: Fsav.write(par + " " + str(Hybrid[par])+"\n")
    Fsav.close()

    Fclc.write("\n*------ Variables\n\n")

    Fclc.write("\n")

    Fclc.write("$PerLen = " + str(eval(Hybrid["PerLen_Hybrid"])) + "\n")
    Fclc.write("$nPeriods = " + str(eval(Hybrid["nPeriods_Hybrid"])) + "\n")
    Fclc.write("$Mcoating=" + str(Hybrid["Mcoating_Hybrid"]) + " ! coating of REC magnets\n")
    Fclc.write("\n")

    Fclc.write("\n")
    Fclc.write("\n$ixSym="+str(ixsym))
    Fclc.write("\n$iySym="+str(iysym))
    Fclc.write("\n$izSym="+str(izsym))
    Fclc.write("\n")

    for par in Hybrid:
      if par == "MatPol_Hybrid": continue
      if par == "nPeriods_Hybrid": continue
      if par == "Mcoating_Hybrid": continue
      if par == "PerLen_Hybrid": continue
      if len(str(Hybrid[par]).split()) > 1:
        sline = "$" + par + " = '" + str(Hybrid[par]) + "'\n"
      else:
        sline = "$" + par + " = " + str(Hybrid[par]) + NL
      #endif
      Fclc.write(sline)
    #endfor par in Hybrid

    Fclc.write("\n")
    Fclc.write("$CurrentByCoil = 0.0\n")
    Fclc.write("$FullGapByCoil = 20.\n")
    Fclc.write("\n")
    Fclc.write("$zCoilByCoil = 0.0\n")
    Fclc.write("\n")
    Fclc.write("$xLenOutByCoil = 60.\n")
    Fclc.write("$zLenInByCoil = 40.\n")
    Fclc.write("$zLenOutByCoil = 50.\n")
    Fclc.write("$HeightByCoil = 30.\n")
    Fclc.write("\n")
    Fclc.write("$CurrentBzCoil = 0.0\n")
    Fclc.write("$FullGapBzCoil = 20.\n")
    Fclc.write("\n")
    Fclc.write("$yCoilBzCoil = 0.0\n")
    Fclc.write("\n")
    Fclc.write("$xLenOutBzCoil = 60.\n")
    Fclc.write("$zLenInBzCoil = 40.   ! Consider rotation!!\n")
    Fclc.write("$zLenOutBzCoil = 50.  ! Consider rotation!!\n")
    Fclc.write("$HeightBzCoil = 30.  ! Consider rotation!!\n")
    Fclc.write("\n")

    Fclc.write("$nDivHeightCoil = 1\n")
    Fclc.write("$nDivWindCoil = 1\n")
    Fclc.write("$nDivArcCoil = 6\n")

    Fclc.write("$FillingCoil = 0.5\n")

    Fclc.write("\n")

    for c in DictUnduColors:
      s = "$" + c + "=" + str(DictUnduColors[c])
      Fclc.write(s+"\n")
    #endfor c in UnduColors

    sline = "$PerLen_Hybrid = $PerLen" + NL
    Fclc.write(sline)
    sline = "$nPeriods_Hybrid = $nPeriods" + NL
    Fclc.write(sline)
    sline = "$Mcoating_Hybrid = $Mcoating" + NL
    Fclc.write(sline)

    for var in VHybrid:
      svar = str(VHybrid[var])
      if svar == '$nPeriods_Hybrid' or \
      svar == '$Mcoating_Hybrid' or \
      svar == '$PerLen_Hybrid': continue
      else:
        sline = var + " = " + svar + NL
      #endif
      Fclc.write(sline)
    #endfor var in VHybrid

    Fclc.write("\n")
    Fclc.write("$RectRiByCoil = $zLenOutByCoil - $zLenInByCoil\n")
    Fclc.write("$nWindingByCoil = ( $zLenOutByCoil - $zLenInByCoil ) * $HeightByCoil\n")
    Fclc.write("$xCoilByCoilDS = ( $nPeriods + 2. ) * $PerLen + $xLenOutByCoil\n")
    Fclc.write("$xCoilByCoilUS = - $xCoilByCoilDS\n")
    Fclc.write("$yCoilTop = ( $FullGapByCoil + $HeightByCoil ) / 2.\n")
    Fclc.write("$yCoilBottom = - $yCoilTop\n")
    Fclc.write("$RectRiBzCoil = $zLenOutBzCoil - $zLenInBzCoil\n")
    Fclc.write("$nWindingBzCoil = ( $zLenOutBzCoil - $zLenInBzCoil ) * $HeightBzCoil\n")
    Fclc.write("$xCoilBzCoilDS = $xCoilByCoilDS + $xLenOutByCoil + $xLenOutBzCoil\n")
    Fclc.write("$xCoilBzCoilUS = - $xCoilBzCoilDS\n")
    Fclc.write("$zBzCoilRight = ( $FullGapBzCoil + $HeightBzCoil ) / 2.\n")
    Fclc.write("$zBzCoilLeft = - $zBzCoilRight\n")
    Fclc.write("$nCoilColor = $red\n")

    Fclc.write("\n")
    Fclc.write("\n")
    Fclc.write("*------ Magnets\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("& Pole\n")
    Fclc.write("BlockDsChamf pol3_H Pol3_H $ColorPol_Hybrid                                                         !key, name, mother, color\n")
    Fclc.write("$xHalfPol3_Hybrid $yPol_Hybrid $zPol_Hybrid                                                         !position\n")
    Fclc.write("$IronIndex_Hybrid                                                                                   !material index\n")
    Fclc.write("$LxPolHalf_Hybrid $LyPol_Hybrid $LzPolHalf_Hybrid $ChamfPol_Hybrid                                  !dimensions \n")
    Fclc.write("$nDivX_PolHalf_Hybrid $nDivY_Pol_Hybrid $nDivZ_PolHalf_Hybrid $FracDivY_Pol_Hybrid $FracDivZ_Pol_Hybrid !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Magnet\n")
    Fclc.write("BlockChamf mag2_H Mag2_H $ColorMag_Hybrid                                                            !key, name, mother, color\n")
    Fclc.write("$xMag2_Hybrid $yMag_Hybrid $zMag_Hybrid                                                             !position\n")
    Fclc.write("$Br_Hybrid -1. 0. 0. $RECIndex_Hybrid                                                               !length bc and comp. of magnetization, material index\n")
    Fclc.write("$LxMag_Hybrid $LyMag_Hybrid $LzMagHalf_Hybrid $ChamfMag_Hybrid                                      !dimensions \n")
    Fclc.write("$nDivX_Mag_Hybrid $nDivY_Mag_Hybrid $nDivZ_MagHalf_Hybrid $FracDivY_Mag_Hybrid $FracDivZ_Mag_Hybrid     !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Pole\n")
    Fclc.write("BlockChamf pol2_H Pol2_H $ColorPol_Hybrid                                                           !key, name, mother, color\n")
    Fclc.write("$xPol2_Hybrid $yPol_Hybrid $zPol_Hybrid                                                             !position\n")
    Fclc.write("$IronIndex_Hybrid                                                                                   !material index\n")
    Fclc.write("$LxPol_Hybrid $LyPol_Hybrid $LzPolHalf_Hybrid $ChamfPol_Hybrid                                      !dimensions \n")
    Fclc.write("$nDivX_Pol_Hybrid $nDivY_Pol_Hybrid $nDivZ_PolHalf_Hybrid $FracDivY_Pol_Hybrid $FracDivZ_Pol_Hybrid     !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Magnet\n")
    Fclc.write("BlockChamf mag1_H Mag1_H $ColorMag_Hybrid                                                            !key, name, mother, color\n")
    Fclc.write("$xMag1_Hybrid $yMag_Hybrid $zMag_Hybrid                                                             !position\n")
    Fclc.write("$Br_Hybrid 1. 0. 0. $RECIndex_Hybrid                                                                !length bc and comp. of magnetization, material index\n")
    Fclc.write("$LxMag_Hybrid $LyMag_Hybrid $LzMagHalf_Hybrid $ChamfMag_Hybrid                                      !dimensions \n")
    Fclc.write("$nDivX_Mag_Hybrid $nDivY_Mag_Hybrid $nDivZ_MagHalf_Hybrid $FracDivY_Mag_Hybrid $FracDivZ_Mag_Hybrid     !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Pole\n")
    Fclc.write("BlockDsChamf pol1_H Pol1_H $ColorPol_Hybrid                                                         !key, name, mother, color\n")
    Fclc.write("$xHalfPol1_Hybrid $yPol_Hybrid $zPol_Hybrid                                                         !position\n")
    Fclc.write("$IronIndex_Hybrid                                                                                   !material index\n")
    Fclc.write("$LxPolHalf_Hybrid $LyPol_Hybrid $LzPolHalf_Hybrid $ChamfPol_Hybrid                                  !dimensions \n")
    Fclc.write("$nDivX_PolHalf_Hybrid $nDivY_Pol_Hybrid $nDivZ_PolHalf_Hybrid $FracDivY_Pol_Hybrid $FracDivZ_Pol_Hybrid !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Module\n")
    Fclc.write("0. 0. 0.                   !offset of module\n")
    Fclc.write("$nPeriods_Hybrid           !number of arrays within module\n")
    Fclc.write("$PerLen_Hybrid 1. 0. 0. 0. !spacing and direction of arrangement, rotation angle\n")
    Fclc.write("1. 1. 1.                   !scaling and symmetry of magnetization vector\n")
    Fclc.write(" \n")
    Fclc.write(" \n")

    Fclc.write("& Special_Pole\n")
    Fclc.write("BlockUsChamf epolh_H EPol_H $ColorPol_Hybrid                                                        !key, name, mother, color\n")
    Fclc.write("$xEndPolHalf_Hybrid $yPol_Hybrid $zPol_Hybrid                                                       !position\n")
    Fclc.write("$IronIndex_Hybrid                                                                                   !material index\n")
    Fclc.write("$LxPolHalf_Hybrid $LyPol_Hybrid $LzPolHalf_Hybrid $ChamfPol_Hybrid                                  !dimensions \n")
    Fclc.write("$nDivX_PolHalf_Hybrid $nDivY_Pol_Hybrid $nDivZ_PolHalf_Hybrid $FracDivY_Pol_Hybrid $FracDivZ_Pol_Hybrid !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("BlockChamf emag1_H EMag1_H $ColorMag_Hybrid                                                         !key, name, mother, color\n")
    Fclc.write("$xEndMag1_Hybrid $yEndMag1_Hybrid $zMag_Hybrid                                                      !position\n")
    Fclc.write("$Br_Hybrid 1. 0. 0. $RECIndex_Hybrid                                                                !length bc and comp. of magnetization, material index\n")
    Fclc.write("$LxMag_Hybrid $LyEndMag1_Hybrid $LzMagHalf_Hybrid $ChamfMag_Hybrid                                  !dimensions \n")
    Fclc.write("$nDivX_Mag_Hybrid $nDivY_Mag_Hybrid $nDivZ_MagHalf_Hybrid $FracDivY_Mag_Hybrid $FracDivZ_Mag_Hybrid     !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Special_Pole\n")
    Fclc.write("BlockChamf epol1_H EPol1_H $ColorPol_Hybrid                                                         !key, name, mother, color\n")
    Fclc.write("$xEndPol1_Hybrid $yEndPol1_Hybrid $zPol_Hybrid                                                      !position\n")
    Fclc.write("$IronIndex_Hybrid                                                                                   !material index\n")
    Fclc.write("$LxPol_Hybrid $LyEndPol1_Hybrid $LzPolHalf_Hybrid $ChamfPol_Hybrid                                  !dimensions \n")
    Fclc.write("$nDivX_Pol_Hybrid $nDivY_Pol_Hybrid $nDivZ_PolHalf_Hybrid $FracDivY_Pol_Hybrid $FracDivZ_Pol_Hybrid     !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("BlockChamf emag2_H EMag2_H $ColorMag_Hybrid                                                         !key, name, mother, color\n")
    Fclc.write("$xEndMag2_Hybrid $yEndMag2_Hybrid $zMag_Hybrid                                                      !position\n")
    Fclc.write("$Br_Hybrid -1. 0. 0. $RECIndex_Hybrid                                                               !length bc and comp. of magnetization, material index\n")
    Fclc.write("$LxMag_Hybrid $LyEndMag2_Hybrid $LzMagHalf_Hybrid $ChamfMag_Hybrid                                  !dimensions \n")
    Fclc.write("$nDivX_Mag_Hybrid $nDivY_Mag_Hybrid $nDivZ_MagHalf_Hybrid $FracDivY_Mag_Hybrid $FracDivZ_Mag_Hybrid     !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Special_Pole\n")
    Fclc.write("BlockChamf epol2_H EPol2_H $ColorPol_Hybrid                                                         !key, name, mother, color\n")
    Fclc.write("$xEndPol2_Hybrid $yEndPol2_Hybrid $zPol_Hybrid                                                      !position\n")
    Fclc.write("$IronIndex_Hybrid                                                                                   !material index\n")
    Fclc.write("$LxPol_Hybrid $LyEndPol2_Hybrid $LzPolHalf_Hybrid $ChamfPol_Hybrid                                  !dimensions \n")
    Fclc.write("$nDivX_Pol_Hybrid $nDivY_Pol_Hybrid $nDivZ_PolHalf_Hybrid $FracDivY_Pol_Hybrid $FracDivZ_Pol_Hybrid     !segmentation\n")
    Fclc.write("\n")

    Fclc.write("& Special_Magnet\n")
    Fclc.write("BlockChamf emag3_H EMag3_H $ColorMag_Hybrid                                                         !key, name, mother, color\n")
    Fclc.write("$xEndMag3_Hybrid $yEndMag3_Hybrid $zMag_Hybrid                                                      !position\n")
    Fclc.write("$Br_Hybrid 1. 0. 0. $RECIndex_Hybrid                                                                !length bc and comp. of magnetization, material index\n")
    Fclc.write("$LxMag_Hybrid $LyEndMag3_Hybrid $LzMagHalf_Hybrid $ChamfMag_Hybrid                                  !dimensions \n")
    Fclc.write("$nDivX_Mag_Hybrid $nDivY_Mag_Hybrid $nDivZ_MagHalf_Hybrid $FracDivY_Mag_Hybrid $FracDivZ_Mag_Hybrid     !segmentation\n")
    Fclc.write("\n")

    Fclc.write(" \n")
    Fclc.write("& Materials\n")
    Fclc.write(str(Nmat) + "            ! number of material files\n")

    for imat in range(Nmat):
      mat = mats[imat]
      if imat == int(Hybrid["RECIndex_Hybrid"]) - 1:
        mat[4] = str(Hybrid["mu_Hybrid"]) + " " + str(Hybrid["KsiPerp_Hybrid"]) + "  ! mu_Par and ksi_Perp\n"
      Fclc.write(str(mat[0]) + " " + str(mat[1]) + " " + str(mat[2]) + " " + mat[3] + "\n")
      if mat[2] == '1':
        Fmat = open(str(mat[3]),'w')
        for line in mat[4]: Fmat.write(line)
        Fmat.close()
      #endif mat[2] == '1'
    #endfor imat in range(Nmat)

    Fclc.write("\n")
    Fclc.write("Coils\n*\n")
    Fclc.write("* Current per winding, filling factor, number of windings, center, normal vector, rotation-angle, total length,\n")
    Fclc.write("* inner width, outer width, inner radius, height, vert/hori/rad\n")
    Fclc.write("* divisions, color-index\n")

    Fclc.write("\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentByCoil $FillingCoil $nWindingByCoil "
    scoil += "$xCoilByCoilUS $yCoilTop $zCoilByCoil 0. 1. 0. 0. "
    scoil += "$xLenOutByCoil $zLenInByCoil $zLenOutByCoil $RectRiByCoil "
    scoil += "$HeightByCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentByCoil $FillingCoil $nWindingByCoil "
    scoil += "$xCoilByCoilDS $yCoilTop $zCoilByCoil 0. 1. 0. 0. "
    scoil += "$xLenOutByCoil $zLenInByCoil $zLenOutByCoil $RectRiByCoil "
    scoil += "$HeightByCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentByCoil $FillingCoil $nWindingByCoil "
    scoil += "$xCoilByCoilUS $yCoilBottom $zCoilByCoil 0. 1. 0. 0. "
    scoil += "$xLenOutByCoil $zLenInByCoil $zLenOutByCoil $RectRiByCoil "
    scoil += "$HeightByCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentByCoil $FillingCoil $nWindingByCoil "
    scoil += "$xCoilByCoilDS $yCoilBottom $zCoilByCoil 0. 1. 0. 0. "
    scoil += "$xLenOutByCoil $zLenInByCoil $zLenOutByCoil $RectRiByCoil "
    scoil += "$HeightByCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentBzCoil $nWindingBzCoil $FillingCoil "
    scoil += "$xCoilBzCoilUS $yCoilBzCoil $zBzCoilRight 0. 0. 1. 0. "
    scoil += "$xLenOutBzCoil $zLenInBzCoil $zLenOutBzCoil $RectRiBzCoil "
    scoil += "$HeightBzCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentBzCoil $nWindingBzCoil $FillingCoil "
    scoil += "$xCoilBzCoilDS $yCoilBzCoil $zBzCoilRight 0. 0. 1. 0. "
    scoil += "$xLenOutBzCoil $zLenInBzCoil $zLenOutBzCoil $RectRiBzCoil "
    scoil += "$HeightBzCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentBzCoil $nWindingBzCoil $FillingCoil "
    scoil += "$xCoilBzCoilUS $yCoilBzCoil $zBzCoilLeft 0. 0. 1. 0. "
    scoil += "$xLenOutBzCoil $zLenInBzCoil $zLenOutBzCoil $RectRiBzCoil "
    scoil += "$HeightBzCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("\n")
    Fclc.write("RectWindings\n")
    scoil = ""
    scoil += "$CurrentBzCoil $nWindingBzCoil $FillingCoil "
    scoil += "$xCoilBzCoilDS $yCoilBzCoil $zBzCoilLeft 0. 0. 1. 0. "
    scoil += "$xLenOutBzCoil $zLenInBzCoil $zLenOutBzCoil $RectRiBzCoil "
    scoil += "$HeightBzCoil $nDivHeightCoil $nDivWindCoil $nDivArcCoil $nCoilColor\n"
    Fclc.write(scoil)

    Fclc.write("EndCoils\n")
    Fclc.write("*************\n")

    Fclc.close()

    try:
      stat = shutil.copyfile(FileCLC,"undumag_Hybrid.clc")
      print("\n--- ",FileCLC," written and copyied to undumag_Hybrid.clc ---")
    except:
      print("\n--- ",FileCLC," written, but not copied to  undumag_Hybrid.clc! Is it a link?  ---")
    #endif

  else:

    #if key == 'UNDUMAG':
    #if Mode == 'Hybrid':
    #Hybrid_Mode=1
    #endif

    # Other Modes

    if Nmodul <= 0 and NMagPolTot > NspecMagPol:
      wError("No modules defined, but periodic items found, cannot write geometry file!")
      return
    #endif Nmodul <= 0 and NMagPolTot > NspecMagPol:

    if Nmat <= 0 and NMagPolTot > 0:
      wError("No material defined, cannot write geometry file!")
      return
    #endif Nmat <= 0

    Flast = open("unduclc.lst","w")
    Flast.write(FileCLC+NL)
    Flast.close()

    Fclc = open(FileCLC,'w')

    Fclc.write("*! Lines written by undugui.py\n")
    Fclc.write("Mode " + Mode + "\n")
    Fclc.write("\n")
    Fclc.write("\n")

    Fclc.write("\n& User_Comment\n")
    Fclc.write(Ucomment.strip() + "\n")

    write_variables(Fclc)

    if NMagPolTot:
      Fclc.write("\n")
      Fclc.write("* Magnets \n")
      Fclc.write("\n")
    #endif

    #debug("uwriteclc")
    imag = 0

    for mp in MagPolsTot:

      imag += 1

      ckey = "\n& "
      if mp[2] == 'yes' or mp[2] == 1: ckey = "\n& Special_"

      if mp[1] == 'Iron': ckey += "Pole\n"
      else: ckey += "Magnet\n"

      cnam = mp[0][0]
      cmoth = mp[0][1]
      key = mp[3]
      cen = mp[4]
      vmat = mp[5]

      scol = vmat[5]
      if scol in DictUnduColors: col = str(DictUnduColors[scol])
      else: col = scol

      Fclc.write(ckey)

      line = key + " " + cnam + " " + cmoth + " " + col
      comm = "!key, name, mother, color\n"
      n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)

      line = cen[0] + " " + cen[1] + " " + cen[2]
      comm = "!position\n"
      n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)

      if mp[1] == 'Iron':
        line = vmat[4]
        comm = " !material index\n"
        n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)
      else:
        line = vmat[0] + " " + vmat[1] + " " + vmat[2] + " " + vmat[3] + " " + vmat[4]
        comm = "!Bc, direction of magnetization, material index\n"
        n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)
      #endif

      if key != 'File' and key != 'Corners':

        siz = mp[6]
        div = mp[7]

        line = siz[0] + " " + siz[1] + " " + siz[2] + " " + siz[3]
        comm = "!dimensions\n"
        n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)

        line = div[0] + " " + div[1] + " " + div[2] + " " + div[3] + " " + div[4]
        comm = "!segmentation\n"
        n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)

      else:

        ncorn = mp[6]
        corns = mp[7]
        div = mp[8]

        line = div[0] + " " + div[1] + " " + div[2] + " " + div[3] + " " + div[4]
        comm = "!segmentation\n"
        n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)

        line = ncorn
        comm = "!number of corners\n"
        n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)

        for corn in corns:
          line = str(corn[0]) + " " + str(corn[1]) + " " + str(corn[2])
          comm = "!x y z\n"
          n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)
        #endfor

      #endif

    #endfor

    for m in Modules:
      Fclc.write("\n& Module\n")
      line = m[0]
      comm = "!offset of module\n"
      n = 50 - len(line)
      Fclc.write(line + blanks[0:n] + comm)
      line = m[1]
      comm = "!number of arrays within module\n"
      n = 50 - len(line)
      Fclc.write(line + blanks[0:n] + comm)
      line = m[2]
      comm = "!spacing and direction of arrangement, rotation angle\n"
      n = 50 - len(line)
      Fclc.write(line + blanks[0:n] + comm)
      line = m[3]
      comm = "!scaling and symmetry of magnetization vector\n"
      n = 50 - len(line)
      Fclc.write(line + blanks[0:n] + comm)
    #endfor

    if Nmat:

      Fclc.write("\n& Materials\n")

      line = str(Nmat)
      comm = "! number of material files\n"
      n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)

      for imat in range(Nmat):

        mat = mats[imat]
        line = str(mat[0]) + " " + str(mat[1]) + " " + str(mat[2]) + " " + mat[3]
        comm = "! number, type, mode, and  filename\n"
        n = 50 - len(line); Fclc.write(line + blanks[0:n] + comm)

        if mat[2] == '1':
          Fmat = open(str(mat[3]),'w')
          for line in mat[4]: Fmat.write(line)
          Fmat.close()
        #endif mat[2] == '1'

      #endfor imat in range(Nmat)

    #endif Nmat

    if len(Coils): write_coils(Coils,Fclc)

    Fclc.close()

  #endif int(AppleII_Mode) > 0

  #print(TransRotCop)
  if len(TransRotCop) > 0:
    uwritetrc(FileCLC)
  #endif

+self,if=trace.
  print(NL,"trace:: Leaving uwriteclc('",callkey,"')")
+self.
#enddef uwriteclc()
+KEEP,unduplgeo,T=PYTHON.
*CMZ :  2.05/01 22/10/2023  12.12.54  by  Michael Scheer
*CMZ :  2.04/14 04/09/2023  13.21.19  by  Michael Scheer
*CMZ :  2.04/10 21/08/2023  15.45.12  by  Michael Scheer
*CMZ :  2.04/09 17/08/2023  15.19.59  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  13.14.39  by  Michael Scheer
*CMZ :  2.04/00 24/12/2022  11.49.32  by  Michael Scheer
*CMZ :  2.03/00 14/07/2022  12.03.10  by  Michael Scheer
*CMZ :  2.02/02 04/07/2022  14.31.24  by  Michael Scheer
*CMZ :  2.02/01 26/01/2022  12.39.30  by  Michael Scheer
*CMZ :  2.02/00 24/03/2021  15.14.49  by  Michael Scheer
*-- Author :    Michael Scheer   26/10/2020

+seq,UnduColors.
+seq,ureadclc.

def undu_coil(ntup='ncoil', fcoil='undumag.fil'):
  if fexist(fcoil):
    ncoil = ncread(ntup,"itype:curr:x1:y1:z1:x2:y2:z2:icol:num:ncoil",fcoil)
    if Nlines > 0: ninfo(ncoil)
  else:
    ncoil = ncre(ntup,"itype:curr:x1:y1:z1:x2:y2:z2:icol:num:ncoil")
  #endif
  return ncoil
#enddef undu_coil

def undu_plot_coil_4x4(ntup='!', fcoil='!'):
  zone(2,2)
  undu_plot_coil('!','!','3d',0)
  nextzone()
  undu_plot_coil('!','!','top',0)
  nextzone()
  undu_plot_coil('!','!','side',0)
  nextzone()
  undu_plot_coil('!','!','beam',0)
#enddef

def undu_plot_coil_top(ntup='!', fcoil='!',isame=0):
  undu_plot_coil('!','!','top',isame)
def undu_plot_coil_side(ntup='!', fcoil='!',isame=0):
  undu_plot_coil('!','!','side',isame)
def undu_plot_coil_beam(ntup='!', fcoil='!',isame=0):
  undu_plot_coil('!','!','beam',isame)

def undu_plot_coil(ntup='!', fcoil='!', mode='3d', isame=0):

  if ntup == '!': ntup = 'ncoil'
  if fcoil == '!': fcoil = 'undumag.fil'
  if not nexist(ntup): ncoil = undu_coil(ntup,fcoil)
  else: ncoil = nget("ncoil")

  if not len(ncoil): return

  #print(ntup,fcoil,mode)

  xmin = min(ncoil.x1.min(),ncoil.x2.min())
  xmax = max(ncoil.x1.max(),ncoil.x2.max())
  ymin = min(ncoil.y1.min(),ncoil.y2.min())
  ymax = max(ncoil.y1.max(),ncoil.y2.max())
  zmin = min(ncoil.z1.min(),ncoil.z2.min())
  zmax = max(ncoil.z1.max(),ncoil.z2.max())

  d = (xmax-xmin)*0.1
  xmin -= d
  xmax += d
  if xmin == xmax:
    xmin = xmin - 1.0
    xmax = xmax + 1.0
  #endif

  d = (ymax-ymin)*0.1
  ymin -= d
  ymax += d
  if ymin == ymax:
    ymin = ymin - 1.0
    ymax = ymax + 1.0
  #endif

  d = (zmax-zmin)*0.1
  zmin -= d
  zmax += d
  if zmin == zmax:
    zmin = zmin - 1.0
    zmax = zmax + 1.0
  #endif

  yzmin = min(ymin,zmin)
  yzmax = max(ymax,zmax)

  if mode.lower() == 'xz' or mode.lower() == 'top':

    if not isame:
      null(xmin,xmax,zmin,zmax)
      txyz("Coil","x/mm","z/mm")
    #endif

    # Exterm langsam!!     for w in ncoil.itertuples():
    #        Ax.plot([w.x1,w.x2],[w.z1,w.z2],UnduColors[w.icol])
    #for w in ncoil.itertuples()

    for icoil in range(ncoil.ncoil.max()):
      coil = ncoil.query("ncoil=="+str(icoil+1))
      for w in coil.itertuples():
        Ax.plot([w.x1,w.x2],[w.z1,w.z2],UnduColors[w.icol])
    #endfor icoil in range(ncoil.num.max()+1)

  elif mode.lower() == 'xy' or mode.lower() == 'side':

    if not isame:
      null(xmin,xmax,ymin,ymax)
      txyz("Coil","x/mm","y/mm")
    #endif

    for icoil in range(ncoil.ncoil.max()):
      coil = ncoil.query("ncoil=="+str(icoil+1))
      for w in coil.itertuples():
        Ax.plot([w.x1,w.x2],[w.y1,w.y2],UnduColors[w.icol])
    #endfor icoil in range(ncoil.num.max()+1)

  elif mode.lower() == 'yz' or mode.lower() == 'beam':

    if not isame:
      null(yzmin,yzmax,yzmin,yzmax)
      txyz("Coil","z/mm","y/mm")
    #endif

    #    Elegant, aber extrem langsam!!
    #    for w in ncoil.itertuples(): Ax.plot([w.z1,w.z2],[w.y1,w.y2],color='blue')

    for icoil in range(ncoil.ncoil.max()):
      coil = ncoil.query("ncoil=="+str(icoil+1))
      for w in coil.itertuples():
        Ax.plot([w.z1,w.z2],[w.y1,w.y2],UnduColors[w.icol])
    #endfor icoil in range(ncoil.num.max()+1)

  else:

    if not isame:
      null3d(xmin,xmax,yzmin,yzmax,yzmin,yzmax)
      txyz("Coil","x/mm","z/mm","y/mm")
    #endif

    for icoil in range(ncoil.ncoil.max()):
      coil = ncoil.query("ncoil=="+str(icoil+1))
      for w in coil.itertuples():
        Ax.plot([w.x1,w.x2],[w.z1,w.z2],[w.y1,w.y2],UnduColors[w.icol])
    #endfor icoil in range(ncoil.num.max()+1)

  #endif mode.lower() == '3d'

#enddef undu_plot_coil(...)

def undu_geo(plopt='sameline'):

+seq,argumentsind.
+seq,mhbglobind.
+seq,UnduColorsind.

  kdump = Kdump
  kpdf = Kpdf
  kecho = Kecho

  Kdump = False
  Kpdf = False
  Kecho = False

  if nargs > 2: ugeomode = int(args[2])
  else: ugeomode = 0

  if plopt == '!': plopt = 'sameline'

  if not nexist("ngeo"):
    if fexist("undumag.geo"):
      tclc = os.stat('undumag.clc').st_mtime_ns
      tgeo = os.stat('undumag.geo').st_mtime_ns
      if tclc > tgeo: print("undumag.geo is older than undumag.clc!")
      ngeo = ncread("ngeo","mag:ityp:xc:yc:zc:moth:ix:iy:iz:mat:icol:mx:my:mz:bc:iplan:icorn:x:y:z:cmag:cmoth","undumag.geo")
    #endif
  else:
    ngeo = nget("ngeo")
  #endif

  if Nlines <= 0:
    undu_plot_coil()
    return
  #endif

  ninfo(ngeo)

  xmin = ngeo.x.min()
  ymin = ngeo.y.min()
  zmin = ngeo.z.min()

  xmax = ngeo.x.max()
  ymax = ngeo.y.max()
  zmax = ngeo.z.max()

  dx = (xmax-xmin)/20.
  dy = (ymax-ymin)/20.
  dz = (zmax-zmin)/20.

  xyzmax = xmax + dx
  if ymax+dy > xyzmax: xyzmax=ymax+dy
  if zmax+dz > xyzmax: xyzmax=zmax+dz
  xyzmin=xmin-dx

  if ymin-dy < xyzmin: xyzmin=ymin-dy
  if zmin-dz < xyzmin: xyzmin=zmin-dz

  yzmin=min(ymin,zmin)
  yzmax=max(ymax,zmax)

  null3d(xmin-dx,xmax+dx,yzmin,yzmax,yzmin,yzmax)

  txyz("geo","x","z","y")
  if len(ngeo) == 0: return

  if ugeomode < 0:
    return
  #endif ugeomode < 0

  ssel = "cmag != 'wire'"
  nmag = ngeo.query(ssel)

  isame = 0

  if len(nmag):

    if ugeomode > 0: # convex hull of items

      mmin = int(ngeo.mag.min())
      mmax = int(ngeo.mag.max())

      for mag in range(mmin,mmax+1):

        ssel = "mag == " + str(mag)
        icmin,icmax = nminmax(nmag,"icol",ssel)

        icmin = int(icmin)
        icmax = int(icmax)

        setmarkercolor(UnduColors[icmin])
        #setlinecolor(UnduColors[icmin])
        nhull = nhull3d(nmag,"x:z:y",ssel,'sameline',
                        facecolor=UnduColors[icmin],edgecolor=UnduColors[icmin],
                        alpha=0,ishow=0)

      #endfor mag in range(mmin,mmax)

      txyz("geo","x","z","y")

    else: # convex hull of mothers

      mmin = int(ngeo.moth.min())
      mmax = int(ngeo.moth.max())

      for moth in range(mmin,mmax+1):

        ssel = "moth==" + str(moth)

        icmin,icmax = nminmax(ngeo,"icol",ssel)
        try: icmin = int(icmin)
        except: continue

        setmarkercolor(UnduColors[icmin])
        #setlinecolor(UnduColors[icmin])

        #nhull = nhull3d(ngeo,"x:z:y",ssel,'sameline')
        nhull = nhull3d(ngeo,"x:z:y",ssel,'sameline', \
        facecolor=UnduColors[icmin],edgecolor=UnduColors[icmin], \
        alpha=0,ishow=0)

      #endfor mag in range(mmin,mmax)

      txyz("geo","x","z","y")

    #endif ugeomode

  #endif

  undu_plot_coil(isame=isame)

  Kdump = kdump
  Kpdf = kpdf
  Kecho = kecho

#enddef undu_geo()

def undu_plot_mag(select='yc<0 and zc<0',plopt='sameline'):

+seq,mhbglobind.
+seq,UnduColorsind.

  kdump = Kdump
  kpdf = Kpdf
  kecho = Kecho

  Kdump = False
  Kpdf = False
  Kecho = False

  if plopt == '!': plopt = 'sameline'

  if not nexist("ngeo"):
    if fexist("undumag.geo"):
      tclc = os.stat('undumag.clc').st_mtime_ns
      tgeo = os.stat('undumag.geo').st_mtime_ns
      if tclc > tgeo: print("undumag.geo is older than undumag.clc!")
      print('\nReading undumag.geo...')
      ngeo = ncread("ngeo","mag:ityp:xc:yc:zc:moth:ix:iy:iz:mat:icol:mx:my:mz:bc:iplan:icorn:x:y:z:cmag:cmoth","undumag.geo")
      print('done\n')
    #endif
  #endif

  print('\nSelection for ',select)

  if len(select) > 0:
    nt = ngeo.query(select)
  else:
    nt = ngeo
  #endif

  print('\nStart plotting')

  if len(nt) == 0:
    print("\n*** Nothing to plot for",select)
    return
  #endif

  xmin = nt.x.min()
  ymin = nt.y.min()
  zmin = nt.z.min()

  xmax = nt.x.max()
  ymax = nt.y.max()
  zmax = nt.z.max()

  dx = (xmax-xmin)/20.
  dy = (ymax-ymin)/20.
  dz = (zmax-zmin)/20.

  xyzmax = xmax + dx
  if ymax+dy > xyzmax: xyzmax=ymax+dy
  if zmax+dz > xyzmax: xyzmax=zmax+dz
  xyzmin=xmin-dx

  if ymin-dy < xyzmin: xyzmin=ymin-dy
  if zmin-dz < xyzmin: xyzmin=zmin-dz

  yzmin=min(ymin,zmin)
  yzmax=max(ymax,zmax)

  null3d(xmin-dx,xmax+dx,yzmin,yzmax,yzmin,yzmax)

  nhull = nhull3d(nt,"x:z:y",'',plopt,edgecolor='black',ishow=0)
  plt.show(block=False)

  mmin = nt.mag.min()
  mmax = nt.mag.max()

  for m in range(mmin,mmax+1):
    selma = "mag==" + str(m)
    nm = nt.query(selma)
    icol = nm.icol.max()
    if len(nm) > 0:
      nhull = nhull3d(nm,"x:z:y",'',plopt,edgecolor=UnduColors[icol],ishow=0)
  #endfor

  plt.show(block=False)
  #txyz(select,"x","z","y")

  Kdump = kdump
  Kpdf = kpdf
  Kecho = kecho

#enddef undu_plot_mag()

def undu_mags(plopt='sameline'):

+seq,argumentsind.
+seq,mhbglobind.
+seq,UnduColorsind.

  #reakpoint()
  kdump = Kdump
  kpdf = Kpdf
  kecho = Kecho

  Kdump = False
  Kpdf = False
  Kecho = False


  if nargs > 2: ugeomode = int(args[2])
  else: ugeomode = 0

  if plopt == '!': plopt = 'sameline'

  if not nexist("nmags"):
    nmags = ncread("nmags","imoth:mag:icol:iplan:icorn:x:y:z:bx:by:bz:imat:cmag:cmoth:ispole","undumag.mag")
  else:
    nmags = nget("nmags")
  #endif

  if not nexist("nvox"):
    nvox = ncread("nvox","cnam:cmoth:icol:modu:kmag:lmag:ivox:icop:x:y:z:bxi:byi:bzi:bxe:bye:bze:ispole","undumag_voxel.lis")
  else:
    nvox = nget("nvox")
  #endif

  xmin = nmags.x.min()
  ymin = nmags.y.min()
  zmin = nmags.z.min()

  xmax = nmags.x.max()
  ymax = nmags.y.max()
  zmax = nmags.z.max()

  dx = (xmax-xmin)/20.
  dy = (ymax-ymin)/20.
  dz = (zmax-zmin)/20.

  xyzmax = xmax + dx
  if ymax+dy > xyzmax: xyzmax=ymax+dy
  if zmax+dz > xyzmax: xyzmax=zmax+dz
  xyzmin=xmin-dx

  if ymin-dy < xyzmin: xyzmin=ymin-dy
  if zmin-dz < xyzmin: xyzmin=zmin-dz

#  getzone('3d')
  null3d(xyzmin,xyzmax,xyzmin,xyzmax,xyzmin,xyzmax)

#  print("Returning");return
  txyz("Magnets","x","z","y")

  if ugeomode < 0:
    ninfo(nmags)
    return
  #endif ugeomode < 0

  mmin = int(nmags.mag.min())
  mmax = int(nmags.mag.max())

  if ugeomode == 0: # convex hull of items

    for mag in range(mmin,mmax+1):

      ssel = "mag==" + str(mag)
      icmin,icmax = nminmax(nmags,"icol",ssel)
      icmin = int(icmin)
      icmax = int(icmax)
      setmarkercolor(UnduColors[icmin])
      setlinecolor(UnduColors[icmin])
      if mag > 1:
        nhull = nhull3d(nmags,"x:z:y",ssel,'sameline',ishow=0)
      else:
        nhull = nhull3d(nmags,"x:z:y",ssel,plopt,ishow=0)
      #endif mag > 0
    #endfor mag in range(mmin,mmax)

    txyz("Magnets","x","z","y")

  #endif ugeomode

  Kdump = kdump
  Kpdf = kpdf
  Kecho = kecho

#enddef undu_mags()
+KEEP,showgeo,T=PYTHON.
*CMZ :  2.05/01 23/10/2023  11.26.32  by  Michael Scheer
*CMZ :  2.04/16 06/09/2023  09.51.05  by  Michael Scheer
*CMZ :  2.04/14 05/09/2023  08.47.32  by  Michael Scheer
*CMZ :  2.04/13 04/09/2023  10.03.11  by  Michael Scheer
*CMZ :  2.04/12 31/08/2023  06.57.01  by  Michael Scheer
*CMZ :  2.04/11 29/08/2023  14.59.29  by  Michael Scheer
*CMZ :  2.04/10 21/08/2023  13.18.56  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.12.52  by  Michael Scheer
*CMZ :  2.04/06 09/07/2023  12.23.11  by  Michael Scheer
*CMZ :  2.03/00 01/09/2022  08.28.07  by  Michael Scheer
*CMZ :  2.02/02 08/03/2022  11.43.34  by  Michael Scheer
*CMZ :  2.02/01 21/10/2021  12.11.52  by  Michael Scheer
*CMZ :  2.02/00 30/03/2021  11.36.44  by  Michael Scheer
*-- Author :    Michael Scheer   13/10/2020
+seq,unduplgeo.

global MainFacets,FcBox,Faces
MainFacets = []
Facets = []
FcBox = []

def read_facets_bounding_box(fb='undumag_bounding_box.fct'):
  global MainFacets, FcBox,Xmin,Xmax,Ymin,Ymax,Zmin,Zmax

  FcBox = []
  if fexist('undumag_bounding_box.fct'):
    tclc = os.stat('undumag.clc').st_mtime_ns
    tbb = os.stat('undumag_bounding_box.fct').st_mtime_ns
    if tclc > tbb:
      print("undumag_bounding_box.fct is older than undumag.clc!")
    #endif
    print('\n--> Reading undumag_bounding_box.fct')
    fbox = open('undumag_bounding_box.fct','r')
    FcBox = np.fromstring(fbox.readline().strip(),dtype=np.float,sep=' ')
    fbox.close()
    Xmin = FcBox[0]
    Xmax = FcBox[1]
    Ymin = FcBox[2]
    Ymax = FcBox[3]
    Zmin = FcBox[4]
    Zmax = FcBox[5]
    print('\n--> Done')
  else:
    wError("File undumag_main_facets not found!")
    return
  #endif
#enddef read_facets_bounding_box(fb='undumag_bounding_box.fct')

def plot_main_faces():

  global MainFacets,Xmin,Xmax,Ymin,Ymax,Zmin,Zmax

  plopt = ''

  Kpdf = False
  Kdump = False
  Kecho = False

  dot()
  getzone('3d')

  facets = MainFacets[0]
  voxels = MainFacets[1]

  dx = (Xmax - Xmin) / 10.
  dy = (Ymax - Ymin) / 10.
  dz = (Zmax - Zmin) / 10.

  null3d(Xmin-dx,Xmax+dx,Zmin-dz,Zmax+dz,Ymin-dy,Ymax+dy)
  txyz(Ucomment,"x [mm]","z [mm]", "y [mm]")

  ax = plt.gca()
  iface = -1

  nfacets = len(facets)

  fcols = []
  for v in voxels:
    if not v[1] in fcols: fcols.append(v[1])
  #endfor

  for col in fcols:
    fcolcol = []
    for i in range(nfacets):
      if voxels[i][1] == col: fcolcol.append(facets[i])
    #endfor
    fpl = mplot3d.art3d.Poly3DCollection(fcolcol)
    fpl.set_color(UnduColors[int(col)])
    fpl.set_edgecolor('black')
    ax.add_collection3d(fpl)

  #endfor

#enddef plot_main_faces()

plot_main_facets = plot_main_faces

def read_main_faces(fname='undumag_main_facets.fct',cs='xyz'):

  F=open(fname,'r')
  fread = F.readlines()
  F.close()

  faces = []
  voxels = []

  l=0
  nface=-1
  #breakpoint()
  nmag = int(fread[l].strip())
  l += 1
  for imag in range(nmag):
    npoi = int(fread[l].split()[0])
    voxels.append(fread[l].split())
    nface += 1
    l += 1
    fac = []
    for ipoi in range(npoi):
      p = np.fromstring(fread[l].strip(),dtype=np.float,sep=' ')
      if cs.lower() == 'xzy':
        fac.append([p[0],p[2],p[1]])
      else:
        fac.append([p[0],p[1],p[2]])
      #endif
      l += 1
    #endfor npoi
    faces.append(np.array(fac))
  #endfor nmag

  return faces,voxels
#enddef read_main_faces(fname)

def _ucoilplot(view='3d', modus='same', item=-1,callkey=''):

  global Coils, Filaments, UnduColors, CurrLoops, NMagPolTot

+self,if=trace.
  print(NL,"trace:: _ucoilplot:",view,modus,item,callkey)
+self.

  if NMagPolTot >= 0 and len(Filaments) == 0:
+self,if=trace.
    print(NL,"trace:: Leaving _ucoilplot, no coils...")
+self.
    return
  #endif

  xmin = 1.e30
  xmax = -1.e30
  ymin = 1.e30
  ymax = -1.e30
  zmin = 1.e30
  zmax = -1.e30

  coiltit = "Coils"
  icoil = -1
  ifound = 0

  kallzero = 1
  for coil in Filaments:
    icoil += 1
    if item > -1 and icoil != item: continue
    curr = calc_var(Coils[icoil][1][0])
    coiltit = Coils[icoil][0][1]
    ifound = 1
    if curr == 0 and modus != 'notsame': continue
    kallzero = 0
    for wire in coil:
      xmin = min(xmin,wire[2],wire[5])
      xmax = max(xmax,wire[2],wire[5])
      ymin = min(ymin,wire[3],wire[6])
      ymax = max(ymax,wire[3],wire[6])
      zmin = min(zmin,wire[4],wire[7])
      zmax = max(zmax,wire[4],wire[7])
    #endfor wire in coil

  #endfor coil in Filaments

  if kallzero: return [xmin,xmax,ymin,ymax,zmin,zmax,kallzero]

  dx = (xmax-xmin)*0.1
  dy = (ymax-ymin)*0.1
  dz = (zmax-zmin)*0.1

  if dx == 0.0: dx = 1.
  if dy == 0.0: dy = 1.
  if dz == 0.0: dz = 1.

  if ifound == 0:
    wError("No coils to plot")
+self,if=trace.
    print(NL,"trace:: Leaving _ucoilplot due to error")
+self.
    return
  #endif

  if view.lower() == 'xz' or view.lower() == 'top':

    if not modus == 'same':
      null(xmin-dx,xmax+dx,zmin-dz,zmax+dz)
      txyz(coiltit,"x/mm","z/mm")
    #endif

    icoil = -1
    for coil in Filaments:
      icoil += 1
      if item > -1 and icoil != item: continue
      color = UnduColors[coil[0][8]]
      for w in coil:
        #               x1    x2    z1   z2     y1    y2
        # 3d: Ax.plot([w[2],w[5]],[w[4],w[7]],[w[3],w[6]],color)
        Ax.plot([w[2],w[5]],[w[4],w[7]],color)
      #endfor
    #endfor

  elif view.lower() == 'xy' or view.lower() == 'side':

    if not modus == 'same':
      null(xmin-dx,xmax+dx,ymin-dy,ymax+dy)
      txyz(coiltit,"x/mm","y/mm")
    #endif

    icoil = -1
    for coil in Filaments:
      icoil += 1
      if item > -1 and icoil != item: continue
      color = UnduColors[coil[0][8]]
      for w in coil:
        #               x1    x2    z1   z2     y1    y2
        # 3d: Ax.plot([w[2],w[5]],[w[4],w[7]],[w[3],w[6]],color)
        Ax.plot([w[2],w[5]],[w[3],w[6]],color)
      #endfor
    #endfor

  elif view.lower() == 'zy' or view.lower() == 'beam':

    if not modus == 'same':
      null(zmin-dz,zmax+dz,ymin-dy,ymax+dy)
      txyz(coiltit,"z/mm","y/mm")
    #endif

    icoil = -1
    for coil in Filaments:
      icoil += 1
      if item > -1 and icoil != item: continue
      color = UnduColors[coil[0][8]]
      for w in coil:
        #               x1    x2    z1   z2     y1    y2
        # 3d: Ax.plot([w[2],w[5]],[w[4],w[7]],[w[3],w[6]],color)
        Ax.plot([w[4],w[7]],[w[3],w[6]],color)
      #endfor
    #endfor

  else:

    if not modus == 'same':
      null3d(xmin-dx,xmax+dx,zmin-dx,zmax+dz,ymin-dy,ymax+dy)
      Xmin = xmin - dx
      Xmax = xmax + dx
      Ymin = ymin - dy
      Ymax = ymax + dy
      Zmin = zmin - dz
      Zmax = zmax + dz
      txyz(coiltit,"x/mm","z/mm","y/mm")
    #endif

    icoil = -1

    for coil in Filaments:
      icoil += 1
      if item > -1 and icoil != item: continue
      color = UnduColors[coil[0][8]]
      for w in coil:
        #         x1    x2    z1   z2     y1    y2
        Ax.plot([w[2],w[5]],[w[4],w[7]],[w[3],w[6]],color)
      #endfor
    #endfor

  #endif modus

+self,if=trace.
  print(NL,"trace:: Leaving _ucoilplot")
+self.

  return [xmin,xmax,ymin,ymax,zmin,zmax,kallzero]

#enddef _ucoilplot(view='3d', modus='same')

def _h3d(h3d,sx,sy,sz):
  global Hull3D
  Hull3D = []
  for plan in h3d:
    pl = []
    for p in plan:
      xzy = [sx*p[0],sy*p[2],sz*p[1]]
      pl.append(xzy)
    #endfor p in plan
    Hull3D.append(pl)
  #endfor p in plan
#enddef _h3d(h3d,sx,sy,sz)

def plothull3dxzy(isame=0,facecolor='blue',alpha=0.5,edgecolor='black', ishow=1,modus='line'):
+seq,uguiglobind.

  h3d =deepcopy(Hull3D)

  if cIxSym == 'yes' and cIySym == 'yes' and cIzSym == 'yes':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,-1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,-1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,-1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,-1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,-1.,-1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
  elif cIxSym == 'no' and cIySym == 'yes' and cIzSym == 'yes':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,-1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
  elif cIxSym == 'yes' and cIySym == 'no' and cIzSym == 'yes':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,-1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,-1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
  elif cIxSym == 'yes' and cIySym == 'yes' and cIzSym == 'no':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,-1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,-1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
  elif cIxSym == 'no' and cIySym == 'no' and cIzSym == 'yes':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
  elif cIxSym == 'no' and cIySym == 'yes' and cIzSym == 'no':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
  elif cIxSym == 'yes' and cIySym == 'no' and cIzSym == 'no':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
    _h3d(h3d,-1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
  elif cIxSym == 'no' and cIySym == 'no' and cIzSym == 'no':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,modus)
  #endif cIxSym == 'yes' and cIySym == 'yes' and if cIzSym == 'yes'

#enddef plothull3dxzy(isame=0,facecolor='blue',alpha=0.5,edgecolor='black', ishow=1)

def _plotMag(imp,key='3dselected'):

  if imp>=0:
    cmag = MagPolsTot[imp][0][0]
    if not cmag in DictMagPolsSel: _selectMag(cmag)
  #endif

  #print('plotMag()?\n',imp,key,'\nDictMothsSel:\n',DictMothsSel,\
  #'\nDictMagPolsSel:\n',DictMagPolsSel)

  if len(DictMagPolsSel) == 0:
    wError(" Nothing selected! ")
    return
  #endif

  setisame(0)

  if key == '3d' or key == '3dselected':
    _showGeoPython(modus='3dselected',item=-4,callkey='plotMag')
  else:
    _showGeoPythonXYZ(modus=key,item=-2,callkey='plotMag')
  #endif

#enddef _plotMag(imp,key='3d'):


def _plotSingleMag(imp,key='xy',isame=0,nmodules=0,itrans=1):

  global MagPolsTot,WallListMags,Isame
  global Xmin,Xmax,Zmin,Zmax,Ymin,Ymax
  global Ntcyls

  mp = MagPolsTot[imp]
  cmag = MagPolsTot[imp][0][0]
  cmoth = MagPolsTot[imp][0][1]

  col = mp[5][5]

  if not col in DictUnduColors:
    kcol = int(calc_var(col))
    col = UnduColors[kcol]
  #endif col not in UnduColors

  points = []
  cen = mp[4]

  if isame <= 0:
    store_kdump_kpdf(); optdump(False); optpdf(False)
  #endif

  if isame == 0:
    ms = getmarkersize()
    setmarkersize(0)
  #endif

  xc = calc_var(cen[0])
  yc = calc_var(cen[1])
  zc = calc_var(cen[2])

  if mp[3].find('Block') > -1:

    corns = blockcorners(mp)

    if itrans != 0 and (cmoth in DictTransRotCop or cmag in DictTransRotCop):
      ctr = []
      for c in corns:
        trc = TransRot(cmag,cmoth,c[0],c[1],c[2])
        ctr.append(trc)
      #endfor
      corns = ctr
    #endif

    if key == 'xy':
      for c in corns: points.append([xc+c[0],yc+c[1]])
    elif key == 'xz':
      for c in corns: points.append([xc+c[0],zc+c[2]])
    elif key == 'zy':
      for c in corns: points.append([zc+c[2],yc+c[1]])
    #endif

    verts, iedges, edges, bounds = qhull2d(points)

  elif mp[3] == 'File' or mp[3] == 'Corners':

    for ic in range(len(mp[7])):

      c1 = xc + calc_var(mp[7][ic][0])
      c2 = yc + calc_var(mp[7][ic][1])
      c3 = zc + calc_var(mp[7][ic][2])

      if itrans != 0 and (cmoth in DictTransRotCop or cmag in DictTransRotCop):
        trc = TransRot(cmag,cmoth,c[0],c[1],c[2])
      else:
        trc = [c1,c2,c3]
      #endif
      if key == 'xy':
        pass
        #c1 = xc + calc_var(mp[7][ic][0])
        #c2 = yc + calc_var(mp[7][ic][1])
      elif key == 'xz':
        c2 = c3
      elif key == 'zy':
        c1 = c3
      #endif

      points.append([c1,c2])

    #endfor ic in range(len(mp[7]))

    verts, iedges, edges, bounds = qhull2d(points)

  elif mp[3] == 'Cylinder':
    ifound = 0
    for ntc in Ntcyls:
      if ntc[1][0][0] == cmag:

        imag = DictMagPolsTot[cmag]
        cen = MagPolsTot[imag][4]

        xc = calc_var(cen[0])
        yc = calc_var(cen[1])
        zc = calc_var(cen[2])

        cen = [xc,yc,zc]

        poly,bounds = cylinderpoly(ntc[2])
        verts = poly

        bounds = [1.e30,-1.e30,1.e30,-1.e30,1.e30,-1.e30]

        iedges = []
        edges = []

        for pgn in poly:

          n = len(pgn)

          for i in range(n):

            j = i + 1
            if j == n: j = 0

            q1 = pgn[i]
            p1 = [q1[0] + xc,q1[1] + yc,q1[2] + zc]
            q2 = pgn[j]
            p2 = [q2[0] + xc,q2[1] + yc,q2[2] + zc]

            if itrans != 0:
              if cmoth in DictTransRotCop or cmag in DictTransRotCop:
                p1 = TransRot(cmag,cmoth,p1[0],p1[1],p1[2])
                p2 = TransRot(cmag,cmoth,p2[0],p2[1],p2[2])
              #endif
            #endif

            if p1[0] < bounds[0]: bounds[0] = p1[0]
            if p2[0] < bounds[0]: bounds[0] = p2[0]
            if p1[0] > bounds[1]: bounds[1] = p1[0]
            if p2[0] > bounds[1]: bounds[1] = p2[0]
            if p1[1] < bounds[2]: bounds[2] = p1[1]
            if p2[1] < bounds[2]: bounds[2] = p2[1]
            if p1[1] > bounds[3]: bounds[3] = p1[1]
            if p2[1] > bounds[3]: bounds[3] = p2[1]
            if p1[2] < bounds[4]: bounds[4] = p1[2]
            if p2[2] < bounds[4]: bounds[4] = p2[2]
            if p1[2] > bounds[5]: bounds[5] = p1[2]
            if p2[2] > bounds[5]: bounds[5] = p2[2]

            if key == 'xy':
              edges.append([[p1[0],p1[1]],[p2[0],p2[1]]])
            elif key == 'xz':
              edges.append([[p1[0],p1[2]],[p2[0],p2[2]]])
            elif key == 'zy':
              edges.append([[p1[2],p1[1]],[p2[2],p2[1]]])
            #endif
            iedges.append([i,j])
          #endfor pgn
        #endfor poly
        break
      #endif cmag
    #endfor Ntcyls

    if key == 'xy':
      pass
    elif key == 'xz':
      bounds[2]= bounds[4]
      bounds[3]= bounds[5]
    elif key == 'zy':
      bounds[0]= bounds[4]
      bounds[1]= bounds[5]
    #endif

  else:
    print('\n*** ', mp[3], 'noch in  _plotSingleMag einfuegen\n')
  #endif type of magnet

  edges = np.array(edges)

  if nmodules <= 0 or itrans == 0:
    for ed in edges:
      et = ed.T
      plt.plot(et[0],et[1],c=col)
    #endfor

  else:

    for m in range(nmodules):

      nper,[tx,ty,tz],rm,ang = _module_to_shift_and_rot(m)

      xrmin = 1.e30
      xrmax = -1.e30
      yrmin = 1.e30
      yrmax = -1.e30
      zrmin = 1.e30
      zrmax = -1.e30

      for ed in edges:
        if ang != 0:
          edr = []
          for i in range(len(ed)):
            if key == 'xy':
              x = ed[i][0]
              y = ed[i][1]
              xr = r[0][0]*x + r[0][1]*y
              yr = r[1][0]*x + r[1][1]*y
              if xr < xrmin: xrmin = xr
              if xr > xrmax: xrmax = xr
              if yr < yrmin: yrmin = yr
              if yr > yrmax: yrmax = yr
            elif key == 'xz':
              x = ed[i][0]
              y = ed[i][2]
              xr = r[0][0]*x + r[0][2]*y
              yr = r[2][0]*x + r[2][2]*y
              if xr < xrmin: xrmin = xr
              if xr > xrmax: xrmax = xr
              if yr < zrmin: zrmin = yr
              if yr > zrmax: zrmax = yr
            #endif
            elif key == 'zy':
              x = ed[i][2]
              y = ed[i][1]
              xr = r[2][2]*x + r[2][1]*y
              yr = r[1][2]*x + r[2][1]*y
              if xr < zrmin: zrmin = xr
              if xr > zrmax: zrmax = xr
              if yr < yrmin: yrmin = yr
              if yr > yrmax: yrmax = yr
            #endif
            edr.append([xr,yr])
          #endfor
          edr = np.array(edr)
          bounds = [xrmin,xrmax,yrmin,yrmax]
        else:
          edr = np.array(edges)
        #endif
      #endfor edges

      for iper in range(nper):

        ett = []
        for e in edr:
          et = e.T
          ett.append(et)
        #endfor

        for e in ett:
          e[0] += iper * tx
          e[1] += iper * ty
          plt.plot(e[0],e[1],c=col)
        #endfor

      #endfor nper

      if nper > 1:
        if key == 'xy':
          tx = (nper-1) * tx
          ty = (nper-1) * ty
        elif key == 'xz':
          tx = (nper-1) * tx
          ty = (nper-1) * tz
        elif key == 'zy':
          tx = (nper-1) * tz
          ty = (nper-1) * ty
        #endif
        if tx > 0: bounds[1] += tx
        else: bounds[0] -= tx
        if ty > 0: bounds[3] += ty
        else: bounds[2] -= ty
      #endif

    #endfor nmodules

  #endif

  return bounds

#enddef _plotSingleMag(imp)

def _showGeo(modus='3d',item=-1,kseg=0,callkey=''):
+self,if=trace.
  print(NL,"trace:: _showGeo:",modus,item,kseg,callkey)
+self.
  if modus == 'undu3d' or modus == 'eps':
    _showGeoUndu(modus,item,1,callkey='showGeo')
  else:
    _showGeoPython(modus,item,callkey='showGeo')
+self,if=trace.
    print(NL,"trace:: Leaving _showGeo")
+self.
#enddef _showGeo(modus='3d',item=-1,kseg=0)

def _module_to_shift_and_rot(imodu):
  global Modules

  mo = Modules[imodu]

  lcen = mo[0]

  w = lcen.split()

  offx = calc_var(w[0])
  offy = calc_var(w[1])
  offz = calc_var(w[2])

  nper = calc_var(mo[1])
  s = mo[2].split()

  perlen = calc_var(s[0])

  vspace = [calc_var(s[1]),calc_var(s[2]),calc_var(s[3])]
  ang = calc_var(s[4])

  cen = [0.0,0.0,0.0]
  vin = [1.0,0.0,0.0]
  istat, vdum, rm = util_rotate(cen,vspace,ang,vin)

  rot11 = rm[0][0]; rot12 = rm[0][1]; rot13 = rm[0][2]
  rot21 = rm[1][0]; rot22 = rm[1][1]; rot23 = rm[1][2]
  rot31 = rm[2][0]; rot32 = rm[2][1]; rot33 = rm[2][2]

  tx = vspace[0] * perlen
  ty = vspace[1] * perlen
  tz = vspace[2] * perlen

  w = mo[3].split()

  bsx = calc_var(w[0])
  bsy = calc_var(w[1])
  bsz = calc_var(w[2])

  return nper,[tx,ty,tz],rm,ang
#enddef _module_to_shift_and_rot(imodu)

def _showGeoPython(modus='3d',item=-1,callkey=''):

+seq,uguiglobind.
+seq,UnduColorsind.

+self,if=trace,debugsgp.
  print(NL,"trace:: _showGeoPython:",modus,item,callkey)
+self.

  isameo = getisame()

  if not isameo: zone(1,1)

  if NMagPolTot == 0 and len(Filaments) == 0:
    print("Nothing to plot!")
+self,if=trace,debugsgp.
    print(NL,"trace:: Leaving _showGeoPython")
+self.
    return
  #endif NMagPolTot == 0

  xplmin = 1.e30
  xplmax = -1.e30
  yplmin = 1.e30
  yplmax = -1.e30
  zplmin = 1.e30
  zplmax = -1.e30

  xyzcoils = []

  if not NMagPolTot:
    xyzcoils = _ucoilplot('3d','notsame',callkey='ShowGeoPython')
+self,if=trace,debugsgp.
    print(NL,"trace:: Leaving _showGeoPython after _ucoilplot(...)")
+self.
  #endif not NMagPolTot

+self,if=trace,debugsgp.
  print(NL,"trace:: showGeoPython")
  imp = 0
  for mp in MagPolsTot:
    imp += 1
    print(imp,mp[0:4])
  #endfor
+self.

  if item == -4 and len(DictMagPolsSel) == 0:
    wError(" Nothing selected! ")
    return
  #endif

  plopt = ''

  Kpdf = False
  Kdump = False
  Kecho = False

  dot()
  getzone('3d')

  null3d(Xmin,Xmax,Zmin,Zmax,Ymin,Ymax)
  setisame(1)

  if len(Filaments) and modus == '3d':
    xyzcoils = _ucoilplot(callkey='ShowGeoPython')

  if item == -3: nmodul = 1
  else: nmodul = Nmodul

  for mm in range(nmodul):

    nper,[tx,ty,tz],rm,ang = _module_to_shift_and_rot(mm)

    if item == -3: nper = 1

    rot11 = rm[0][0]; rot12 = rm[0][1]; rot13 = rm[0][2]
    rot21 = rm[1][0]; rot22 = rm[1][1]; rot23 = rm[1][2]
    rot31 = rm[2][0]; rot32 = rm[2][1]; rot33 = rm[2][2]

    w = Modules[mm][3].split()
    bsx = calc_var(w[0])
    bsy = calc_var(w[1])
    bsz = calc_var(w[2])

    nmp = NMagPolTot

    if item == -4:
      nmp = NMagPolSel
    #endif

+self,if=trace,debugsgp.
    print(NL,"trace:: showGeoPython:nmp",nmp)
+self.
    for imp in range(nmp):

      if item == -4:
        cmag = MagPolsSel[imp]
        imag = DictMagPolsTot[cmag]
        mp = MagPolsTot[imag]
        #print(mp)
      else:
        mp = MagPolsTot[imp]
      #endif

      sspec = str(mp[2])

+self,if=trace,debugsgp.
      try: print(NL,"imag,cmag,mp",imag,cmag,NL,mp)
      except: pass
      print(mp)
+self.
      if sspec == '1' or sspec == 'yes': ispec=1
      else: ispec = 0

      if item == -2 and ispec !=0: continue # skip specials
      if item == -3 and ispec ==0: continue # only specials

      cmag = mp[0][0]
      cmoth = mp[0][1]

      col = mp[5][5]

      if not col in DictUnduColors:
        kcol = int(calc_var(col))
        col = UnduColors[kcol]
      #endif col not in UnduColors

      points = []
      iscyl = 0

      cen = mp[4]

      xc = calc_var(cen[0])
      yc = calc_var(cen[1])
      zc = calc_var(cen[2])

      if mp[3].find('Block') > -1:

        corns = blockcorners(mp)
+self,if=debugsgp.
        print("corns:",NL,corns)
+self.
        for corn in corns:

          xx = corn[0]; yy = corn[1]; zz = corn[2]

          if callkey != 'plotMag':
            if cmoth in DictTransRotCop or cmag in DictTransRotCop:
              t = TransRot(cmag,cmoth,xx,yy,zz)
              xx = t[0]
              yy = t[1]
              zz = t[2]
              #print("t:",cmag,yy,t[2])
            #endif
            x = xc + rot11*xx + rot12*yy + rot13*zz
            y = yc + rot21*xx + rot22*yy + rot23*zz
            z = zc + rot31*xx + rot32*yy + rot33*zz
          else:
            x = xx + xc
            y = yy + yc
            z = zz + zc
          #endif

          points.append([x,y,z])

        #endfor corn in corns

      elif mp[3] == 'File' or mp[3] == 'Corners':

        for ic in range(len(mp[7])):

          xx = calc_var(mp[7][ic][0])
          yy = calc_var(mp[7][ic][1])
          zz = calc_var(mp[7][ic][2])

          if callkey != 'plotMag':
            if cmoth in DictTransRotCop or cmag in DictTransRotCop:
              t = TransRot(cmag,cmoth,c1,c2,c3)
              xx = t[0]
              yy = t[1]
              zz = t[2]
            #endif
            x = xc + rot11*xx + rot12*yy + rot13*zz
            y = yc + rot21*xx + rot22*yy + rot23*zz
            z = zc + rot31*xx + rot32*yy + rot33*zz
          else:
            x = xx + xc
            y = yy + yc
            z = zz + zc
          #endif

          points.append([x,y,z])

        #endfor ic in range(len(mp[7]))

      elif mp[3] == 'Cylinder':
        iscyl = 1
      else:
        Quit("_showGeoPython: " + mp[3] + " hier einfügen")
      #endif mp[3] == 'Block'

      #dtx = -tx; dty = -ty; dtz = -tz
      dtx = 0.; dty = 0.; dtz = 0.

      mper = nper

      for iper in range(mper):

        if not iscyl:

          pp = []

          for p in points:
            pp.append([p[0]+dtx,p[1]+dty,p[2]+dtz])
          #endfor p in points
+self,if=debugsgp.
          print("pp:",NL,pp)
+self.
          verts,ifaces,faces,bounds = hull3d(pp)
          plothull3dxzy(isame=1,edgecolor=col,ishow=0,modus='line')

          if bounds[0] < xplmin: xplmin = bounds[0]
          if bounds[1] > xplmax: xplmax = bounds[1]
          if bounds[2] < yplmin: yplmin = bounds[2]
          if bounds[3] > yplmax: yplmax = bounds[3]
          if bounds[4] < zplmin: zplmin = bounds[4]
          if bounds[5] > zplmax: zplmax = bounds[5]

        else: #iscyl

          for ntc in Ntcyls:
            if ntc[1][0][0] == cmag:

              poly,bounds = cylinderpoly(ntc[2])

              for pgn in poly:

                pp = []

                for poi in pgn:

                  p = [poi[0] + xc,poi[1] + yc,poi[2] + zc]

                  if callkey != 'plotMag':
                    if cmoth in DictTransRotCop or cmag in DictTransRotCop:
                      p = TransRot(cmag,cmoth,p[0],p[1],p[2])
                    #endif
                    if ang != 0:
                      x = rot11*p[0] + rot12*p[1] + rot13*p[3] + dtx
                      y = rot21*p[0] + rot22*p[1] + rot23*p[3] + dty
                      z = rot31*p[0] + rot32*p[1] + rot33*p[3] + dtz
                    else:
                      x = p[0] + dtx
                      y = p[1] + dty
                      z = p[2] + dtz
                    #endif
                  else:
                    x = p[0]
                    y = p[1]
                    z = p[2]
                  #endif

                  if x < xplmin: xplmin = x
                  if x > xplmax: xplmax = x
                  if y < yplmin: yplmin = y
                  if y > yplmax: yplmax = y
                  if z < zplmin: zplmin = z
                  if z > zplmax: zplmax = z

                  pp.append([x,y,z])

                #endfor

                pt = np.array(pp).T
                vplxyz(pt[0],pt[2],pt[1],'samelineclosed',color=col)

              #endfor
              break
            #endif
          #endfor

        #endif iscyl

        if ispec != 0: break
        dtx += tx; dty += ty; dtz += tz

      #endfor iper in range(1,nper+1):

    #endfor mag in range(nmag)

    if ispec != 0: break
  #endfor mm in range(Nmodul)

  if len(xyzcoils) and xyzcoils[6] == 0:
    xplmin = min(xplmin,xyzcoils[0])
    xplmax = max(xplmax,xyzcoils[1])
    yplmin = min(yplmin,xyzcoils[2])
    yplmax = max(yplmax,xyzcoils[3])
    zplmin = min(zplmin,xyzcoils[4])
    zplmax = max(zplmax,xyzcoils[5])
  #endif

  dx = (xplmax - xplmin) * 0.05
  dy = (yplmax - yplmin) * 0.05
  dz = (zplmax - zplmin) * 0.05

  ax = plt.gca()

  ax.set_xlim(xplmin-dx,xplmax+dx)
  ax.set_zlim(yplmin-dy,yplmax+dy)
  ax.set_ylim(zplmin-dz,zplmax+dz)

  txyz(Ucomment,"x [mm]","z [mm]","y [mm]")

  setisame(isameo)

+self,if=trace,debugsgp.
  print(NL,"trace:: Leaving _showGeoPython:")
+self.
#enddef _showGeoPython(modus='3d',item=-1)

def _showGeoPythonXYZ(modus='xy',item=-1,callkey=''):

+seq,uguiglobind.
+seq,UnduColorsind.

+self,if=trace,debugsgp.
  print(NL,"trace:: _showGeoPythonXYZ:",modus,item,callkey)
+self.

  isameo = getisame()

  if not isameo: zone(1,1)

  if NMagPolTot == 0 and len(Filaments) == 0:
    print("Nothing to plot!")
+self,if=trace,debugsgp.
    print(NL,"trace:: Leaving _showGeoPythonXYZ")
+self.
    return
  #endif NMagPolTot == 0

  isameo = getisame()

  xplmin = 1.e30
  xplmax = -1.e30
  yplmin = 1.e30
  yplmax = -1.e30
  zplmin = 1.e30
  zplmax = -1.e30

  if not NMagPolTot:
    _ucoilplot(modus,'notsame',callkey='ShowGeoPythonXYZ')
+self,if=trace,debugsgp.
    print(NL,"trace:: Leaving _showGeoPythonXYZ after _ucoilplot(...)")
+self.
  #endif not NMagPolTot

+self,if=trace,debugsgp.
  print(NL,"trace:: showGeoPythonXYZ")
  imp = 0
  for mp in MagPolsTot:
    imp += 1
    print(imp,mp[0:4])
  #endfor
+self.

  dot()
  getzone()

  plopt = ''

  Kpdf = False
  Kdump = False
  Kecho = False

  kgo = getgrid()
  if kgo: optgrid()
  setishow(0)

  xplmin = 1.e30
  xplmax = -1.e30
  yplmin = 1.e30
  yplmax = -1.e30

  null()

  itrans = 1
  if callkey == 'plotMag': itrans = 0

  if item == -4: # specials

    for imag in range(NMagPolTot):
      if MagPolsTot[imag][2] == 0: continue
      bounds = _plotSingleMag(imag,modus,1,0,itrans)
      if bounds[0] < xplmin: xplmin = bounds[0]
      if bounds[1] > xplmax: xplmax = bounds[1]
      if bounds[2] < yplmin: yplmin = bounds[2]
      if bounds[3] > yplmax: yplmax = bounds[3]
    #endfor

  elif item == -2: #selected

    for cmag in MagPolsSel:
      imag = DictMagPolsTot[cmag]
      bounds = _plotSingleMag(imag,modus,1,Nmodul,itrans)
      if bounds[0] < xplmin: xplmin = bounds[0]
      if bounds[1] > xplmax: xplmax = bounds[1]
      if bounds[2] < yplmin: yplmin = bounds[2]
      if bounds[3] > yplmax: yplmax = bounds[3]
    #endfor

  elif item == -3: # periodic

    for imag in range(NMagPolTot):
      if MagPolsTot[imag][2] == 1: continue
      bounds = _plotSingleMag(imag,modus,1,Nmodul,itrans)
      if bounds[0] < xplmin: xplmin = bounds[0]
      if bounds[1] > xplmax: xplmax = bounds[1]
      if bounds[2] < yplmin: yplmin = bounds[2]
      if bounds[3] > yplmax: yplmax = bounds[3]
    #endfor

  else: # all

    for imag in range(NMagPolTot):
      if MagPolsTot[imag][2] == 0: itrans = 1
      else: itrans = 0
      bounds = _plotSingleMag(imag,modus,1,Nmodul,itrans)
      if bounds[0] < xplmin: xplmin = bounds[0]
      if bounds[1] > xplmax: xplmax = bounds[1]
      if bounds[2] < yplmin: yplmin = bounds[2]
      if bounds[3] > yplmax: yplmax = bounds[3]
    #endfor

    if len(Filaments):
      xyzcoils = _ucoilplot(modus,callkey='ShowGeoPythonXYZ')
      #print(xyzcoils)
      if xyzcoils[6] == 0:
        if modus == 'xy':
          xplmin = min(xplmin,xyzcoils[0])
          xplmax = max(xplmax,xyzcoils[1])
          yplmin = min(yplmin,xyzcoils[2])
          yplmax = max(yplmax,xyzcoils[3])
        elif modus == 'xz':
          xplmin = min(xplmin,xyzcoils[0])
          xplmax = max(xplmax,xyzcoils[1])
          yplmin = min(yplmin,xyzcoils[4])
          yplmax = max(yplmax,xyzcoils[5])
        elif modus == 'zy':
          xplmin = min(xplmin,xyzcoils[4])
          xplmax = max(xplmax,xyzcoils[5])
          yplmin = min(yplmin,xyzcoils[2])
          yplmax = max(yplmax,xyzcoils[3])
        #endif
      #endif

  #endif item

  dx = (xplmax - xplmin) * 0.05
  dy = (yplmax - yplmin) * 0.05

  ax = plt.gca()

  ax.set_xlim(xplmin-dx,xplmax+dx)
  ax.set_ylim(yplmin-dy,yplmax+dy)

  setishow(1)

  if modus == 'xy':
    txyz(Ucomment,"x [mm]","y [mm]")
  elif modus == 'xz':
    txyz(Ucomment,"x [mm]","z [mm]")
  elif modus == 'zy':
    txyz(Ucomment,"z [mm]","y [mm]")
  #endif

  if not NMagPolTot:
    _ucoilplot(modus,'notsame',callkey='ShowGeoPythonXYZ')
+self,if=trace,debugsgp.
    print(NL,"trace:: Leaving _showGeoPythonXYZ after _ucoilplot(...)")
+self.
  #endif not NMagPolTot

+self,if=trace,debugsgp.
  print(NL,"trace:: Leaving _showGeoPythonXYZ")
+self.

  setisame(isameo)

#enddef _showGeoPythonXYZ(modus='3d',item=-1)

def _showGeoUndu(modus='3d',item=-1,kseg=0,callkey=''):
+seq,uguiglobind.
+seq,UnduColorsind.

  global MainFacets

  isameo = get_isame()
  print("_showGeoUndu:",modus,item,kseg,callkey)
  print("_showGeoUndu:MustUpdate:",MustUpdate)

  Rmodus = 'SEGMENTATION STDOUT=undumag.lun6'

  if NMagPolTot == 0:
    print("Nothing to plot!")
    return
  #endif NMagPolTot == 0

  if MustUpdate:
+self,if=debpy.
    Quit("*** _undumag in showgeo wegen MustUpdate ***")
+self.

    _undumag("showGeoUndu")  #run undumag

#    if nexist("Ngeo"): Ngeo = ndelete("Ngeo")
#    if fexist('undumag.geo'):
#      Ngeo = ncread("Ngeo","mag:ityp:xc:yc:zc:moth:ix:iy:iz:mat:icol:mx:my:mz:bc:iplan:icorn:x:y:z:cmag:cmoth","undumag.geo")
    MustUpdate = 0

  #endif MustUpdate

  if modus == 'undu3d':

    if item < 0:

      read_facets_bounding_box()

      if fexist('undumag_main_facets.fct'):
        tclc = os.stat('undumag.clc').st_mtime_ns
        tgeo = os.stat('undumag_main_facets.fct').st_mtime_ns
        if tclc > tgeo:
          print("undumag_main_facets.fct is older than undumag.clc!")
        #endif
        print('\n--> Reading undumag_main_facets.fct')
        mfaces,mvoxels = read_main_faces('undumag_main_facets.fct','xzy')
        MainFacets = [mfaces,mvoxels]
        print('\n--> Done')
      else:
        wError("File undumag_main_facets not found!")
        return
      #endif

      if fexist('undumag_facets.fct'):
        tclc = os.stat('undumag.clc').st_mtime_ns
        tgeo = os.stat('undumag_facets.fct').st_mtime_ns
        if tclc > tgeo:
          print("undumag_facets.fct is older than undumag.clc!")
        #endif
        print('\n--> Reading undumag_facets.fct')
        faces,voxels = read_faces('undumag_facets.fct','xzy')
        Facets = [faces,voxels]
        print('\n--> Done')
      else:
        wError("File undumag_facets.fct not found!")
        return
      #endif

      plopt = ''

      Kpdf = False
      Kdump = False
      Kecho = False

      dot()
      getzone('3d')

      facets = Facets[0]
      voxels = Facets[1]

      dx = (Xmax - Xmin) / 10.
      dy = (Ymax - Ymin) / 10.
      dz = (Zmax - Zmin) / 10.

      #null3d(xmin-dx,xmax+dx,zmin-dz,zmax+dz,ymin-dy,ymax+dy)

      null3d(Xmin-dx,Xmax+dx,Zmin-dz,Zmax+dz,Ymin-dy,Ymax+dy)
      txyz(Ucomment,"x [mm]","z [mm]", "y [mm]")

      ax = plt.gca()
      iface = -1
#      for v in voxels:
#        nfacets = int(v[0])
#        fcol = int(v[1])
#        edcol = int(v[2])
#        fvox = []
#        for i in range(nfacets):
#          iface += 1
#          fvox.append(faces[iface])
#        #endfor
#        fpl = mplot3d.art3d.Poly3DCollection(fvox)
#        ax.add_collection3d(fpl)
      #endfor

      nfacets = len(facets)

      fcols = []
      for v in voxels:
        if not v[1] in fcols: fcols.append(v[1])
      #endfor

      for col in fcols:
        fcolcol = []
        for i in range(nfacets):
          if voxels[i][1] == col:
            fcolcol.append(facets[i])
#            print(facets[i])
          #endif
        #endfor

        fpl = mplot3d.art3d.Poly3DCollection(fcolcol)
        fpl.set_color(UnduColors[int(col)])
        fpl.set_edgecolor('black')
        ax.add_collection3d(fpl)

      #endfor

    #endif item < 0

  if modus == 'undu3dvgeo':

    if item < 0:

      if fexist('undumag_voxels.geo'):
        tclc = os.stat('undumag.clc').st_mtime_ns
        tgeo = os.stat('undumag_voxels.geo').st_mtime_ns
        if tclc > tgeo:
          print("undumag_voxels.geo is older than undumag.clc!")
        #endif
        print('\n--> Reading undumag_voxels.geo')
        Nvox = ncread("Nvox","mag:ivox:ix:iy:iz:iplan:icorn:x:y:z:xc:yc:zc:vol:icol","undumag_voxels.geo")
        print('\n--> Done')
      else:
        wError("File undumag_voxels.geo not found!")
        return
      #endif

      plopt = ''

      Kpdf = False
      Kdump = False
      Kecho = False

      dot()
      getzone('3d')
      #nplot("Nvox","x:z:y","mag<10")
      nmag = int(Nvox.mag.max())

#      xmin = Nvox.x.min()
#      xmax = Nvox.x.max()
#      ymin = Nvox.y.min()
#      ymax = Nvox.y.max()
#      zmin = Nvox.z.min()
#      zmax = Nvox.z.max()

#      dx = (xmax - xmin) / 10.
#      dy = (ymax - ymin) / 10.
#      dz = (zmax - zmin) / 10.

      #null3d(xmin-dx,xmax+dx,zmin-dz,zmax+dz,ymin-dy,ymax+dy)
      null3d(Xmin,Xmax,Zmin,Zmax,Ymin,Ymax)
      txyz(Ucomment,"x [mm]","z [mm]", "y [mm]")

      for mag in range(nmag):
        selmag = 'mag==' + str(mag+1)
        kcol = Nvox.query(selmag + ' and iplan==1 and icorn==1').icol.max()
        col = UnduColors[kcol]
        mhull3d(Nvox,"x:z:y",selmag,edgecolor=col,isame=1)
      #endfor mag in range(nmag)
    #endif item < 0

  elif modus == 'undu3dngeo':

    if item < 0:

      if not nexist("Ngeo"):
        if fexist("undumag.geo"):
          tclc = os.stat('undumag.clc').st_mtime_ns
          tgeo = os.stat('undumag.geo').st_mtime_ns
          if tclc > tgeo:
            print("undumag.geo is older than undumag.clc!")
          #endif
          Ngeo = ncread("Ngeo","mag:ityp:xc:yc:zc:moth:ix:iy:iz:mat:icol:mx:my:mz:bc:iplan:icorn:x:y:z:cmag:cmoth","undumag.geo")
        #endif
      #endif

      plopt = ''

      Kpdf = False
      Kdump = False
      Kecho = False

      dot()
      getzone('3d')
      #nplot("Ngeo","x:z:y","mag<10")
      nmag = int(Ngeo.mag.max())

      xmin = Ngeo.x.min()
      xmax = Ngeo.x.max()
      ymin = Ngeo.y.min()
      ymax = Ngeo.y.max()
      zmin = Ngeo.z.min()
      zmax = Ngeo.z.max()

      dx = (xmax - xmin) / 10.
      dy = (ymax - ymin) / 10.
      dz = (zmax - zmin) / 10.

      #null3d(xmin-dx,xmax+dx,zmin-dz,zmax+dz,ymin-dy,ymax+dy)
      null3d(Xmin,Xmax,Zmin,Zmax,Ymin,Ymax)
      txyz(Ucomment,"x [mm]","z [mm]", "y [mm]")

      for mag in range(nmag):
        selmag = 'mag==' + str(mag+1)
        kcol = Ngeo.query(selmag + ' and iplan==1 and icorn==1').icol.max()
        col = UnduColors[kcol]
        mhull3d(Ngeo,"x:z:y",selmag,edgecolor=col,isame=1)
      #endfor mag in range(nmag)

    #endif item < 0

  elif modus == 'eps':
    eps = Image.open('undumag.eps')
    eps.show()
  #endif modus == '3d'

  Isame = isameo

+self,if=trace.
  print(NL,"trace:: Leaving _showGeoUndu",NL)
+self.

#enddef _showGeoUndu(modus)
+DECK,undumag_plot,T=PYTHON.
*CMZ :  2.05/01 22/10/2023  09.28.56  by  Michael Scheer
*CMZ :  2.03/00 22/08/2022  13.20.15  by  Michael Scheer
*CMZ :  2.02/01 18/01/2022  12.35.54  by  Michael Scheer
*CMZ :  2.02/00 25/03/2021  12.55.05  by  Michael Scheer
*CMZ :  2.01/08 09/08/2020  17.37.56  by  Michael Scheer
*CMZ :  2.01/05 05/03/2020  15.42.01  by  Michael Scheer
*-- Author : Michael Scheer
# +PATCH,//UNDUMAG/PYTHON
# +DECK,undumag_plot,T=C++.

global WavesMode
WavesMode = 'UNDUPLOT'

+seq,uguiimports.
+seq,uguiglobals.
+seq,undumagplotglobal.
+seq,showgeo.

MrunOld = -1
Nreload = 1
Kover = 0

global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil,ngeo
ntraj=-1;nbprof=-1;nmap=-1;nmapint=-1;nmapintf=-1;nmh=-1;nmat=-1;
nbyeff=-1;nbzeff=-1;ncoil=-1

WaveFilePrefix = 'undumag_'

#if not MShWelcome: undu_get_runnumber()

+seq,unduplgeo.

#aliases

uby = undu_nby
ubyz = undu_nbybz
ubybz = undu_nbybz
ubz = undu_nbz
ubyz = undu_nbybz
ubybz = undu_nbybz
utraj = undu_traj

ubyzeff = undu_nbybz_eff
ubybzeff = undu_nbybz_eff
ubyeff = undu_nbyeff
ubzeff = undu_nbzeff
+KEEP,undumagplot,T=PYTHON.
*CMZ :  2.05/01 23/10/2023  13.28.02  by  Michael Scheer
*CMZ :  2.04/14 04/09/2023  13.21.19  by  Michael Scheer
*CMZ :  2.04/06 19/05/2023  14.39.38  by  Michael Scheer
*CMZ :  2.04/00 12/01/2023  13.01.22  by  Michael Scheer
*CMZ :  2.03/00 01/09/2022  08.59.11  by  Michael Scheer
*CMZ :  2.02/02 03/03/2022  12.00.04  by  Michael Scheer
*CMZ :  2.02/01 14/04/2021  15.36.43  by  Michael Scheer
*CMZ :  2.02/00 25/03/2021  13.45.13  by  Michael Scheer
*CMZ :  2.01/08 09/08/2020  17.37.56  by  Michael Scheer
*CMZ :  2.01/05 05/03/2020  15.42.01  by  Michael Scheer
*-- Author : Michael Scheer

# +PATCH,//UNDUMAG/PYTHON
# +KEEP,undumagplot,T=PYTHON.

+seq,undureadbeff.

def check_run():
  global MrunOld, Nreload, Mrun
  undu_get_runnumber()
  if MrunOld == -1:
    MrunOld = Mrun
  else:
    if Mrun != MrunOld:
      window_clear()
      MrunOld = Mrun
  #endif
  if Nreload == 1: nreloadupl()
#enddef

def wError(errtxt='Fehler in undumag_plot.py'):
  print(errtxt)
#enddef

def undu_traj(varlis='x:z:y',sel="",plopt=''):
+seq,uguibeffglobind.
  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil,Kover,Kurad

  if not os.path.exists("urad_traxyz.dat"):
    Kurad = 0
    return
  #endif

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("ntraj"):
    vlis = 'x:y:z:t:vx:vy:vz:Bx:By:Bz:gamma:Ex:Ey:Ez'
    ntraj = ncread("ntraj",vlis,"urad_traxyz.dat")
  #endif not UnduTrajRead

  Kurad = 1

  ebeam = ntraj.gamma.max()*0.000511

  ms = getmarkersize()
  setmarkersize(1.0)

  nplot("ntraj",varlis,sel,"",plopt)

  if not re.search("same",plopt) and varlis == 'x:z:y':
    txyz("Trajectory for E = " + str("%g"%ebeam) + " GeV","x [mm]","z [mm]","y [mm]")

  setmarkersize(ms)
#enddef undu_traj(sel="",plopt='')

def undu_get_runnumber():

  global MrunOld, Nreload, Kover, Mrun,Mcomment,Mdate,Waveplot,Krun,ROFx,ROFy

  try:
    Frun = open("undumag.run",'r')
    srun = Frun.readline().strip()
    Frun.close()
    spl = srun.split(' ',1)
    Mrun = spl[0]
    spl = spl[1].strip().split()
    Mcomm = ""
    for i in range(len(spl)-2): Mcomm += ' ' + spl[i]
    Mcomment = ""
    for c in Mcomm:
      if ord(c) != 0: Mcomment += c
    #endfor
    #Mcomment.strip()
    Mdate = spl[-1] + " " + spl[-2]
  except:
    Mrun = '-9999'
    Mcomment = 'No file undumag.run found'
    Mdate = time.asctime(time.localtime(time.time()))
  #endtry

  Waveplot = 2

  Krun = True

  ROFx = 1.0-len(Mcomment)/100
  ROFx = 0.03
  ROFy = 0.95

#enddef undu_get_runnumber()

#if not MShWelcome: undu_get_runnumber()

def undu_nbybz_profile(sel="",plopt=''):

  global MrunOld, Nreload, Kover, Mrun
  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nbprof"):
    vlis = 'x:y:z:Bx:By:Bz'
    nbprof = ncread("nbprof",vlis,"undumag_field_profile.dat")
  else:
    nbprof = nget("nbprof")
  #endif not UnduMapRead

  if plopt == '':
    if len(nbprof) < 20:
      plopt = 'marker'
    else:
      plopt = 'line'
    #endif
  #endif

  plotopt(plopt)
  iline, imarker = Iline,Imarker

  if Iline:
    nplot("nbprof","z:By",sel,"",'line')
    lmblue()
    nplot("nbprof","z:Bz",sel,"",'sameline')
    lmred()
    if imarker:
      nplot("nbprof","z:By",sel,"",'samemarker')
      lmblue()
      nplot("nbprof","z:Bz",sel,"",'samemarker')
    #endif
    imarker = 0
   #endif

  lmred()
  if imarker:
    nplot("nbprof","z:By",sel,"",'marker')
    lmblue()
    nplot("nbprof","z:Bz",sel,"",'samemarker')
    if not Kover: plt.legend(['By','Bz'])
  #endif
  lmred()

  if not Kover: plt.legend(['By','Bz'])

  tit = "Field Profile"
  if sel != "": tit += ' ( ' + sel + ' )'
  txyz(tit,"z [mm]","B [T]")

#enddef undu_nbybz_profile()

def undu_read_guimode():
  global ngmod
  if not nexist("ngmod") and os.path.exists("undumag.gmd"):
    ngmod = ncread("ngmod","krun:gmod","undumag.gmd")
  #endif
#enddef

def undu_read_mat():

  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

+self,if=tracepl.
  print("tracepl::undu_read_mat: Entered")
+self.
  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nmat"):
    nmat = ncread("nmat","mat:mtyp:mkind:h:m:chi","undumag.mat")
  #endif

  if not nexist("nbr") and os.path.exists("undumag.brn"):
    fmh = open("undumag.brn","r")
    lines = fmh.readlines()
    fmh.close()
    if len(lines) > 1:
      nbr = ncread("nbr","mat:br","undumag.brn")
    #endif
  #endif

  if not nexist("nmh") and os.path.exists("undumag.mh"):
    fmh = open("undumag.mh","r")
    lines = fmh.readlines()
    fmh.close()
    if len(lines) > 1:
      nmh = ncread("nmh","mtyp:mmod:easyX:easyY:easyZ:h:m:mat:kbr","undumag.mh")
    #endif
  #endif

+self,if=tracepl.
  print("tracepl::undu_read_mat: Leaving")
+self.
#enddef

def undu_mat_mh(mat=12):
+self,if=tracepl.
  print("tracepl::undu_mat_mh: Entered")
+self.
  optnstat()
  undu_read_mat()

  mat1 = 1
  mat2 = 1

  if mat == 12:
    if nexist("nmh"):
      if nmh.mtyp.min() == 1 and nmh.mtyp.max() == 2:
        zone(3,1)
        mat1 = 1
        mat2 = 2
      #endif
    else:
      mat1 = 0
      mat2 = 0
    #endif
  elif mat == 1:
    mat1 = nexist("nmh")
    mat2 = 0
  elif mat == 2:
    mat1 = 0
    mat2 = nexist("nmh")
  #endif

+self,if=tracepl.
  print("tracepl::undu_mat_mh: mat1,mat2:",mat1,mat2)
+self.
  if mat1 == 0 and mat2 == 0:

    if mat == 1:

      if nexist("nmat"):

        n1 = nmat.query("mtyp==1")
        nmatmax = n1.mat.max()

        magmin = n1.m.min()
        magmax = n1.m.max()
        hmin = n1.h.min()
        hmax = n1.h.max()

        null(hmin,hmax,magmin,magmax)

        for i in range(nmatmax):
          sel = "mtyp==1 and mat==" + str(i+1)
          h1 = nmat.query(sel).h.min()
          h2 = nmat.query(sel).h.max()
          m1 = nmat.query(sel).m.min()
          m2 = nmat.query(sel).m.max()
          chi = (m2-m1) / (h2-h1)
          npllbs(nmat,"h:m",sel)
          dm = m2 - m1
          dh = (h2-h1)*0.8
          textWC(h1+dh,m1+dh*chi-dm*0.2,"$\mu_0$ = " + str(g3(chi+1.0)),8)
        #endfor

        txyz("Magnetisation along easy-axis","H [T]","$\mu_0$ M [T]")
      #endif

    elif mat == 2:
      pass
    #endif mat == 1

  elif mat1 == 1:

    if len(nmh.query("mtyp==1")):

      setmarkersize(2)

      hmn = nmh.query('mtyp==1').h.min()
      hmx = nmh.query('mtyp==1').h.max()
      dh = (hmx - hmn) / 20.
      if dh < 1.e-6: dh = 0.1
      hmn -= dh
      hmx += dh

      bcmn = nmh.query('mtyp==1').m.min()
      bcmx = nmh.query('mtyp==1').m.max()
      dh = (bcmx - bcmn) / 20.
      if dh < 1.e-6: dh = 0.1

      bcmn -= dh
      bcmx += dh

      null(hmn,hmx,bcmn,bcmx)

      nplmrs(nmh,"h:m","mtyp==1")

      if nexist("nbr"):
        vm,vbr = ncopv(nbr,"mat:abs(br)")
        lbr = len(vbr)
        for i in range(lbr):
          sel = "mat==" + str(vm[i])
          h1 = nmat.query(sel).h.min()
          h2 = nmat.query(sel).h.max()
          m1 = nmat.query(sel).m.min()
          m2 = nmat.query(sel).m.max()
          chi = (m2-m1) / (h2-h1)
          npllbs(nmat,"h:m",sel)
#          print(sel,h1,h2,m1,m2)
          dm = bcmx - bcmn
          dh = (hmx-hmn)*0.8
          textWC(hmn+dh,bcmn+dh*chi-dm*0.2,"$\mu_0$ = " + str(g3(chi+1.0)),8)
        #endfor
      #endif

      txyz("Magnetisation along easy-axis","H [T]","$\mu_0$ M [T]")

  #endif

  if mat2 == 2:

    if mat1: nextzone()

    hmn = max(nmh.query('mtyp==2 and mmod==3').h.min(),nmat.query('mtyp==2 and mkind==3').h.min())
    hmx = min(nmh.query('mtyp==2 and mmod==3').h.max(),nmat.query('mtyp==2 and mkind==3').h.max())

    setmarkersize(2)
    null(0.,0.005,0.,2.5)
    txyz("Magnetisation of Fe","H [T]","$\mu_0$ M [T]")

    nplot(nmh,"h:m","mtyp==2 and mmod==3 and h<0.005","","same")
    xint = vcre(1000,hmn,0.005)
    ninter(nmat,"h:m","mtyp==2 and mkind==3",xint)
    nplot(Ninter,"x:y","","","sameline",color='b')
    nextzone()

    hmx = nmh.query('mtyp==2 and mmod==3').h.max()
    null(0.,hmx*1.1,0.,2.5)
    txyz("Magnetisation of Fe","H [T]","$\mu_0$ M [T]")

    sel = "mtyp == 2 and mmod==3 and h <=" + str(hmx)
    nplot(nmh,"h:m",sel,"","same")
    xint = vcre(1000,hmn,hmx)
    sel = "mtyp == 2 and mkind==3 and h <=" + str(hmx)
    ninter(nmat,"h:m","mat==2",xint)
    nplot(Ninter,"x:y","","","sameline",color='b')

  #endif

+self,if=tracepl.
  print("tracepl::undu_mat_mh: Leaving")
+self.
#enddef undu_mat_mh(mat=12)

def undu_read_map():

  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nmap") and fexist("undumag.map"):
    fmap = open("undumag.map","r")
    icomm = 1
    ncomm = 0
    while icomm:
      cline = fmap.readline()
      if cline[0] != '*': icomm=0
      ncomm += 1
    #endwhile
    words = cline.split()
    if len(words) > 8:
      vlis = 'kmoth:kmag:mat:ityp:matmod:x:y:z:Bx:By:Bz:B:Hx:Hy:Hz:H:Mx:My:Mz:M:BxD:ByD:BzD:ifail:kfail:cmag:cmoth'
    else:
      vlis = 'x:y:z:Bx:By:Bz:ifail:kfail'
    #endif
    nmap = ncread("nmap",vlis,"undumag.map",skiphead=ncomm)
  #endif not UnduMapRead

  if not nexist("nmapint") and fexist("undumag_integral.map"):
    vlis = 'xi:xe:y:z:byint1:bzint1:byint2:bzint2'
    nmapint = ncread("nmapint",vlis,"undumag_integral.map")
  #endif not UnduMapRead

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nmapintinf"):
    vlis = 'y:z:byint1:bzint1:byint1dip:bzint1dip'
    nmapintinf = ncread("nmapintinf",vlis,"undumag_integrals_inf.map")
  #endif not UnduMapRead

#enddef undu_read_map()

def undu_nbybz_eff(sel="",plopt='line'):
+seq,uguibeffglobind.

  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil
  global Nhead

  undu_readbeff()

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nbyeff"):
    nbyeff = ncread("nbyeff","n:x:by:bz:ifail","undumag_byeff.dat")
  #endif

  if not nexist("nbzeff"):
    nbzeff = ncread("nbzeff","n:x:by:bz:ifail","undumag_bzeff.dat")
  #endif

  ksta = getstat()
  optnstat()

  nplot("nbyeff","x:by",sel,"",plopt)
  lmblue()
  nplot("nbzeff","x:bz",sel,"",plopt+"same")
  #if not Kover: plt.legend(['By', 'Bz'])

  if not Kover:
    text(0.7,0.9,"ByMax: "+ '{:.3g}'.format(Undu_ByMax) + " T",color='red',halign='left')
    text(0.7,0.82,"ByMin: "+ '{:.3g}'.format(Undu_ByMin) + " T",color='red',halign='left')
    text(0.7,0.7,"BzMax: "+ '{:.3g}'.format(Undu_BzMax) + " T",color='blue',halign='left')
    text(0.7,0.62,"BzMin: "+ '{:.3g}'.format(Undu_BzMin) + " T",color='blue',halign='left')
    text(0.60,0.26,"Beff: "+ '{:.3g}'.format(Undu_Beff) + " T",16,halign=LEFT)
    text(0.60,0.20,"Keff: "+ '{:.3g}'.format(Undu_Keff),16,halign=LEFT)
  else:
    text(0.3,0.9,"ByMax: "+ '{:.3g}'.format(Undu_ByMax) + " T",color='red',halign='left')
    text(0.3,0.82,"ByMin: "+ '{:.3g}'.format(Undu_ByMin) + " T",color='red',halign='left')
    text(0.3,0.7,"BzMax: "+ '{:.3g}'.format(Undu_BzMax) + " T",color='blue',halign='left')
    text(0.3,0.62,"BzMin: "+ '{:.3g}'.format(Undu_BzMin) + " T",color='blue',halign='left')
    text(0.65,0.26,"Beff: "+ '{:.3g}'.format(Undu_Beff) + " T",halign=LEFT)
    text(0.65,0.20,"Keff: "+ '{:.3g}'.format(Undu_Keff),halign=LEFT)
  #endif

#  nogrid()

  if not re.search("same",plopt): txyz("On-axis field for Beff","x [mm]","B [T]")
  lmred()

  optstat(ksta)
#enddef undu_nbybz_eff(sel="",plopt='line')

def undu_nbybz(sel="",plopt='line',lzone=0):
+seq,uguibeffglobind.

  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil,Kover

  if not Kover and lzone == 0:
    check_run()
    zone(1,1)
  #endif

  ksta = getstat()
  optnstat()

  if not nexist("nuon"):
    nuon = ncread("nuon","x:by:bz:byi:bzi:byii:bzii:ifail","undumag_on-axis.dat")
  #endif not Uonread

  nplot("nuon","x:by",sel,"",plopt)
  lmblue()
  nplot("nuon","x:bz",sel,"",plopt+"same")
  if not Kover: plt.legend(['By', 'Bz'])

  if not re.search("same",plopt): txyz("On-axis field","x [mm]","B [T]")
  lmred()

  optstat(ksta)

#enddef undu_nbybz(sel="",plopt='line')

def undu_nbybzInt1(sel="",plopt='line'):
+seq,uguibeffglobind.

  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  optnstat()

  if not nexist("nuon"):
    nuon = ncread("nuon","x:by:bz:byi:bzi:byii:bzii:ifail","undumag_on-axis.dat")
  #endif not Uonread

  undu_readbeff()

  nplot("nuon","x:byi",sel,"",plopt)
  lmblue()
  nplot("nuon","x:bzi",sel,"",plopt+"same")
  #if not Kover: plt.legend(['By_Int1', 'Bz_Int1'])

  if not Kover:
    text(0.6,0.9,"1. Integral of By: "+ '{:.3g}'.format(Undu_ByInt1) + " Tmm",color='red',halign='left')
    text(0.6,0.82,"1. Integral of Bz: "+ '{:.3g}'.format(Undu_BzInt1) + " Tmm",color='blue',halign='left')
  else:
    text(0.01,0.9,"1. Int. of By:\n"+ '{:.3g}'.format(Undu_ByInt1) + " Tmm",6,color='red',halign='left')
    text(0.01,0.7,"1. Int. of Bz:\n"+ '{:.3g}'.format(Undu_BzInt1) + " Tmm",6,color='blue',halign='left')
  #endif

  if not re.search("same",plopt): txyz("First integral of on-axis field","x [mm]","B_Int_1 [Tmm]")
  lmred()

#enddef undu_nbybzInt1(sel="",plopt='line')

def undu_nbybzInt2(sel="",plopt='line'):
+seq,uguibeffglobind.

  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nuon"):
    nuon = ncread("nuon","x:by:bz:byi:bzi:byii:bzii:ifail","undumag_on-axis.dat")
  #endif not Uonread

  undu_readbeff()

  nplot("nuon","x:byii",sel,"",plopt)
  lmblue()
  nplot("nuon","x:bzii",sel,"",plopt+"same")

  if not Kover:
    text(0.7,0.9,"2. Integral of By: "+ '{:.3g}'.format(Undu_ByInt2) + " Tmm$^{2}$",color='red')
    text(0.7,0.82,"2. Integral of Bz: "+ '{:.3g}'.format(Undu_BzInt2) + " Tmm$^{2}$",color='blue')
  else:
    text(0.01,0.9,"2. Int. of By:\n"+ '{:.3g}'.format(Undu_ByInt2) + " Tmm$^{2}$",6,color='red',halign='left')
    text(0.01,0.7,"2. Int. of Bz:\n"+ '{:.3g}'.format(Undu_BzInt2) + " Tmm$^{2}$",6,color='blue',halign='left')
  #endif

  if not re.search("same",plopt): txyz("Second integral of on-axis field","x [mm]","B_Int_2 [Tmm$^{2}$]")
  lmred()

#enddef undu_nbybzInt2(sel="",plopt='line')

def undu_nbzeff(sel="",plopt='line'):
+seq,uguibeffglobind.
  global Ubzeffread

  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nbzeff"):
    nbzeff = ncread("nbzeff","n:x:by:bz:ifail","undumag_bzeff.dat")
  #endif not Ubzeffread

  nplot("nbzeff","x:bz",sel,"",plopt)
  if not re.search("same",plopt): txyz("Field for BzEff","x[mm]","Bz[T]")
#enddef undu_nbz()

def undu_nbyeff(sel="",plopt='line'):
+seq,uguibeffglobind.

  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nbyeff"):
    nbyeff = ncread("nbyeff","n:x:by:bz:ifail","undumag_byeff.dat")
  #endif not Ubyeffread

  nplot("nbyeff","x:by",sel,"",plopt)
  if not re.search("same",plopt): txyz("Field for ByEff","x[mm]","By[T]")
#enddef undu_nbz()

def undu_nby(sel="",plopt='line'):
+seq,uguibeffglobind.
  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nuon"):
    nuon = ncread("nuon","x:by:bz:byi:bzi:byii:bzii:ifail","undumag_on-axis.dat")
  #endif not Uonread
  nplot("nuon","x:by",sel,"",plopt)
  if not re.search("same",plopt): txyz("On-axis field","x[mm]","By[T]")
#enddef undu_nbz()

def undu_nbyint1(sel="",plopt='line'):
+seq,uguibeffglobind.
  Quit("War mal falsch, noch nötig??")
  if not nexist("nuon"):
    window_clear()
    nuon = ncread("nuon","x:by:bz:byi:bzi:byii:bzii:ifail","undumag_on-axis.dat")
  #endif not Uonread
  nplot("nuon","x:byi",sel,"",plopt)
  if not re.search("same",plopt): txyz("On-axis field","x[mm]","By[T]")
#enddef undu_nbz()

def undu_nby(sel="",plopt='line'):
+seq,uguibeffglobind.
  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nuon"):
    nuon = ncread("nuon","x:by:bz:byi:bzi:byii:bzii:ifail","undumag_on-axis.dat")
  #endif not Uonread
  nplot("nuon","x:by",sel,"",plopt)
  if not re.search("same",plopt): txyz("On-axis field","x[mm]","By[T]")
#enddef undu_nby()

def undu_nbz(sel="",plopt='line'):
+seq,uguibeffglobind.
  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil

  if not Kover:
    check_run()
    zone(1,1)
  #endif

  if not nexist("nuon"):
    nuon = ncread("nuon","x:by:bz:byi:bzi:byii:bzii:ifail","undumag_on-axis.dat")
  #endif not Uonread
  nplot("nuon","x:bz",sel,"",plopt)
  if not re.search("same",plopt): txyz("On-axis field","x[mm]","Bz[T]")
  #endif not re.search("same",plopt)
#enddef undu_nby()

def undu_b():
+seq,argumentsind.
+seq,mhbglobind.

  global Uonread, Ubyeffread, Ubzeffread, UnduMapRead

  print("\n--- Begin of undu_b() ---\n")

  knew = 0
  check_run()

  if not nexist('nuon'):
    nuon = ncread("nuon","x:by:bz:byi:bzi:byii:bzii:ifail","undumag_on-axis.dat")
    knew = 1
  if not nexist('nbyeff'):
    nbyeff = ncread("nbyeff","n:x:by:bz:ifail","undumag_byeff.dat")
    knew = 1
  if not nexist('nbzeff'):
    nbzeff = ncread("nbzeff","n:x:by:bz:ifail","undumag_bzeff.dat")
    knew = 1

  if not nexist("nmap") and fexist("undumag.map"):
    fmap = open("undumag.map","r")
    icomm = 1
    ncomm = 0
    while icomm:
      cline = fmap.readline()
      if cline[0] != '*': icomm=0
      ncomm += 1
    #endwhile
    words = cline.split()
    if len(words) > 8:
      vlis = 'kmoth:kmag:mat:ityp:matmod:x:y:z:Bx:By:Bz:B:Hx:Hy:Hz:H:Mx:My:Mz:M:BxD:ByD:BzD:ifail:kfail:cmag:cmoth'
    else:
      vlis = 'x:y:z:Bx:By:Bz:ifail:kfail'
    #endif
    nmap = ncread("nmap",vlis,"undumag.map",skiphead=ncomm)
    knew = 1
  #endif

  Uonread = 1
  Ubyeffread = 1
  Ubzeffread = 1
  UnduMapRead = 1

  if knew: nlist()
  #nplot(nuon,"x:by")

  print("\n--- End of undu_b() ---\n")

#enddef undu_b():

def ndeleteupl(isilent=1):
  if Nntup > 0: print("\n --- Deleting old Ntuples\n")
  ndelete("Nvox",isilent)
  ndelete("ngeo",isilent)
  ndelete("nmap",isilent)
  ndelete("nmapint",isilent)
  ndelete("nmapintinf",isilent)
  ndelete("nbyeff",isilent)
  ndelete("nbzeff",isilent)
  ndelete("ncoil",isilent)
  ndelete("nbprof",isilent)
  ndelete("ntraj",isilent)
  ndelete("nuon",isilent)
  ndelete("nmat",isilent)
  ndelete("nmh",isilent)
#enddef ndeleteupl(isilent=0)

def nreloadupl():

  global Nreload,Nvox
  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil,ngeo

  ndeleteupl()

  # Attention: There is also an Ngeo in undugui.py
  if not nexist("ngeo"):
    if fexist("undumag.geo"):
      tclc = os.stat('undumag.clc').st_mtime_ns
      tgeo = os.stat('undumag.geo').st_mtime_ns
      if tclc > tgeo:
        print("undumag.geo is older than undumag.clc!")
      #endif
      ngeo = ncread("ngeo","mag:ityp:xc:yc:zc:moth:ix:iy:iz:mat:icol:mx:my:mz:bc:iplan:icorn:x:y:z:cmag:cmoth","undumag.geo")
    #endif
  #endif

  if fexist('undumag_voxels.geo'):
    tclc = os.stat('undumag.clc').st_mtime_ns
    tgeo = os.stat('undumag_voxels.geo').st_mtime_ns
    if tclc > tgeo:
      print("undumag_voxels.geo is older than undumag.clc!")
    #endif
    print('\n--> Reading undumag_voxels.geo')
    Nvox = ncread("Nvox","mag:ivox:ix:iy:iz:iplan:icorn:x:y:z:xc:yc:zc:vol:icol","undumag_voxels.geo")
    print('\n--> Done')
  #endif

  if fexist('urad_traxyz.dat'):
    vlis = 'x:y:z:t:vx:vy:vz:Bx:By:Bz:gamma:Ex:Ey:Ez'
    ntraj = ncread("ntraj",vlis,"urad_traxyz.dat")
  #endif

  if fexist('undumag_field_profile.dat'):

    vlis = 'x:y:z:Bx:By:Bz'
    nbprof = ncread("nbprof",vlis,"undumag_field_profile.dat")

  #endif

  if fexist('undumag_integral.map'):
    vlis = 'xi:xe:y:z:byint1:bzint1:byint2:bzint2'
    nmapint = ncread("nmapint",vlis,"undumag_integral.map")

  #endif

  if fexist('undumag_integrals_inf.map'):
    vlis = 'y:z:byint1:bzint1:byint1dip:bzint1dip'
    nmapintinf = ncread("nmapintinf",vlis,"undumag_integrals_inf.map")
  #endif

  if fexist('undumag.mat'):
    nmat = ncread("nmat","mat:mtyp:mkind:h:m:chi","undumag.mat")
  #endif

  if fexist('undumag.mh'):
    fmh = open('undumag.mh','r')
    mh = fmh.readlines()
    fmh.close()
    if len(mh) > 1:
      nmh = ncread("nmh","mtyp:mmod:easyX:easyY:easyZ:h:m:mat:kbr","undumag.mh")
    #endif
  #endif

  if not nexist("nbr") and os.path.exists("undumag.brn"):
    fmh = open("undumag.brn","r")
    lines = fmh.readlines()
    fmh.close()
    if len(lines) > 1:
      nbr = ncread("nbr","mat:br","undumag.brn")
    #endif
  #endif

  if fexist('undumag_on-axis.dat'):
    nuon = ncread("nuon","x:by:bz:byi:bzi:byii:bzii:ifail","undumag_on-axis.dat")

  if fexist('undumag_byeff.dat'):
    nbyeff = ncread("nbyeff","n:x:by:bz:ifail","undumag_byeff.dat")

  if fexist('undumag_bzeff.dat'):
    nbzeff = ncread("nbzeff","n:x:by:bz:ifail","undumag_byeff.dat")

  if fexist('undumag_byeff.fil'):
    ncoil = ncread("ncoil","itype:curr:x1:y1:z1:x2:y2:z2:icol:num:ncoil","undumag.fil")

  if fexist("undumag.map"):
    fmap = open("undumag.map","r")
    icomm = 1
    ncomm = 0
    while icomm:
      cline = fmap.readline()
      if cline[0] != '*': icomm=0
      ncomm += 1
    #endwhile
    words = cline.split()
    if len(words) > 8:
      vlis = 'kmoth:kmag:mat:ityp:matmod:x:y:z:Bx:By:Bz:B:Hx:Hy:Hz:H:Mx:My:Mz:M:BxD:ByD:BzD:ifail:kfail:cmag:cmoth'
    else:
      vlis = 'x:y:z:Bx:By:Bz:ifail:kfail'
    #endif
    nmap = ncread("nmap",vlis,"undumag.map",skiphead=ncomm)
  #endif

  nlist()
  print(NL,NL)

  Nreload = 0
#enddef

def undu_overview():

  global Kover, Kurad, Hybrid_Mode, AppleII_Mode
  global ntraj,nbprof,nmap,nmapint,nmapintf,nmh,nbr,nmat,nbyeff,nbzeff,ncoil,ngmod

  idebug = 0

  KdumpO = get_kdump()
  KpdfO = get_kpdf()
  KechoO = get_kecho()

  set_kdump(False)
  set_kpdf(False)
  set_kecho(False)

  Kover = 1
  window_clear()

  undu_read_guimode()
  undu_read_mat()

  iFe = 0
  if nexist('nmh') and  nmh.mtyp.max() == 2: iFe = 1

  ksta = getstat()
  optnstat()

  if idebug: print("ngmod.gmod.max():",ngmod.gmod.max())

  if ngmod.gmod.max() < 3:

    if iFe: zone(4,2)
    else: zone(3,2)

    undu_nbybz()
    nextzone()

    undu_nbybzInt1()
    nextzone()

    if iFe == 0:

      if os.path.exists("urad_traxyz.dat"):
        undu_traj()
        nextzone()
      else:
        Kurad = 0
        undu_nbybzInt2()
        nextzone()
      #endif

      undu_nbybz_eff()
      nextzone()

      undu_nbybz_profile()
      nextzone()

      undu_mat_mh(1)

    else:

      Kurad = 0

      undu_nbybzInt2()
      nextzone()

      undu_mat_mh(1)
      nextzone()

      undu_nbybz_eff()
      nextzone()

      undu_nbybz_profile()
      nextzone()

      hmn = max(nmh.query('mat==2').h.min(),nmat.query('mat==2').h.min())
      hmx = min(nmh.query('mat==2').h.max(),nmat.query('mat==2').h.max())

      setmarkersize(2)
      null(0.,0.005,0.,2.5)
      txyz("Magnetisation of Fe","H [T]","$\mu_0$ M [T]")

      nplot(nmh,"h:m","mat==2 and h<0.005","","same")
      xint = vcre(1000,hmn,0.005)
      ninter(nmat,"h:m","mat==2",xint)
      nplot(Ninter,"x:y","","","sameline",color='b')
      nextzone()

      null(0.,hmx*1.1,0.,2.5)
      txyz("Magnetisation of Fe","H [T]","$\mu_0$ M [T]")

      sel = "mat == 2 and h <=" + str(hmx)
      nplot(nmh,"h:m",sel,"","same")
      xint = vcre(1000,hmn,hmx)
      ninter(nmat,"h:m","mat==2",xint)
      nplot(Ninter,"x:y","","","sameline",color='b')

    #endif

  else: # Mirror

    zone(5,1)
    setleftmargin(0.06)
    setrightmargin(0.97)
    #setxspace(0.5)

    undu_nbybz_eff()
    nextzone()

    undu_nbybz_profile()
    nextzone()

    setmarkersize(2)

    if nexist("nmh"):
      nplot(nmh,"h:m","mtyp==1")
      hmn = max(nmh.query('mtyp==1').h.min(),nmat.query('mtyp==1').h.min())
      hmx = min(nmh.query('mtyp==1').h.max(),nmat.query('mtyp==1').h.max())
      sel = 'mat == 1 and h <= ' + str(hmx)
      xint = vcre(100,hmn,hmx)
      ninter(nmat,"h:m","mtyp==1",xint)
      sel = 'x <= ' + str(hmx)
      nplot(Ninter,"x:y","","","sameline",color='b')
      txyz("Magnetisation along easy-axis","H [T]","$\mu_0$ M [T]")
    else:
      nplot(nmat,"h:m","mtyp==1","","line",color='b')
      txyz("Magnetisation curve for easey axis","H [T]","$\mu_0$ M [T]")
    #endif

    nextzone()

    null(0.,0.005,0.,2.5)
    txyz("Magnetisation of Fe","H [T]","$\mu_0$ M [T]")

    if nexist("nmh"):
      nplot(nmh,"h:m","mat==2 and mmod!=0","","same")
    #endif

    #ninter(nmat,"h:m","mat==2 and h<0.005")
    ninter(nmat,"h:m","h<=0.005 and mat==2")
    vplxy(Ninter.x,Ninter.y,"sameline",color='b')
    nextzone()

    if nexist("nmh"):
      nstat(nmh,"h","mat==2 and mmod!=0",isilent=1)
      null(0.,Nmax*1.1,0.,2.5)
      nplot(nmh,"h:m","mat==2 and mmod!=0","","same")
      ninter(nmat,"h:m","mat==2")
      vplxy(Ninter.x,Ninter.y,"sameline",color='b')
    else:
      npllb(nmat,"h:m","mat==2")
    #endif
    txyz("Magnetisation of Fe","H [T]","$\mu_0$ M [T]")

  #endif

  set_kdump(KdumpO)
  set_kpdf(KpdfO)
  set_kecho(KechoO)

  undu_get_runnumber()

  if Krun == True: run_on_figure()

  pp("undumag_overview.pdf")

  Kover = 0

  optstat(ksta)

#enddef

def undu_plot_mag_magnetization(cnams='',msize=-9.):

  global MainFacets,Xmin,Xmax,Ymin,Ymax,Zmin,Zmax

  if msize < 0: msi = getmarkersize()
  else: msi = msize

  if nexist("nmap") == 0:
    if fexist("undumag.map"):
      undu_read_map()
    else:
      print("\n*** File undumag.map not found ***")
      return
    #endif
  #endif

  nmap = nget("nmap")
  #reakpoint()

  if len(MainFacets) == 0:
    try:
      faces,voxels = read_main_faces(fname='undumag_main_facets.fct',cs='xzy')
      MainFacets = [faces,voxels]
    except:
      print('*** Error reading file undumag_main_facets.fct ***')
      return
    #endtry
  #endif

  if len(cnams) == 0: cnams = ''

  if type(cnams) != list:
    if cnams == '':
      clist = []
      for v in voxels:
        cmag = v[5]
        cmoth = v[6]
        if not cmag in clist: clist.append(cmag)
      #endfor
    else:
      clist = [cnams]
    #endif
  else:
    clist = cnams
  #endif

  if len(clist) == 0:
    print("\n*** Nothing to plot ***")
    return
  #endif

  try:
    c = nmap.cmag[0]
  except:
    print("\n*** No magnets found in undumag.map, check undumag.nam and rerun UNDUMAG ***")
    return
  #endtry

  if len(FcBox) == 0:
    read_facets_bounding_box(fb='undumag_bounding_box.fct')
  #endif

  null3d(Xmin,Xmax,Zmin,Zmax,Ymin,Ymax)

  Xmin = 1.0e30
  Xmax = -1.0e30
  Ymin = 1.0e30
  Ymax = -1.0e30
  Zmin = 1.0e30
  Zmax = -1.0e30

  getzone('3d')
  ax = plt.gca()

  selli = []
  cnamo = ''

  for cnam in clist:

    plf = []

    if True:
      #try:

      facets = MainFacets[0]
      voxels = MainFacets[1]

      nfacets = len(facets)

      ifound = -1
      iv = -1
      for v in voxels:
        iv += 1
        kcol = UnduColors[int(v[1])]
        cmag = v[5]
        cmoth = v[6]
        if cmag == cnam or cmoth == cnam:
          ifound = iv
          break
      #endfor

      for i in range(nfacets):
        if voxels[i][5] == cnam or voxels[i][6] == cnam:
          ft = facets[i].T
          Xmin = min(Xmin,ft[0].min())
          Xmax = max(Xmax,ft[0].max())
          Ymin = min(Ymin,ft[2].min())
          Ymax = max(Ymax,ft[2].max())
          Zmin = min(Zmin,ft[1].min())
          Zmax = max(Zmax,ft[1].max())
          plf.append(facets[i])
        #endif
      #endfor

      #breakpoint()

      fpl = mplot3d.art3d.Poly3DCollection(plf)

      fpl.set_color(kcol)
      fpl.set_edgecolor(kcol)
      fpl.set_alpha(0.0)

      ax.add_collection3d(fpl)

      sel = "cmag == '" + cnam + "' or " + "cmoth == '" + cnam + "'"
      if cnamo != cnam: selli.append(sel)
      cnamo = cnam

      #except:
    else:
      print("\n*** Failed. Check undumag.nam and rerun UNDUMAG ***")
      return
    #endtry

  #endfor clist

  sel = selli[0]
  for i in range(1,len(selli)):
    sel += ' or ' + selli[i]
  #endfor

  mso = getmarkersize()
  setmarkersize(msi)
  npl(nmap,"x:z:y:M",sel,plopt='same')
  setmarkersize(mso)

  if len(plf) == 0:
    print("\n*** Nothing to plot, check item name or undumag.nam and rerun UNDUMAG ***")
    print("\nItems found:\n")
    return
  #endif

  dx = (Xmax - Xmin) / 10.
  dy = (Ymax - Ymin) / 10.
  dz = (Zmax - Zmin) / 10.

  if dx == 0: dx = 1
  if dy == 0: dy = 1
  if dz == 0: dz = 1

  ax.set_xlim(Xmin-dx,Xmax+dx)
  ax.set_ylim(Zmin-dz,Zmax+dy)
  ax.set_zlim(Ymin-dy,Ymax+dz)

  if len(clist) == 1:
    txyz(clist[0],"x [mm]","z [mm]", "y [mm]")
  else:
    txyz('',"x [mm]","z [mm]", "y [mm]")
  #endif

  showplot()

#enddef undu_plot_mag_magnetization():

def undu_plot_mag_3d(cnams='',alpha=1.0):

  global MainFacets,Facets,Xmin,Xmax,Ymin,Ymax,Zmin,Zmax

  if nexist("nmap") == 0:
    if fexist("undumag.map"):
      undu_read_map()
    else:
      print("\n*** File undumag.map not found ***")
      return
    #endif
  #endif

  nmap = nget("nmap")

  if len(MainFacets) == 0:
    try:
      mfaces,mvoxels = read_main_faces(fname='undumag_main_facets.fct',cs='xzy')
      MainFacets = [mfaces,mvoxels]
    except:
      print('*** Error reading file undumag_main_facets.fct ***')
      return
    #endtry
  #endif

  if len(Facets) == 0:
    try:
      faces,voxels = read_main_faces(fname='undumag_facets.fct',cs='xzy')
      Facets = [faces,voxels]
    except:
      print('*** Error reading file undumag_facets.fct ***')
      return
    #endtry
  #endif

  #reakpoint()

  if len(cnams) == 0: cnams = ''

  if type(cnams) != list:
    if cnams == '':
      clist = []
      for v in mvoxels:
        cmag = v[5]
        cmoth = v[6]
        if not cmag in clist: clist.append(cmag)
      #endfor
    else:
      clist = [cnams]
    #endif
  else:
    clist = cnams
  #endif

  if len(clist) == 0:
    print("\n*** Nothing to plot ***")
    return
  #endif

  try:
    c = nmap.cmag[0]
  except:
    print("\n*** No magnets found in undumag.map, check undumag.nam and rerun UNDUMAG ***")
    return
  #endtry

  if len(FcBox) == 0:
    read_facets_bounding_box(fb='undumag_bounding_box.fct')
  #endif

  null3d(Xmin,Xmax,Zmin,Zmax,Ymin,Ymax)

  Xmin = 1.0e30
  Xmax = -1.0e30
  Ymin = 1.0e30
  Ymax = -1.0e30
  Zmin = 1.0e30
  Zmax = -1.0e30

  getzone('3d')
  ax = plt.gca()

  selli = []
  cnamo = ''

  #reakpoint()
  for cnam in clist:

    plf = []

    if True:
      #try:

      facets = Facets[0]
      voxels = Facets[1]

      nfacets = len(facets)

      ifound = -1
      iv = -1
      for v in voxels:
        iv += 1
        kcol = UnduColors[int(v[1])]
        cmag = v[6]
        cmoth = v[7]
        if cmag == cnam or cmoth == cnam:
          ifound = iv
          break
      #endfor

      for i in range(nfacets):
        if voxels[i][6] == cnam or voxels[i][7] == cnam:
          ft = facets[i].T
          Xmin = min(Xmin,ft[0].min())
          Xmax = max(Xmax,ft[0].max())
          Ymin = min(Ymin,ft[2].min())
          Ymax = max(Ymax,ft[2].max())
          Zmin = min(Zmin,ft[1].min())
          Zmax = max(Zmax,ft[1].max())
          plf.append(facets[i])
        #endif
      #endfor

      #breakpoint()

      fpl = mplot3d.art3d.Poly3DCollection(plf)

      fpl.set_color(kcol)
      fpl.set_edgecolor('black')
      fpl.set_alpha(alpha)

      ax.add_collection3d(fpl)

      sel = "cmag == '" + cnam + "' or " + "cmoth == '" + cnam + "'"
      if cnamo != cnam: selli.append(sel)
      cnamo = cnam

      #except:
    else:
      print("\n*** Failed. Check undumag.nam and rerun UNDUMAG ***")
      return
    #endtry

  #endfor clist

  if len(plf) == 0:
    print("\n*** Nothing to plot, check item name or undumag.nam and rerun UNDUMAG ***")
    print("\nItems found:\n")
    return
  #endif

  dx = (Xmax - Xmin) / 10.
  dy = (Ymax - Ymin) / 10.
  dz = (Zmax - Zmin) / 10.

  if dx == 0: dx = 1
  if dy == 0: dy = 1
  if dz == 0: dz = 1

  ax.set_xlim(Xmin-dx,Xmax+dx)
  ax.set_ylim(Zmin-dz,Zmax+dy)
  ax.set_zlim(Ymin-dy,Ymax+dz)

  if len(clist) == 1:
    txyz(clist[0],"x [mm]","z [mm]", "y [mm]")
  else:
    txyz('',"x [mm]","z [mm]", "y [mm]")
  #endif

  showplot()

#enddef undu_plot_mag3d():

+DECK,undu_ipylogon,T=PYTHON.
*CMZ :  2.05/01 23/10/2023  14.04.41  by  Michael Scheer
*-- Author :    Michael Scheer   23/10/2023
# +PATCH,//UNDUMAG/PYTHON
# +DECK,undu_ipylogon,T=PYTHON.

print("--- undumag undu_ipylogon.py ---\n")

import sys
args=sys.argv
arg1 = args[1]
nargs = len(args)

import undumag_plot as u
from undumag_plot import *

optconsole()
set_console_title("unduPython")

ntuples = 1
global Nhead,Ntup,Nind,Nntup

if arg1 == "last":
  try:
    Farg = open("ipylogon.arg","r")
    argl = Farg.readlines()
    Farg.close()
    if len(argl):
      sys.argv = [sys.argv[0]]
      for arg in argl: sys.argv.append(arg.strip())
    #endif
  except: pass
#endif

args=sys.argv
arg1 = args[1]
nargs = len(args)

if not arg1 == "last" and nargs > 0:
  Farg = open("ipylogon.arg","w")
  for i in range(1,nargs): Farg.write(args[i] + "\n")
  Farg.close()
#endif

seed(0)

if nargs > 1:

    if arg1 == "none":
      pass
    elif arg1 == "default":
      pass

    elif arg1 == "load":

      read_facets_bounding_box()
      MainFacets = read_main_faces()
      faces,voxels = read_faces('undumag_facets.fct',cs='xzy')
      undu_read_map()
      undu_geo() # other arguments are evaluated in undu_geo

    elif arg1[:3] == "mag" or arg1 == 'M':

      select = []
      if nargs > 2:
        for ia in range(2,len(args)): select.append(args[ia])
      #endif

      undu_plot_mag_magnetization(select,msize=5.)

    elif arg1[:3] == "seg" or arg1 == "S":

        optconsole()
        set_console_title("unduPython")
        select = []
        if nargs > 2:
          for ia in range(2,len(args)): select.append(args[ia])
        #endif
        undu_plot_mag_3d(select,alpha=1.0)
        getconsole()

    elif arg1 == "onax":

        optconsole()
        set_console_title("unduPython")

        optnstat()

        undu_nbybz()

        nuon = nget('nuon')

        bymax = nuon.by.max()

#        if fexist("unduradia.map"):
#          nrmap = ncread("nrmap","x:y:z:bx:by:bz:b:hx:hy:hz:h:mx:my:mz:m","unduradia.map")
#          nplmls(nrmap,"y:bz")
#          nplmcs(nrmap,"y:bx")
#          bzmaxrad = nrmap.bz.max()
#          text(0.8,0.8,"RADIA <-> UNDUMAG BvMax:" + '\n'+ pg5(bzmaxrad/bymax-1))
#        #endif

    elif arg1 == "beff":

        optconsole()
        set_console_title("unduPython")
        undu_b()
        undu_nbybz_eff()

    elif arg1 == "geo":

        optconsole()
        set_console_title("unduPython")
        undu_geo() # other arguments are evaluated in undu_geo
        getconsole()

    elif arg1 == "map":

        optconsole()
        set_console_title("unduPython")

        undu_read_map()

        if not nexist("nmags"):
          nmags = ncread("nmags","imoth:mag:icol:iplan:icorn:x:y:z:bx:by:bz:imat:cmag:cmoth:ispole","undumag.mag")
        #endif

        if not nexist("nvox"):
          nvox = ncread("nvox","cnam:cmoth:icol:modu:kmag:lmag:ivox:icop:x:y:z:bxi:byi:bzi:bxe:bye:bze:ispole","undumag_voxel.lis")
        #endif

        ninfo("nmap")

        npl("nmap","x:By")
        txyz("","x/mm","By/T")

        getconsole()

    elif arg1 == "radia":

      if fexist("unduradia_mag.map"):
        nmag = ncread("nmag","x:y:z:bx:by:bz:b:hx:hy:hz:h:mx:my:mz:m","unduradia_mag.map")
      #endif

      if fexist("unduradia_pol.map"):
        npol = ncread("npol","x:y:z:bx:by:bz:b:hx:hy:hz:h:mx:my:mz:m","unduradia_pol.map")
      #endif

      if fexist("unduradia.map"):
        nrmap = ncread("nrmap","x:y:z:bx:by:bz:b:hx:hy:hz:h:mx:my:mz:m","unduradia.map")
      #endif

      #npl(nrmap,"y:bz")
      nlist()

      npl(nmag,"y:x:z")

    elif arg1 == "intmap":

        optconsole()
        set_console_title("unduPython")

        if not nexist("nmapint"):
          if fexist("undumag_integral.map"):
            vlis = 'xi:xe:y:z:byint1:bzint1:byint2:bzint2'
            nmapint = ncread("nmapint",vlis,"undumag_integral.map")
          #endif
        #endif

        if not nexist("nmapintinf"):
          vlis = 'y:z:byint1:bzint1:byint1dip:bzint1dip'
          nmapintinf = ncread("nmapintinf",vlis,"undumag_integrals_inf.map")
        #endif not UnduMapRead

        if not nexist("nmapintref"):
          vlis = 'y:z:byint1:bzint1:byint1dip:bzint1dip'
          Fref="undumag_integrals_inf.ref"
          if fexist(Fref):
            nmapintref = ncread("nmapintref",vlis,Fref)
          else:
            nmapintref = ncre("nmapintref","nmapintref",vlis)
          #endif
        #endif not UnduMapRead

        if not nexist("nmags"):
          nmags = ncread("nmags","imoth:mag:icol:iplan:icorn:x:y:z:bx:by:bz:imat:cmag:cmoth:ispole","undumag.mag")
        #endif
        if not nexist("nvox"):
          nvox = ncread("nvox","cnam:cmoth:icol:modu:kmag:lmag:ivox:icop:x:y:z:bxi:byi:bzi:bxe:bye:bze:ispole","undumag_voxel.lis")
        #endif

        npll(nmapintinf,"z:byint1","y==0")
        npllbs(nmapintinf,"z:bzint1","y==0")

    elif arg1 == "coil":

        optconsole()
        set_console_title("unduPython")
        if nargs > 4: ncoil = undu_plot_coil(args[2],args[3],args[4])
        elif nargs > 3: ncoil = undu_plot_coil(args[2],args[3])
        elif nargs > 2: ncoil = undu_plot_coil(args[2])
        else: ncoil = undu_plot_coil()
        getconsole()

    elif arg1 == "ucoilsside":
        import ucoils_plot
        from ucoils_plot import *
        ucoils_plot('side')
    elif arg1 == "ucoilstop":
        import ucoils_plot
        from ucoils_plot import *
        ucoils_plot('top')
    elif arg1 == "ucoilsbeam":
        import ucoils_plot
        from ucoils_plot import *
        ucoils_plot('beam')

#endif nargs > 1

if ntuples:
  for n in range(len(Nhead)):
    snam = Nhead[n][1]
    #print(snam)
    exec(snam + ' = nget("' + snam + '")')
  #endfor
#endif

wans()
+PATCH,MODULES.
*CMZ :  2.04/05 14/03/2023  12.19.23  by  Michael Scheer
+DECK,magnet_struct,T=F77.
*CMZ :  2.05/01 06/10/2023  08.25.51  by  Michael Scheer
*CMZ :  2.04/27 02/10/2023  13.45.41  by  Michael Scheer
*CMZ :  2.04/17 12/09/2023  09.42.21  by  Michael Scheer
*CMZ :  2.04/16 06/09/2023  16.15.55  by  Michael Scheer
*CMZ :  2.04/14 06/09/2023  06.43.30  by  Michael Scheer
*CMZ :  2.04/13 03/09/2023  09.50.42  by  Michael Scheer
*CMZ :  2.04/10 23/08/2023  08.17.05  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  19.31.25  by  Michael Scheer
*CMZ :  2.04/03 03/03/2023  16.41.34  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  16.37.47  by  Michael Scheer
*CMZ :  2.04/01 23/01/2023  09.51.15  by  Michael Scheer
*CMZ :  2.04/00 13/01/2023  10.56.20  by  Michael Scheer
*CMZ :  2.02/02 16/02/2022  15.17.02  by  Michael Scheer
*CMZ :  2.02/01 06/02/2022  11.20.01  by  Michael Scheer
*-- Author :    Michael Scheer   25/04/2021
      module magnets_structure

      integer nconcave_t
      character(512), dimension (:), allocatable :: clcconcave

      type T_concave

c          double precision, dimension (:,:,:), allocatable :: faces

      double precision, dimension (:,:), allocatable :: verts,
     &  fcen,fnorm

      double precision, dimension (:), allocatable ::
     &  xhull0,yhull0,zhull0,
     &  xhull,yhull,zhull,xdivs,ydivs,zdivs

      integer, dimension (:,:,:), allocatable :: kvoxels
      integer, dimension (:,:), allocatable :: kedge,ifaces
      integer, dimension (:), allocatable :: lifaces,npois,
     &  kface,khull,kcopy,lface,kconcave

      character(512), dimension (:), allocatable :: cinhom

      double precision
     &  xyz(3),size(3),trans(3),rot(3,3),Br(3),
     &  yfracdiv,xmin,ymin,zmin,xmax,ymax,zmax,
     &  volume,gcen(3),dxdiv,dydiv,dzdiv,yfrac,
     &  zfracdiv,zfrac,uschamf,dschamf,cylphi,BrN,xyzinh(4),xvolume,yvolume,
     &  zvolume

      integer :: kmag,nhull,icol,imat,nverts,nface,
     &  nxdiv,nydiv,nzdiv,matindex,mattype,IsConvex,
     &  kfacelast,nedge,nvoxels,IsPole,IsSpecial,
     &  IsBlock,nhull0,IsPart,ncopy=0,kmodule=0,
     &  IsInhom=0,mxdiv,mydiv,mzdiv,IsRotated,nconcave,npoimax

      character(32) ctype,cnam,cmoth
      character(1024) cfile

      type(T_Voxel), dimension(:), allocatable ::  t_voxels, t_xcuts
      type(T_Voxel), dimension(:,:), allocatable :: t_xycuts
      type(T_Voxel), dimension(:,:,:), allocatable :: t_xyzcuts

      end type T_concave

      type(T_Concave), dimension(:), allocatable :: t_concaves

      double precision ::
     &  xcwmin=1.0d30,xcwmax=-1.0d30,
     &  ycwmin=1.0d30,ycwmax=-1.0d30,
     &  zcwmin=1.0d30,zcwmax=-1.0d30,
     &  xmin_t=1.0d30,xmax_t=-1.0d30,
     &  ymin_t=1.0d30,ymax_t=-1.0d30,
     &  zmin_t=1.0d30,zmax_t=-1.0d30,
     &  xsymmm_t

      integer nclcbuff,nclcspec,nclcmag,nclccoil,nclcvar,nclcmod,nclcmat,
     &  kunduplot_mode

      integer :: iwwork,iwfct=0,iwgeo=0,iwvgeo=0,iwmag=0

      integer :: nvar_t=0,nmag_t=0,nvox_t=0,niron_t=0,kvox=0,kfirstiron_t=0,
     &  nspecmag_t=0,kfirstiron_spec_t=0,ncoils_t=0,ncwires_t=0,nmagtot_t=0,
     &  ncornmax_t=8,nplanmax_t=16, nmodule_t=0, nmagcopy_t=0,nvoxcopy_t=0,
     &  nclccop_t=0,nmoth_t=0,nmothtot_t=0,nmagsym_t=0,ninhom_t=0,nmaginhom_t=0

      integer, dimension (:,:), allocatable :: ifacets
      integer :: nfacets=0
      integer, dimension (:), allocatable :: ksort_t,kmaglist_t,maginhom_t

      character(512), dimension (:), allocatable :: clcbuff,clcmag,clccoil,
     &  clcvar,clcmod,clcmat,clctrarot,clccop,clcspec,clcinhom

      type T_variable
        character(128) cname
        double precision val
      end type T_variable

      type(T_variable), dimension(:), allocatable :: t_variables

      type T_Voxel

      double precision, dimension (:), allocatable :: xhull,yhull,zhull
      double precision, dimension (:,:), allocatable :: plan, vcen,vnorm

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: kface,khull,isfacet,lface

      double precision xyz(3),size(3),trans(3),rot(3,3),Br(3),
     &  gcen(3),volume,xmin,xmax,ymin,ymax,zmin,zmax

      integer nhull,ixdiv,iydiv,izdiv,nedge,nface,kfacelast,
     &  IsPole,IsBlock,mxdiv,mydiv,mzdiv

      end type T_Voxel

      type T_Voxel_Copy
        integer, dimension (:), allocatable :: isfacet
        integer kmagnet,kmodule,kcopy,kvoxel,kproto,ispole,nface
        double precision Br(3),Brn,gcen(3)
      end type T_Voxel_Copy

      type T_Magnet_Copy
        integer kproto,kmodule,kcopy,IsPole,IsSpecial
        double precision gcen(3),Br(3),BrN,xmin,xmax,ymin,ymax,zmin,zmax,
     &    size(3),volume
        character(32) ctype,cnam,cmoth
      end type T_Magnet_Copy

      type T_Magnet_Sym
        integer kproto,kmodule,kcopy,IsPole,IsSpecial
        double precision gcen(3),Br(3),BrN,xmin,xmax,ymin,ymax,zmin,zmax
        character(32) ctype,cnam,cmoth
      end type T_Magnet_Sym

      type T_Magnet

        double precision, dimension (:,:), allocatable :: fcen,fnorm
        double precision, dimension (:), allocatable :: xhull0,yhull0,zhull0,
     &    xhull,yhull,zhull,ydivs,zdivs

        integer, dimension (:,:,:), allocatable :: kvoxels
        integer, dimension (:,:), allocatable :: kedge
        integer, dimension (:), allocatable :: kface,khull,kcopy,lface

        character(512), dimension (:), allocatable :: cinhom

        double precision xyz(3),size(3),trans(3),rot(3,3),Br(3),yfracdiv,
     &    xmin,ymin,zmin,xmax,ymax,zmax,volume,gcen(3),dxdiv,dydiv,dzdiv,yfrac,
     &    zfracdiv,zfrac,uschamf,dschamf,cylphi,BrN,xyzinh(4),xvolume,yvolume,
     &    zvolume

        integer :: kmag,nface,nhull,icol,imat,nxdiv,nydiv,nzdiv,matindex,mattype,
     &    kfacelast,nedge,nvoxels,IsPole,IsSpecial,IsBlock,nhull0,IsPart,
     &    ncopy=0,kmodule=0,IsInhom=0,mxdiv,mydiv,mzdiv,IsRotated

        character(32) ctype,cnam,cmoth
        character(1024) cfile

        type(T_Voxel), dimension(:), allocatable ::  t_voxels, t_xcuts
        type(T_Voxel), dimension(:,:), allocatable :: t_xycuts
        type(T_Voxel), dimension(:,:,:), allocatable :: t_xyzcuts

      end type T_Magnet

      type T_Mother

        double precision, dimension (:), allocatable :: xhull,yhull,zhull

        integer, dimension (:,:), allocatable :: kedge
        integer, dimension (:), allocatable :: kface,khull,magnets

        double precision xyz(3),xmin,ymin,zmin,xmax,ymax,zmax,gcen(3)

        integer :: nmagnets=0,nhull,kfacelast

        character(32) :: cmoth=''

      end type T_Mother

      type T_Filament
        double precision curr,x1,y1,z1,x2,y2,z2
        integer icolor
      end type T_Filament

      type T_Coil
        integer ncwireI,ncwireE,iibuff,iebuff
        character(128) ctype,cnam
        character(1024) cparams
        double precision params(100)
      endtype T_Coil

      type(T_Magnet), dimension(:), allocatable ::  t_magnets, t_magnets_copy
      type(T_Coil), dimension(:), allocatable ::  t_coils

      type T_Module
        integer ncopy
        double precision offset(3),phi,vspace(3), scalmag(3),rotmat(3,3)
      end type T_Module

      character(32), dimension(:), allocatable :: chmutts

      integer, dimension (:), allocatable :: magmodule
      integer, parameter :: ntransrotcop_p=1000, nmat_p=1000

      integer :: ntransrotcop=0, nmat_t=0, t_matrec(3,nmat_p), nowarnugv=0
      double precision transrotcop(8,ntransrotcop_p)
      character(128) ctransrotcop(ntransrotcop_p)

      type(T_Mother), dimension(:), allocatable ::  t_mothers
      type(T_Module), dimension(:), allocatable ::  t_modules
      type(T_Magnet_Copy), dimension(:), allocatable ::  t_magcopy
      type(T_Magnet_Sym), dimension(:), allocatable ::  t_magsym
      type(T_Voxel_Copy), dimension(:), allocatable ::  t_voxcopy

      double precision, dimension (:), allocatable ::
     &  xpuffer1,ypuffer1,zpuffer1,
     &  xpuffer2,ypuffer2,zpuffer2,
     &  xpuffer3,ypuffer3,zpuffer3

      end module magnets_structure
+PATCH,GOOD.
*CMZ :  2.05/01 10/10/2023  14.27.20  by  Michael Scheer
+DECK,clc_cut_concave.
*CMZ :  2.05/01 10/10/2023  14.26.43  by  Michael Scheer
*-- Author :    Michael Scheer   02/10/2023
      subroutine clc_cut_concave(tc1,tc2,kcut)

      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use utilmod

      implicit none

      double precision, dimension(:,:), allocatable :: verts,verts1,verts2,
     &  vwork,verts2d
      double precision, dimension(:), allocatable :: xb,yb,zb

      integer, dimension(:,:), allocatable :: ifaces1,ifaces2,ifaces
      integer, dimension(:), allocatable :: npois1,npois2,npois,
     &  lifaces,lifaces1,lifaces2,khull,ivera2d

      double precision ymin,ymax,
     &  pcut(3),p1(3),p2(3),p3(3),vnor(3),dot,pcen(3),rotmat(3,3),pcenrot(3),
     &  rotinv(3,3),x1,x2,y1,y2,z1,z2,xc(2),zc(2),cut,dy,p(3),q(3)
c      double precision u33(3,3),w33(3,3)

      integer :: kpoicut,kcut,iplan,ipoi,npoi,kplancut,isig,isigo,
     &  i,istatus,nallo=-32,npoimax,npoimax1,npoimax2,nface,nface1,nface2,n1,n2,
     &  nverts1,nverts2,nverts,ic,lcut(2),icut(2),ifound,mfaces,k,nhull,
     &  ntri,itri

+seq,hulldim.

      Type(T_Concave) tc1,tc2

      save nallo

      if (nallo.lt.0) then
        nallo=-nallo
        allocate(xb(nallo),yb(nallo),zb(nallo),
     &    vwork(3,nallo),verts(3,nallo),verts2d(2,nallo),
     &    ifaces(nallo,nallo),ifaces1(nallo,nallo),ifaces2(nallo,nallo),
     &    lifaces(nallo),lifaces1(nallo),lifaces2(nallo),
     &    npois(nallo),npois1(nallo),npois2(nallo),khull(nallo),ivera2d(nallo))
      endif

      if (nallo.lt.max(npoimax,nface)**2) then
        deallocate(xb,yb,zb,verts,ifaces1,ifaces2,npois1,npois2,khull,
     &    verts2d,ivera2d)
        nallo=2*max(npoimax,nface)**2
        allocate(xb(nallo),yb(nallo),zb(nallo),verts2d(2,nallo),
     &    vwork(3,nallo),verts(3,nallo),
     &    ifaces(nallo,nallo),ifaces1(nallo,nallo),ifaces2(nallo,nallo),
     &    lifaces(nallo),lifaces1(nallo),lifaces2(nallo),
     &    npois(nallo),npois1(nallo),npois2(nallo),khull(nallo),ivera2d(nallo))
      endif

      npoimax=tc1%npoimax
      nface=tc1%nface
      ifaces(1:npoimax,1:nface)=tc1%ifaces(1:npoimax,1:nface)
      npois(1:nface)=tc1%npois(1:nface)
      lifaces(1:nface)=tc1%lifaces(1:nface)
      nverts=tc1%nverts
      verts=tc1%verts

      kcut=0
      if (tc1%isconvex.ne.0.or.tc1%nconcave.eq.0) return

      !call util_break

      ! Triangulation

      mfaces=nface
      do iplan=1,mfaces

        npoi=npois(iplan)
        khull(1:npoi)=ifaces(1:npoi,iplan)
        xb(1:npoi)=verts(1,ifaces(1:npoi,iplan))
        yb(1:npoi)=verts(2,ifaces(1:npoi,iplan))
        zb(1:npoi)=verts(3,ifaces(1:npoi,iplan))

        p=[xb(2)-xb(1),yb(2)-yb(1),zb(2)-zb(1)]
        q=[xb(3)-xb(2),yb(3)-yb(2),zb(3)-zb(2)]

        call util_vcross(p,q,vnor)
        vnor=abs(vnor)/norm2(vnor)

        if (vnor(1).gt.0.1d0) then
          verts2d(1,1:npoi)=yb(1:npoi)
          verts2d(2,1:npoi)=zb(1:npoi)
        else if (vnor(2).gt.0.1d0) then
          verts2d(1,1:npoi)=xb(1:npoi)
          verts2d(2,1:npoi)=zb(1:npoi)
        else
          verts2d(1,1:npoi)=xb(1:npoi)
          verts2d(2,1:npoi)=yb(1:npoi)
        endif

        call  util_triangu_2d(npoi,verts2d,ivera2d,ntri,tiny,istatus)

        ifaces(1:3,iplan)=khull(ivera2d(1:3))
        npois(iplan)=3

        do itri=2,ntri
          nface=nface+1
          ifaces(1:3,nface)=khull(ivera2d((itri-1)*3+1:(itri-1)*3+3))
          npois(nface)=3
        enddo

      enddo !nface

      kpoicut=tc1%kconcave(1)
      pcut=verts(:,kpoicut)

      kplancut=0
      do iplan=1,nface
        npoi=npois(iplan)
        do ipoi=1,npoi
          if(ifaces(ipoi,iplan).eq.kpoicut) then
            kplancut=iplan
            exit
          endif
        enddo
        if (kplancut.gt.0) then
          isigo=0
          p1=verts(:,ifaces(1,kplancut))
          p2=verts(:,ifaces(2,kplancut))
          p3=verts(:,ifaces(3,kplancut))
          pcen=(p1+p2+p3)/3.0d0
          call util_vcross(p2-p1,p3-p2,vnor)
          vnor=vnor/norm2(vnor)
          do i=1,nverts
            dot=dot_product(verts(:,i)-pcen,vnor)
            if (dot.gt.hulltiny) then
              isig=1
            else if (dot.lt.-hulltiny) then
              isig=-1
            else
              isig=0
            endif
            if (isigo.eq.0.and.isig.ne.0) isigo=isig
            if (isig.ne.0.and.isig.ne.isigo) then
              kplancut=-kplancut
              exit
            endif
          enddo
        endif
        if (kplancut.lt.0) then
          exit
        else
          kplancut=0
        endif
      enddo

      if (kplancut.gt.0) then
        kcut=-1
        return
      endif

      kplancut=-kplancut
      kcut=1

      call util_rotate_vector_to_y_axis(vnor,rotmat,istatus)
      rotinv=transpose(rotmat)

c      call util_matrix_multiplication(3,3,3,rotmat,rotinv,u33,w33)
c      do i=1,3
c        print*,u33(i,1:3)
c      enddo
c      stop
      call util_mat_mul_vec_3x3(rotmat,pcen,pcenrot)
      do i=1,nverts
        call util_mat_mul_vec_3x3(rotmat,verts(:,i),vwork(:,i))
        write(88,*)sngl(verts(:,i)),sngl(vwork(:,i)),i
        flush(88)
      enddo
      verts=vwork

      write(80,*)nverts
      do i=1,nverts
        write(80,*)verts(:,i)
      enddo
      write(80,*)nface
      do iplan=1,nface
        npoi=npois(iplan)
        write(80,*)npoi
        write(80,*)ifaces(1:npoi,iplan)
      enddo
      flush(80)

      cut=pcenrot(2)

      nface1=0
      nface2=0
      npoimax1=0
      npoimax2=0
      nverts1=nverts
      nverts2=nverts

      verts1=verts
      verts2=verts

      call util_break
      print*,cut
      do iplan=1,nface

        ic=0
        icut=0
        npoi=npois(iplan)

        do ipoi=1,npoi
          xb(ipoi)=verts(1,ifaces(ipoi,iplan))
          yb(ipoi)=verts(2,ifaces(ipoi,iplan))
          zb(ipoi)=verts(3,ifaces(ipoi,iplan))
          write(89,*)xb(ipoi),yb(ipoi),zb(ipoi),ipoi,iplan
          flush(89)
        enddo

        xb(npoi+1)=xb(1)
        yb(npoi+1)=yb(1)
        zb(npoi+1)=zb(1)

        ymin=minval(yb(1:npoi))
        ymax=maxval(yb(1:npoi))

c        print*,iplan,ymin,ymax

        if(abs(ymax-ymin).gt.hulltiny.and.ymax.le.cut+hulltiny) then
          nface1=nface1+1
          ifaces1(1:npoi,nface1)=ifaces(1:npoi,iplan)
          npois1(nface1)=npoi
        else if(ymin.ge.cut-hulltiny) then
          nface2=nface2+1
          ifaces2(1:npoi,nface2)=ifaces(1:npoi,iplan)
          npois2(nface2)=npoi
        else
          do ipoi=1,npoi
            x1=xb(ipoi)
            x2=xb(ipoi+1)
            y1=yb(ipoi)
            y2=yb(ipoi+1)
            z1=zb(ipoi)
            z2=zb(ipoi+1)
            if (y1.lt.cut-hulltiny.and.y2.gt.cut+hulltiny
     &          .or.
     &          y1.gt.cut+hulltiny.and.y2.lt.cut-hulltiny) then
              print*,iplan,cut
              print*,x1,y1,z1
              print*,x2,y2,z2
              dy=(cut-y1)/(y2-y1)
c              print*,dy
              ic=ic+1
              if (ic.gt.2) then
                stop "*** Schneidefehler!"
              endif
              icut(ic)=ipoi
              xc(ic)=x1+(x2-x1)*dy
              zc(ic)=z1+(z2-z1)*dy
              print*,xc(ic),zc(ic)
            endif !cut it
          enddo
        endif

        if (ic.ne.0) then

c          call util_break

          do i=1,ic
            ifound=0
            p1=[xc(i),cut,zc(i)]
            do ipoi=1,nverts
              if(norm2(p1-verts(:,ipoi)).lt.hulltiny) then
                ifound=1
                exit
              endif
            enddo
            if (ifound.eq.0) then
              nverts=nverts+1
              lcut(i)=nverts
              verts(:,nverts)=p1
              npois(iplan)=npois(iplan)+1
              ifaces(npois(iplan),iplan)=nverts
              xb(npois(iplan))=p1(1)
              yb(npois(iplan))=p1(2)
              zb(npois(iplan))=p1(3)
            else
              npois(iplan)=npois(iplan)+1
              ifaces(npois(iplan),iplan)=ipoi
              lcut(i)=icut(i)
              xb(npois(iplan))=p1(1)
              yb(npois(iplan))=p1(2)
              zb(npois(iplan))=p1(3)
            endif
          enddo

          nface1=nface1+1
          nface2=nface2+1

          n1=0
          n2=0

          do i=1,npois(iplan)
            k=ifaces(i,iplan)
            if(abs(yb(i)-cut).le.hulltiny) then
c              if (k.eq.lcut(1).or.k.eq.lcut(2)) then
                n1=n1+1
                ifaces1(n1,nface1)=k
                n2=n2+1
                ifaces2(n2,nface2)=k
c              else
c                n1=n1+1
c                ifaces1(n1,nface1)=ifaces(i,iplan)
c                n2=n2+1
c                ifaces2(n2,nface2)=ifaces(i,iplan)
c              endif
            else if(yb(i).le.cut+hulltiny) then
c              if (k.eq.lcut(1).or.k.eq.lcut(2)) then
                n1=n1+1
                ifaces1(n1,nface1)=k
c              else
c                n1=n1+1
c                ifaces1(n1,nface1)=ifaces(i,iplan)
c              endif
            else if(yb(i).ge.cut-hulltiny) then
c              if (k.eq.lcut(1).or.k.eq.lcut(2)) then
                n2=n2+1
                ifaces2(n2,nface2)=k
c              else
c                n2=n2+1
c                ifaces2(n2,nface2)=ifaces(i,iplan)
c              endif
            endif
          enddo
          npois1(nface1)=n1
          npois2(nface2)=n2
        endif
      enddo !nface

      do i=1,nverts
        call util_mat_mul_vec_3x3(rotinv,verts(:,i),vwork(:,i))
      enddo
      verts=vwork

      npoimax=0
      do iplan=1,nface1
        do ipoi=1,npois1(iplan)
          npoimax=npoimax+1
          i=ifaces1(ipoi,iplan)
          xb(npoimax)=verts(1,i)
          yb(npoimax)=verts(2,i)
          zb(npoimax)=verts(3,i)
        enddo
      enddo
      call util_weed_points(npoimax,xb,yb,zb,hulltiny**2)
      do ipoi=1,npoimax
        write(81,*)xb(ipoi),yb(ipoi),zb(ipoi),ipoi
        flush(81)
      enddo

      npoimax=0
      do iplan=1,nface2
        do ipoi=1,npois2(iplan)
          npoimax=npoimax+1
          i=ifaces2(ipoi,iplan)
          xb(npoimax)=verts(1,i)
          yb(npoimax)=verts(2,i)
          zb(npoimax)=verts(3,i)
        enddo
      enddo
      call util_weed_points(npoimax,xb,yb,zb,hulltiny**2)
      do ipoi=1,npoimax
        write(82,*)xb(ipoi),yb(ipoi),zb(ipoi),ipoi
        flush(82)
      enddo

      stop

      return
      end
