+TITLE.
UNDUMAG  2.04/10  23/08/2023  16.14.31
+PATCH,FOR.
*CMZ :  0.00/00 20/04/2016  13.00.13  by  Michael Scheer
+DECK,undumag_ini,T=F77.
*CMZ :  2.04/10 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/05 15/03/2023  09.34.01  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  17.02.39  by  Michael Scheer
*CMZ :  2.03/00 23/07/2022  09.18.29  by  Michael Scheer
*CMZ :  2.02/02 02/03/2022  13.23.21  by  Michael Scheer
*CMZ :  2.02/01 10/02/2022  12.55.23  by  Michael Scheer
*CMZ :  2.02/00 31/03/2021  20.30.51  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.27.23  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  16.04.15  by  Michael Scheer
*CMZ :  2.01/04 18/07/2019  13.56.54  by  Michael Scheer
*CMZ :  2.01/03 13/06/2019  15.03.29  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  14.56.07  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.15.25  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  14.30.21  by  Michael Scheer
*CMZ :  2.00/03 23/04/2018  17.47.12  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.39.07  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.09.03  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  16.25.38  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.30.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.59.20  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.35.49  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  19.08.03  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  13.53.24  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  11.50.12  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  18.37.06  by  Michael Scheer
*CMZ :  1.23/02 17/09/2017  11.21.15  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  16.23.00  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  14.53.35  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  08.50.03  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  11.30.39  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.56.28  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  12.48.09  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  13.11.48  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.31.54  by  Michael Scheer
*CMZ :  1.18/03 13/06/2017  15.30.31  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  14.09.42  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  09.19.34  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.04.28  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.55.08  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.22.37  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  12.23.38  by  Michael Scheer
*CMZ :  1.15/11 26/04/2017  11.23.30  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.22.06  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  14.32.29  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.29.10  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.46.33  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.15.21  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  19.50.52  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  11.26.05  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  09.16.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  10.00.53  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.14.36  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  15.40.55  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  16.37.53  by  Michael Scheer
*CMZ :  1.12/00 24/02/2017  08.47.15  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.24.23  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.18.36  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.27.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  10.13.44  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.40  by  Michael Scheer
*CMZ :  1.11/01 06/01/2017  13.46.07  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  15.56.40  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  15.36.58  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.12.02  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.10/00 01/11/2016  09.47.47  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.08.03  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  09.12.28  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  18.54.27  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.39.27  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.51.14  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.43.31  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.17  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.32.16  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.35.03  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.29.44  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.28  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  13.31.19  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.37.12  by  Michael Scheer
*CMZ :  1.02/02 12/09/2016  10.20.23  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.27.52  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  14.10.42  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  17.52.14  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.06.57  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.47  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.13.39  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  15.05.25  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  17.54.03  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  13.38.55  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.51.40  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.27.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.43  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  15.56.38  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.48.03  by  Michael Scheer
*CMZ :  1.17/15 19/04/2016  15.54.31  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  12.32.55  by  Michael Scheer
*CMZ :  1.17/13 08/04/2016  11.47.10  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.29.22  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  12.46.06  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.46.34  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.41.39  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.58.50  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.42.21  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016

      subroutine undumag_ini(kseg)

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      double precision undumag_variable_getval

+seq,phyconparam.
+seq,seqdebug.
+seq,random.

      integer lun,lunst,ivrmlo,lunrn,lundum,k,i,idatetime(8),kseg
      double precision retval

      character(10) dtday,dttime,dtzone

      twopi=twopi1

      open(newunit=lun,file="undumag.stat")
      write(lun,*)"1"
      flush(lun)
      close(lun)

      call undumag_greeter

      ! read undumag.nam
      call undumag_ini_namelists

      if (kseg.ne.0) then
        kechocalc=0
      endif

      ixsymo=ixsym
      iysymo=iysym
      izsymo=izsym

      ! initialize random generator
      call undumag_ini_random
c      call undumag_ini_displacement

      ! read undumag.clc
      call undumag_read_clc

      ! calculate variables
      call undumag_calc_new(kechocalc)

      nowarnugv=1

      if (perlen.eq.9999.0d0) then
        retval=undumag_variable_getval("PerLen")
        if (retval.ne.-9999.0d29) then
          perlen=retval
        else
          write(lun6,*)"*** Error in undumag_ini: Bad return from undumag_variable_getval for PerLen ***"
          write(lun6,*)"*** Setting PerLen = 100.0 ***"
          perlen=100.0d0
        endif
      endif

      retval=undumag_variable_getval("ixsym")
      if (retval.ne.-9999.0d29) ixsym=nint(retval)
      retval=undumag_variable_getval("iysym")
      if (retval.ne.-9999.0d29) iysym=nint(retval)
      retval=undumag_variable_getval("izsym")
      if (retval.ne.-9999.0d29) izsym=nint(retval)
      nowarnugv=0

      if (ixsym.ne.ixsymo.or.iysym.ne.iysymo.or.izsym.ne.izsymo) then
        print*,"*** Warning in undumag_ini: Symmetry operations of undumag.nam overwritten with values of undumag.clc ***"
      endif

      if (ixsym.lt.0.or.iysym.lt.0.or.izsym.lt.0) then
        print*,"*** Warning in undumag_ini: Hard symmetry operations, i.e. duplication of magnets not allowed ***"
        print*,"*** Switching to soft symmetry  ***"
        ixsym=abs(ixsym)
        iysym=abs(iysym)
        izsym=abs(izsym)
      endif

      call undumag_ini_materials

      call undumag_ini_magnets(kseg)
      if (kseg.ne.0) return

      if (irnmode.eq.1.or.irnmode.eq.2) then

        kundurun=0

        open(newunit=lundum,file="undumag.run",form='formatted',recl=512)
        read(lundum,*,end=197)kundurun
197     kundurun=kundurun+1
        close(lundum)

        if (irnmode.eq.2) irnseed(12)=irnseed(12)+kundurun
        call util_random_set_seed(irnsize,irnseed)

      else if (irnmode<0) then

        open(newunit=lunrn,file='undumag.seeds',status='old')
        read(lunrn,*) k
        do i=1,irnsize
          read(lunrn,*)k,irnseed(k)
        enddo
        close(lunrn)
        call util_random_set_seed(irnsize,irnseed)
      else
        call util_random_init(irnsize,irnseed)
      endif

      open(newunit=lundum,file="undumag.run",form='formatted',recl=512)

      read(lundum,*,end=97)kundurun
97    kundurun=kundurun+1

      rewind(lundum)

      call date_and_time(dtday,dttime,dtzone,idatetime)

      write(lundum,*) kundurun,trim(usercom),' ',
     &  dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &  ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
      flush(lundum)
      close(lundum)

      open(newunit=lundum,file="undumag.runs",form='formatted',recl=512,
     &  access='append')
      write(lundum,*) kundurun,trim(usercom),' ',
     &  dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &  ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
      close(lundum)

      open(newunit=lun,file='undumag.run',status='old')
      read(lun,'(a)')cundutit
      close(lun)
      cundutit(1:1)='*'

      ! write buffer file undumag.mag
      kunduplot_mode=iunduplot_mode
      if (iundugeo.ne.0.or.iunduplot.ne.0 ) then
        call undumag_magfile
      endif

      ! write magnets, poles, and coils to undumag.geo
      if (iundugeo.ne.0) call undumag_geo

      if (iundugeo.lt.0) then
        open(newunit=lunst,file="undumag.stat")
        write(lunst,*)"0"
        flush(lunst)
        close(lunst)
        stop "--- Programm UNDUMAG terminated due to iundugeo < 0 ---"
      endif

      ! write magnets, poles, and coils to undumag.eps
      if (iunduplot.ne.0) call undumag_bpolyplot

      if (iunduplot.lt.0) then
        open(newunit=lunst,file="undumag.stat")
        write(lunst,*)"0"
        flush(lunst)
        close(lunst)
        stop "--- Programm UNDUMAG terminated due to iunduplot < 0 ---"
      endif

      ! write interface to RADIA
      call clcmag_to_radia
      !call undumag_to_radia

      ! write CAD file undumag.wrl of magnets and poles if ivrml.ne.0

      ivrmlo=ivrml
      ivrml=abs(ivrml)
      call undumag_to_vrml
      ivrml=ivrmlo

      if (ivrml.lt.0) then
        open(newunit=lunst,file="undumag.stat")
        write(lunst,*)"0"
        flush(lunst)
        close(lunst)
        stop "--- Programm UNDUMAG terminated due to ivrml < 0 ---"
      endif

      return
      end
+DECK,undumag_proc.
*CMZ :  2.04/09 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/08 10/08/2023  09.28.20  by  Michael Scheer
*CMZ :  2.04/06 22/05/2023  15.36.58  by  Michael Scheer
*CMZ :  2.04/03 28/02/2023  10.11.37  by  Michael Scheer
*CMZ :  2.03/00 24/07/2022  14.55.26  by  Michael Scheer
*CMZ :  2.02/02 01/07/2022  18.10.55  by  Michael Scheer
*CMZ :  2.02/01 11/02/2022  09.44.24  by  Michael Scheer
*CMZ :  2.02/00 29/03/2021  08.13.23  by  Michael Scheer
*CMZ :  2.01/04 19/07/2019  11.32.16  by  Michael Scheer
*CMZ :  2.01/03 19/02/2019  15.12.23  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  13.35.13  by  Michael Scheer
*CMZ :  2.00/03 24/04/2018  12.57.46  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  09.06.41  by  Michael Scheer
*CMZ :  1.25/03 22/03/2018  17.04.20  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  12.51.53  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  13.46.00  by  Michael Scheer
*CMZ :  1.23/04 03/10/2017  10.43.48  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  16.00.03  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  12.01.46  by  Michael Scheer
*CMZ :  1.20/03 26/06/2017  09.29.58  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.34.18  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.59.54  by  Michael Scheer
*CMZ :  1.20/00 20/06/2017  17.45.31  by  Michael Scheer
*CMZ :  1.18/03 13/06/2017  16.03.07  by  Michael Scheer
*CMZ :  1.17/08 27/05/2017  11.11.36  by  Michael Scheer
*CMZ :  1.17/07 22/05/2017  09.11.18  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.30.34  by  Michael Scheer
*CMZ :  1.17/05 18/05/2017  10.15.55  by  Michael Scheer
*CMZ :  1.17/04 10/05/2017  11.28.21  by  Michael Scheer
*CMZ :  1.17/00 07/05/2017  21.16.08  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  14.06.14  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  17.05.33  by  Michael Scheer
*CMZ :  1.15/10 10/04/2017  16.42.28  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  12.38.19  by  Michael Scheer
*CMZ :  1.15/07 05/04/2017  09.12.16  by  Michael Scheer
*CMZ :  1.15/02 31/03/2017  13.42.48  by  Michael Scheer
*CMZ :  1.15/00 27/03/2017  12.51.14  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  12.49.30  by  Michael Scheer
*CMZ :  1.11/01 06/01/2017  13.35.57  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.48.13  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  12.14.11  by  Michael Scheer
*CMZ :  1.06/00 19/09/2016  14.23.58  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.07.58  by  Michael Scheer
*CMZ :  1.02/01 04/09/2016  16.24.12  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  13.44.31  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  15.00.54  by  Michael Scheer
*CMZ :  0.00/14 19/08/2016  14.32.22  by  Michael Scheer
*CMZ :  0.00/13 19/08/2016  13.59.01  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.07.26  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  11.54.42  by  Michael Scheer
*CMZ :  0.00/09 05/07/2016  16.15.09  by  Michael Scheer
*CMZ :  0.00/07 22/06/2016  16.13.38  by  Michael Scheer
*CMZ :  0.00/05 13/06/2016  15.10.33  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.49.34  by  Michael Scheer
*CMZ :  0.00/03 04/05/2016  11.42.42  by  Michael Scheer
*CMZ :  0.00/02 02/05/2016  10.17.29  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  09.45.18  by  Michael Scheer
*CMZ :  1.17/13 06/04/2016  16.00.49  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.48.31  by  Michael Scheer
*CMZ :  1.17/11 06/04/2016  09.12.36  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.20.09  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.24.11  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  09.03.19  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.44.39  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  11.59.54  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  19.09.17  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  09.58.20  by  Michael Scheer
*CMZ :  1.17/02 14/03/2016  10.05.05  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_proc

+self,if=omp.
      use omp_lib
+self.
      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

!      bpebc(1:3,imag) contains position of magnet imag
!      bpebc(4:6,imag) contains normalized magnetization vector of magnet imag

      implicit none

      double precision, dimension (:,:), allocatable :: bciron

      double precision x,y,z,hxo,hyo,hzo,h,hx,hy,hz,bn,xcut,
     &  tr(3,3),ti(3,3),bcrot3,hconvo,hconvr,dh,dho,dampirono,
     &  bc(3),vmaglab(3),xin(3),yin(3),a(3),yopt,xopt,yp(3),
     &  bx,by,bz,bmax

      real g(3),xm,ym,zm

      integer imag,jc,iterold,ifail,nmatsiz,idx,nmaxth,mag,lun,nplan,
     &  krunmatrix,mmag,i,k,m,iplan,lunst,ith,iprint,istat,magbmax,imat
      integer :: nconv=0,mark=0

      integer, dimension (:), allocatable :: irecover
      integer*8 nmagnmag,mat,mapmode

      logical lexist

      save nmaxth,ith

      if (nrec.eq.0.and.ncwires.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Nothing to solve in undumag_proc, i.e. no magnets no coils  ***"
        write(lun6,*)
        return
      endif

      if (kprint.lt.0) kprint=0

      if (niron.gt.0.and.kresiron.ne.0) then
        do imag=nrec+1,nrec+niron
           mat=nint(bpebc(9,imag))
           mapmode=mapmode+matmaps(3,mat)
        enddo
        if (mapmode.eq.0) then
          write(lun6,*)
          write(lun6,*)"*** Only iron with infinity mu found***"
          write(lun6,*)"*** KRESIRON SET TO ZERO ***"
          write(lun6,*)
          kresiron=0
        endif
        if (kresiron.ne.0.and.kprint.eq.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning KRESIRON IS SET, BUT KPRINT ZERO ***"
          write(lun6,*)"*** KRESIRON SET TO ZERO ***"
          write(lun6,*)
          kresiron=0
        endif
      else if (niron.le.0.and.kresiron.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning KRESIRON is set, but there is no iron ****"
          write(lun6,*)"*** KRESIRON set to zero ***"
          write(lun6,*)
          kresiron=0
      endif

      open(newunit=lunst,file="undumag.sta")
      write(lunst,*)kundurun,konv,iwarnsum
      write(lunst,*)"undumag_proc"
      close(lunst)

      if (newclc.ne.0) then
        do imag=1,nmag
          imat=int(bpebc(9,imag))
          if (matmaps(2,imat).eq.1) cycle
          bpebc(4,imag)=0.001 ! for convmat etc.
          bpebc(7,imag)=0.001 ! for convmat etc.
        enddo
      endif

      allocate(bciron(9,niron))

      if (kpreset.eq.0) bpebc(11:13,nrec+1:nmag)=0.0d0

      dampirono=dampiron
      dampiron=abs(dampiron)

      if (ncwires.gt.0) then
        bmax=-1.0d30
        do imag=1,nmag
          x=bpebc(1,imag)/1000.0d0
          y=bpebc(2,imag)/1000.0d0
          z=bpebc(3,imag)/1000.0d0
          call undumag_bcoils(x,y,z,bx,by,bz,istat)
          bpebc(18,imag)=bx
          bpebc(19,imag)=by
          bpebc(20,imag)=bz
          bn=sqrt(bx**2+by**2+bz**2)
          if (bn.gt.bmax) then
            bmax=bn
            magbmax=imag
            xm=x*1000.
            ym=y*1000.
            zm=z*1000.
          endif
        enddo
        if (nmag.gt.0) then
          write(lun6,*)
          write(lun6,'(a,g12.5,a,3g12.5)')"Undumag_proc: Max. field of coils in magnets: ",sngl(bmax)," at ",xm,ym,zm
          write(lun6,*)
        endif
      endif

      if (maxiter.le.0.or.(nmag.eq.0.and.kbextern.eq.0))
     &  goto 99999

      if (irandmag.lt.0) then
        do imag=1,nmag
          call util_random(3,g)
          g=g-0.5
          if (abs(g(1)).lt.randox10) then
            if (g(1).gt.0.0d0) then
              g(1)=g(1)+randox10
            else
              g(1)=g(1)-randox10
            endif
          endif
          if (abs(g(2)).lt.randoy10) then
            if (g(2).gt.0.0d0) then
              g(2)=g(2)+randoy10
            else
              g(2)=g(2)-randoy10
            endif
          endif
          if (abs(g(3)).lt.randoz10) then
            if (g(3).gt.0.0d0) then
              g(3)=g(3)+randoz10
            else
              g(3)=g(3)-randoz10
            endif
          endif
          bpebc(1,imag)=bpebc(1,imag)+g(1)*randox
          bpebc(2,imag)=bpebc(2,imag)+g(2)*randoy
          bpebc(3,imag)=bpebc(3,imag)+g(3)*randoz
        enddo
      endif

      allocate(bc0(10,nmag))

      allocate(bpm(nplanmax,nmag))
      do imag=1,nmag
        if(bpebc(8,imag).eq.1) then !not a rectangular magnet
          do iplan=1,iabs(ibpeplan(imag))
            bpm(iplan,imag)=bpetm(1,7,iplan,imag)
          enddo
        endif
      enddo

      bc0(7:10,1:nmag)=bpebc(11:14,1:nmag) ! keep the original magnetization

      iterold=maxiteriron
      kconv=0

      kinside=0
      h=0.0d0

      allocate (convmat(3,3,nxconv,nmag))
      if (ncwires.gt.0) then
        allocate(bxconvw(nxconv),byconvw(nxconv),bzconvw(nxconv))
      endif
c      allocate(bcc(3,nmag))

c      bcc(1:3,1:nmag)=bpebc(4:6,1:nmag)

      nmaxth=1
+self,if=omp.
      nmaxth=OMP_GET_MAX_THREADS()
      if (nthreads.gt.0) nmaxth=min(nmaxth,nthreads)
      write(lun6,*)
      write(lun6,*)"Number of CPU cores used:",nmaxth
      write(lun6,*)
+self.

      allocate(irecover(nmaxth))
      irecover=0
      ith=1
      do mag=1,nmag

        do i=1,nxconv

          x=xconv(i)
          xcut=2.0d0*xsym-x
          y=yconv
          z=zconv

          if (ncwires.gt.0) then
            call undumag_bcoils(x,y,z,bxconvw(i),byconvw(i),bzconvw(i),ifail)
          endif

          bpebc(4:6,mag)=0.0d0
          bpebc(3+1,mag)=1.0d0

          if(bpebc(8,mag).eq.1) then !not a rectangular magnet
            do iplan=1,iabs(ibpeplan(mag))
              bpetm(1,7,iplan,mag)=bpetm(1,8,iplan,mag)
            enddo
          endif

          call undumag_bpolyeder1(mag,x,y,z,hx,hy,hz,ifail)

          if (ifail.gt.0) then
            write(lun6,*)""
            write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
            write(lun6,*)"mag,x,y,z:",mag,x,y,z
            write(lun6,*)""
            iwarnsum=10
          else if (ifail.lt.0) then
c            write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
c            write(lun6,*)"mag, ifail:",mag,ifail
            irecover(ith)=irecover(ith)+1
          endif

          convmat(1,1,i,mag)=hx
          convmat(2,1,i,mag)=hy
          convmat(3,1,i,mag)=hz

          if (ixsym.eq.0) then
            if (iysym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
c                write(lun6,*)"mag,ifail:",mag,ifail
              endif
              convmat(1,1,i,mag)=convmat(1,1,i,mag)-hx
              convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
              convmat(3,1,i,mag)=convmat(3,1,i,mag)-hz
            endif
            if (izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
c                write(lun6,*)"mag,ifail:",mag,ifail
              endif
              convmat(1,1,i,mag)=convmat(1,1,i,mag)+hx
              convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
              convmat(3,1,i,mag)=convmat(3,1,i,mag)-hz
            endif
            if (iysym.ne.0.and.izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
c                write(lun6,*)"mag,ifail:",mag,ifail
              endif
              convmat(1,1,i,mag)=convmat(1,1,i,mag)-hx
              convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
              convmat(3,1,i,mag)=convmat(3,1,i,mag)+hz
            endif
          else !ixsym
            call undumag_bpolyeder1(mag,xcut,y,z,hx,hy,hz,ifail)
            if (ifail.gt.0) then
              write(lun6,*)""
              write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
              write(lun6,*)"mag,x,y,z:",mag,xcut,y,z
              write(lun6,*)""
            else if (ifail.lt.0) then
c              write(lun6,*)"mag,ifail:",mag,ifail
              irecover(ith)=irecover(ith)+1
            endif
            convmat(1,1,i,mag)=convmat(1,1,i,mag)-hx
            convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
            convmat(3,1,i,mag)=convmat(3,1,i,mag)+hz
            if (iysym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,1,i,mag)=convmat(1,1,i,mag)-hx
              convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
              convmat(3,1,i,mag)=convmat(3,1,i,mag)-hz
              call undumag_bpolyeder1(mag,xcut,-y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,xcut,-y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,1,i,mag)=convmat(1,1,i,mag)+hx
              convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
              convmat(3,1,i,mag)=convmat(3,1,i,mag)-hz
            endif
            if (izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,1,i,mag)=convmat(1,1,i,mag)+hx
              convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
              convmat(3,1,i,mag)=convmat(3,1,i,mag)-hz
              call undumag_bpolyeder1(mag,xcut,y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,xcut,y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,1,i,mag)=convmat(1,1,i,mag)-hx
              convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
              convmat(3,1,i,mag)=convmat(3,1,i,mag)-hz
            endif
            if (iysym.ne.0.and.izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,1,i,mag)=convmat(1,1,i,mag)-hx
              convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
              convmat(3,1,i,mag)=convmat(3,1,i,mag)+hz
              call undumag_bpolyeder1(mag,xcut,-y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 convmat:"
                write(lun6,*)"mag,x,y,z:",mag,xcut,-y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,1,i,mag)=convmat(1,1,i,mag)+hx
              convmat(2,1,i,mag)=convmat(2,1,i,mag)+hy
              convmat(3,1,i,mag)=convmat(3,1,i,mag)+hz
            endif
          endif !(ixsym.eq.0) then

          bpebc(4:6,mag)=0.0d0
          bpebc(3+2,mag)=1.0d0

          if(bpebc(8,mag).eq.1) then !not a rectangular magnet
            do iplan=1,iabs(ibpeplan(mag))
              bpetm(1,7,iplan,mag)=bpetm(2,8,iplan,mag)
            enddo
          endif

          call undumag_bpolyeder1(mag,x,y,z,hx,hy,hz,ifail)

          if (ifail.gt.0) then
            write(lun6,*)""
            write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
            write(lun6,*)"mag,x,y,z:",mag,x,y,z
            write(lun6,*)""
            iwarnsum=10
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
          endif

          convmat(1,2,i,mag)=hx
          convmat(2,2,i,mag)=hy
          convmat(3,2,i,mag)=hz

          if (ixsym.eq.0) then
            if (iysym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,2,i,mag)=convmat(1,2,i,mag)-hx
              convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
              convmat(3,2,i,mag)=convmat(3,2,i,mag)-hz
            endif
            if (izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,2,i,mag)=convmat(1,2,i,mag)+hx
              convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
              convmat(3,2,i,mag)=convmat(3,2,i,mag)-hz
            endif
            if (iysym.ne.0.and.izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,2,i,mag)=convmat(1,2,i,mag)-hx
              convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
              convmat(3,2,i,mag)=convmat(3,2,i,mag)+hz
            endif
          else !ixsym
            call undumag_bpolyeder1(mag,xcut,y,z,hx,hy,hz,ifail)
            if (ifail.gt.0) then
              write(lun6,*)""
              write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
              write(lun6,*)"mag,x,y,z:",mag,xcut,y,z
              write(lun6,*)""
            else if (ifail.lt.0) then
              irecover(ith)=irecover(ith)+1
            endif
            convmat(1,2,i,mag)=convmat(1,2,i,mag)-hx
            convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
            convmat(3,2,i,mag)=convmat(3,2,i,mag)+hz
            if (iysym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,2,i,mag)=convmat(1,2,i,mag)-hx
              convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
              convmat(3,2,i,mag)=convmat(3,2,i,mag)-hz
              call undumag_bpolyeder1(mag,xcut,-y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,xcut,-y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,2,i,mag)=convmat(1,2,i,mag)+hx
              convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
              convmat(3,2,i,mag)=convmat(3,2,i,mag)-hz
            endif
            if (izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,2,i,mag)=convmat(1,2,i,mag)+hx
              convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
              convmat(3,2,i,mag)=convmat(3,2,i,mag)-hz
              call undumag_bpolyeder1(mag,xcut,y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,xcut,y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,2,i,mag)=convmat(1,2,i,mag)-hx
              convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
              convmat(3,2,i,mag)=convmat(3,2,i,mag)-hz
            endif
            if (iysym.ne.0.and.izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,2,i,mag)=convmat(1,2,i,mag)-hx
              convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
              convmat(3,2,i,mag)=convmat(3,2,i,mag)+hz
              call undumag_bpolyeder1(mag,xcut,-y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,xcut,-y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,2,i,mag)=convmat(1,2,i,mag)+hx
              convmat(2,2,i,mag)=convmat(2,2,i,mag)+hy
              convmat(3,2,i,mag)=convmat(3,2,i,mag)+hz
            endif
          endif !(ixsym.eq.0) then

          bpebc(4:6,mag)=0.0d0
          bpebc(3+3,mag)=1.0d0

          if(bpebc(8,mag).eq.1) then !not a rectangular magnet
            do iplan=1,iabs(ibpeplan(mag))
              bpetm(1,7,iplan,mag)=bpetm(1,8,iplan,mag)
            enddo
          endif

          call undumag_bpolyeder1(mag,x,y,z,hx,hy,hz,ifail)

          if (ifail.gt.0) then
            write(lun6,*)""
            write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
            write(lun6,*)"mag,x,y,z:",mag,x,y,z
            write(lun6,*)""
            iwarnsum=10
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
          endif

          convmat(1,3,i,mag)=hx
          convmat(2,3,i,mag)=hy
          convmat(3,3,i,mag)=hz

          if (ixsym.eq.0) then
            if (iysym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,3,i,mag)=convmat(1,3,i,mag)-hx
              convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
              convmat(3,3,i,mag)=convmat(3,3,i,mag)-hz
            endif
            if (izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,3,i,mag)=convmat(1,3,i,mag)+hx
              convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
              convmat(3,3,i,mag)=convmat(3,3,i,mag)-hz
            endif
            if (iysym.ne.0.and.izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,3,i,mag)=convmat(1,3,i,mag)-hx
              convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
              convmat(3,3,i,mag)=convmat(3,3,i,mag)+hz
            endif
          else !ixsym
            call undumag_bpolyeder1(mag,xcut,y,z,hx,hy,hz,ifail)
            if (ifail.gt.0) then
              write(lun6,*)""
              write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
              write(lun6,*)"mag,x,y,z:",mag,xcut,y,z
              write(lun6,*)""
            else if (ifail.lt.0) then
              irecover(ith)=irecover(ith)+1
            endif
            convmat(1,3,i,mag)=convmat(1,3,i,mag)-hx
            convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
            convmat(3,3,i,mag)=convmat(3,3,i,mag)+hz
            if (iysym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,3,i,mag)=convmat(1,3,i,mag)-hx
              convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
              convmat(3,3,i,mag)=convmat(3,3,i,mag)-hz
              call undumag_bpolyeder1(mag,xcut,-y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,xcut,-y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,3,i,mag)=convmat(1,3,i,mag)+hx
              convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
              convmat(3,3,i,mag)=convmat(3,3,i,mag)-hz
            endif
            if (izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,3,i,mag)=convmat(1,3,i,mag)+hx
              convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
              convmat(3,3,i,mag)=convmat(3,3,i,mag)-hz
              call undumag_bpolyeder1(mag,xcut,y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,xcut,y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,3,i,mag)=convmat(1,3,i,mag)-hx
              convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
              convmat(3,3,i,mag)=convmat(3,3,i,mag)-hz
            endif
            if (iysym.ne.0.and.izsym.ne.0) then
              call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,x,-y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,3,i,mag)=convmat(1,3,i,mag)-hx
              convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
              convmat(3,3,i,mag)=convmat(3,3,i,mag)+hz
              call undumag_bpolyeder1(mag,xcut,-y,-z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1 for convmat:"
                write(lun6,*)"mag,x,y,z:",mag,xcut,-y,-z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              convmat(1,3,i,mag)=convmat(1,3,i,mag)+hx
              convmat(2,3,i,mag)=convmat(2,3,i,mag)+hy
              convmat(3,3,i,mag)=convmat(3,3,i,mag)+hz
            endif
          endif !(ixsym.eq.0) then

        enddo ! nxconv
      enddo ! magmag

      if (irecover(ith).ne.0) then
        write(lun6,*)"*** Warning in undumag_proc: Recovered from ",irecover(ith),
     &    " errors while calculating convergence vector ***"
      endif

      if (matrix.gt.0) then
        allocate(wwmatrix4(3,3,nmag,nmag),stat=istat)
        if (istat.ne.0) then
          write(lun6,*)'*** Error in undumag_proc: Not enough memory for interaction matrix of size 3x3x',nmag,' x ',nmag
          stop "*** UNDUMAG ABORTED ***"
        endif
        wwmatrix4=0.0d0
      endif

      irecover=0

      if (matrix.gt.0) then

        call util_zeit_kommentar(lun6,"Setting-up the matrix.")

        nmagnmag=nmag*nmag
        write(lun6,*)
        write(lun6,*)"Matrix size:",nmag," x ",nmag," = ",nmagnmag
        write(lun6,*)

        iumatrix=0
        do imag=1,nmag
          if (irandmag.eq.0) then
            x=bpebc(1,imag)/1000.0d0
            y=bpebc(2,imag)/1000.0d0
            z=bpebc(3,imag)/1000.0d0
          else
            call util_random(3,g)
            x=(bpebc(1,imag)+(g(1)-0.5)*randoxa)/1000.0d0
            y=(bpebc(2,imag)+(g(2)-0.5)*randoya)/1000.0d0
            z=(bpebc(3,imag)+(g(3)-0.5)*randoza)/1000.0d0
          endif
          xcut=2.0d0*xsym-x

          mark=mark+1
+self,if=omp.
!$OMP PARALLEL NUM_THREADS(nmaxth) DEFAULT(PRIVATE)
!$OMP& SHARED(lun6,irecover,ixsym,iysym,izsym,bpebc,bpetm,ibpeplan,wwmatrix4)
!$OMP& FIRSTPRIVATE(imag,nmag,x,y,z,xcut)
          ith=OMP_GET_THREAD_NUM()+1
!$OMP DO
+self.

          do mag=1,nmag

            bpebc(4:6,mag)=0.0d0
            bpebc(3+1,mag)=1.0d0

            if(bpebc(8,mag).eq.1) then !not a rectangular magnet
              do iplan=1,iabs(ibpeplan(mag))
                bpetm(1,7,iplan,mag)=bpetm(1,8,iplan,mag)
              enddo
            endif

            call undumag_bpolyeder1(mag,x,y,z,hx,hy,hz,ifail)

            h=sqrt(hx**2+hy**2+hz**2)
            if (h.gt.2.0d0) then
              write(lun6,*)"*** Warning in undumag_proc: Strange H return by undumag_bpolyeder1 for wwmatrix(1...)"
              write(lun6,*)"imag,mag, hx,hy,hz",imag,mag,hx,hy,hz
            endif

            if (ifail.gt.0) then
              write(lun6,*)""
              write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
              print '(a,2i7,3f7.5,3e15.5e3)',"mag1,mag2,x,y,z:",mag,imag,x,y,z,hx,hy,hz
              write(lun6,*)""
              iwarnsum=10
            else if (ifail.lt.0) then
              irecover(ith)=irecover(ith)+1
            endif

            wwmatrix4(1,1,mag,imag)=hx
            wwmatrix4(1,2,mag,imag)=hy
            wwmatrix4(1,3,mag,imag)=hz

            if (ixsym.eq.0) then
              if (iysym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)-hx
                wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)-hy
                wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)-hz
              endif

              if (izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)+hx
                wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)+hy
                wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)+hz
              endif
              if (iysym.ne.0.and.izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)-hx
                wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)-hy
                wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)-hz
              endif
            else !ixsym
              call undumag_bpolyeder1(mag,xcut,y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)-hx
              wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)-hy
              wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)-hz
              if (iysym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)-hx
                wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)-hy
                wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)-hz
                call undumag_bpolyeder1(mag,xcut,-y,z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,-y,z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)+hx
                wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)+hy
                wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)+hz
              endif
              if (izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)+hx
                wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)+hy
                wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)+hz
                call undumag_bpolyeder1(mag,xcut,y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)-hx
                wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)-hy
                wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)-hz
              endif
              if (iysym.ne.0.and.izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)-hx
                wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)-hy
                wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)-hz
                call undumag_bpolyeder1(mag,xcut,-y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,-y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(1,1,mag,imag)=wwmatrix4(1,1,mag,imag)+hx
                wwmatrix4(1,2,mag,imag)=wwmatrix4(1,2,mag,imag)+hy
                wwmatrix4(1,3,mag,imag)=wwmatrix4(1,3,mag,imag)+hz
              endif
            endif !(ixsym.eq.0) then

            bpebc(4:6,mag)=0.0d0
            bpebc(3+2,mag)=1.0d0

            if(bpebc(8,mag).eq.1) then !not a rectangular magnet
              do iplan=1,iabs(ibpeplan(mag))
                bpetm(1,7,iplan,mag)=bpetm(2,8,iplan,mag)
              enddo
            endif

            call undumag_bpolyeder1(mag,x,y,z,hx,hy,hz,ifail)

            h=sqrt(hx**2+hy**2+hz**2)
            if (h.gt.2.0d0) then
              write(lun6,*)"*** Warning in undumag_proc: Strange H return by undumag_bpolyeder1 for wwmatrix(2...)"
              write(lun6,*)"imag,mag, hx,hy,hz",imag,mag,hx,hy,hz
            endif

            if (ifail.gt.0) then
              write(lun6,*)""
              write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
              write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,y,z
              write(lun6,*)""
            else if (ifail.lt.0) then
              irecover(ith)=irecover(ith)+1
            endif

            wwmatrix4(2,1,mag,imag)=hx
            wwmatrix4(2,2,mag,imag)=hy
            wwmatrix4(2,3,mag,imag)=hz

            if (ixsym.eq.0) then
              if (iysym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
                wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
                wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
              endif
              if (izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
                wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
                wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
              endif
              if (iysym.ne.0.and.izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
                wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
                wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
              endif
            else !ixsym
              call undumag_bpolyeder1(mag,xcut,y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,y,z
                write(lun6,*)""
              else if (ifail.lt.0) then
                irecover(ith)=irecover(ith)+1
              endif
              wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
              wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
              wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
              if (iysym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
                wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
                wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
                call undumag_bpolyeder1(mag,xcut,-y,z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,-y,z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
                wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
                wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
              endif
              if (izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
                wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
                wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
                call undumag_bpolyeder1(mag,xcut,y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
                wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
                wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
              endif
              if (iysym.ne.0.and.izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
                wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
                wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
                call undumag_bpolyeder1(mag,xcut,-y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,-y,-z
                  write(lun6,*)""
                else if (ifail.lt.0) then
                  irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(2,1,mag,imag)=wwmatrix4(2,1,mag,imag)+hx
                wwmatrix4(2,2,mag,imag)=wwmatrix4(2,2,mag,imag)+hy
                wwmatrix4(2,3,mag,imag)=wwmatrix4(2,3,mag,imag)+hz
              endif
            endif !(ixsym.eq.0) then

            bpebc(4:6,mag)=0.0d0
            bpebc(3+3,mag)=1.0d0

            if(bpebc(8,mag).eq.1) then !not a rectangular magnet
              do iplan=1,iabs(ibpeplan(mag))
                bpetm(1,7,iplan,mag)=bpetm(3,8,iplan,mag)
              enddo
            endif

            call undumag_bpolyeder1(mag,x,y,z,hx,hy,hz,ifail)
            h=sqrt(hx**2+hy**2+hz**2)
            if (h.gt.2.0d0) then
              write(lun6,*)"*** Warning in undumag_proc: Strange H return by undumag_bpolyeder1 for wwmatrix(3...)"
              write(lun6,*)"imag,mag, hx,hy,hz",imag,mag,hx,hy,hz
            endif

            if (ifail.gt.0) then
              write(lun6,*)""
              write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
              write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,y,z
              write(lun6,*)""
            else if (ifail.lt.0) then
              irecover(ith)=irecover(ith)+1
            endif

            wwmatrix4(3,1,mag,imag)=hx
            wwmatrix4(3,2,mag,imag)=hy
            wwmatrix4(3,3,mag,imag)=hz

            if (ixsym.eq.0) then
              if (iysym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,z
                  write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)-hx
                wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)-hy
                wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)-hz
              endif
              if (izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,y,-z
                  write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)-hx
                wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)-hy
                wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)-hz
              endif
              if (iysym.ne.0.and.izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,-z
                  write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)+hx
                wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)+hy
                wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)+hz
              endif
            else !ixsym
              call undumag_bpolyeder1(mag,xcut,y,z,hx,hy,hz,ifail)
              if (ifail.gt.0) then
                write(lun6,*)""
                write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,y,z
                write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
              endif
              wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)+hx
              wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)+hy
              wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)+hz
              if (iysym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,z
                  write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)-hx
                wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)-hy
                wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)-hz
                call undumag_bpolyeder1(mag,xcut,-y,z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,-y,z
                  write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)-hx
                wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)-hy
                wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)-hz
              endif
              if (izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,y,-z
                  write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)-hx
                wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)-hy
                wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)-hz
                call undumag_bpolyeder1(mag,xcut,y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,y,-z
                  write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)-hx
                wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)-hy
                wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)-hz
              endif
              if (iysym.ne.0.and.izsym.ne.0) then
                call undumag_bpolyeder1(mag,x,-y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,x,-y,-z
                  write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)+hx
                wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)+hy
                wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)+hz
                call undumag_bpolyeder1(mag,xcut,-y,-z,hx,hy,hz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)""
                  write(lun6,*)"*** Warning in undumag_proc: Bad return of undumag_bpolyeder1:"
                  write(lun6,*)"mag1,mag2,x,y,z:",mag,imag,xcut,-y,-z
                  write(lun6,*)""
          else if (ifail.lt.0) then
            irecover(ith)=irecover(ith)+1
                endif
                wwmatrix4(3,1,mag,imag)=wwmatrix4(3,1,mag,imag)+hx
                wwmatrix4(3,2,mag,imag)=wwmatrix4(3,2,mag,imag)+hy
                wwmatrix4(3,3,mag,imag)=wwmatrix4(3,3,mag,imag)+hz
              endif
            endif !:(ixsym.eq.0) then
99          continue

          enddo ! magmag

+self,if=omp.
!$OMP END DO
!$OMP END PARALLEL
+self.
c          bpebc(4:6,imag)=bci
        enddo !imag

        do ith=2,nmaxth
          irecover(1)=irecover(1)+irecover(ith)
        enddo
        if (irecover(1).ne.0) then
          write(lun6,*)"*** Warning in undumag_proc: Recovered from ",irecover(1),
     &      " errors while calculating interaction matrix ***"
        endif

        deallocate(irecover)

        mark=mark+1

        call util_zeit_kommentar(lun6,"Matrix set up.")

        iumatrix=matrix

+self,if=matrixdeb.
        if (matrix.gt.1) then
          open(newunit=lun,file='undumag.mtr')
          do i=1,nmag
            do m=1,nmag
              write(lun,*)wwmatrix4(1:3,1:3,m,i)
            enddo
          enddo
          close(lun)
        endif
+self.

        if (matrix.gt.1) then
          open(newunit=lun,file='undumag_matrix.pst',form="unformatted")
          write(lun)kundurun,nmag
          do i=1,nmag
            do m=1,nmag
              write(lun)wwmatrix4(1:3,1:3,m,i)
            enddo
          enddo
          close(lun)
          call util_zeit_kommentar(lun6,"Matrix written to file undumag_matrix.pst.")
        endif

      else if (matrix.lt.0) then

        call util_zeit_kommentar(lun6,"Reading interaction matrix from undumag_matrix.pre")
        open(newunit=lun,file='undumag_matrix.pre',status='old',form="unformatted")
        read(lun)krunmatrix,mmag
        if (mmag.ne.nmag) then
          write(lun6,*)"*** Error in undumag_proc: Matrix of file undumag_matrix.mag does not match number of magnets ***"
          stop
        endif

        do i=1,mmag
          do k=1,mmag
            read(lun)wwmatrix4(1:3,1:3,k,i)
          enddo
        enddo
        close(lun)
        call util_zeit_kommentar(lun6,"Interaction matrix read")
        iumatrix=matrix

      endif !matrix.ne.0

      do imag=1,nmag
        bn=bc0(10,imag)
        bpebc(4:6,imag)=bc0(7:9,imag)*bn
        bpebc(7,imag)=bn
      enddo
c      bpebc(4:6,1:nmag)=bcc(1:3,1:nmag)
c      deallocate(bcc)

      do imag=1,nmag
        if(bpebc(8,imag).eq.1) then !not a rectangular magnet
          do iplan=1,ibpeplan(imag)
            bpetm(1,7,iplan,imag)=bpm(iplan,imag)
          enddo
        endif
      enddo

      magmag=0

      allocate(bc00(6,nmag))
      mark=mark+1

      do imag=1,nmag
+self,if=-bc00double.
        bc00(1,imag)=wwmatrix4(1,1,imag,imag)
        bc00(2,imag)=wwmatrix4(2,2,imag,imag)
        bc00(3,imag)=wwmatrix4(3,3,imag,imag)
+self,if=bc00double.
        nplan=iabs(ibpeplan(imag))

        x=bpebc(1,imag)/1000.0d0
        y=bpebc(2,imag)/1000.0d0
        z=bpebc(3,imag)/1000.0d0

        bc=bpebc(4:6,imag)
        magmag=imag

        bpebc(4,imag)=1.0d0
        bpebc(5,imag)=0.0d0
        bpebc(6,imag)=0.0d0
        bpetm(1,7,1:nplan,imag)=bpetm(1,8,1:nplan,imag)
        call undumag_bpolyeder1(imag,x,y,z,hx,hy,hz,ifail)
        bc00(1,imag)=hx

        if (hx.ne.hx) then
          write(lun6,*)"*** Warning in undumag_proc: Hx is not a number (NaN) ***"
          write(lun6,*)
     &        "kiter,iterirontot,imag,x,y,z:",
     &      kiter,iterirontot,imag,hx
        endif

        bpebc(4,imag)=0.0d0
        bpebc(5,imag)=1.0d0
        bpebc(6,imag)=0.0d0
        bpetm(1,7,1:nplan,imag)=bpetm(2,8,1:nplan,imag)
        call undumag_bpolyeder1(imag,x,y,z,hx,hy,hz,ifail)
        bc00(2,imag)=hy

        if (hy.ne.hy) then
          write(lun6,*)"*** Warning in undumag_proc: Hx is not a number (NaN) ***"
          write(lun6,*)
     &      "kiter,iterirontot,imag,x,y,z:",
     &      kiter,iterirontot,imag,hy
        endif

        bpebc(4,imag)=0.0d0
        bpebc(5,imag)=0.0d0
        bpebc(6,imag)=1.0d0
        bpetm(1,7,1:nplan,imag)=bpetm(3,8,1:nplan,imag)
        call undumag_bpolyeder1(imag,x,y,z,hx,hy,hz,ifail)
        bc00(3,imag)=hz

        if (hz.ne.hz) then
          write(lun6,*)"*** Warning in undumag_proc: Hx is not a number (NaN) ***"
          write(lun6,*)
     &      "kiter,iterirontot,imag,x,y,z:",
     &      kiter,iterirontot,imag,hz
        endif

        bpebc(4:6,imag)=bc
        bpetm(1,7,1:nplan,imag)=bpm(1:nplan,imag)

        if (kpreset.eq.0) bpebc(4:6,imag)=0.0d0

        if(bpebc(8,imag).eq.1) then !not a rectangular magnet
          vmaglab(1:3)=bpebc(4:6,imag)
          do iplan=1,iabs(ibpeplan(imag))
            bpetm(1,7,iplan,imag)=
     &        vmaglab(1)*bpetm(1,8,iplan,imag)+
     &        vmaglab(2)*bpetm(2,8,iplan,imag)+
     &        vmaglab(3)*bpetm(3,8,iplan,imag)
          enddo
        endif
+self. if=bc00double.
      enddo !nmag

      call undumag_bconv(h)

      call util_zeit_kommentar(lun6,"Starting relaxation.")

      mark=mark+1

      halt=0.0d0
      xin(1)=0.0d0
      xin(2)=1.0d0
      xin(3)=2.0d0
      do kiter=1,maxiter

        if (niron.gt.0) then
          if (kesti.gt.0) then
            bciron(1:3,1:niron)=bciron(4:6,1:niron)
            bciron(4:6,1:niron)=bciron(7:9,1:niron)
            bciron(7:9,1:niron)=bpebc(4:6,nrec+1:nrec+niron)
            if(kiter.ge.kesti) then
              do imag=nrec+1,nrec+niron
                do i=1,3
                  yin(1)=bciron(i,imag)
                  yin(2)=bciron(i+3,imag)
                  yin(3)=bciron(i+6,imag)
                  call util_parabel(xin,yin,a,yp,xopt,yopt,ifail)
                  if (ifail.eq.0) then
                    bpebc(3+i,nrec+1:nrec+niron)=a(1)+a(2)*3.0d0+a(3)*9.0d0
                  endif
                enddo
              enddo
            endif
          endif
          call undumag_relax_iron
        endif

        if (kiter.lt.maxiter.or.niron.eq.0) call undumag_relax_rec

        iprint=0
        if (kprint.gt.0) then
          if (mod(kiter,kprint).eq.0.or.kiter.eq.1.or.kiter.eq.maxiter) iprint=1
        endif

        kinside=0

        if (iprint.eq.1.or.kiter.eq.1) then
          h=0.0d0
          call undumag_bconv(h)
c        write(lun6,*)"proc: kiter,h:",kiter,h
          kconv=0
          if (halt.ne.0.0d0) then
            dh=(h/halt)-1.0d0
          else
            dh=0.0d0
          endif
          hconvr=abs(dh)
        endif

        if (iprint.ne.0.and.halt.ne.0.0d0) then

          call undumag_residuals_iron

          if (niron.gt.0.and.kresiron.ne.0) then
            if (kresiron.eq.1.and.hresidiron.le.resiron) goto 9999
          endif

          if (hconvr.lt.hconva) then
            print '(a,3I6,a,3g13.5)',"kiter, niterrec, niteriron, Hold, H, (H-Hold)/Hold:",
     &        kiter,niterrec,niteriron," ",halt,h,(h-halt)/halt
            if (dampfac.eq.0.0d0) then
              nconv=nconv+1
              if (nconv.ge.3) then
                if (kresiron.eq.2.and.hresidiron.le.resiron.or.
     &            kresiron.eq.0.or.niron.eq.0) goto 9999
              endif
            else
              dampiron=dampiron*dampfac
              hconva=min(hconvbase*exp(log(dampiron)*hconvexp),hconva)
c              maxiteriron=(log(0.0001)/log(1.0d0-dampiron)+1)
              if (hconva.lt.1.0d-10) then
                print '(a,3I6,a,3g13.5)',"kiter, niterrec, niteriron, Hold, H, (H-Hold)/Hold:",
     &            kiter,niterrec,niteriron," ",halt,h,(h-halt)/halt
                if (kresiron.eq.2.and.hresidiron.le.resiron.or.
     &            kresiron.eq.0) goto 9999
              endif
              write(lun6,*)"dampiron, hconv:",dampiron,hconva
            endif
          else if  (kiter.gt.2.and.hconv.lt.-1000.0d0.and.
     &        (dh.gt.0.0d0.and.dho.lt.0.0d0
     &        .or.
     &        dh.lt.0.0d0.and.dho.gt.0.0d0)
     &        ) then
            print '(a,3I6,a,3g13.5)',
     &        "kiter, niterrec, niteriron, Hold, H, (H-Hold)/Hold:",
     &        kiter,niterrec,niteriron," ",halt,h,(h-halt)/halt
            if (kresiron.eq.2.and.hresidiron.le.resiron.or.
     &        kresiron.eq.0) goto 9999
          else if  (kiter.gt.2.and.hconv.lt.0.0d0.and.hconv.gt.-1000.0d0.and.hconvr.ge.hconvo) then
            print '(a,3I6,a,3g13.5)',
     &        "kiter, niterrec, niteriron, Hold, H, (H-Hold)/Hold:",
     &        kiter,niterrec,niteriron," ",halt,h,(h-halt)/halt
            if (kresiron.eq.2.and.hresidiron.le.resiron.or.
     &        kresiron.eq.0) goto 9999
          else if (iprint.ne.0.or.kiter.eq.maxiter) then
            print '(a,3I6,a,3g13.5)',"kiter, niterrec, niteriron, Hold, H, (H-Hold)/Hold:",
     &        kiter,niterrec,niteriron," ",halt,h,(h-halt)/halt
          endif
        else if (iprint.ne.0 ) then
          print '(a,3I6,a,3g13.5)',"kiter, niterrec, niteriron, H:",
     &      kiter,niterrec,niteriron," ",h
        endif

        if (niron.gt.0.and.iprint.ne.0.and.kiter.gt.1) write(lun6,*)"RMS of iron residuals:",sngl(hresidiron)

        if (iprint.ne.0.and.kdumpconv.ne.0) then
          inquire(file="undumag.sta",exist=lexist)
          if (lexist.eqv..false.) then
            konv=-1
            write(lun6,*)"------------------------------------------------------------"
            call util_zeit_kommentar(lun6,"Aborted since file undumag.sta is missing!")
            open(newunit=lunst,file="undumag.sta")
            write(lunst,*)kundurun,konv,iwarnsum
            write(lunst,*)"Aborted by user!"
            close(lunst)
            return
          endif

          open(newunit=lunst,file="undumag.sta")
          write(lunst,*)kundurun,konv,iwarnsum
          write(lunst,*)"undumag_proc"
          if (halt.eq.0.0d0) then
            write(lunst,'(a,3I6,a,4g13.5)') "kiter, niterrec, niteriron, dampiron, H:",
     &        kiter,niterrec,niteriron," ",dampiron,h
          else
            write(lunst,'(a,3I6,a,4g13.5)') "kiter, niterrec, niteriron, (H-Hold)/Hold:",
     &        kiter,niterrec,niteriron," ",dampiron,(h-halt)/halt
          endif
          close(lunst)
        endif !(kdumpconv.ne.0) then

        if (iprint.ne.0) then
          hconvo=hconvr
          dho=dh
        endif

        if (dampirono.lt.0.0d0) then
          if (dh.gt.0) then
            dampiron=dampiron+(1.0d0-dampiron)*0.001d0
          else
            dampiron=dampiron/10.0d0
            dampirono=9999.0d0
          endif
          write(lun6,*)"dampiron adapted:",sngl(dampiron)
        endif

        if (iprint.ne.0) then
          inquire(file="undumag.sta",exist=lexist)
          if (lexist.eqv..false.) then
            konv=-1
            write(lun6,*)"------------------------------------------------------------"
            call util_zeit_kommentar(lun6,"Aborted since file undumag.sta is missing!")
            open(newunit=lunst,file="undumag.sta")
            write(lunst,*)kundurun,konv,iwarnsum
            write(lunst,*)"Aborted by user!"
            close(lunst)
            return
          endif
          iprint=0
        endif

        if (halt.ne.0.0d0.and.niron.eq.0) then
          if (abs(h/halt-1.0d0).lt.hconva) then
            print '(a,3I6,a,3g13.5)',"kiter, niterrec, niteriron, Hold, H, (H-Hold)/Hold:",
     &        kiter,niterrec,niteriron," ",halt,h,(h-halt)/halt
            goto 9999
          endif
        endif

        halt=h
      enddo !iter

9999  continue
c      deallocate(bc00)
      deallocate(bc0)
      deallocate(bpm)

99999 continue

      if (kiter.ge.maxiter) then
        konv=0
        write(lun6,*)"------------------------------------------------------------"
        call util_zeit_kommentar(lun6,"Relaxation finished, since max. number of iterations reached.")
        open(newunit=lunst,file="undumag.sta")
        write(lunst,*)kundurun,konv,iwarnsum
        write(lunst,*)"Maximum number of iterations reached!"
        close(lunst)
      else
        konv=1
        write(lun6,*)"------------------------------------------------------------"
        call util_zeit_kommentar(lun6,"Relaxation finished, convergence reached.")
        open(newunit=lunst,file="undumag.sta")
        write(lunst,*)kundurun,konv,iwarnsum
        write(lunst,*)"Convergence reached!"
        close(lunst)
      endif

      write(lun6,*)"Total number of iterations for magnets and poles:",
     &  iterrectot,iterirontot
      write(lun6,*)"------------------------------------------------------------"

      deallocate(bciron)

      return
      end
+DECK,undumag_end.
*CMZ :  2.04/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  16.57.37  by  Michael Scheer
*CMZ :  2.04/01 20/01/2023  13.43.13  by  Michael Scheer
*CMZ :  2.04/00 16/01/2023  14.39.15  by  Michael Scheer
*CMZ :  2.03/00 01/09/2022  10.41.39  by  Michael Scheer
*CMZ :  2.02/02 26/02/2022  12.52.35  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 29/03/2021  09.45.50  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.14.56  by  Michael Scheer
*CMZ :  2.01/05 05/06/2020  17.09.33  by  Michael Scheer
*CMZ :  2.01/04 29/07/2019  12.05.13  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.25.31  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  16.20.58  by  Michael Scheer
*CMZ :  2.00/03 19/04/2018  11.05.57  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  13.46.37  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  16.46.42  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  11.15.27  by  Michael Scheer
*CMZ :  1.25/03 03/04/2018  08.01.24  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.03.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.17.42  by  Michael Scheer
*CMZ :  1.25/00 14/03/2018  12.58.50  by  Michael Scheer
*CMZ :  1.24/01 13/10/2017  11.37.28  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  14.05.37  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.07.37  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  15.55.08  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.18.42  by  Michael Scheer
*CMZ :  1.22/02 04/08/2017  07.56.26  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.55.33  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.09.09  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  15.38.45  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.35.35  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  16.39.29  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.15.48  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.22.03  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  16.12.25  by  Michael Scheer
*CMZ :  1.18/00 02/06/2017  09.38.06  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  15.20.49  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  08.36.20  by  Michael Scheer
*CMZ :  1.17/06 18/05/2017  22.30.31  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  15.55.38  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  17.57.38  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.15.17  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  09.01.37  by  Michael Scheer
*CMZ :  1.15/07 04/04/2017  13.49.11  by  Michael Scheer
*CMZ :  1.15/05 03/04/2017  13.40.53  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.57.38  by  Michael Scheer
*CMZ :  1.15/03 02/04/2017  15.45.35  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.38.56  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  15.25.06  by  Michael Scheer
*CMZ :  1.15/00 27/03/2017  15.13.40  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  14.39.06  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.16.46  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.26.29  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.53.52  by  Michael Scheer
*CMZ :  1.11/04 23/01/2017  17.22.15  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.28  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.48.13  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.22.30  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.52.38  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.18.26  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.45.21  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.30.02  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.49.21  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.57.45  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.31.52  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  14.13.49  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  15.30.08  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  12.45.07  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.03.06  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.37.39  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  11.57.51  by  Michael Scheer
*CMZ :  0.00/11 18/07/2016  09.18.11  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.57.35  by  Michael Scheer
*CMZ :  0.00/09 28/06/2016  15.42.08  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/05 13/06/2016  12.45.02  by  Michael Scheer
*CMZ :  0.00/02 30/04/2016  13.12.13  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.02.34  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  15.51.06  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.38.32  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.40.54  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  15.11.21  by  Michael Scheer
*CMZ :  1.17/03 22/03/2016  07.59.20  by  Michael Scheer
*CMZ :  1.17/02 07/03/2016  16.32.54  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_end

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

+seq,seqdebug.
+seq,random.

      double precision, dimension (:,:,:,:), allocatable :: bmap
      double precision, dimension (:,:), allocatable :: hmvoxel,hmagvox
      double precision, dimension (:), allocatable ::
     &  xint,bxa,bya,bza,
     &  byint,bzint,byint2,bzint2,
     &  xinti,byai,bzai,
     &  byinti,bzinti,byint2i,bzint2i,
     &  xintnor,bxanor,byanor,bzanor,
     &  byintnor,bzintnor,byint2nor,bzint2nor,
     &  xintd,bxad,byad,bzad,
     &  byintd,bzintd,byint2d,bzint2d,
     &  ws1,ws2,ws3,ws4,coef

      double precision :: retval,undumag_variable_getval,br

      integer, dimension (:), allocatable :: kfailbyeff,kfailbzeff,kfailon

      double precision x,y,z,bx,by,bz,hx,hy,hz,bcx,bcy,bcz,b,bprog,h,
     &  bc,dx,dy,dz,vmaglab(3),a(3),xopt,yopt,yint,zint,
     &  xminbeff,xmaxbeff,dkeffzd,
     &  bymaxbeff,bzmaxbeff,xbymax,xbzmax,xbeffo,
     &  beffd,beffzd,dkeffd,xmaxbeffnor,xminbeffnor,
     &  yp(3),bp(3),dum,bmaxp,
     &  bmaxbeffd,bmnbeffd,bmxbeffd,bmnbeffzd,bmxbeffzd,
     &  y2z2,py,pz,pryz,zr,yr,cosa,sina,
     &  xx,yy,zz,quadperlen,halfperlen,dxkbmode,bdx,bdy,bdz,x3(3),b3(3),a3(3),
     &  zmin,
     &  byif,bzif,bcrecmax,bcrecmin,bcironmax,bcironmin,bn,
     &  hcon,easy(3),easyn

      double precision :: bxexint=0.0d0, byexint=0.0d0, bzexint=0.0d0

      real g(3),xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &  dxpl,dypl,dzpl,xpl(2),ypl(2),zpl(2),
     &  bzplmin,bzplmax,bziplmin,bziplmax,bziiplmin,bziiplmax,
     &  byplmin,byplmax,byiplmin,byiplmax,byiiplmin,byiiplmax,
     &  s0min,s1min,s2min,s3min,s0,s1,s2,s3,
     &  s0max,s1max,s2max,s3max,xlaboff,ylaboff,brn,
     &  zppl(1000),bypl(1000),bzpl(1000),hbmatmin,hbmatmax,
     &  bcmaxrec,bcminrec,hmaxrec,hminrec,hmaxiron

      integer luninf,luni,lun,kfail,ifail77,ifail,imoth,iron,imag,ix,iy,iz,
     &  matmap2,matmap3,n,lunmag,lunst,lunmat,
     &  lunpost,idis,mat,mtyp,imat,
     &  iplan,nplan,i,ibmax,ixon,ixonnor,
     &  itry,ixbeff,ixbeffnor,nfirst,nlast,lunkill,irecover,
     &  lunw,icorn,ncorn,nper,ibrn,kbrn,kx

      integer :: jcharge=-1,nthstep=1

      integer nstepp,nphp,npawp
      parameter (nstepp=1000000,nphp=10001,npawp=10000)

      double precision
     &  gammai,dgamtot,powden,xexit,yexit,zexit,
     &  traxyz(14,nstepp),
     &  phener(nphp),stokes(4,nphp),vnxex,vnyex,vnzex,texit,
     &  byint1f,bzint1f,byint2f,bzint2f,
     &  byint1fnor,bzint1fnor,byint2fnor,bzint2fnor,
     &  byint1fd,bzint1fd,byint2fd,bzint2fd,
     &  bxint1inf,byint1inf,bzint1inf,byi,bzi,byint1infd,bzint1infd

      complex*16 aradx(nphp),arady(nphp),aradz(nphp)

      integer ndim,istatus,ifreq,istep,lunz,nz
      real hpaw(npawp)
      common/pawc/hpaw

+seq,mshplt.
+seq,phyconparam.

      character(64) ctitle,chtime,chrun
      character(24) cbint

      save

      call  util_random_get_seed(irnsize,irnseed)

      hcon=9999.0d0
      if (halt.ne.0.0d0) then
        call undumag_bconv(hcon)
        hcon=(hcon-halt)/halt
      endif

      open(newunit=lunst,file="undumag.sta")
      write(lunst,*)kundurun,konv,iwarnsum, kiter,iterrectot,iterirontot,hresidiron,hcon
      if (konv.eq.1) then
        write(lunst,*)"Convergence reached"
      else if (konv.eq.0) then
        if (maxiter.eq.0) then
          write(lunst,*)"No iterations done due to maxiter=0"
        else
          write(lunst,*)"Maximum number of iterations reached"
        endif
      else
        write(lunst,*)"Terminated with problems"
      endif

      write(lunst,*)"undumag_end"

      flush(lunst)
      close(lunst)

      if (krunnum.ne.0) then
        write(chrun,*)kundurun
        if (usercom.ne.'') then
          ctitle=trim(usercom)//", Run: "//trim(chrun)
        else
          ctitle=", Run: "//trim(chrun)
        endif
      else
        ctitle=trim(usercom)
      endif

      nowarnugv=1
      retval=undumag_variable_getval("nPeriods")
      if (retval.ne.-9999.0d29) then
        nper=nint(retval)
      else
        nper=-1
      endif
      nowarnugv=0

      call util_zeit_kommentar(lun6,"Writing undumag.mh")

      open(newunit=lunmag,file="undumag.mh")
      write(lunmag,'(a)') '* ' // ctitle

      if (maxiter.eq.0.and.kpreset.eq.0) goto 9999

      if (nmag.eq.0.and.kbextern.eq.0.and.ncwires.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_end: Returning, since there are no magnetic items ***"
        write(lun6,*)
        goto 9999
      endif

      if (maxiter.gt.1) then

        call util_zeit_kommentar(lun6,"Writing undumag.pst")

        open(newunit=lunpost,file='undumag.pst')

        bcrecmax=-1.0d30
        bcrecmin=+1.0d30
        bcironmax=-1.0d30
        bcironmin=1.0d30

        if (nrec.eq.0) then
          bcrecmax=+0.0d0
          bcrecmin=-0.0d0
        endif
        if (niron.eq.0) then
          bcironmax=+0.0d0
          bcironmin=-0.0d0
        endif

        do imag=1,nmag

          bn=sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)

          if (imag.le.nrec) then
            if (bn.gt.bcrecmax) bcrecmax=bn
            if (bn.lt.bcrecmin) bcrecmin=bn
          else
            if (bn.gt.bcironmax) bcironmax=bn
            if (bn.lt.bcironmin) bcironmin=bn
          endif

          nplan=ibpeplan(imag)
          write(lunpost,*)nplan,bpebc(1:17,imag)
          do iplan=1,nplan
            write(lunpost,*)bpemag(1:3,1,iplan,imag),
     &        bpetm(1:3,8,iplan,imag)
          enddo !iplan

        enddo
        flush(lunpost)
        close(lunpost)

      endif !(maxiter.gt.0) then

      if (maxiter.gt.0.and.maxiteriron.gt.0) call undumag_residuals_iron

      write(lun6,*)
      write(lun6,*)"File undumag.pst written."
      write(lun6,*)

      write(lun6,*)
      write(lun6,*)"Minimum and maximum magnetization of magnets:",
     &  sngl(bcrecmin),sngl(bcrecmax)
      write(lun6,*)"Minimum and maximum magnetization of iron:",
     &  sngl(bcironmin),sngl(bcironmax)
      write(lun6,*)
      write(lun6,*)"RMS of iron magnetization residuals:",
     &  sngl(hresidiron)
      write(lun6,*)

      if (nxbeff.lt.5) nxbeff=5

      allocate (
     &  kfailbyeff(nxbeff),kfailbzeff(nxbeff),kfailon(nxmap),
     &  xintnor(nxmap),
     &  byintnor(nxmap),bzintnor(nxmap),
     &  byint2nor(nxmap),bzint2nor(nxmap),
     &  xint(nxmap),
     &  byint(nxmap),bzint(nxmap),
     &  byint2(nxmap),bzint2(nxmap),
     &  xintd(nxmap),
     &  byintd(nxmap),bzintd(nxmap),
     &  byint2d(nxmap),bzint2d(nxmap),
     &  bxa(nxmap),bya(nxmap),bza(nxmap),
     &  bxanor(nxmap),byanor(nxmap),bzanor(nxmap),
     &  bxad(nxmap),byad(nxmap),bzad(nxmap),
     &  ws1(nxmap),ws2(nxmap),ws3(nxmap),ws4(nxmap),coef(nxmap))

      if (nmag.eq.0.and.ncwires+nrace.eq.0.and.kbextern.eq.0) then
        xmapmin=0.1
        xmapmax=0.1
      endif

      if (nxmap.gt.1) then
        dx=(xmapmax-xmapmin)/(nxmap-1)
        x=xmapmin-dx
      else
        xmapmin=(xmapmax+xmapmin)/2.0d0
        dx=0.0d0
      endif

      if (nymap.gt.1) then
        dy=(ymapmax-ymapmin)/(nymap-1)
        y=ymapmin-dy
      else
        ymapmin=(ymapmax+ymapmin)/2.0d0
        dy=0.0d0
      endif

      if (nzmap.gt.1) then
        dz=(zmapmax-zmapmin)/(nzmap-1)
        z=zmapmin-dz
      else
        zmapmin=(zmapmax+zmapmin)/2.0d0
        dz=0.0d0
      endif

      if (kbextern.ne.0) then
        bxexint=bxex*(xmapmax-xmapmin)
        byexint=byex*(xmapmax-xmapmin)
        bzexint=bzex*(xmapmax-xmapmin)
      endif

      if (idipoles.ne.0) then
        call util_zeit_kommentar(lun6,"Calculating dipole map")
        do ix=1,nxmap
          x=xmapmin+(ix-1)*dx
          xintd(ix)=x
          call undumag_dipoles_field(x/1000.0d0,0.0d0,0.0d0,
     &      bxad(ix),byad(ix),bzad(ix),ifail)
          if (ifail.gt.0) then
            write(lun6,*)"Undumag_dipoles_field returned failure for on-axis field at point ",
     &        ix,x,y,z
          endif
        enddo
      endif !(idipoles.ne.0) then

      if (intmaglis.ne.0) then

        if (idipoles.ne.0) then
          do imag=1,ndipoles
            if (dipoles(8,imag).ne.0.0d0) then
              if (dipoles(8,imag).eq.2.0d0) then
                dipoles(4,imag)=-dipoles(4,imag)
              endif
            else
              dipoles(8,imag)=-1.0d0
            endif
          enddo
        endif !(idipoles.ne.0) then

        do imag=1,nmag
          if (bpebc(17,imag).ne.0.0d0) then
            if (bpebc(17,imag).eq.2.0d0) then
              bpebc(4:6,imag)=-bpebc(4:6,imag)
              if(bpebc(8,imag).eq.1) then !not rectangular nor cylindrical magnet
                vmaglab(1:3)=bpebc(4:6,imag)
                nplan=iabs(ibpeplan(imag))
                do iplan=1,nplan
                  bpetm(1,7,iplan,imag)=
     &              vmaglab(1)*bpetm(1,8,iplan,imag)+
     &              vmaglab(2)*bpetm(2,8,iplan,imag)+
     &              vmaglab(3)*bpetm(3,8,iplan,imag)
                enddo
              endif
            endif
          else
            bpebc(17,imag)=-1.0d0
          endif
        enddo
      endif

      x=xmapmin-dx
      ixon=0
      ixonnor=0
      irecover=0
      itry=0

      call util_zeit_kommentar(lun6,"Calculating on-axis field")

      do ix=1,nxmap
        idis=0
11      x=xmapmin+(ix-1)*dx
        ! to avoid boundary effects:
        call util_random(3,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif

        if (itry.eq.0.and.randoz.gt.0.0d0) g=0.

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        xint(ix)=x

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif

        if (randoz.ge.0.0d0) then
          z=g(3)*randoza
        else
          z=randoza
        endif

        ifail=0
        kkfail=0

        if (itry.eq.0) ifail=-1

        call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &    bxa(ix),bya(ix),bza(ix),ifail)

        if (itry.eq.0.and.ifail.eq.-1) then
          ifail=0
        endif

        if (ifail.ne.0) kkfail=ifail

        b=sqrt(bxa(ix)**2+bya(ix)**2+bza(ix)**2)

        ifail77=0

        if (ix.gt.2) then
          call util_parabel(xint(ix-2),bxa(ix-2),
     &      a,yp,xopt,yopt,kfail)
          if (kfail.eq.0) then
            bx=a(1)+a(2)*x+a(3)*x*x
          else
            ifail77=77
          endif
          if (ifail.ne.0) kkfail=ifail
          call util_parabel(xint(ix-2),bya(ix-2),
     &      a,yp,xopt,yopt,kfail)
          if (kfail.eq.0) then
            by=a(1)+a(2)*x+a(3)*x*x
          else
            ifail77=77
          endif
          if (ifail.ne.0) kkfail=ifail
          call util_parabel(xint(ix-2),bza(ix-2),
     &      a,yp,xopt,yopt,kfail)
          if (kfail.eq.0) then
            bz=a(1)+a(2)*x+a(3)*x*x
          else
            ifail77=77
          endif
          if (ifail.ne.0) kkfail=ifail
          bprog=sqrt(bx*bx+by*by+bz*bz)
          if (bprog.gt.1.0d-9.and.abs((b-bprog)/(b+bprog)).gt.rcvthron) then
            ifail77=77
          endif
        endif

        if (bprog.gt.1.0d-9.and.ifail77.eq.77.and.idis.eq.0) then
          write(lun6,*)"Discontinuity or numerical problems for on-axis field discovered, check rcvthron, x, dB, randox etc."
          write(lun6,*)"x, B, Bexpected, dB:",x,b,bprog,abs((b-bprog)/(b+bprog))
          idis=1
        endif

        if (ifail.ne.0.and.itry.lt.10) then
          itry=itry+1
          goto 11
        endif
        itry=0

        if (ifail.gt.0) then
          write(lun6,*)"Undumag_field returned failure for on-axis field at point ",
     &      ix,x,y,z
        else
          if (ifail.lt.0) then
            irecover=irecover+1
          endif
          ixon=ixon+1
          kfailon(ixon)=ifail
          if (ifail.eq.0) then
            ixonnor=ixonnor+1
            xintnor(ixonnor)=xint(ix)
            bxanor(ixonnor)=bxa(ix)
            byanor(ixonnor)=bya(ix)
            bzanor(ixonnor)=bza(ix)
          endif
          xint(ixon)=xint(ix)
          bxa(ixon)=bxa(ix)
          bya(ixon)=bya(ix)
          bza(ixon)=bza(ix)
        endif
      enddo !ix

      if (irecover.ne.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_end:  On-axis field calculations with ",irecover, " recovered errors ***"
        write(lun6,*)
c        do ix=1,ixon
c          if (kfailon(ix).ne.0) then
c            write(lun6,*)ix,xint(ix),bya(ix),bza(ix)
c          endif
c        enddo
c        write(lun6,*)
      endif
      if (ixon.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_end: No field data on-axis calculated ***"
        write(lun6,*)
      endif

      if (ixonnor.gt.1) then

        if (isimpson.eq.0) then
          call util_spline_running_integral(xintnor,byanor,ixonnor,byintnor,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xintnor,bzanor,ixonnor,bzintnor,coef,
     &      ws1,ws2,ws3,ws4)

          call util_spline_running_integral(xintnor,byintnor,ixonnor,
     &      byint2nor,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xintnor,bzintnor,ixonnor,
     &      bzint2nor,coef,
     &      ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixonnor,xintnor,byanor,byintnor)
          call util_simpson_running_integral(ixonnor,xintnor,bzanor,bzintnor)
          call util_simpson_running_integral(ixonnor,xintnor,byintnor,byint2nor)
          call util_simpson_running_integral(ixonnor,xintnor,bzintnor,bzint2nor)
        endif

      endif

      if (ixon.gt.1) then

        if (isimpson.eq.0) then
          call util_spline_running_integral(xint,bya,ixon,byint,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xint,bza,ixon,bzint,coef,
     &      ws1,ws2,ws3,ws4)

          call util_spline_running_integral(xint,byint,ixon,byint2,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xint,bzint,ixon,bzint2,coef,
     &      ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixon,xint,bya,byint)
          call util_simpson_running_integral(ixon,xint,bza,bzint)
          call util_simpson_running_integral(ixon,xint,byint,byint2)
          call util_simpson_running_integral(ixon,xint,bzint,bzint2)
        endif

      endif !ixon

      if (idipoles.ne.0) then
        if (nxmap.gt.0.and.maxiter.gt.0) then
          if (isimpson.eq.0) then
            call util_spline_running_integral(xintd,byad,nxmap,byintd,coef,
     &        ws1,ws2,ws3,ws4)
            call util_spline_running_integral(xintd,bzad,nxmap,bzintd,coef,
     &        ws1,ws2,ws3,ws4)

            call util_spline_running_integral(xintd,byintd,nxmap,byint2d,coef,
     &        ws1,ws2,ws3,ws4)
            call util_spline_running_integral(xintd,bzintd,nxmap,bzint2d,coef,
     &        ws1,ws2,ws3,ws4)
          else
            call util_simpson_running_integral(nxmap,xintd,byad,byintd)
            call util_simpson_running_integral(nxmap,xintd,bzad,bzintd)
            call util_simpson_running_integral(nxmap,xintd,byintd,byint2d)
            call util_simpson_running_integral(nxmap,xintd,bzintd,bzint2d)
          endif
        endif !nxmap
      endif !(idipoles.ne.0) then

      byplmin=1.0e30
      byplmax=-1.0e30
      byiplmin=1.0e30
      byiplmax=-1.0e30
      byiiplmin=1.0e30
      byiiplmax=-1.0e30
      bzplmin=1.0e30
      bzplmax=-1.0e30
      bziplmin=1.0e30
      bziplmax=-1.0e30
      bziiplmin=1.0e30
      bziiplmax=-1.0e30

c Calculate on-axis field{
      open(newunit=lun,file="undumag_on-axis.dat")

      if (ixon.gt.1) then

        do ix=1,ixon
          if (bza(ix).lt.bzplmin) bzplmin=sngl(bza(ix))
          if (bza(ix).gt.bzplmax) bzplmax=sngl(bza(ix))
          if (bzint(ix).lt.bziplmin) bziplmin=sngl(bzint(ix))
          if (bzint(ix).gt.bziplmax) bziplmax=sngl(bzint(ix))
          if (bzint2(ix).lt.bziiplmin) bziiplmin=sngl(bzint2(ix))
          if (bzint2(ix).gt.bziiplmax) bziiplmax=sngl(bzint2(ix))
          if (bya(ix).lt.byplmin) byplmin=sngl(bya(ix))
          if (bya(ix).gt.byplmax) byplmax=sngl(bya(ix))
          if (byint(ix).lt.byiplmin) byiplmin=sngl(byint(ix))
          if (byint(ix).gt.byiplmax) byiplmax=sngl(byint(ix))
          if (byint2(ix).lt.byiiplmin) byiiplmin=sngl(byint2(ix))
          if (byint2(ix).gt.byiiplmax) byiiplmax=sngl(byint2(ix))
          write(lun,'(7(1pe17.7e3)," ",I10)')xint(ix),
     &      bya(ix),bza(ix),
     &      byint(ix),bzint(ix),
     &      byint2(ix),bzint2(ix),kfailon(ix)
        enddo

      else !ixon
        write(lun,*) "0. 0. 0. 0. 0. 0. 0. 0."
      endif !ixon

      flush(lun)
      close(lun)

c Calculate on-axis field}

      if (idipoles.ne.0) then

        open(newunit=lun,file="undumag_on-axis_dipoles.dat")

        if (nxmap.gt.1) then

          do ix=1,nxmap
            write(lun,'(10(1pe17.7e3))')xintd(ix),
     &        byad(ix),bzad(ix),
     &        byintd(ix),bzintd(ix),
     &        byint2d(ix),bzint2d(ix)
          enddo

        else !ixon
          write(lun,*) "0. 0. 0. 0. 0. 0. 0."
        endif !ixon

        flush(lun)
        close(lun)

      endif !(idipoles.ne.0) then

c Calculate field map{

      call util_zeit_kommentar(lun6,"Calculating field map")

      open(newunit=lun,file="undumag.map")

      if (knointmap.eq.0) then
        open(newunit=luni,file="undumag_integral.map")
        call util_zeit_kommentar(lun6,"Writing undumag.map and undumag_integral.map")
      else
        call util_zeit_kommentar(lun6,"Writing undumag.map")
      endif

      if (kmapnohead.eq.0) then
        call util_time_and_date(chtime)
        if (kmapmode.eq.0) then
          write(lun,'(a)') '* ' // trim(ctitle)
          write(lun,'(a)')"* " // trim(chtime)
          write(lun,'(a)')"* imoth imag mat ityp matmod x/mm y/mm z/mm Bx/T By/T Bz/T B/T Hx/T Hy/T Hz/T H/T Mx/T My/T Mz/T M/T BxDip/T ByDip/T BzDip/T ifail kfail"
        else
          write(lun,'(a)') '* ' // trim(ctitle)
          write(lun,'(a)')"* " // trim(chtime)
          write(lun,'(a)')"* x/mm y/mm z/mm Bx/T By/T Bz/T ifail kfail"
          write(lun,'(a)')"* scaling = 0.001 0.001 0.001 1.0 1.0 1.0 for WAVE"
        endif
        if (knointmap.eq.0) then
          write(luni,'(a)')"* xi/mm xe/mm y/mm z/mm ByInt1/Tmm BzInt1/Tmm ByInt2/Tmm**2 BzInt2/Tmm**2"
        endif
      endif

      if (nxmap*nymap*nzmap.le.0) then
        x=0.0d0
        y=0.0d0
        z=0.0d0
        bx=0.0d0
        by=0.0d0
        bz=0.0d0
        b=0.0d0
        hx=0.0d0
        hy=0.0d0
        hz=0.0d0
        h=0.0d0
        bcx=0.0d0
        bcy=0.0d0
        bcz=0.0d0
        bc=0.0d0
        if (kmapmode.eq.0) then
          write(lun,*)"0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0"
        else
          write(lun,*)"0.0 0.0 0.0 0.0 0.0 0.0"
        endif

      else !(nxmap*nymap*nzmap.le.0) then

        irecover=0
        x=xmapmin-dx
        itry=0
        kkfail=0

        if (knointmap.eq.0) then
          allocate(xinti(nxmap),byai(nxmap),bzai(nxmap),
     &      byinti(nxmap),bzinti(nxmap),
     &      bmap(4,nxmap,nymap,nzmap),
     &      byint2i(nxmap),bzint2i(nxmap)
     &      )
        endif

        do ix=1,nxmap
          x=x+dx
          y=ymapmin-dy
          do iy=1,nymap
            y=y+dy
            z=zmapmin-dz
            do iz=1,nzmap
              z=z+dz
              if (knomagmap.eq.0.or.knopolmap.eq.0) then
                kinside=-1
              else
                kinside=0
              endif
14            call util_random(3,g)
              g=g-0.5
              if (abs(g(1)).lt.randox10) then
                if (g(1).gt.0.0d0) then
                  g(1)=g(1)+randox10
                else
                  g(1)=g(1)-randox10
                endif
              endif
              if (abs(g(2)).lt.randoy10) then
                if (g(2).gt.0.0d0) then
                  g(2)=g(2)+randoy10
                else
                  g(2)=g(2)-randoy10
                endif
              endif
              if (abs(g(3)).lt.randoz10) then
                if (g(3).gt.0.0d0) then
                  g(3)=g(3)+randoz10
                else
                  g(3)=g(3)-randoz10
                endif
              endif
              if (itry.eq.0.and.randoz.gt.0.0d0) g=0.
              if (randox.ge.0.0d0) then
                xx=x+g(1)*randoxa ! millimeter!
              else
                xx=x+randoxa ! millimeter!
              endif
              if (randoy.ge.0.0d0) then
                yy=y+g(2)*randoya
              else
                yy=y+randoya
              endif
              if (randoz.ge.0.0d0) then
                zz=z+g(3)*randoza
              else
                zz=z+randoza
              endif
              if (angmaprotx.ne.0.0d0) then
                yr=yy-cenmaprotxy
                zr=zz-cenmaprotxz
                cosa=cos(angmaprotx)
                sina=sin(angmaprotx)
                zz=cosa*zr-sina*yr+cenmaprotxz
                yy=sina*zr+cosa*yr+cenmaprotxy
              endif
c              if (ix.eq.70) iseqdebug=1

              ifail=0
              if (itry.eq.0) ifail=-1

              call undumag_field(xx/1000.0d0,yy/1000.0d0,zz/1000.0d0,
     &          hx,hy,hz,ifail)

              if (itry.eq.0.and.ifail.eq.-1) then
                ifail=0
              endif

              if (ifail.ne.0) kkfail=ifail
              if (ifail.eq.-20000) ifail=0 ! inside magnet
              if (ifail.ne.0.and.itry.lt.10) then
                itry=itry+1
                goto 14
              endif
              itry=0
              if (ifail.gt.0) then
                write(lun6,*)"Undumag_field returned failure at point: ",xx,yy,zz
              else if (ifail.lt.0) then
                irecover=irecover+1
              endif
c              write(lun6,*)"field:",ix,iy,iz
              if (idipoles.ne.0) then
                call undumag_dipoles_field(xx/1000.0d0,yy/1000.0d0,zz/1000.0d0,
     &            bdx,bdy,bdz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)"Undumag_dipoles_field returned failure at point: ",
     &              xx,yy,zz
                endif !(idipoles.ne.0) then
              else if (ifail.lt.0) then
                irecover=irecover+1
              endif

              if (kinside.gt.0) then
                imag=kinside
                mat=nint(bpebc(9,imag))
                imoth=nint(bpebc(15,imag))
                bcx=bpebc(4,imag)
                bcy=bpebc(5,imag)
                bcz=bpebc(6,imag)
                matmap2=matmaps(2,mat)
                matmap3=matmaps(3,mat)
              else !kinside
                imoth=0
                imag=0
                mat=0
                matmap2=0
                matmap3=0
                bcx=0.0d0
                bcy=0.0d0
                bcz=0.0d0
              endif !kinside

              bx=hx+bcx
              by=hy+bcy
              bz=hz+bcz
              b=sqrt(bx*bx+by*by+bz*bz)
              h=sqrt(hx*hx+hy*hy+hz*hz)
              bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

              if (iforcegrid.ne.0) then
                xx=x
                yy=y
                zz=z
              endif
              if (kmapmode.eq.0) then
                write(lun,*)
     &            imoth,imag,mat,matmap2,matmap3,
     &            sngl(xx),sngl(yy),sngl(zz),
     &            sngl(bx),sngl(by),sngl(bz),sngl(b),
     &            sngl(hx),sngl(hy),sngl(hz),sngl(h),
     &            sngl(bcx),sngl(bcy),sngl(bcz),sngl(bc),
     &            sngl(bdx),sngl(bdy),sngl(bdz),
     &            ifail,kkfail
              else
                write(lun,*)
     &            sngl(xx),sngl(yy),sngl(zz),sngl(bx),sngl(by),sngl(bz),ifail,kkfail
              endif
              if (knointmap.eq.0) then
                bmap(1,ix,iy,iz)=x
                bmap(2,ix,iy,iz)=by
                bmap(3,ix,iy,iz)=bz
                bmap(4,ix,iy,iz)=ifail
               endif
            enddo !nzmap
          enddo !nymap
        enddo !nxmap

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif
      endif !(nxmap*nymap*nzmap.le.0) then

      kinside=-1
      if (knomagmap.eq.0) then
        irecover=0
        do imag=1,nrec

          !x1y1z1
          imoth=nint(bpebc(15,imag))
          mat=nint(bpebc(9,imag))
          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          x=bpebc(1,imag) !mm
          y=bpebc(2,imag) !mm
          z=bpebc(3,imag) !mm
          bcx=bpebc(4,imag)
          bcy=bpebc(5,imag)
          bcz=bpebc(6,imag)
          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,hx,hy,hz,ifail)
          if (ifail.gt.0) then
            write(lun6,*)"Undumag_field returned failure at point: ",x,y,z
          else if (ifail.lt.0) then
            irecover=irecover+1
          endif
          bx=hx+bcx
          by=hy+bcy
          bz=hz+bcz
          b=sqrt(bx*bx+by*by+bz*bz)
          h=sqrt(hx*hx+hy*hy+hz*hz)
          bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)
          bdx=-9.0d0
          bdy=-9.0d0
          bdz=-9.0d0
          if (kmapmode.eq.0) then
            write(lun,*)
     &        imoth,imag,mat,matmap2,matmap3,
     &        sngl(x),sngl(y),sngl(z),
     &        sngl(bx),sngl(by),sngl(bz),sngl(b),
     &        sngl(hx),sngl(hy),sngl(hz),sngl(h),
     &        sngl(bcx),sngl(bcy),sngl(bcz),sngl(bc),
     &        sngl(bdx),sngl(bdy),sngl(bdz),
     &        ifail
          else
            write(lun,*)
     &        sngl(x),sngl(y),sngl(z),sngl(bx),sngl(by),sngl(bz)
          endif
        enddo ! imag

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations inside magnets with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif

      endif !knomagmap

      if (knomagmap.eq.0) then

        irecover=0
        allocate(hmagvox(2,nrec))

        bcminrec=1.0e30
        bcmaxrec=-1.0e30
        hminrec=1.0e30
        hmaxrec=-1.0e30

        do imag=1,nrec

          easy=bpebc(11:13,imag)
          easyn=sqrt(easy(1)**2+easy(2)**2+easy(3)**2)

          imoth=nint(bpebc(15,imag))

          mat=nint(bpebc(9,imag))

          if (newclc.ne.0) then

            kbrn=0
            do ibrn=1,nbrnmat
              if (nint(brnmat(1,ibrn)).eq.mat) then
                kbrn=ibrn
                exit
              endif
            enddo

            if (kbrn.eq.0) then
              write(lun6,*)
              write(lun6,*)"*** Warning in undumag_end: Could not find REC material in list of Br ***"
              write(lun6,*)"*** Be careful with plots of magnetisation ***"
            endif

          else
            kbrn=1
          endif !newclc

          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          x=bpebc(1,imag) !mm
          y=bpebc(2,imag) !mm
          z=bpebc(3,imag) !mm

          bcx=bpebc(4,imag)
          bcy=bpebc(5,imag)
          bcz=bpebc(6,imag)
          bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,hx,hy,hz,ifail)

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_field returned failure at point: ",x,y,z
          else if (ifail.lt.0) then
            irecover=irecover+1
          endif

          h=(hx*easy(1)+hy*easy(2)+hz*easy(3))/easyn
          bc=(bcx*easy(1)+bcy*easy(2)+bcz*easy(3))/easyn

          write(lunmag,'(a,I5,1p5e12.4,2I5)')"1 ",matmap3,easy,h,bc,mat,kbrn

          hmagvox(1,imag)=h
          hmagvox(2,imag)=bc

          if (bc.lt.bcminrec) bcminrec=sngl(bc)
          if (bc.gt.bcmaxrec) bcmaxrec=sngl(bc)

          if (h.lt.hminrec) hminrec=sngl(h)
          if (h.gt.hmaxrec) hmaxrec=sngl(h)

        enddo ! imag

        if (hmaxrec-hminrec.lt.1.0e-6) then
          hminrec=-2.0
          hmaxrec=0.0
        endif

        if (bcmaxrec-bcminrec.lt.1.0e-6) then
          bcminrec=0.0
          bcmaxrec=2.
        endif

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations inside magnets with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif

      endif !knomagmap

      hmaxiron=2.5

      if (knopolmap.eq.0) then

        irecover=0
        hmaxiron=0.0

        allocate(hmvoxel(2,niron))
        iron=0

        do imag=nrec+1,nrec+niron

          iron=iron+1

          !x1y1z1
          imoth=nint(bpebc(15,imag))

          mat=nint(bpebc(9,imag))

          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          x=bpebc(1,imag) !mm
          y=bpebc(2,imag) !mm
          z=bpebc(3,imag) !mm

          bcx=bpebc(4,imag)
          bcy=bpebc(5,imag)
          bcz=bpebc(6,imag)

          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,hx,hy,hz,ifail)

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_field returned failure at point: ",x,y,z
          else if (ifail.lt.0) then
            irecover=irecover+1
          endif

          bx=hx+bcx
          by=hy+bcy
          bz=hz+bcz
          b=sqrt(bx*bx+by*by+bz*bz)
          h=sqrt(hx*hx+hy*hy+hz*hz)
          bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

          bdx=-9.0d0
          bdy=-9.0d0
          bdz=-9.0d0

          if (matmap2.eq.2) then
            hmvoxel(1,iron)=h
            hmvoxel(2,iron)=bc
            if (h.gt.hmaxiron) hmaxiron=sngl(h)
          endif

          if (kmapmode.eq.0) then
            write(lun,*)
     &        imoth,imag,mat,matmap2,matmap3,
     &        sngl(x),sngl(y),sngl(z),
     &        sngl(bx),sngl(by),sngl(bz),sngl(b),
     &        sngl(hx),sngl(hy),sngl(hz),sngl(h),
     &        sngl(bcx),sngl(bcy),sngl(bcz),sngl(bc),
     &        sngl(bdx),sngl(bdy),sngl(bdz),
     &        ifail
          else
            write(lun,*)
     &        sngl(x),sngl(y),sngl(z),sngl(bx),sngl(by),sngl(bz)
          endif
        enddo ! imag

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations inside iron with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif

      endif !knopolmap

      if (knointmap.eq.0) then

        do iy=1,nymap
          do iz=1,nzmap
            yint=ymapmin+(iy-1)*dy
            zint=zmapmin+(iz-1)*dz
            kx=0
            do ix=1,nxmap
              if (bmap(4,ix,iy,iz).ne.0.0d0) cycle
              kx=kx+1
              xinti(kx)=bmap(1,ix,iy,iz)
              byai(kx)=bmap(2,ix,iy,iz)
              bzai(kx)=bmap(3,ix,iy,iz)
            enddo !ix
            if (kx.gt.1.and.knointmap.eq.0) then
              if (isimpson.eq.0) then
                call util_spline_running_integral(xinti,byai,kx,byinti,coef,
     &            ws1,ws2,ws3,ws4)
                call util_spline_running_integral(xinti,bzai,kx,bzinti,coef,
     &            ws1,ws2,ws3,ws4)
                call util_spline_running_integral(xinti,byinti,kx,byint2i,coef,
     &            ws1,ws2,ws3,ws4)
                call util_spline_running_integral(xinti,bzinti,kx,bzint2i,coef,
     &            ws1,ws2,ws3,ws4)
              else
                call util_simpson_running_integral(kx,xinti,byai,byinti)
                call util_simpson_running_integral(kx,xinti,bzai,bzinti)
                call util_simpson_running_integral(kx,xinti,byinti,byint2i)
                call util_simpson_running_integral(kx,xinti,bzinti,bzint2i)
              endif
              write(luni,'(8(1pe17.7e3))')xinti(1),xinti(kx),yint,zint,
     &          byinti(kx),bzinti(kx),byint2i(kx),bzint2i(kx)
            endif !kx
          enddo !iz
        enddo !iy

        flush(luni)
        close(luni)

        flush(lun)
        close(lun)

      endif !knointmap

c Calculate field map}

      call util_zeit_kommentar(lun6,"Writing undumag_mh_rec.eps")
+self,if=debugend.
      !call util_break
+self.
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_mh_rec.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

c{ Plot Magnetization of magnets

      if (nmag.gt.0) then

        xplmin=hminrec
        xplmax=hmaxrec
        yplmin=bcminrec
        yplmax=bcmaxrec

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        xplmin=xplmin-0.1*dxpl
        xplmax=xplmax+0.1*dxpl
        yplmin=yplmin-0.1*dypl
        yplmax=yplmax+0.1*dypl

        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'H [T]','M [T]',' ')
        call mshplt_set_marker_size(0.25)

        call mgset('PLCI',4.)

        xpl(1)=hminrec
        xpl(2)=hmaxrec

        do ibrn=1,nbrnmat
          mat=nint(brnmat(1,ibrn))
          brn=sngl(abs(brnmat(2,ibrn)))
          matmap2=matmaps(2,mat)
          if (matmap2.eq.1) then
            ypl(1)=brn+sngl(bcmat(2,1,mat))*xpl(1)
            ypl(2)=brn+sngl(bcmat(2,1,mat))*xpl(2)
            call mpl(2,xpl,ypl)
          else if (matmap2.eq.2) then
            ypl(1)=brn+sngl(bcmat(3,1,mat))*xpl(1)
            ypl(2)=brn+sngl(bcmat(3,1,mat))*xpl(2)
            call mpl(2,xpl,ypl)
          endif

        enddo !nbrnmat

        call mgset('PLCI',2.)

        if (knomagmap.eq.0) then
          do imag=1,nrec
            xpl(1)=sngl(hmagvox(1,imag))
            ypl(1)=sngl(hmagvox(2,imag))
            call mpm(1,xpl,ypl)
          enddo
        endif

        call muwk(0,0)
        call mshplt_end

      endif !nmag
c} Plot Magnetization of magnets

      if (niron.gt.0.and.(nmag+ncwires+nrace.gt.0.or.kbextern.gt.0)) then

        call util_zeit_kommentar(lun6,"Writing undumag_mh_iron.eps")
        call mshplt_init(20,15.,15.,25,25,600,600,
     &    'undumag_mh_iron.eps','','',0.)

+self,if=debugend.
      !call util_break
+self.
        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif
        if (krunnum.ne.0) then
          write(ctitle,*)kundurun
          call util_string_trim(ctitle,nfirst,nlast)
          ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
        else
          ctitle=trim(usercom)
        endif

        if (kcomment.ne.0) call mtitle(trim(ctitle))
        call mshplt_hplset('YGTI',-0.5)

c{ Plot Magnetization of iron

        gsiz_ps=0.4

        xplmin=0.0
        xplmax=0.005
        yplmin=0.0
        yplmax=2.5

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mshplt_set_pad(3.5,10.,4.,18.)
        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'H [T]','M [T]',' ')
        call mshplt_set_marker_size(0.25)

        call mgset('PLCI',4.)

        do imat=1,nmatfiles

          if (matmaps(2,imat).eq.1) cycle

          mat=matmaps(1,imat)
          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          if (matmap3.eq.0) cycle

          if (matmap3.eq.0) then
            xpl(1)=sngl(xplmin)
            xpl(2)=sngl(xplmax)
            ypl(1:2)=sngl(bcmat(2,1,mat))
            call mpl(2,xpl,ypl)
          else
            do i=1,matmaps(4,mat)-1
              xpl(1:2)=sngl(feh1(i:i+1))
              ypl(1:2)=sngl(fem1(i:i+1))
              call mpl(2,xpl,ypl)
            enddo
          endif

        enddo !imat

        call mgset('PLCI',2.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            easy=0.0
            write(lunmag,'(a,i5,1p5e12.4,2I5)')
     &        "2 ",matmap3,easy,xpl(1),ypl(1),mat, mat*0
            if (matmap3.eq.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
c            if (xpl(1).lt.0.01) then
              call mpm(1,xpl,ypl)
c            else
c              print*,"holla hmvoxel"
c            endif
          enddo
        endif

        call mgset('PLCI',3.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            if (matmap3.ne.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
c            if (xpl(1).lt.0.01) then
              call mpm(1,xpl,ypl)
c            else
c              print*,"holla hmvoxel"
c            endif
            easy=0
            write(lunmag,'(a,i5,1p5e12.4,2I5)')
     &        "2 ",matmap3,easy,xpl(1),ypl(1),mat,mat*0
          enddo
        endif

        call muwk(0,0)

        xplmin=0.0
        xplmax=hmaxiron
        if (hmaxiron.eq.0.0d0) then
          xplmax=sngl(feh1(matmaps(4,2)))
        endif
        yplmin=0.0
        yplmax=2.5

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mshplt_set_pad(12.5,19.,4.,18.)
        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'H [T]','M [T]',' ')

        call mgset('PLCI',4.)
        if (matmap2.eq.0) then
          ypl(1:2)=sngl(bcmat(2,1,2))
          call mpl(2,xpl,ypl)
        else
          do i=1,matmaps(4,2)-1
            xpl(1:2)=sngl(feh1(i:i+1))
            ypl(1:2)=sngl(fem1(i:i+1))
            call mpl(2,xpl,ypl)
          enddo
        endif

        call mgset('PLCI',2.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            if (matmap3.eq.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
            if (xpl(1).lt.0.01) call mpm(1,xpl,ypl)
          enddo
        endif

        call mgset('PLCI',3.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            if (matmap3.ne.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
            if (xpl(1).lt.0.01) call mpm(1,xpl,ypl)
          enddo
        endif

        call mgset('PLCI',2.)

        call muwk(0,0)
        call mshplt_end

      endif !(niron.gt.0) then

c} Magnetization of iron

c      write(lun6,*)"matrix:",matrix

      write(lun6,*)"Symmetries:"
      write(lun6,*)"ixsym, iysym, izsym, xsym:",ixsymo,iysymo,izsymo,xsym

      kinside=0
      write(lun6,*)
      write(lun6,*)"Conv. points and field H[T] there:"
c      iseqdebug=1
      do i=1,nxconv
        call undumag_field(xconv(i),yconv,zconv,hx,hy,hz,ifail)
        if (ifail.gt.0) then
          write(lun6,*)"Undumag_field returned unrecovered failure at convergence point: ",
     &      xconv(i)*1000.0,yconv*1000.0,zconv*1000.0
        endif
        write(lun6,'(a,i6,6g15.5)')" ",i,xconv(i)*1000.,yconv*1000.,zconv*1000.,
     &    hx,hy,hz
      enddo

      byint1fnor=0.0d0
      byint2fnor=0.0d0
      bzint1fnor=0.0d0
      bzint2fnor=0.0d0

      if (ixonnor.gt.1) then
        byint1fnor=byintnor(ixonnor)
        bzint1fnor=bzintnor(ixonnor)
        byint2fnor=byint2nor(ixonnor)
        bzint2fnor=bzint2nor(ixonnor)
      endif

      byint1f=0.0d0
      byint2f=0.0d0
      bzint1f=0.0d0
      bzint2f=0.0d0
      byint1fd=0.0d0
      byint2fd=0.0d0
      bzint1fd=0.0d0
      bzint2fd=0.0d0

      if (ixon.gt.1) then
        byint1f=byint(ixon)
        bzint1f=bzint(ixon)
        byint2f=byint2(ixon)
        bzint2f=bzint2(ixon)
      endif

      if (ixon.gt.1) then
        byint1fd=byintd(ixon)
        bzint1fd=bzintd(ixon)
        byint2fd=byint2d(ixon)
        bzint2fd=bzint2d(ixon)
      endif

      bxint1inf=0.0d0
      byint1inf=0.0d0
      bzint1inf=0.0d0
      byint1infd=0.0d0
      bzint1infd=0.0d0

      x=0.0d0
      y=0.0d0
      z=0.0d0

      if (maxiter.gt.0.and.nxmap.gt.0) then

        !call util_break
        call util_zeit_kommentar(lun6,"Writing undumag_integrals_inf.map")

        open(newunit=luninf,file="undumag_integrals_inf.map")
        write(luninf,'(a)')"* y/mm z/mm ByInt1/Tmm BzInt1/Tmm ByInt1_Dip/Tmm BzInt1_Dip/Tmm"

        y=ymapmin-dy
        do iy=1,nymap

          y=y+dy
          z=zmapmin-dz

          do iz=1,nzmap
            z=z+dz

            y=y/1000.0d0
            z=z/1000.0d0

            bxint1inf=0.0d0
            byint1inf=0.0d0
            bzint1inf=0.0d0

            byint1infd=0.0d0
            bzint1infd=0.0d0

            if (idipoles.ne.0) then
              do imag=1,nmag
                if (bpebc(17,imag).lt.0.0d0) cycle
                call undumag_dipoles_int(imag,y,z,byi,bzi,ifail)
                if (ifail.ne.0) then
                  write(lun6,*)"*** Error in undumag_end: Bad return from undumag_dipoles_int ***"
                endif
                byint1infd=byint1infd+byi
                bzint1infd=bzint1infd+bzi
              enddo !nmag
            endif !(idipoles.ne.0) then

            x=0.0d0

            call undumag_bintinf_sym(0.0d0,y,z,1.0d0,0.0d0,0.0d0,
     &        bxint1inf,byint1inf,bzint1inf,ifail)

            if (ifail.ne.0) then
              write(lun6,*)
              write(lun6,*)"*** Warning in undumag_end: Bad return from undumag_bintinf_sym ***"
              write(lun6,*)"*** y,z:",y,z," ***"
            endif

            y=y*1000.0d0
            z=z*1000.0d0

            write(luninf,'(6(1pe17.7e3))')y,z,
     &        byint1inf*1000.0d0,bzint1inf*1000.0d0,
     &        byint1infd*1000.0d0,bzint1infd*1000.0d0

          enddo !iz
        enddo !iy

        flush(luninf)
        close(luninf)

        bxint1inf=0.0d0
        byint1inf=0.0d0
        bzint1inf=0.0d0

        byint1infd=0.0d0
        bzint1infd=0.0d0

        x=0.0d0 !m
        y=0.0d0 !m
        z=0.0d0 !m

        call undumag_bintinf_sym(x,y,z,1.0d0,0.0d0,0.0d0,
     &    bxint1inf,byint1inf,bzint1inf,ifail)
        if (ifail.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end: Bad return from undumag_bintinf_sym ***"
          write(lun6,*)"*** y,z:",y,z," ***"
        endif

        if (idipoles.ne.0) then

          do imag=1,ndipoles

            y2z2=dipoles(2,imag)**2+dipoles(3,imag)**2
            py=dipoles(6,imag)*dipoles(4,imag)
            pz=dipoles(7,imag)*dipoles(4,imag)
            pryz=py*dipoles(2,imag)+pz*dipoles(3,imag)

            if (y2z2.ne.0.0d0) then
              byint1infd=byint1infd
     &          +3.0d0*pryz*dipoles(2,imag)*2.0d0/3.0d0/y2z2**2*2.0d0
     &          -2.0d0/y2z2*py
              bzint1infd=bzint1infd
     &          +3.0d0*pryz*dipoles(3,imag)*2.0d0/3.0d0/y2z2**2*2.0d0
     &          -2.0d0/y2z2*pz
            else
              write(lun6,*)"*** Error in undumag_end: Integration of dipole fields fails, since distance to dipole is zero for dipole",
     &          imag," ***"
            endif
          enddo
        endif !(idipoles.ne.0) then

      endif !(maxiter.gt.1) then

      bxint1inf=bxint1inf*1000.0d0
      byint1inf=byint1inf*1000.0d0
      bzint1inf=bzint1inf*1000.0d0

      write(lun6,*)
      write(lun6,*)"Initial and final damping factors for relaxation of iron:",
     &  sngl(dampi),sngl(damp8)
      write(lun6,*)
      write(lun6,*)"Maximum iteration used for Chi(H) for iron:",nchimax
      write(lun6,*)
      write(lun6,*) "1. Integrals ByI  and BzI  in [Tmm]:  ",
     &  sngl(byint1f),sngl(bzint1f)
      byif=byint1f
      bzif=bzint1f
      write(lun6,*) "1. Integrals ByI  and BzI  in [Tmm], without recovered points:  ",
     &  sngl(byint1fnor),sngl(bzint1fnor)
      write(lun6,*) "1. Integrals ByI and BzI [Tmm], analytically,"
      write(lun6,*) "NOT including external field:  ",
     &  sngl(byint1inf),sngl(bzint1inf)

      if (idipoles.ne.0) then
        write(lun6,*) "1. Integrals ByI  and BzI  in [Tmm] for dipole approx.:  ",
     &    sngl(byint1fd),sngl(bzint1fd)
        write(lun6,*) "1. Integrals ByI and BzI [Tmm], analytically, dipole approx.,"
        write(lun6,*) "NOT including external field:  ",
     &    sngl(byint1infd),sngl(bzint1infd)
      endif !(idipoles.ne.0) then

      write(lun6,*)
      write(lun6,*) "External field [T]:",sngl(bxex),sngl(byex),sngl(bzex)
      write(lun6,*) "1. Integrals ByI and BzI [Tmm] of external field:  ",
     &  sngl(byexint),sngl(bzexint)

      write(lun6,*)
      write(lun6,*) "2. Integrals ByII and BzII in [Tmm**2]: ",
     &  sngl(byint2f),sngl(bzint2f)
      write(lun6,*) "2. Integrals ByII and BzII in [Tmm**2], without recovered points: ",
     &  sngl(byint2fnor),sngl(bzint2fnor)

      if (idipoles.ne.0) then
        write(lun6,*) "2. Integrals ByII and BzII in [Tmm**2] for dipole approx.: ",
     &    sngl(byint2fd),sngl(bzint2fd)
        write(lun6,*)
      endif !(idipoles.ne.0) then

      write(lun6,*)
      dx=xint(nxmap)-xint(1)
      if (nxmap.gt.1) then
        write(lun6,*)"Range of integration and step size:",xint(1),xint(nxmap),dx/(nxmap-1)
      else
        write(lun6,*)"Range of integration and step size:",xint(1),xint(nxmap)," 0.0"
      endif
      write(lun6,*)"By and Bz there:",
     &  sngl(bya(1)),sngl(bza(1)),sngl(bya(nxmap)),sngl(bza(nxmap))
      write(lun6,*)"By*x-range and Bz*x-range there:",
     &  sngl(bya(1)*dx),sngl(bza(1)*dx),sngl(bya(nxmap)*dx),sngl(bza(nxmap)*dx)
      write(lun6,*)

      call util_zeit_kommentar(lun6,"Writing undumag_on-axis_by_bz.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_on-axis_by_bz.eps','','',0.)

      if (ixon.gt.1) then

        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif
        if (krunnum.ne.0) then
          write(ctitle,*)kundurun
          call util_string_trim(ctitle,nfirst,nlast)
          ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
        else
          ctitle=trim(usercom)
        endif

        if (kcomment.ne.0) call mtitle(trim(ctitle))
        call mshplt_hplset('YGTI',-0.5)

c{ Plot By, Bz

        gsiz_ps=0.4

        xplmin=sngl(xmapmin)
        xplmax=sngl(xmapmax)
        yplmin=min(byplmin,bzplmin)
        yplmax=max(byplmax,bzplmax)
        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bya(ix))
          ypl(2)=sngl(bya(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('PLCI',4.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bza(ix))
          ypl(2)=sngl(bza(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mshplt_set_pad(4.,19.,3.,18.)

        call mshplt_set_text_angle(90.)
        call mshplt_text_ndc(-0.1,0.9,'B [T]')
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.85,-0.1,'x [mm]')

c        call mgset('CHHE',0.4)
c        call mshplt_set_text_angle(0.)
c        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
cc        call mtx(xplmax-dxpl*0.05,yplmin-dypl*0.175,'x [mm]')
c        call mshplt_set_text_angle(90.)
c        if (abs(yplmax).lt.1.0e-3) then
c          call mshplt_text_ndc(-0.1,0.86,'B [T]')
c        else
c          call mshplt_text_ndc(-0.1,0.88,'B [T]')
c        endif
c        call mtx(xplmin-dxpl*0.15,yplmax-dypl*0.05,'B [T]')
        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        call mshplt_text_ndc(0.85,0.9,'By')
        call mshplt_set_text_color(0,0,0,1)
        call mshplt_text_ndc(0.85,0.83,'Bz')
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)

        call muwk(0,0)
        call mshplt_end

      endif !ixon

c} Plot By, Bz

c{ Plot ByInt, BzInt

      call util_zeit_kommentar(lun6,"Writing undumag_on-axis_byint_bzint.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_on-axis_byint_bzint.eps','','',0.)
      if (kcomment.ne.0) call mtitle(trim(ctitle))
      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      call mshplt_hplset('YGTI',-0.5)

      if (ixon.gt.1) then

        call mgset('CHHE',0.3)
        call mshplt_set_text_color(1,0,0,0)
        gsiz_ps=0.4

        xplmin=sngl(xmapmin)
        xplmax=sngl(xmapmax)
        yplmin=min(byiplmin,bziplmin)
        yplmax=max(byiplmax,bziplmax)
        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin
        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(byint(ix))
          ypl(2)=sngl(byint(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('PLCI',4.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bzint(ix))
          ypl(2)=sngl(bzint(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('CHHE',0.4)
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
        call mshplt_set_text_angle(90.)
        call mshplt_text_ndc(-0.1,0.7,'1. Integral of B [Tmm]')
        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        cbint="1. Int By = "
        call mshplt_text_ndc(0.77,0.9,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') byint1f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') byint1f
        cbint(11:14)="Tmm"
        call mshplt_text_ndc(0.77,0.85,cbint)
        call mshplt_set_text_color(0,0,0,1)
        cbint="1. Int Bz = "
        call mshplt_text_ndc(0.77,0.80,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') bzint1f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') bzint1f
        cbint(11:14)="Tmm"
        call mshplt_text_ndc(0.77,0.75,cbint)
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)

      endif !ixon

      call muwk(0,0)
      call mshplt_end

c} Plot ByInt, BzInt

c{ Plot ByInt2, BzInt2

      call util_zeit_kommentar(lun6,"Writing undumag_on-axis_byint2_bzint2.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_on-axis_byint2_bzint2.eps','','',0.)
      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)
      gsiz_ps=0.4

      if (ixon.gt.1) then

        call mgset('CHHE',0.3)
        call mshplt_set_text_color(1,0,0,0)

        xplmin=sngl(xmapmin)
        xplmax=sngl(xmapmax)
        yplmin=min(byiiplmin,bziiplmin)
        yplmax=max(byiiplmax,bziiplmax)
        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin
        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(byint2(ix))
          ypl(2)=sngl(byint2(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('PLCI',4.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bzint2(ix))
          ypl(2)=sngl(bzint2(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('CHHE',0.4)
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
        call mshplt_set_text_angle(90.)
        call mshplt_text_ndc(-0.1,0.77,'2. Integral of B [Tmm^2]')
        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        cbint="2. Int By = "
        call mshplt_text_ndc(0.73,0.9,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') byint2f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') byint2f
        cbint(9:14)="Tmm^2"
        call mshplt_text_ndc(0.73,0.85,cbint)
        call mshplt_set_text_color(0,0,0,1)
        cbint="2. Int Bz = "
        call mshplt_text_ndc(0.73,0.80,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') bzint2f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') bzint2f
        cbint(9:14)="Tmm^2"
        call mshplt_text_ndc(0.73,0.75,cbint)
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)
      endif !ixon

      call muwk(0,0)
      call mshplt_end
c} Plot ByInt2, BzInt2

c Calculate beff{

      deallocate (xintnor)
      deallocate (bxanor)
      deallocate (byanor)
      deallocate (bzanor)
      deallocate (byintnor)
      deallocate (bzintnor)
      deallocate (byint2nor)
      deallocate (bzint2nor)
      deallocate (xint)
      deallocate (bxa)
      deallocate (bya)
      deallocate (bza)
      deallocate (byint)
      deallocate (bzint)
      deallocate (byint2)
      deallocate (bzint2)
      deallocate (ws1)
      deallocate (ws2)
      deallocate (ws3)
      deallocate (ws4)
      deallocate (coef)

      allocate (
     &  xintnor(nxbeff),
     &  byintnor(nxbeff),bzintnor(nxbeff),
     &  byint2nor(nxbeff),bzint2nor(nxbeff),
     &  bxanor(nxbeff),byanor(nxbeff),bzanor(nxbeff),
     &  xint(nxbeff),
     &  byint(nxbeff),bzint(nxbeff),
     &  byint2(nxbeff),bzint2(nxbeff),
     &  bxa(nxbeff),bya(nxbeff),bza(nxbeff),
     &  ws1(nxbeff),ws2(nxbeff),ws3(nxbeff),ws4(nxbeff),coef(nxbeff))

c      if (xbeff.eq.9999.0d0) xbeff=xconv(nxconv/2+1)
      if (xbeff.eq.9999.0d0) xbeff=xcenter
      if (xbeff.eq.-9999.0d0) xbeff=(xmapmin+xmapmax)/2.0d0

      xbeffo=xbeff

      halfperlen=perlen/2.0d0
      quadperlen=perlen/4.0d0

      bymaxbeff=-1.0d30
      bzmaxbeff=-1.0d30

      if (kbeffmode.eq.9999) then
        if (nper.gt.0) then
          kbeffmode=0
        else
          kbeffmode=1
        endif
      endif

      if (kbeffmode.eq.0) then
        xminbeff=xbeff-perlen*0.51
        xmaxbeff=xbeff+perlen*0.51
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
        dxkbmode=abs(kbeffmode)*dx
      else
        xminbeff=xbeff-quadperlen
        xmaxbeff=xbeff+quadperlen
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        dxkbmode=abs(kbeffmode)*dx
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
      endif

      xbymax=xbeff
      xbzmax=xbeff

      do ix=1,nxbeff

        x=xminbeff+(ix-1)*dx
        xx=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          cycle
        endif

        call util_random(3,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        xint(ix)=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          if (x.lt.xbeff) then
            x=xx+abs(xx-x)
          else
            x=xx-abs(xx-x)
          endif
        endif

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif
        if (randoz.ge.0.0d0) then
          z=g(3)*randoza
        else
          z=randoza
        endif

        if (kbeffmode.eq.0) then
          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &      bx,by,bz,ifail)
        else
          if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
            cycle
          endif
          if (abs(x-xbeff).le.quadperlen) then
            call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
          else if (x.lt.xbeff) then
            call undumag_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          else
            call undumag_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          endif
        endif !kbeffmode

        if (ifail.ne.0) cycle

        if (abs(by).gt.bymaxbeff) then
          bymaxbeff=abs(by)
          xbymax=xminbeff+(ix-1)*dx
        endif

        if (abs(bz).gt.bzmaxbeff) then
          bzmaxbeff=abs(bz)
          xbzmax=xminbeff+(ix-1)*dx
        endif

      enddo !ix

      if (bymaxbeff.lt.1.0d-4*bzmaxbeff) xbymax=xbzmax
      if (bzmaxbeff.lt.1.0d-4*bymaxbeff) xbzmax=xbymax

      call undumag_beffy_beffz(
     &  byint1f,bzint1f,
     &  byint2f,bzint2f,
     &  byint1inf,bzint1inf,
     &  byint1fnor,bzint1fnor,
     &  byint2fnor,bzint2fnor,
     &  byexint,bzexint)

      if (idipoles.ne.0) then

        call util_zeit_kommentar(lun6,"Writing undumag_bzeff_dipoles.dat")
        open(newunit=lun,file="undumag_bzeff_dipoles.dat")

        xbeff=xbzmax
        xminbeff=xbeff-perlen/2.0d0
        xmaxbeff=xbeff+perlen/2.0d0

        halfperlen=perlen/2.0d0
        quadperlen=perlen/4.0d0

        if (abs(xbeffo-xminbeff).le.quadperlen) then
          xminbeff=xminbeff-halfperlen
          xmaxbeff=xmaxbeff-halfperlen
        else if (xbeffo-xminbeff.gt.halfperlen*1.001) then
          xminbeff=xminbeff+halfperlen
          xmaxbeff=xmaxbeff+halfperlen
        endif

        if (xbeffz.ne.-9999.0d0) then
          xbeff=xbeffz
          xminbeff=xbeff-perlen/2.0d0
          xmaxbeff=xbeff+perlen/2.0d0
        endif

        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff

        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        x=xminbeff-dx
        dxkbmode=abs(kbeffmode)*dx

        ixbeff=0
        ixbeffnor=0
        irecover=0

        do ix=1,nxbeff

          x=xminbeff+(ix-1)*dx
          xint(ix)=x
          if (kbeffmode.eq.0) then
            call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bxa(ix),bya(ix),bza(ix),ifail)
          else
            if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
              cycle
            endif
            if (abs(x-xbeff).le.quadperlen) then
              call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
            else if (x.lt.xbeff) then
              call undumag_dipoles_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            else
              call undumag_dipoles_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            endif
          endif !kbeffmode

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_dipoles_field returned failure for Bzeff calculation at point ",ix,xint(ix)
          else
            ixbeff=ixbeff+1
            xint(ixbeff)=xint(ix)
            bxa(ixbeff)=bxa(ix)
            bya(ixbeff)=bya(ix)
            bza(ixbeff)=bza(ix)
          endif

        enddo

        if (ixbeff.gt.0) then

          x3=xint(1:3)
          b3=bya(1:3)
          call parabel_short(x3,b3,a3)
          xint(1)=xminbeff
          bya(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2
          b3=bza(1:3)
          call parabel_short(x3,b3,a3)
          bza(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2

          x3=xint(ixbeff-2:ixbeff)
          b3=bya(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          xint(ixbeff)=xmaxbeff
          bya(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2
          b3=bza(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          bza(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2

          do i=1,ixbeff
            write(lun,*)i,xint(i),bya(i),bza(i)
          enddo

          call util_spline_running_integral(xint,bza,ixbeff,bzint,coef,
     &      ws1,ws2,ws3,ws4)

          bmnbeffd=1.0d30
          bmxbeffd=-1.0d30
          bmaxbeffd=-1.0d30
          do i=1,ixbeff
            if (bza(i).gt.bmxbeffd) then
              bmxbeffd=bza(i)
            endif
            if (bza(i).lt.bmnbeffd) then
              bmnbeffd=bza(i)
            endif
            if (abs(bza(i)).gt.bmaxbeffd) then
              bmaxbeffd=abs(bza(i))
              ibmax=i
            endif
            bzint(i)=bzint(i)**2
          enddo

          if (ibmax.eq.1) ibmax=2
          if (ibmax.eq.ixbeff) ibmax=ixbeff-1

          yp(1)=1.0d0
          yp(2)=2.0d0
          yp(3)=3.0d0
          bp(1)=abs(bza(ibmax-1))
          bp(2)=abs(bza(ibmax))
          bp(3)=abs(bza(ibmax+1))

          call util_max_parabel(3,yp,bp,dum,bmaxp,ws1,ws2,ifail)
          if (ifail.eq.0) bmaxbeffd=bmaxp

          call util_spline_running_integral(xint,bzint,ixbeff,bzint2,coef,
     &      ws1,ws2,ws3,ws4)

          beffd= sqrt(bzint2(ixbeff)/(xint(ixbeff)-xint(1)))
c Correct for endpole effects
          if (bmaxbeffd.ne.0.0d0) then
            beffd=beffd*(bmxbeffd-bmnbeffd)/2.0d0/bmaxbeffd
          endif
          bmaxbeffd=(bmxbeffd-bmnbeffd)/2.0d0
          dkeffd = beffd * sqrt(2.0d0)  * 3.0d8 / 0.511d6 / 1000.0d0
          beffd = dkeffd / ((xint(ixbeff)-xint(1))*100.0d0) / 0.934d0 * 1000.0d0

          bmnbeffzd=bmnbeffd
          bmxbeffzd=bmxbeffd
          beffzd=beffd
          dkeffzd=dkeffd

          flush(lun) !undumag_bzeff_dipoles.beff
          close(lun) !undumag_bzeff_dipoles.beff

        else

          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end: No field data for Bzeff calculation ***"
          write(lun6,*)

        endif

        call util_zeit_kommentar(lun6,"Writing undumag_byeff_dipoles.dat")
        open(newunit=lun,file="undumag_byeff_dipoles.dat")

        xbeff=xbymax
        xminbeff=xbeff-perlen/2.0d0
        xmaxbeff=xbeff+perlen/2.0d0

        halfperlen=perlen/2.0d0
        quadperlen=perlen/4.0d0

        if (abs(xbeffo-xminbeff).le.quadperlen) then
          xminbeff=xminbeff-halfperlen
          xmaxbeff=xmaxbeff-halfperlen
        else if (xbeffo-xminbeff.gt.halfperlen*1.001) then
          xminbeff=xminbeff+halfperlen
          xmaxbeff=xmaxbeff+halfperlen
        endif

        if (xbeffy.ne.-9999.0d0) then
          xbeff=xbeffy
          xminbeff=xbeff-perlen/2.0d0
          xmaxbeff=xbeff+perlen/2.0d0
        endif

        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff

        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        x=xminbeff-dx
        dxkbmode=abs(kbeffmode)*dx

        ixbeff=0
        ixbeffnor=0
        irecover=0
        do ix=1,nxbeff
          x=xminbeff+(ix-1)*dx
          xint(ix)=x
          if (kbeffmode.eq.0) then
            call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bxa(ix),bya(ix),bza(ix),ifail)
          else
            if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
              cycle
            endif
            if (abs(x-xbeff).le.quadperlen) then
              call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
            else if (x.lt.xbeff) then
              call undumag_dipoles_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            else
              call undumag_dipoles_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            endif
          endif !kbeffmode

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_dipoles_field returned failure for Byeff calculation at point ",ix,xint(ix)
          else
            ixbeff=ixbeff+1
            xint(ixbeff)=xint(ix)
            bxa(ixbeff)=bxa(ix)
            bya(ixbeff)=bya(ix)
            bza(ixbeff)=bza(ix)
          endif
        enddo

        if (ixbeff.gt.0) then

          x3=xint(1:3)
          b3=bya(1:3)
          call parabel_short(x3,b3,a3)
          xint(1)=xminbeff
          bya(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2
          b3=bza(1:3)
          call parabel_short(x3,b3,a3)
          bza(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2

          x3=xint(ixbeff-2:ixbeff)
          b3=bya(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          xint(ixbeff)=xmaxbeff
          bya(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2
          b3=bza(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          bza(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2

          do i=1,ixbeff
            write(lun,*)i,xint(i),bya(i),bza(i)
          enddo

          call util_spline_running_integral(xint,bya,ixbeff,byint,coef,
     &      ws1,ws2,ws3,ws4)

          bmnbeffd=1.0d30
          bmxbeffd=-1.0d30
          bmaxbeffd=-1.0d30
          do i=1,ixbeff
            if (bya(i).gt.bmxbeffd) then
              bmxbeffd=bya(i)
            endif
            if (bya(i).lt.bmnbeffd) then
              bmnbeffd=bya(i)
            endif
            if (abs(bya(i)).gt.bmaxbeffd) then
              bmaxbeffd=abs(bya(i))
              ibmax=i
            endif
            byint(i)=byint(i)**2
          enddo

          if (ibmax.eq.1) ibmax=2
          if (ibmax.eq.ixbeff) ibmax=ixbeff-1

          yp(1)=1.0d0
          yp(2)=2.0d0
          yp(3)=3.0d0
          bp(1)=abs(bya(ibmax-1))
          bp(2)=abs(bya(ibmax))
          bp(3)=abs(bya(ibmax+1))

          call util_max_parabel(3,yp,bp,dum,bmaxp,ws1,ws2,ifail)
          if (ifail.eq.0) bmaxbeffd=bmaxp

          call util_spline_running_integral(xint,byint,ixbeff,byint2,coef,
     &      ws1,ws2,ws3,ws4)

          beffd= sqrt(byint2(ixbeff)/(xint(ixbeff)-xint(1)))
c Correct for endpole effects
          if (bmaxbeffd.ne.0.0d0) then
            beffd=beffd*(bmxbeffd-bmnbeffd)/2.0d0/bmaxbeffd
          endif
          bmaxbeffd=(bmxbeffd-bmnbeffd)/2.0d0
          dkeffd = beffd * sqrt(2.0d0)  * 3.0d8 / 0.511d6 / 1000.0d0
          beffd = dkeffd / ((xint(ixbeff)-xint(1))*100.0d0) / 0.934d0 * 1000.0d0

          flush(lun) !undumag_byeff_dipoles.beff
          close(lun) !undumag_byeff_dipoles.beff

        else

          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end: No field data for Byeff calculation ***"
          write(lun6,*)

        endif !ixbeff

        write(lun6,*)"XminBeff, XmaxBeff (dipole approx.):",
     &    sngl(xminbeff),sngl(xmaxbeff)

        write(lun6,*)"ByMin, ByMax, (ByMax-ByMin)/2, ByEff (dipoles approx.):",
     &    sngl(bmnbeffd),sngl(bmxbeffd),
     &    sngl((bmxbeffd-bmnbeffd)/2.0d0),sngl(beffd)

        write(lun6,*)"BzMin, BzMax, (BzMax-BzMin)/2, BzEff (dipole approx.):",
     &    sngl(bmnbeffzd),sngl(bmxbeffzd),
     &    sngl((bmxbeffzd-bmnbeffzd)/2.0d0),sngl(beffzd)

        write(lun6,*)
        write(lun6,*)"Beff = Sqrt( ByEff**2 + BzEff**2 ) (dipole approx.):",
     &    sngl(sqrt(beffd**2+beffzd**2))

        dkeffd=sngl(sqrt(dkeffd**2+dkeffzd**2))

        write(lun6,*)

        write(lun6,*)"Keff and first harmonic [eV] (dipole approx):",
     &    sngl(dkeffd),sngl(950.0d0*ebeam**2/(1.0d0+dkeffd**2/2.0d0)/(perlen/10.0d0))
        write(lun6,*)

        call util_zeit_kommentar(lun6,"Writing undumag_dipoles.beff")
        open(newunit=lun,file="undumag_dipoles.beff")
        write(lun,*)"* Run:"
        write(lun,*)kundurun
        write(lun,*)"* XminBeff XmaxBeff:"
        write(lun,*)
     &    sngl(xminbeff),sngl(xmaxbeff)
        write(lun,*)"* ByMin, ByMax, (ByMax-ByMin)/2, ByEff:"
        write(lun,*)
     &    sngl(bmnbeffd),sngl(bmxbeffd),
     &    sngl((bmxbeffd-bmnbeffd)/2.0d0),sngl(beffd)
        write(lun,*)"* BzMin, BzMax, (BzMax-BzMin)/2, BzEff:"
        write(lun,*)
     &    sngl(bmnbeffzd),sngl(bmxbeffzd),
     &    sngl((bmxbeffzd-bmnbeffzd)/2.0d0),sngl(beffzd)
        write(lun,*)"* Beff = Sqrt( ByEff**2 + BzEff**2 ):"
        write(lun,*)
     &    sngl(sqrt(beffd**2+beffzd**2))
        write(lun,*)"* ByInt1, BzInt1, ByInt2, BzInt2:"
        write(lun,*)
     &    sngl(byint1fd),sngl(bzint1fd),
     &    sngl(byint2fd),sngl(bzint2fd)
        write(lun,*)"* ByInt1Inf, BzInt1Inf:"
        write(lun,*)
     &    sngl(byint1infd),sngl(bzint1infd)
        flush(lun)
        close(lun)
!} beff
      endif !(idipoles.ne.0) then

      deallocate (xint)
      deallocate (bxa)
      deallocate (bya)
      deallocate (bza)
      deallocate (byint)
      deallocate (bzint)
      deallocate (byint2)
      deallocate (bzint2)
      deallocate (ws1)
      deallocate (ws2)
      deallocate (ws3)
      deallocate (ws4)
      deallocate (coef)

      if (kurad.ne.0) then

        ndim=nstepp
        gammai=ebeam/emassg1

        if (xelec.eq.9999.0d0) xelec=xmapmin
        if (xf.eq.9999.0d0) xf=xmapmax

        xelec=xelec/1000.0d0
        yelec=yelec/1000.0d0
        zelec=zelec/1000.0d0

        ds=ds/1000.0d0

        xobsv=xobsv/1000.0d0
        yobsv=yobsv/1000.0d0
        zobsv=zobsv/1000.0d0

        xf=xf/1000.0d0
        yf=yf/1000.0d0
        zf=zf/1000.0d0

        call urad(jcharge,
     &    gammai,dgamtot
     &    ,xelec,yelec,zelec,vxelec,vyelec,vzelec
     &    ,xf,yf,zf,efx,efy,efz,
     &    xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds
     &    ,nthstep,nstep,ndim,traxyz
     &    ,xobsv,yobsv,zobsv,phelow,phehig,
     &    nphener,phener,aradx,arady,aradz,stokes,powden
     &    ,ieneloss,ivelofield,istatus
     &    )

        write(lun6,*)
        write(lun6,'(a,3g15.5)')"xelec, yelec, zelec for urad [mm]:",
     &    xelec*1000.,yelec*1000.,zelec*1000.
        write(lun6,'(a,3g15.5)')"vxelec, vyelec, vzelec for urad:",
     &    vxelec,vyelec,vzelec
        write(lun6,'(a,2g15.5)')"ebeam [GeV], gamma for urad:",ebeam, gamma
        write(lun6,'(a,3g15.5)')"xexit, yexit, zexit [mm]:",
     &    xexit*1000.0,yexit*1000.0,zexit*1000.0
        write(lun6,'(a,2g15.5)')"hori. and vert. kick at xexit [mrad]:",
     &    vnzex/vnxex*1000., vnyex/vnxex*1000.

        xplmin=1.0e30
        xplmax=-1.0e30
        yplmin=1.0e30
        yplmax=-1.0e30
        zplmin=1.0e30
        zplmax=-1.0e30

        call util_zeit_kommentar(lun6,"Writing urad_traxyz.dat")
        open(newunit=lun,file='urad_traxyz.dat',recl=256)

        do istep=1,nstep
          if (traxyz(1,istep).lt.xplmin) xplmin=sngl(traxyz(1,istep))
          if (traxyz(1,istep).gt.xplmax) xplmax=sngl(traxyz(1,istep))
          if (traxyz(2,istep).lt.yplmin) yplmin=sngl(traxyz(2,istep))
          if (traxyz(2,istep).gt.yplmax) yplmax=sngl(traxyz(2,istep))
          if (traxyz(3,istep).lt.zplmin) zplmin=sngl(traxyz(3,istep))
          if (traxyz(3,istep).gt.zplmax) zplmax=sngl(traxyz(3,istep))
          write(lun,'(14e17.7e3)')traxyz(1:3,istep)*1000.0,traxyz(4:14,istep)
        enddo

        flush(lun)
        close(lun)

c{ Plot x,y,z

        call util_zeit_kommentar(lun6,"Writing undumag_trajectory.eps")
        call mshplt_init(20,15.,15.,25,25,600,600,
     &    'undumag_trajectory.eps','','',0.)

        gsiz_ps=0.4

        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif

        theta_ps=sngl(traxyz_theta)
        phi_ps=sngl(traxyz_phi)

        xplmin=xplmin*1000.
        xplmax=xplmax*1000.
        yplmin=yplmin*1.0e6
        zplmin=zplmin*1.0e6
        yplmax=yplmax*1.0e6
        zplmax=zplmax*1.0e6

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin
        dzpl=zplmax-zplmin

        if (dypl.lt.1.0e-9) dypl=1.0
        if (dzpl.lt.1.0e-9) dzpl=1.0

        xplmin=xplmin-dxpl*0.05
        xplmax=xplmax+dxpl*0.05
        yplmin=yplmin-dypl*0.05
        yplmax=yplmax+dypl*0.05
        zplmin=zplmin-dzpl*0.05
        zplmax=zplmax+dzpl*0.05

        if (yplmin.le.zplmin) then
          zplmin=yplmin
        else
          yplmin=zplmin
        endif

        if (yplmax.ge.zplmax) then
          zplmax=yplmax
        else
          yplmax=zplmax
        endif

        call mshplt_frame3d_xzy(
     &    xplmin,xplmax,
     &    yplmin,yplmax,
     &    zplmin,zplmax,
     &    'x [mm]','y [mu-m]','z [mu-m]','')

        call mshplt_set_text_color(1,0,0,0)
        gsiz_ps=0.4
        call mgset('CHHE',0.4)
        call mshplt_text_ndc(0.1,1.05,ctitle)

        call mgset('PLCI',2.)

        do istep=1,nstep-1
          xpl(1)=sngl(traxyz(1,istep))*1000.
          xpl(2)=sngl(traxyz(1,istep+1))*1000.
          ypl(1)=sngl(traxyz(2,istep))*1.0e6
          ypl(2)=sngl(traxyz(2,istep+1))*1.0e6
          zpl(1)=zplmax+zplmin-sngl(traxyz(3,istep))*1.0e6
          zpl(2)=zplmax+zplmin-sngl(traxyz(3,istep+1))*1.0e6
          call mpl3(2,xpl,zpl,ypl)
        enddo

        call mshplt_end

c} Plot x,y,z

c{ Plot y,z

      call util_zeit_kommentar(lun6,"Writing undumag_y_z.eps")

      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_y_z.eps','','',0.)

      if (ixon.gt.1) then

        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif
        if (krunnum.ne.0) then
          write(ctitle,*)kundurun
          call util_string_trim(ctitle,nfirst,nlast)
          ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
        else
          ctitle=trim(usercom)
        endif

        if (kcomment.ne.0) call mtitle(trim(ctitle))
        call mshplt_hplset('YGTI',-0.5)

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do istep=1,nstep-1
          xpl(1)=sngl(traxyz(1,istep))*1000.
          xpl(2)=sngl(traxyz(1,istep+1))*1000.
          zpl(1)=sngl(traxyz(2,istep))*1.0e6
          zpl(2)=sngl(traxyz(2,istep+1))*1.0e6
          call mpl(2,xpl,zpl)
        enddo

        call mgset('PLCI',4.)

        do istep=1,nstep-1
          xpl(1)=sngl(traxyz(1,istep))*1000.
          xpl(2)=sngl(traxyz(1,istep+1))*1000.
          ypl(1)=sngl(traxyz(3,istep))*1.0e6
          ypl(2)=sngl(traxyz(3,istep+1))*1.0e6
          call mpl(2,xpl,ypl)
        enddo

        call mgset('CHHE',0.4)
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
        call mshplt_set_text_angle(90.)

        call mshplt_text_ndc(-0.1,0.65,'trajectory [mu-m]')

        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        call mshplt_text_ndc(0.85,0.9,'y')
        call mshplt_set_text_color(0,0,0,1)
        call mshplt_text_ndc(0.85,0.83,'z')
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)

        call muwk(0,0)
        call mshplt_end

      endif !ixon

c} Plot y,z

        s0min=1.0e30
        s1min=1.0e30
        s2min=1.0e30
        s3min=1.0e30
        s0max=-1.0e30
        s1max=-1.0e30
        s2max=-1.0e30
        s3max=-1.0e30
        call util_zeit_kommentar(lun6,"Writing urad_stokes.dat")
        open(newunit=lun,file='urad_stokes.dat',recl=256)
        do ifreq=1,nphener
          s0=sngl(stokes(1,ifreq))
          s1=sngl(stokes(2,ifreq))
          s2=sngl(stokes(3,ifreq))
          s3=sngl(stokes(4,ifreq))
          write(lun,*)sngl(phener(ifreq)),s0,s1,s2,s3
          if (s0.lt.s0min) s0min=s0
          if (s1.lt.s1min) s1min=s1
          if (s2.lt.s2min) s2min=s2
          if (s3.lt.s3min) s3min=s3
          if (s0.gt.s0max) s0max=s0
          if (s1.gt.s1max) s1max=s1
          if (s2.gt.s2max) s2max=s2
          if (s3.gt.s3max) s3max=s3
        enddo
        flush(lun)
        close(lun)

      endif !kurad

      call util_zeit_kommentar(lun6,"Writing undumag_spectrum.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_spectrum.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (krunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      if (nphener.ne.0) then

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

      gsiz_ps=0.4

      xplmin=sngl(phelow)
      xplmax=sngl(phehig)

! S0
      yplmin=s0min
      yplmax=s0max

      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(4.,10.,12.,18.)

      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S0 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_get_axis_label_offset(xlaboff,ylaboff)
      call mshplt_set_axis_label_offset(xlaboff,ylaboff*0.75)
      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  yplmin,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      call mshplt_set_text_angle(0.)

      call mgset('PLCI',2.)

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(1,ifreq))
        ypl(2)=sngl(stokes(1,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

! S1
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(13.,19.,12.,18.)
      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S1 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  -yplmax-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      call mgset('PLCI',2.)

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(2,ifreq))
        ypl(2)=sngl(stokes(2,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

      call mgset('PLCI',4.)

! S2
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(4.,10.,4.,10.)
      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S2 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  -yplmax-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      call mgset('PLCI',2.)

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(3,ifreq))
        ypl(2)=sngl(stokes(3,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

! S3
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(13.,19.,4.,10.)
      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S3 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  -yplmax-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(4,ifreq))
        ypl(2)=sngl(stokes(4,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

      call muwk(0,0)
      call mshplt_end

+self,if=-nowarnings.
      flush(lunwarn)
      close(lunwarn)
+self.,if=-nowarnings.

      endif !(nphener.ne.0) then

      if (kdumpconv.ne.0) then
        flush(lunconv)
        close(lunconv)
      endif

      if (killbadmag.lt.0.and.killbadmag.ne.-9999) then
        i=0
        call util_zeit_kommentar(lun6,"Writing undumag.bad")
        open(newunit=lunkill,file="undumag.bad")
        do imag=1,nmag
          if (bpebc(16,imag).ne.0.0d0) then
            write(lunkill,*)imag,nint(bpebc(16,imag)),bpebc(1:6,imag)
            i=i+1
          endif
        enddo
        flush(lunkill)
        close(lunkill)
        write(lun6,*)
        write(lun6,*)"File undumag.bad written, number of bad voxel:",i
      endif

      if (idipoles.ne.0) then
        call util_zeit_kommentar(lun6,"Writing undumag_map.dip")
        open(newunit=lun,file="undumag_map.dip")
        do imag=1,ndipoles
          write(lun,'(14e17.7e3)')dipoles(1:3,imag),
     &      dipoles(4,imag)*dipoles(5:7,imag),dipoles(9:16,imag)
        enddo
        flush(lun)
        close(lun)
      endif

      if (intmaglis.ne.0) then
        write(lun6,*)
        write(lun6,*)" --- Due to flag intmaglis, only magnets on file undumag_magmap.lis do contribute to field map ---"
        write(lun6,*)
      endif

c      call muwk(0,0)
c      call mshplt_end

+self,if=debugb.
      yint=0.0d0
      zint=0.0d0
      call undumag_bintinf_sym(0.0d0,yint,zint,1.0d0,0.0d0,0.0d0,
     &  bxintinf,byintinf,bzintinf,ifail)

      call undumag_field_int(1,
     &  1.0d0,yint,zint,
     &  1.0d0,0.0d0,0.0d0,
     &  bxi,byi,bzi,ifail)
      write(lun6,*)"---------------------------------------------"
      write(lun6,*)

      write(lun6,*)"Wahrheit a:",bxi*twopi*1000.0d0,byi*1000.0d0,bzi*1000.0d0
      write(lun6,*)"Wahrheit n:","           Null           ",byif,bzif
      write(lun6,*)"Wahrheit a:",bxi*twopi*1000.0d0,byi*twopi*1000.0d0,bzi*twopi*1000.0d0
      write(lun6,*)"Wahrheit n:","           Null           ",byif*twopi,bzif*twopi

+self.
+self,if=debuge.
      yint=0.0d0
      zint=0.0d0
      call undumag_bintinf_sym(0.0d0,yint,zint,1.0d0,0.0d0,0.0d0,
     &  bxintinf,byintinf,bzintinf,ifail)
      write(lun6,*)"Wahrheit a:",bxi*1000.0d0,byi*1000.0d0,bzi*1000.0d0
      write(lun6,*)"Wahrheit n:","           Null           ",byif,bzif
      write(lun6,*)"Nherung:  ","           Null          ",byint1infd,bzint1infd
      write(lun6,*)"Glaube:     ",
     &  bxintinf*1000.0d0,byintinf*1000.0d0,bzintinf*1000.0d0
+self.
      byplmin=1.0e30
      bzplmin=1.0e30
      byplmax=-1.0e30
      bzplmax=-1.0e30
      call util_zeit_kommentar(lun6,"Writing undumag_field_profile.dat")
      open(newunit=lunz,file='undumag_field_profile.dat')
      nz=(nint(zmaxprof-zminprof))+1
      zmin=dble(nint(zminprof))-1.0d0
      i=0
      do iz=1,nz
22      z=zmin+dble(iz)
        x=(xminbeff+xmaxbeff)/2.0d0
        y=0.0d0
        ! to avoid boundary effects:
        call util_random(3,g)
        g=g-0.5
c+self,if=rando10.
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif
c+self.,if=rando10.

        if (itry.eq.0.and.randoz.gt.0.0d0) g=0.

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif

        if (randoz.ge.0.0d0) then
          z=z+g(3)*randoza
        else
          z=z+randoza
        endif

        ifail=0

        if (itry.eq.0) ifail=-1

        call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,bx,by,bz,ifail)

        if (itry.eq.0.and.ifail.eq.-1) then
          ifail=0
        endif

        if (ifail.ne.0.and.itry.lt.10) then
          itry=itry+1
          goto 22
        endif
        itry=0

        if (ifail.le.0) then
          i=i+1
          write(lunz,*)x,y,z,bx,by,bz
          zppl(i)=sngl(z)
          bypl(i)=sngl(by)
          bzpl(i)=sngl(bz)
          if (by.lt.byplmin) byplmin=sngl(by)
          if (by.gt.byplmax) byplmax=sngl(by)
          if (bz.lt.bzplmin) bzplmin=sngl(bz)
          if (bz.gt.bzplmax) bzplmax=sngl(bz)
        endif

      enddo
      flush(lunz)
      close(lunz)

      nz=i

      call util_zeit_kommentar(lun6,"Writing undumag_field_profile.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_field_profile.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (krunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

c{ Plot By, Bz

      gsiz_ps=0.4

      xplmin=sngl(zminprof)
      xplmax=sngl(zmaxprof)
      yplmin=min(byplmin,bzplmin)
      yplmax=max(byplmax,bzplmax)
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mplfra(
     &  xplmin-dxpl*0.05,
     &  xplmax+dxpl*0.05,
     &  yplmin-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  '')

      call mgset('PLCI',2.)
      call mshplt_set_marker_size(0.5)

      do i=1,nz-1
        xpl(1)=sngl(zppl(i))
        xpl(2)=sngl(zppl(i+1))
        ypl(1)=sngl(bypl(i))
        ypl(2)=sngl(bypl(i+1))
        call mpl(2,xpl,ypl)
      enddo

      call mgset('PLCI',4.)

      do i=1,nz-1
        xpl(1)=sngl(zppl(i))
        xpl(2)=sngl(zppl(i+1))
        ypl(1)=sngl(bzpl(i))
        ypl(2)=sngl(bzpl(i+1))
        call mpl(2,xpl,ypl)
      enddo

      call mgset('CHHE',0.4)
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.9,-0.1,'z [mm]')
      call mshplt_set_text_angle(90.)
      if (abs(yplmax).lt.1.0e-3) then
        call mshplt_text_ndc(-0.1,0.86,'B [T]')
      else
        call mshplt_text_ndc(-0.1,0.88,'B [T]')
      endif
      call mshplt_set_text_angle(0.)
      call mgset('CHHE',0.5)
      call mshplt_set_text_color(0,1,0,0)
      call mshplt_text_ndc(0.85,0.9,'By')
      call mshplt_set_text_color(0,0,0,1)
      call mshplt_text_ndc(0.85,0.83,'Bz')
      call mshplt_set_text_color(1,0,0,0)
      call mgset('CHHE',0.4)

      call muwk(0,0)
      call mshplt_end

      call util_zeit_kommentar(lun6,"Writing undumag.wav")
      open(newunit=lunw,file='undumag.wav')

      write(lunw,'(a)')cundutit
      write(lunw,*)ncwires,nrec,nmag,nplanmax,ncornmax,' 20',' 3',' 8',
     &  " ! ncwires, nrec, nmag, nplanmax, ncornmax, 1_dim_bpebc, 1_dim_bperot, 2_dim_bpetm"
      write(lunw,*)ixsym,iysym,izsym,kxcenter,xsym,xcenter
      write(lunw,*)perlen,xmapmin,xmapmax,nper
      write(lunw,*)kurad,ebeam
      write(lunw,*)xelec,yelec,zelec
      write(lunw,*)vxelec,vyelec,vzelec
      write(lunw,*)xf,yf,zf
      write(lunw,*)efx,efy,efz
      write(lunw,*)tiny,window

      do imag=1,nmag
        write(lunw,*)imag
        write(lunw,*)bpebc(:,imag)
        nplan=ibpeplan(imag)
        write(lunw,*)nplan,ibpecol(imag)
        do iplan=1,nplan
          ncorn=ibpecorn(iplan,imag)
          write(lunw,*)ncorn
          do icorn=1,ncorn
            write(lunw,*)bpemag(1:3,icorn,iplan,imag)
            write(lunw,*)bperot(1:3,icorn,iplan,imag)
          enddo
          do i=1,8
            write(lunw,*)bpetm(1:3,i,iplan,imag)
          enddo
        enddo
      enddo

      do i=1,ncwires
        write(lunw,*)wire(:,i)
      enddo

      flush(lunw)
      close(lunw)

      call undumag_uout

      call util_zeit_kommentar(lun6,"Writing undumag.mat")
+self,if=debugend.
      !call util_break
+self.

      open(newunit=lunmat,file="undumag.mat")

      write(lunmat,'(a)') '* ' // ctitle

      do mat=1,nmatfiles
        n=matmaps(4,mat)
        mtyp=matmaps(2,mat)
        if (mtyp.eq.1) then
          if (n.eq.0) then
            if (newclc.ne.0) then
              br=0.0d0
              do ibrn=1,nbrnmat
                if (abs(brnmat(2,ibrn)).gt.br) br=abs(brnmat(2,ibrn))
              enddo
              kbrn=0
              do ibrn=1,nbrnmat
                if (nint(brnmat(1,ibrn)).eq.mat) then
                  kbrn=ibrn
                  exit
                endif
              enddo
              if (kbrn.eq.0) then
                write(lun6,*)
                write(lun6,*)"*** Warning in undumag_end: Could not find REC material in list of Br ***"
                write(lun6,*)"*** Be careful with plots of magnetisation ***"
              endif
              brn=sngl(abs(brnmat(2,ibrn)))
              hbmatmin=sngl(brn-bcmat(2,1,mat)*br)
              hbmatmax=sngl(brn+bcmat(2,1,mat)*br)
            endif !newclc
            write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(-br),hbmatmin,sngl(bcmat(3,1,mat))
            write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(br),hbmatmax,sngl(bcmat(3,1,mat))
          else
            do i=1,n
              write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(bcmat(1:3,i,mat))
            enddo
          endif
        else if (mtyp.eq.2) then
          do i=1,n
            write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(bcmat(1:3,i,mat))
          enddo
        endif !mtyp
      enddo

      flush(lunmat)
      close(lunmat)

      open(newunit=lunmat,file="undumag.brn")

      write(lunmat,'(a)') '* ' // ctitle

      do mat=1,nbrnmat
        write(lunmat,*) brnmat(1:2,mat)
      enddo

      flush(lunmat)
      close(lunmat)

      call clcmag_voxels_list(1)

      open(newunit=lunst,file="undumag.stat")
      write(lunst,*)"0"
      flush(lunst)
      close(lunst)

      flush(lunmag)
      close(lunmag)

9999  continue

      call  util_random_get_seed(irnsize,irnseed)

      call util_get_free_lun(lun)
      call util_zeit_kommentar(lun6,"Writing undumag.seeds")

      open(newunit=lun,file='undumag.seeds',status='unknown')

      write(lun,*)irnsize, kundurun
      do i=1,irnsize
        write(lun,*)i,irnseed(i)
      enddo

      flush(lun)
      close(lun)

      open(newunit=lun,file='undumag.gmd',status='unknown')
      write(lun,*)kundurun,modegui
      flush(lun)
      close(lun)

      return
      end
+DECK,undumag_relax_rec.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  08.59.21  by  Michael Scheer
*CMZ :  1.23/02 31/08/2017  12.21.55  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  13.42.22  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  14.14.30  by  Michael Scheer
*CMZ :  1.15/00 23/03/2017  17.02.57  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  16.57.45  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  09.36.56  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  16.17.07  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  10.40.13  by  Michael Scheer
*CMZ :  1.10/02 25/11/2016  10.03.38  by  Michael Scheer
*CMZ :  1.07/00 22/09/2016  11.23.13  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.31.45  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  15.11.30  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  14.32.50  by  Michael Scheer
*CMZ :  0.00/13 28/07/2016  12.39.02  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.04.42  by  Michael Scheer
*CMZ :  0.00/09 25/06/2016  14.02.31  by  Michael Scheer
*CMZ :  0.00/07 22/06/2016  14.20.00  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  13.40.01  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.50.43  by  Michael Scheer
*CMZ :  0.00/02 30/04/2016  13.06.46  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.15  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.47.36  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.18.50  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  18.46.54  by  Michael Scheer
*CMZ :  1.17/02 11/03/2016  16.48.04  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_relax_rec

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

!      bpebc(1:3,imag) contains position of magnet imag
!      bpebc(4:6,imag) contains normalized magnetization vector of magnet imag

      implicit none

      double precision bn,bx,by,bz,hx,hy,hz,bc(3),hpar,hper,parmag,permag,
     &  x,y,z,bcrot(3),hrot(3),hh(3),easy(3),hzmax,hzmin,bcint,dbcdh,
     &  h,hold,ht(3),vnormlab(3),vmaglab(3),hxtest,hytest,hztest,htest

      integer ifail,imoth,imag,iter,i,j,mat,matmode,ihz,nhz,mapmode,ical,iplan

      data ical/0/

      kconvrec=0
      h=0.0d0

      hxtest=0.0d0
      hytest=0.0d0
      hztest=0.0d0
      htest=0.0d0
      kinside=-1

      if (kdumpconv.ne.0) then
        do imag=1,nrec
          imoth=bpebc(15,imag)
          if (matrix.eq.0) then
            x=bpebc(1,imag)/1000.0d0
            y=bpebc(2,imag)/1000.0d0
            z=bpebc(3,imag)/1000.0d0
            call undumag_field(x,y,z,hx,hy,hz,ifail)
          else
            call undumag_bpolyeder_matrix(imag,hx,hy,hz,ifail)
          endif
          write(lunconv,*)kiter,iterrectot,imoth,imag,
     &      x*1000.0d0,y*1000.0d0,z*1000.0d0,
     &        hx,hy,hz,sqrt(hx**2+hy**2+hz**2)
     &      ,hxtest,hytest,hztest,htest,
     &      bpebc(4:6,imag),
     &      sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
        enddo
      endif

      do iter=1,maxiterrec

        iterrectot=iterrectot+1

        bc0(4:6,1:nrec)=bpebc(4:6,1:nrec)

        do imag=1,nrec

          mat=nint(bpebc(9,imag))
          easy=bpebc(11:13,imag)

          mapmode=matmaps(3,mat)
          nhz=matmaps(4,mat)

          if (matrix.eq.0) then
            x=bpebc(1,imag)/1000.0d0
            y=bpebc(2,imag)/1000.0d0
            z=bpebc(3,imag)/1000.0d0
            ! bpolyeder returns H, if inside magnet!
            kinside=-1
            call undumag_field(x,y,z,hh(1),hh(2),hh(3),ifail)
          else
            call undumag_bpolyeder_matrix(imag,hh(1),hh(2),hh(3),ifail)
          endif

          hpar=hh(1)*easy(1)+hh(2)*easy(2)+hh(3)*easy(3)
          hrot=hh-hpar*easy

          if (mapmode.eq.1) then
            ! equidistant map
            parksi=bcmat(2,1,mat)
            perksi=bcmat(3,1,mat)
            bc0(4:6,imag)=hrot*perksi+(bc0(10,imag)+hpar*parksi)*easy
          else if (mapmode.eq.2) then
            ! equidistant map
            perksi=bcmat(3,1,mat)
            hzmin=bcmat(1,1,mat)
            hzmax=bcmat(1,nhz,mat)
            if (hpar.ge.hzmin.and.hpar.le.hzmax) then
              if (nhz.gt.1) then
                ihz=int((hpar-hzmin)/((hzmax-hzmin)/(nhz-1)))+1
                ihz=min(ihz,nhz-1)
                if (ihz.lt.nhz) then
                  bc0(4:6,imag)=hrot*perksi+
     &              (bcmat(2,ihz,mat)+(bcmat(2,ihz+1,mat)-bcmat(2,ihz,mat))/
     &              (bcmat(1,ihz+1,mat)-bcmat(1,ihz,mat))*
     &              (hpar-bcmat(1,ihz,mat)))*easy
                else
                  bc0(4:6,imag)=hrot*perksi+
     &              (bcmat(2,ihz-1,mat)+(bcmat(2,ihz,mat)-bcmat(2,ihz-1,mat))/
     &              (bcmat(1,ihz,mat)-bcmat(1,ihz-1,mat))*
     &              (hpar-bcmat(1,ihz-1,mat)))*easy
                endif
              else
                write(lun6,*)"*** Error in undumag_relax_rec: Only one data point for mat:",mat
                stop
              endif
            else
              write(lun6,*)"*** Error in undumag_relax_rec: H out of range, mat, H:",mat,hpar
              stop
            endif
          else
            write(lun6,*)"*** Error in undumag_relax_rec: Unknown material mode:",mapmode
            stop
          endif !mapmode

        enddo !nrec

        do imag=1,nrec

          if (
     &        bc0(4,imag).ne.bc0(4,imag)
     &        .or.
     &        bc0(5,imag).ne.bc0(5,imag)
     &        .or.
     &        bc0(6,imag).ne.bc0(6,imag)
     &        ) then
            write(lun6,*)"*** Warning in undumag_relax_rec: Magnetization bpebc is not a number ***"
            write(lun6,*)
     &        "kiter,iterrectot,imag,x,y,z:",
     &        kiter,iterrectot,imag,bpebc(1:3,imag)
            write(lun6,*)"Previous values of magnetization kept:"
            write(lun6,*)bpebc(4:6,imag)
          else
            bpebc(4:6,imag)=bc0(4:6,imag)
            bpebc(7,imag)=sqrt(
     &        bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
          endif
          vmaglab(1:3)=bpebc(4:6,imag)
          do iplan=1,iabs(ibpeplan(imag))
            vnormlab(1:3)=bpetm(1:3,8,iplan,imag)
            bpetm(1,7,iplan,imag)=
     &        vmaglab(1)*vnormlab(1)+
     &        vmaglab(2)*vnormlab(2)+
     &        vmaglab(3)*vnormlab(3)
          enddo
        enddo

        niterrec=iter

        if (kdumpconv.ne.0) then
          imoth=bpebc(15,imag)
          hxtest=0.0d0
          hytest=0.0d0
          hztest=0.0d0
          htest=0.0d0
          do imag=1,nrec
            if (matrix.eq.0) then
              x=bpebc(1,imag)/1000.0d0
              y=bpebc(2,imag)/1000.0d0
              z=bpebc(3,imag)/1000.0d0
              call undumag_field(x,y,z,hx,hy,hz,ifail)
            else
              call undumag_bpolyeder_matrix(imag,hx,hy,hz,ifail)
            endif
            write(lunconv,*)kiter,iterrectot,imoth,imag,
     &        x*1000.0d0,y*1000.0d0,z*1000.0d0,
     &        hx,hy,hz,sqrt(hx**2+hy**2+hz**2)
     &        ,hxtest,hytest,hztest,htest,
     &        bpebc(4:6,imag),
     &        sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
          enddo
        endif

        kinside=0
        hold=h
        h=0.0d0

        if (maxiterrec.gt.1) then
          call undumag_bconv(h)
          if (hold.ne.0.0d0) then
            if (abs(h/hold-1.0d0).lt.hconva) then
              kconvrec=1
              goto 9999
            endif
          endif
        endif

      enddo !iter

9999  continue

      ical=1

      return
      end
+DECK,undumag_relax_iron.
*CMZ :  2.04/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  20.27.45  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.01/03 30/04/2019  13.33.26  by  Michael Scheer
*CMZ :  2.00/03 24/04/2018  12.16.06  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  08.58.25  by  Michael Scheer
*CMZ :  1.23/03 22/09/2017  17.51.41  by  Michael Scheer
*CMZ :  1.23/02 31/08/2017  12.21.44  by  Michael Scheer
*CMZ :  1.19/00 19/06/2017  12.56.59  by  Michael Scheer
*CMZ :  1.17/08 29/05/2017  16.45.03  by  Michael Scheer
*CMZ :  1.17/07 22/05/2017  09.09.02  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.27.21  by  Michael Scheer
*CMZ :  1.17/05 18/05/2017  09.23.26  by  Michael Scheer
*CMZ :  1.17/04 09/05/2017  14.57.54  by  Michael Scheer
*CMZ :  1.17/03 09/05/2017  13.13.21  by  Michael Scheer
*CMZ :  1.17/02 09/05/2017  13.07.06  by  Michael Scheer
*CMZ :  1.17/01 08/05/2017  20.49.50  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  16.36.43  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  13.33.40  by  Michael Scheer
*CMZ :  1.15/12 05/05/2017  10.18.32  by  Michael Scheer
*CMZ :  1.15/11 03/05/2017  09.18.32  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.30.22  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  16.50.20  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  16.18.05  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  15.44.29  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  15.24.09  by  Michael Scheer
*CMZ :  1.10/02 28/11/2016  16.36.32  by  Michael Scheer
*CMZ :  1.07/00 22/09/2016  11.21.55  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  12.04.03  by  Michael Scheer
*CMZ :  1.05/00 16/09/2016  12.00.51  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  15.11.30  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  14.42.07  by  Michael Scheer
*CMZ :  1.02/01 04/09/2016  16.30.16  by  Michael Scheer
*CMZ :  1.02/00 30/08/2016  12.06.55  by  Michael Scheer
*CMZ :  1.01/00 20/08/2016  20.03.15  by  Michael Scheer
*CMZ :  0.00/13 18/08/2016  09.26.09  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.19.24  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.26.19  by  Michael Scheer
*CMZ :  0.00/10 14/07/2016  12.10.17  by  Michael Scheer
*CMZ :  0.00/09 06/07/2016  08.44.44  by  Michael Scheer
*CMZ :  0.00/02 02/05/2016  08.14.51  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  15.04.02  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.29.14  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  10.50.55  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  18.47.26  by  Michael Scheer
*CMZ :  1.17/03 22/03/2016  09.00.36  by  Michael Scheer
*CMZ :  1.17/02 14/03/2016  18.22.42  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_relax_iron

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

      real, dimension (:), allocatable :: rshuffle
      integer, dimension (:), allocatable :: ishuffle,iwarn

      double precision bc(3),x,y,z,bx,by,bz,dh3(3),h3(3),b,b3(3),h3e(3),he,
     &  h3t(3),ht,bc3(3),f3(3),
     &  hx,hy,hz,bpebc1(9),bn,
     &  dmag1,dmag2,dmag,dbc(3),bco(3),h,hcold,hold,hmin,hmax,femag,
     &  htest,hxtest,hytest,hztest,h1,vmaglab(3),dhmin5,dh,dho,
     &  fesat,htesto,chi,bcvox(3),ftol,dhth,dhtho,dum1,dum2,
     &  dumv1(3),dumv2(3),fm0,fm1,h0,ddhth,chio

      double precision vnor,vx,vy,vz

+seq,bcbuff.

      integer kfail,ifail,imoth,lmag,kmag,imag,iter,k,i,iron1,iron2,
     &  iplan,ih,il,
     &  nhz,mat,mapmode,ichi,kdump8,i1,i2

      save hold,ishuffle,rshuffle,iwarn

      vnor(vx,vy,vz)=sqrt(vx**2+vy**2+vz**2) !inline code

      iron1=nrec+1
      iron2=nmag

      if (ncwires.eq.0.and.nrec.eq.0) then
        do kmag=iron1,iron2
          bpebc(4:7,kmag)=0.0d0
        enddo
        return
      endif

      kconviron=0
      h=0.0d0
      kdump8=0

      if (kiter.eq.1) then

        allocate (ishuffle(nmag))
        allocate (rshuffle(nmag))
        allocate (iwarn(nmag))

        iwarn=0
        lmag=0

        do kmag=iron1,iron2
          lmag=lmag+1
          ishuffle(lmag)=kmag
        enddo

+self,if=damp8.
        damp8=dampiron
        idamp8=1
+self.,if=damp8.

        write(lun6,*)
        write(lun6,*)"Max. number iterations in undumag_relax_iron, i.e. maxiterion:",maxiteriron
        write(lun6,*)

        lmag=0

        magmag=0
        hold=0.0d0

      endif !(kiter.eq.1) then

      if (kshuffle.ne.0) then
        call util_random(niron,rshuffle)
        do i=1,niron
          k=niron-i+1
          kmag=rshuffle(i)*k+1.0
          lmag=ishuffle(kmag)
          ishuffle(kmag)=ishuffle(k)
          ishuffle(k)=lmag
        enddo
      endif !kshuffle

      hxtest=0.0d0
      hytest=0.0d0
      hztest=0.0d0
      htest=0.0d0
      kinside=-1

      if (kdumpconv.ne.0) then
        lmag=0
        do kmag=iron1,iron2
          lmag=lmag+1
          imag=ishuffle(lmag)
          x=bpebc(1,imag)/1000.0d0
          y=bpebc(2,imag)/1000.0d0
          z=bpebc(3,imag)/1000.0d0
          imoth=nint(bpebc(15,imag))
          call undumag_field(x,y,z,hx,hy,hz,ifail)
          write(lunconv,*)kiter,iterirontot,imoth,imag,
     &      x*1000.0d0,y*1000.0d0,z*1000.0d0,
     &        hx,hy,hz,sqrt(hx**2+hy**2+hz**2)
     &      ,hxtest,hytest,hztest,htest,
     &      bpebc(4:6,imag),
     &      sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
        enddo
      endif

      hcold=0.0d0

      do iter=1,maxiteriron

        iterirontot=iterirontot+1

        bc0(4:6,iron1:iron2)=bpebc(4:6,iron1:iron2)

        kinside=-1
        lmag=0

        do kmag=iron1,iron2

          lmag=lmag+1
          imag=ishuffle(lmag)

          mat=nint(bpebc(9,imag))
          mapmode=matmaps(3,mat)
          bco=bc0(4:6,imag)

          if (mapmode.eq.0) then ! mu is infinite until saturation is reached

            if (matrix.eq.0) then
              write(lun6,*)"*** Error in undumag_relax_iron: Mapmode=0 requires matrix mode ***"
              stop
            else
              call undumag_bpolyeder_matrix(imag,h3t(1),h3t(2),h3t(3),ifail)
              h3=bc00(1:3,imag)*bco
            endif

            h3e=h3t-h3
            he=sqrt(h3e(1)**2+h3e(2)**2+h3e(3)**2)

            bc3=-h3e/bc00(1:3,imag)
            bn=vnor(bc3(1),bc3(2),bc3(3))
            femag=bn

            fesat=bcmat(2,1,mat)

            if (bn.gt.fesat) then
              bc3=bc3/femag*fesat
            endif

            dbc=bc3-bco
            bc0(4:6,imag)=bco+dbc*dampiron

            if (ibulk.eq.0) then
              ! For this mode, magnetization is immediatly updated
              bpebc(4:6,imag)=bc0(4:6,imag)
              vmaglab(1:3)=bpebc(4:6,imag)
              do iplan=1,iabs(ibpeplan(imag))
                bpetm(1,7,iplan,imag)=
     &            vmaglab(1)*bpetm(1,8,iplan,imag)+
     &            vmaglab(2)*bpetm(2,8,iplan,imag)+
     &            vmaglab(3)*bpetm(3,8,iplan,imag)
              enddo
            endif !ibulk

          else if (mapmode.eq.2) then

            nhz=matmaps(4,mat)
            fesat=bcmat(2,nhz,mat)

            if (kiter.eq.1.and.iter.eq.1.and.isplinefm.ne.0) then
              call util_spline_coef(feh1,fem1,nhz,0.0d0,0.0d0,
     &          fespl1,fewspl1,fewspl2,fewspl3,fewspl4)
              call util_spline_coef(fem1,feh1,nhz,0.0d0,0.0d0,
     &          ufespl1,fewspl1,fewspl2,fewspl3,fewspl4)
            endif

            if (matrix.eq.0) then
              write(lun6,*)"*** Error in undumag_relax_iron: Mapmode=2 requires matrix mode ***"
              stop
            else
              call undumag_bpolyeder_matrix(imag,h3t(1),h3t(2),h3t(3),ifail)
              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_relax_iron: Bad return from undumag_bpolyeder_matrix for magnet ",imag," ***"
              endif
              h3=bc00(1:3,imag)*bco
            endif

            ht=sqrt(h3t(1)**2+h3t(2)**2+h3t(3)**2)
            h3e=h3t-h3
            he=sqrt(h3e(1)**2+h3e(2)**2+h3e(3)**2)
            h3=h3t
            h=ht

            if (nhz.eq.3) then
              ifail=0
              if (h.lt.feh1(2)) then
                femag=fem1(1)+(fem1(2)-fem1(1))/(feh1(2)-feh1(1))*(h-feh1(1))
              else
                femag=fem1(2)+(fem1(3)-fem1(2))/(feh1(3)-feh1(2))*(h-feh1(2))
              endif
            else
              hmin=bcmat(1,1,mat)
              hmax=bcmat(1,nhz,mat)
              femag=fesat
              ifail=-1
              if (h.ge.hmin.and.h.le.hmax) then
                !non-equidistant linear interpolation
                call util_interpol_linear(nhz,feh1,fem1,h,femag,ifail)
              endif
              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_relax_iron: H is out of range for material or bad interpolation",mat
                write(lun6,*)"iter, mag, Hmin, Hmax, H:", iter,imag, hmin,hmax,h
                stop
              endif
            endif

            chio=0.0d0
            chi=1.0d0

            ifail=-1

            do ichi=1,nchiiron
              chio=chi
              chi=femag/h
              if(abs(chio/chi-1.0d0).lt.chicut) then
                exit
              endif
              h3(1:3)=h3e(1:3)/(1.0d0-bc00(1:3,imag)*chi)
              h=sqrt(h3(1)**2+h3(2)**2+h3(3)**2)
              if (nhz.eq.3) then
                ifail=0
                if (h.lt.feh1(2)) then
                  femag=fem1(1)+(fem1(2)-fem1(1))/(feh1(2)-feh1(1))*(h-feh1(1))
                else
                  femag=fem1(2)+(fem1(3)-fem1(2))/(feh1(3)-feh1(2))*(h-feh1(2))
                endif
              else
                hmin=bcmat(1,1,mat)
                hmax=bcmat(1,nhz,mat)
                femag=fesat
                ifail=-1
                if (h.ge.hmin.and.h.le.hmax) then
                  !non-equidistant linear interpolation
                  if (isplinefm.eq.0) then
                    call util_interpol_linear(nhz,feh1,fem1,h,femag,kfail)
                    if (kfail.ne.0) then
                      write(lun6,*)"*** Error in undumag_relax_iron: H is out of range for material or bad interpolation",mat
                      write(lun6,*)"mag, Hmin, Hmax, H:", imag, hmin,hmax,h
                      stop
                    endif
                  else
                    call util_spline_inter(feh1,fem1,fespl1,nhz,h,femag,0)
                  endif
                endif
              endif
              bcvox=h3/h*femag
            enddo !ichi

            dbc=bcvox-bco
            bc0(4:6,imag)=bco+dbc*dampiron

            if (ichi.gt.nchiiron) ichi=nchiiron
            if (ichi.gt.nchimax) nchimax=ichi

            if (ibulk.eq.0) then
              ! For this mode, magnetization is immediatly updated
              bpebc(4:6,imag)=bc0(4:6,imag)
              vmaglab(1:3)=bpebc(4:6,imag)
              do iplan=1,iabs(ibpeplan(imag))
                bpetm(1,7,iplan,imag)=
     &            vmaglab(1)*bpetm(1,8,iplan,imag)+
     &            vmaglab(2)*bpetm(2,8,iplan,imag)+
     &            vmaglab(3)*bpetm(3,8,iplan,imag)
              enddo
            endif !ibulk

          else if (mapmode.eq.3) then

            nhz=matmaps(4,mat)
            fesat=bcmat(2,nhz,mat)

            if (kiter.eq.1.and.iter.eq.1.and.isplinefm.ne.0) then
              call util_spline_coef(feh1,fem1,nhz,0.0d0,0.0d0,
     &          fespl1,fewspl1,fewspl2,fewspl3,fewspl4)
              call util_spline_coef(fem1,feh1,nhz,0.0d0,0.0d0,
     &          ufespl1,fewspl1,fewspl2,fewspl3,fewspl4)
            endif

            if (matrix.eq.0) then
              write(lun6,*)"*** Error in undumag_relax_iron: Mapmode=3 requires matrix mode ***"
              stop
            else
              call undumag_bpolyeder_matrix(imag,h3t(1),h3t(2),h3t(3),ifail)
              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_relax_iron: Bad return from undumag_bpolyeder_matrix for magnet ",imag," ***"
              endif
              h3=bc00(1:3,imag)*bco
            endif

            h3e=h3t-h3
            he=sqrt(h3e(1)**2+h3e(2)**2+h3e(3)**2)
            h3=h3e
            h=he

            ifail=1

            i1=1
            i2=nhz

            h=feh1(i1)
            femag=fem1(i1)

            bc3=h3e/(h/femag-bc00(1:3,imag))
            h3t=h3e+bc00(1:3,imag)*bc3
            ht=vnor(h3t(1),h3t(2),h3t(3))

            dhth=ht-h

            hhbuff(1)=dhth
            bcbuff(1)=femag

            h=feh1(i2)
            femag=fem1(i2)

            bc3=h3e/(h/femag-bc00(1:3,imag))
            h3t=h3e+bc00(1:3,imag)*bc3
            ht=vnor(h3t(1),h3t(2),h3t(3))

            dhth=ht-h

            hhbuff(2)=dhth
            bcbuff(2)=femag

            il=i1
            ih=i2

            do while ((ih-il).gt.1)

              i=(ih+il)/2

              h=feh1(i)
              femag=fem1(i)

              bc3=h3e/(h/femag-bc00(1:3,imag))
              h3t=h3e+bc00(1:3,imag)*bc3
              ht=vnor(h3t(1),h3t(2),h3t(3))
              dhth=ht-h

              hhbuff(3)=dhth
              bcbuff(3)=femag

              if (
     &            hhbuff(1).gt.0.0d0.and.hhbuff(3).lt.0.0d0.or.
     &            hhbuff(1).lt.0.0d0.and.hhbuff(3).gt.0.0d0
     &            ) then
                ih=i
                hhbuff(2)=hhbuff(3)
                bcbuff(2)=bcbuff(3)
              else if (
     &            hhbuff(2).gt.0.0d0.and.hhbuff(3).lt.0.0d0.or.
     &            hhbuff(2).lt.0.0d0.and.hhbuff(3).gt.0.0d0
     &            ) then
                il=i
                hhbuff(1)=hhbuff(3)
                bcbuff(1)=bcbuff(3)
              else
                ifail=91
                goto 91
              endif

            enddo !while

            dhtho=hhbuff(1)
            dhth=hhbuff(2)
            fm0=bcbuff(1)
            fm1=bcbuff(2)

            do ichi=1,nchiiron

              ddhth=(dhth-dhtho)/(fm1-fm0)
              femag=fm0-dhtho/ddhth
              fm0=fm1
              fm1=femag

              if (fm1.lt.fem1(nhz)) then
                if (isplinefm.eq.0) then
                  call util_interpol_linear(nhz,fem1,feh1,fm1,h,kfail)
                  if (kfail.ne.0) then
                    write(lun6,*)"*** Error in undumag_relax_iron: H is out of range for material or bad interpolation",mat
                    write(lun6,*)"mag, Hmin, Hmax, H:", imag,hmin,hmax,h
                    stop
                  endif
                else
                  call util_spline_inter(fem1,feh1,ufespl1,nhz,fm1,h,0)
                endif
              else
                fm1=fem1(nhz)
                h=feh1(nhz)
              endif

              bc3=h3e/(h/fm1-bc00(1:3,imag))
              h3t=h3e+bc00(1:3,imag)*bc3
              ht=vnor(h3t(1),h3t(2),h3t(3))
              dhtho=dhth
              dhth=ht-h
              femag=fm1

              if (abs(dhth).lt.chicut) then
                ifail=0
                exit
              endif

            enddo !nchiiron

91          continue

            if (ifail.ne.0.and.iwarn(imag).eq.0) then

              write(lun6,*)
              write(lun6,*)"*** Error in undumag_relax_iron: No solution found for magnet ",imag
              write(lun6,*)"Total iteration:",kiter
              write(lun6,*)"Iron iteration:",iter
              write(lun6,*)"Check parameters like nchiiron or chicut or try relaxation mode 2!"
              write(lun6,*)
              iwarn(imag)=1

            else

              bc3=h3e/(h/femag-bc00(1:3,imag))

              dbc=bc3-bco
              bc0(4:6,imag)=bco+dbc*dampiron
+self,if=damp8.
              bc0(4:6,imag)=bco+dbc*damp8

              if (kdump8.eq.0) then
                if (damp8.lt.0.1d0) then
                  damp8=damp8+damp8*sqrt((1.0d0-damp8)*damp8)
                else if (damp8.lt.0.99d0) then
                  damp8=damp8+damp8*((1.0d0-damp8)*damp8)**2
                else
                  damp8=1.0d0
                endif
                kdump8=1
              endif
+self.,if=damp8.

              if (ibulk.eq.0) then
                ! For this mode, magnetization is immediatly updated
                bpebc(4:6,imag)=bc0(4:6,imag)
                vmaglab(1:3)=bpebc(4:6,imag)
                do iplan=1,iabs(ibpeplan(imag))
                  bpetm(1,7,iplan,imag)=
     &              vmaglab(1)*bpetm(1,8,iplan,imag)+
     &              vmaglab(2)*bpetm(2,8,iplan,imag)+
     &              vmaglab(3)*bpetm(3,8,iplan,imag)
                enddo
              endif !ibulk

            endif !ifail

            !end mapmode.eq.3

          else !mapmode
            write(lun6,*)"*** Error in undumag_relax_iron: Unknown material mode:",mapmode
            stop
          endif !mapmode

        enddo !niron

        if (ibulk.ne.0) then
          lmag=0
          do kmag=iron1,iron2
            lmag=lmag+1
            imag=ishuffle(lmag)
            if (
     &          bc0(4,imag).ne.bc0(4,imag)
     &          .or.
     &          bc0(5,imag).ne.bc0(5,imag)
     &          .or.
     &          bc0(6,imag).ne.bc0(6,imag)
     &          ) then
              write(lun6,*)"*** Warning in undumag_relax_iron: Magnetization bpebc is not a number (NaN) ***"
              write(lun6,*)
     &          "kiter,iterirontot,imag,x,y,z:",
     &          kiter,iterirontot,imag,bpebc(1:3,imag)
              write(lun6,*)"Previous values of magnetization kept:"
              write(lun6,*)bpebc(4:6,imag)
            else
              bpebc(4:6,imag)=bc0(4:6,imag)
              bpebc(7,imag)=sqrt(
     &          bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
            endif

            vmaglab(1:3)=bpebc(4:6,imag)
            do iplan=1,iabs(ibpeplan(imag))
              bpetm(1,7,iplan,imag)=
     &          vmaglab(1)*bpetm(1,8,iplan,imag)+
     &          vmaglab(2)*bpetm(2,8,iplan,imag)+
     &          vmaglab(3)*bpetm(3,8,iplan,imag)
            enddo
          enddo

        endif !ibulk

        niteriron=iter
        kinside=0

        htesto=htest
        htest=0.0d0

        if (maxiteriron.gt.1) then

          call undumag_bconv(htest)
          if (
     &        htest-hold.gt.0.0d0.and.hcold.lt.0.0d0
     &        .or.
     &        htest-hold.lt.0.0d0.and.hcold.gt.0.0d0
     &        ) then
            lmag=0
            do kmag=iron1,iron2
              lmag=lmag+1
              imag=ishuffle(lmag)
              bpebc(4:6,imag)=(bpebc(4:6,imag)+bc00(4:6,imag))/2.0d0
              bpebc(7,imag)=sqrt(
     &          bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
              vmaglab(1:3)=bpebc(4:6,imag)
              do iplan=1,iabs(ibpeplan(imag))
                bpetm(1,7,iplan,imag)=
     &            vmaglab(1)*bpetm(1,8,iplan,imag)+
     &            vmaglab(2)*bpetm(2,8,iplan,imag)+
     &            vmaglab(3)*bpetm(3,8,iplan,imag)
              enddo
            enddo
          endif

          if (kdumpconv.ne.0) then
            kinside=-1
            lmag=0
            do kmag=iron1,iron2
              lmag=lmag+1
              imag=ishuffle(lmag)
              x=bpebc(1,imag)/1000.0d0
              y=bpebc(2,imag)/1000.0d0
              z=bpebc(3,imag)/1000.0d0
              call undumag_field(x,y,z,hx,hy,hz,ifail)
              imoth=nint(bpebc(15,imag))
              write(lunconv,*)kiter,iterirontot,imoth,imag,
     &          x*1000.0d0,y*1000.0d0,z*1000.0d0,
     &          hx,hy,hz,sqrt(hx**2+hy**2+hz**2)
     &          ,hxtest,hytest,hztest,htest,
     &          bpebc(4:6,imag),
     &          sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
            enddo
          endif

          if (kconviron.gt.2) goto 9999

          if (hold.ne.0.0.and.dampfac.eq.0.0d0) then
            if (abs(htest/hold-1.0d0).lt.hconva) then
              kconviron=1
              goto 9999
            endif
          endif

          hcold=htest-hold
          hold=htest
          bc00(4:6,iron1:iron2)=bpebc(4:6,iron1:iron2)

        endif !maxiteriron.gt.1

      enddo !iter

9999  continue

      hold=htest

      return
      end
+DECK,undumag_bpolyeder.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/00 26/10/2020  14.56.48  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  12.32.35  by  Michael Scheer
*CMZ :  2.01/03 15/07/2019  15.03.51  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  16.29.19  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  14.11.34  by  Michael Scheer
*CMZ :  1.23/03 19/09/2017  19.25.01  by  Michael Scheer
*CMZ :  1.23/02 30/08/2017  13.27.12  by  Michael Scheer
*CMZ :  1.22/02 31/07/2017  10.32.51  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.46.06  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  09.55.55  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  09.17.17  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.26.26  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  11.26.04  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  16.58.30  by  Michael Scheer
*CMZ :  1.15/10 12/04/2017  14.53.10  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.30.25  by  Michael Scheer
*CMZ :  1.15/03 03/04/2017  10.59.22  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  07.35.42  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  13.53.21  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.31.38  by  Michael Scheer
*CMZ :  1.11/03 16/01/2017  12.22.22  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  09.47.59  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.07/00 23/09/2016  09.19.06  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.10.51  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.27.23  by  Michael Scheer
*CMZ :  0.00/13 28/07/2016  16.09.29  by  Michael Scheer
*CMZ :  0.00/09 06/07/2016  08.42.18  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  13.18.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.13  by  Michael Scheer
*CMZ :  0.00/01 25/04/2016  16.03.15  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.41.34  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  09.46.51  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  13.27.16  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.31.31  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  13.53.25  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  10.43.50  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  18.38.48  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bpolyeder(xin,yin,zin,bxout,byout,bzout,ifail)
c
c      Calculation of magnetic field of polyhedron according to
c      Oleb Chubar, Pascal Elleaume and Joel Chavanne
c      J. Synchrotron Rad. (1998) 5, 481-484
c
c Paper contains an error: The rotation matrix is wrong, since for nz=-1 the
c                          determinant is -1, which yields to errors??.
c Private notice:
c Einige Terme sind unklar, Notizen finden sich im Ordner RADIA/POLYMAG
c Siehe auch Notebooks: rec_int.nb, qx_rect.nb etc.
c oder Reduce olegqz.red, qxqyqz.red, rec_int.red etc.

+self,if=omp.
      use omp_lib
+self.
      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none
+seq,seqdebug.

      double precision xin,yin,zin,bxout,byout,bzout
      double precision r1(3),r2(3),dlab(3),blab(3)
      double precision ts(3,3),tsinv(3,3),bplan(3),bcvn,vnormlab(3)
      double precision xx,yy,zz,xxrot,yyrot,zzrot,xx00,xxsh
      double precision a,b,z,qx,qy,qz,qxp,qyp,qzp,qxm,qym,qzm,
     &  pi4inv,reverse,tiny2,
     &  bxm,bym,bzm,bxp,byp,bzp,rr0,rrm
      double precision q(3,3),vmagrot(3),vmaglab(3),h(3),
     &  xr(2),yr(2),zr(2),dum,dume,bo(3,nthreadp)

      double precision xmin,xmax,ymin,ymax,zmin,zmax,bx,by,bz

      parameter (pi4inv=0.0795774715459477d0)

      integer ical
      integer itiny,iwtiny,jtiny
      integer imag,iplan,ncorn,icorn,i,j,k,ip2,kwarn,kwarni,ic
      integer nx,ny,nz,ifailin,ifail,ifailm,ifailp,ishim,ishima,iimag,
     &  nmag1,nmag2,iout,linside,
     &  kfail(nthreadp),kinsidelocal(nthreadp)

      integer nmaxth,ith,istat

      save bo,nmaxth,ith,ical,kinsidelocal

      data ical/0/

      kwarncom=0

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      tiny2=tiny*tiny

      ifailin=ifail
      ifail=0
      ifailm=0
      ifailp=0

c calculate field at (xin,yin,zin)

      if (magmag.lt.0) then
        return
      endif !magmag.le.0

c      if (xin.eq.0.0d0) return
      xx=xin*1000.0d0
c      if (abs(xx+15.6).lt.0.05) then
c        iseqdebug=1
c      else
c        iseqdebug=0
c      endif
      yy=yin*1000.0d0
      zz=zin*1000.0d0

      itiny=0
      jtiny=0
      iwtiny=0

      if (ical.eq.0) then
        nmaxth=1
        ith=1
+self,if=omp.
        nmaxth=nthreads
        nmaxth=OMP_GET_MAX_THREADS()
        if (nthreads.gt.0) nmaxth=min(nmaxth,nthreads,nthreadp)
c        write(lun6,*)"Number of CPU cores used:",nmaxth
+self.
        bo=0.0d0
        ical=1
      endif

      bo=0.0d0
      kinsidelocal=kinside
      kwarni=0
      kwarn=0
      kfail=0

+self,if=omp.
!$OMP PARALLEL NUM_THREADS(nmaxth) DEFAULT(PRIVATE)
!$OMP& SHARED(kfail,iseqdebug,kinsidelocal,ical,bpetm,window,bpebc,bpemag,ibpeplan,ibpecorn,bperot,bo,iwarnbound,nwarnbound)
!$OMP& FIRSTPRIVATE(nmag,itiny,jtiny,iwtiny,tiny,xin,yin,zin,xx,yy,zz,kwarni,kwarn,lun6)
      ith=OMP_GET_THREAD_NUM()+1
      bo(1:3,ith)=0.0d0
!$OMP DO
+self.
      do imag=1,nmag

        if (bpebc(17,imag).lt.0.0d0) then
          cycle
        endif

        bcvn=0.0d0

        if (abs(xx-bpebc(1,imag)).le.window) then

          !non-zero magnetization and no virgin shim
          if (bpebc(7,imag).ne.0.0d0.and.bpebc(7,imag).ne.9999.) then

            if(bpebc(8,imag).eq.1) then !not rectangular nor cylindrical magnet

c check, if we are inside of magnet; we assume convex shape
              if (kinsidelocal(ith).ne.-1) then

                iout=-1

                do iplan=1,ibpeplan(imag)

                  dlab(1)=xx-bpemag(1,1,iplan,imag)
                  dlab(2)=yy-bpemag(2,1,iplan,imag)
                  dlab(3)=zz-bpemag(3,1,iplan,imag)

                  vnormlab(1)=bpetm(1,8,iplan,imag)
                  vnormlab(2)=bpetm(2,8,iplan,imag)
                  vnormlab(3)=bpetm(3,8,iplan,imag)

                  if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &                dlab(3)*vnormlab(3).gt.0.d0) then
                    iout=1
                    goto 97
                  endif

                enddo !iplan

c                if (imag.gt.1) then
c                  write(lun6,*)'*** Eder:',nmaxth,ith,kinsidelocal(1:nmaxth)
c                  stop
c                endif
c                if (iout.eq.-1) then
c                  write(lun6,*)ith,imag,sngl(xx),sngl(yy),sngl(zz)
c                  kinsidelocal(ith)=imag
c                endif !iout

97              continue
              endif !inside?

              do iplan=1,ibpeplan(imag)

                bcvn=-bpetm(1,7,iplan,imag)*pi4inv

                bplan(1)=0.d0
                bplan(2)=0.d0
                bplan(3)=0.d0

c transform everything to the nz=(0,0,1) system

c                if (iseqdebug.ne.0) dum=bcvn
                if (bcvn.eq.0.0d0) cycle

                if (ibpecorn(iplan,imag).gt.0) then

                  ts(1:3,1:3)=bpetm(1:3,1:3,iplan,imag)
                  tsinv(1:3,1:3)=bpetm(1:3,4:6,iplan,imag)

                  xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
                  yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
                  zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

                  ncorn=ibpecorn(iplan,imag)-1
                  do icorn=1,ncorn

                    ip2=icorn+1

19                  continue

                    r1(1)=bperot(1,icorn,iplan,imag)-xxrot
                    r1(2)=bperot(2,icorn,iplan,imag)-yyrot
                    r1(3)=bperot(3,icorn,iplan,imag)-zzrot

                    r2(1)=bperot(1,ip2,iplan,imag)-xxrot
                    r2(2)=bperot(2,ip2,iplan,imag)-yyrot
                    r2(3)=bperot(3,ip2,iplan,imag)-zzrot

                    if (abs(r1(1)-r2(1)).gt.tiny) then

                      a=(r2(2)-r1(2))/(r2(1)-r1(1))
                      b=r1(2)-a*r1(1)

                      if (abs(a).lt.tiny2) then
                        a=0.0d0
                        b=r1(2)
                      endif

                      z=r1(3)
                      kwarn=0

c                      if (iseqdebug.ne.0) iseqdebug=1
                      call undumag_bpeq(r1(1),r2(1),a,b,z,qx,qy,qz,
     &                  tiny,reverse,kwarn)
c                      if (iseqdebug.eq.2) then
c                        write(lun6,*)imag,iplan,icorn,kwarn
c                      endif

                      if (kwarn.ne.0) then
                        bpebc(16,imag)=kwarn
c                        write(lun6,*)"eder: kwarn,imag,xx,yy,zz",kwarn,imag,xx,yy,zz
                      endif
c                      if (kwarn.eq.1.or.kwarn.eq.6) kwarn=0
                      if (kwarn.eq.1.or.kwarn.eq.6.and.iwarn2pi.eq.0) kwarn=0
                      if (kwarn.eq.6) kwarni=6

c                      if (bcvn.ne.0.0d0) then
                      if (qx.ne.qx.or.qy.ne.qy.or.qz.ne.qz
     &                    .or.
     &                    (kwarn.ne.0)) then
                        kfail(ith)=imag
c                        goto 799
                      endif !qx,qy,qz, kwarn

                      bplan(1)=bplan(1)-qx*bcvn
                      bplan(2)=bplan(2)-qy*bcvn
                      bplan(3)=bplan(3)-qz*bcvn
c                      endif !bcvn

c                      if (iseqdebug.ne.0) write(lun6,*)xin,iplan,icorn,bplan,kwarn
                    endif !r1(1)-r2(1)

                  enddo !icorn=1,ncorn

                  blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
                  blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
                  blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

                  if (
     &                blab(1).ne.blab(1)
     &                .or.
     &                blab(2).ne.blab(2)
     &                .or.
     &                blab(3).ne.blab(3)
     &                ) then
                    if (kudebug.eq.2) then
                      write(lun6,*)"*** Error 3 in undumag_bpolyeder: blab is not a number (NaN) ***"
                      write(lun6,*)
     &                  "imag,iplan,xin,yin,zin:",imag,iplan,xin,yin,zin,iseqdebug
c                    write(lun6,*)"blab",blab
c                    write(lun6,*)"tsinv",tsinv
                    endif
                    kfail(ith)=imag
c                    stop
                  endif

                  bo(1,ith)=bo(1,ith)+blab(1)
                  bo(2,ith)=bo(2,ith)+blab(2)
                  bo(3,ith)=bo(3,ith)+blab(3)

                endif !ncorn

              enddo ! iplan=1,nplan

            else !bpebc(8,imag) .eq. 1

              if (kinsidelocal(ith).ne.-1) then

                iout=-1

                do iplan=1,ibpeplan(imag)

                  dlab(1)=xx-bpemag(1,1,iplan,imag)
                  dlab(2)=yy-bpemag(2,1,iplan,imag)
                  dlab(3)=zz-bpemag(3,1,iplan,imag)

                  vnormlab(1)=bpetm(1,8,iplan,imag)
                  vnormlab(2)=bpetm(2,8,iplan,imag)
                  vnormlab(3)=bpetm(3,8,iplan,imag)

                  if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &                dlab(3)*vnormlab(3).gt.0.d0) then
                    iout=1
                    goto 911
                  endif

                enddo !iplan

                if (iout.eq.-1) then
                  kinsidelocal(ith)=imag
                endif !iout

911             continue
              endif !inside?

c rectangular or cylindrical magnet
              vmaglab(1:3)=bpebc(4:6,imag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

              ts(1:3,1:3)=bpetm(1:3,1:3,1,imag)
              tsinv(1:3,1:3)=bpetm(1:3,4:6,1,imag)

              xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
              yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
              zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

              vmagrot(1)=
     &          ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
              vmagrot(2)=
     &          ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
              vmagrot(3)=
     &          ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

              xr(1)=bperot(1,1,1,imag)-xxrot
              xr(2)=bperot(1,2,1,imag)-xxrot
              yr(1)=bperot(2,1,1,imag)-yyrot
              yr(2)=bperot(2,3,1,imag)-yyrot
              zr(1)=bperot(3,1,1,imag)-zzrot
              zr(2)=bperot(3,1,3,imag)-zzrot

              if (xr(1).eq.0.0d0) xr(1)=1.0d-15
              if (xr(2).eq.0.0d0) xr(2)=1.0d-15
              if (yr(1).eq.0.0d0) yr(1)=1.0d-15
              if (yr(2).eq.0.0d0) yr(2)=1.0d-15
              if (zr(1).eq.0.0d0) zr(1)=1.0d-15
              if (zr(2).eq.0.0d0) zr(2)=1.0d-15

              q=0.0d0

              q(1,2)=1.0d0
              q(1,3)=1.0d0
              q(2,3)=1.0d0

              do i=1,2
                do j=1,2
                  do k=1,2
                    q(1,1)=q(1,1)+
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                yr(j)/xr(i)*zr(k)/
     &                sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
     &                )

                    q(2,2)=q(2,2)+
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                xr(j)/yr(i)*zr(k)/
     &                sqrt(yr(i)**2+xr(j)**2+zr(k)**2)
     &                )

                     dum=
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                yr(j)/zr(i)*xr(k)/
     &                sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
     &                )
                    q(3,3)=q(3,3)+dum
c                    write(lun6,*)"--- imag,zzrot",imag,zzrot
c                    write(lun6,*)"i,j,k",i,j,k,xr(k),yr(j),zr(i)
c                    write(lun6,*)"xx,dum,q33",xx,dum,q(3,3)

                    dum=zr(k)+sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
                    dume=(-1.0d0)**(i+j+k)

                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(1,2)=q(1,2)*dum
                      else
                        q(1,2)=q(1,2)/dum
                      endif
                    endif

                    dum=yr(k)+sqrt(xr(i)**2+zr(j)**2+yr(k)**2)
                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(1,3)=q(1,3)*dum
                      else
                        q(1,3)=q(1,3)/dum
                      endif
                    endif

                    dum=xr(k)+sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(2,3)=q(2,3)*dum
                      else
                        q(2,3)=q(2,3)/dum
                      endif
                    endif

                  enddo !k
                enddo !j
              enddo !i

              q(1,2)=log(q(1,2))
              q(1,3)=log(q(1,3))
              q(2,3)=log(q(2,3))

              q(2,1)=q(1,2)
              q(3,1)=q(1,3)
              q(3,2)=q(2,3)

              h(1)=
     &          -(q(1,1)*vmagrot(1)+q(1,2)*vmagrot(2)+q(1,3)*vmagrot(3))*
     &          pi4inv
              h(2)=
     &          -(q(2,1)*vmagrot(1)+q(2,2)*vmagrot(2)+q(2,3)*vmagrot(3))*
     &          pi4inv
              h(3)=
     &          -(q(3,1)*vmagrot(1)+q(3,2)*vmagrot(2)+q(3,3)*vmagrot(3))*
     &          pi4inv

              bplan(1)=h(1)
              bplan(2)=h(2)
              bplan(3)=h(3)

c              write(lun6,*)"h============================:",h

              blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
              blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
              blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

              bo(1,ith)=bo(1,ith)+blab(1)
              bo(2,ith)=bo(2,ith)+blab(2)
              bo(3,ith)=bo(3,ith)+blab(3)

            endif !(bpebc(8,imag).eq.1)

          endif !non-zero magnetization

c        write(lun6,'(3g15.5)'),xin,imag,imag,bo(2,ith)

        endif !window
c799     continue
      enddo !imag=1,nmag
+self,if=omp.
!$OMP END DO
!$OMP END PARALLEL
+self.

9999  continue

      do ic=1,nmaxth
        ifail=ifail+kfail(ic)
        bxout=bxout+bo(1,ic)
        byout=byout+bo(2,ic)
        bzout=bzout+bo(3,ic)
      enddo

      if (kinside.ne.-1) then
        kinside=0
        do ic=1,nmaxth
          kinside=kinside+kinsidelocal(ic)
        enddo
      endif

      if (bxout.ne.bxout.or.byout.ne.byout.or.bzout.ne.bzout
     &  .or.bxout.gt.1.0d30
     &  .or.byout.gt.1.0d30
     &    .or.bzout.gt.1.0d30) then
        bxout=0.0d0
        byout=0.0d0
        bzout=0.0d0
        ifail=11
      endif

      if (abs(bxout).le.1.0d-15) bxout=0.0d0
      if (abs(byout).le.1.0d-15) byout=0.0d0
      if (abs(bzout).le.1.0d-15) bzout=0.0d0

c      if (iseqdebug.ne.0) write(lun6,*)"ifail:",ifail
      if (ifail.ne.0) goto 7799

      goto 7979

7799  continue

      if (corrtiny.eq.0.0) then
        ifail=-4
        goto 7979
      endif

      if (kudebug.eq.2) then
        write(lun6,*)"*** ifail,xin,yin,zin"
      endif

      kwarncom=1
      ifail=-3

C Not working for unknown reasons for OMP ?? still true 20.4.2017??

      if (kinside.ne.-1) then
        kinside=0
      endif

      call undumag_bpolyeder_corr(xin-corrtiny,yin-corrtiny,zin-corrtiny,
     &  bxm,bym,bzm,ifailm)

      if (kinside.ne.-1) then
        linside=kinside
        kinside=0
      endif

      call undumag_bpolyeder_corr(xin+corrtiny,yin+corrtiny,zin+corrtiny,
     &  bxp,byp,bzp,ifailp)

      if (kinside.ne.-1) then
        kinside=max(linside,kinside)
      endif

      if (ifailm.eq.0.and.ifailp.eq.0) then
        bxout=(bxm+bxp)/2.0d0
        byout=(bym+byp)/2.0d0
        bzout=(bzm+bzp)/2.0d0
        ifail=-1
        kwarncom=1
      else if (ifailm.eq.0) then
        bxout=bxm
        byout=bym
        bzout=bzm
        kwarncom=2
        ifail=2
      else if (ifailp.eq.0) then
        bxout=bxp
        byout=byp
        bzout=bzp
        kwarncom=2
        ifail=2
      else
        if (ifailin.ge.0) then
          write(lun6,*) "*** Warning in undumag_bpolyeder: Could not recover for x,y,z:",
     &      sngl(xin*1000.),sngl(yin*1000.0),sngl(zin*1000.)
          write(lun6,*)"Differences in Bx,By,Bz, abs. and. rel.:",
     &      sngl(abs(bxp-bxm)),sngl(abs(byp-bym)),sngl(abs(bzp-bzm))
        endif
        bxout=(bxm+bxp)/2.0d0
        byout=(bym+byp)/2.0d0
        bzout=(bzm+bzp)/2.0d0
        if (ifailin.ge.0) then
          print '(6e15.4)',
     &      abs((bxp-bxm)/(bxout+1.0d-15)),abs((byp-bym)/(byout+1.0d-15)),
     &      abs((bzp-bzm)/(bzout+1.0d-15))
        endif
        kwarncom=3
        ifail=3
      endif

7979  continue

c      if (ncwires+nrace.gt.0) then
c        call undumag_bcoils(xin,yin,zin,bx,by,bz,istat)
c        bxout=bxout+bx
c        byout=byout+by
c        bzout=bzout+bz
c        if (istat.ne.0) ifail=ifail+1000
c      endif

      return
      end
+DECK,undumag_bpolyeder1.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  11.32.22  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  13.34.14  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.46.06  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  16.10.27  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  16.58.01  by  Michael Scheer
*CMZ :  1.15/10 07/04/2017  15.04.31  by  Michael Scheer
*CMZ :  1.15/07 05/04/2017  08.32.51  by  Michael Scheer
*CMZ :  1.15/05 03/04/2017  14.06.28  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  08.06.45  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  13.54.17  by  Michael Scheer
*CMZ :  1.14/00 17/03/2017  14.15.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  16.49.26  by  Michael Scheer
*CMZ :  1.13/02 08/03/2017  17.13.43  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  14.04.22  by  Michael Scheer
*CMZ :  1.11/03 16/01/2017  12.22.22  by  Michael Scheer
*CMZ :  1.11/00 13/12/2016  10.43.26  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.46.22  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.11.09  by  Michael Scheer
*CMZ :  0.00/13 08/08/2016  09.34.27  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  12.57.31  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.27  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.41.34  by  Michael Scheer
*CMZ :  1.17/11 06/04/2016  09.11.57  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.34.26  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  13.01.49  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  12.17.41  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bpolyeder1(imag,xin,yin,zin,bxout,byout,bzout,ifail)
c
c      Calculation of magnetic field of polyhedron according to
c      Oleb Chubar, Pascal Elleaume and Joel Chavanne
c      J. Synchrotron Rad. (1998) 5, 481-484
c
c Paper contains an error: The rotation matrix is wrong, since for nz=-1 the
c                          determinant is -1, which yields to errors??.


+seq,bpolyederf90u.
      use undumagf90m
      use commandlinef90m

      implicit none
+seq,seqdebug.
      double precision xin,yin,zin
     &  ,bxout,byout,bzout
      double precision r1(3),r2(3),dlab(3),blab(3)
      double precision ts(3,3),tsinv(3,3),bplan(3),bcvn,vnormlab(3)
      double precision xx,yy,zz,xxrot,yyrot,zzrot,xx00,xxsh
      double precision a,b,z,qx,qy,qz,qxp,qyp,qzp,qxm,qym,qzm,
     &  pi4inv,reverse,tiny2,
     &  bxm,bym,bzm,bxp,byp,bzp,xxm,yym,zzm,xxp,yyp,zzp,xx0,yy0,zz0,
     &  rr0,rrm
      double precision q(3,3),vmagrot(3),vmaglab(3),h(3),
     &  xr(2),yr(2),zr(2),dum,dume,pow,sqr

      double precision xmin,xmax,ymin,ymax,zmin,zmax,bx,by,bz

      parameter (pi4inv=0.0795774715459477d0)

      integer ical
      integer iout,itiny,iwtiny,jtiny
      integer imag,iplan,icorn,i,j,k,ip2,kwarni,kwarn
      integer nx,ny,nz,ifail,ifailm,ifailp,ishim,ishima,iimag,nmag1,nmag2,
     &  istat

      data ical/0/

      tiny2=tiny*tiny

      ifail=0
      ifailm=0
      ifailp=0

c      kwarncom=0

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

c      if (
c     &    xin.ge.outbox(1,1).and.xin.le.outbox(2,1)
c     &    .and.
c     &    yin.ge.outbox(1,2).and.yin.le.outbox(2,2)
c     &    .and.
c     &    zin.ge.outbox(1,3).and.zin.le.outbox(2,3)
c     &    ) return
			
      ifail=0
      kwarni=0

c calculate field at (xin,yin,zin)

      if (imag.eq.0) then
        write(lun6,*)'*** Error 1: undumag_bpolyeder1 called with imag=0! '
        stop
      endif !magmag.le.0

      if (bpebc(17,imag).lt.0.0d0) return

      xx=xin*1000.0d0
      xx00=xx
      yy=yin*1000.0d0
      zz=zin*1000.0d0

1     continue
      xxp=xx
      yyp=yy
      zzp=zz

      xx0=xx
      yy0=yy
      zz0=zz

      xxm=xx
      yym=yy
      zzm=zz

      itiny=0
      jtiny=0
      iwtiny=0

      q=0.0d0

      if (abs(xx00-bpebc(1,imag)).gt.window) goto 9999

      !non-zero magnetization and no virgin shim
      if (
     &    bpebc(7,imag).ne.0.0d0
     &    .and.bpebc(7,imag).ne.9999.0d0
     &    ) then

        if(bpebc(8,imag).eq.1) then !not a rectangular magnet

c check, if we are inside of magnet; we assume convex shape

          iout=-1
          inside=imag

          do iplan=1,ibpeplan(imag)

            dlab(1)=xx-bpemag(1,1,iplan,imag)
            dlab(2)=yy-bpemag(2,1,iplan,imag)
            dlab(3)=zz-bpemag(3,1,iplan,imag)

            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

            if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &          dlab(3)*vnormlab(3).gt.0.d0) then
              iout=1
              inside=0
              goto 97
            endif

          enddo !iplan

          if (iout.eq.-1) then
            kinside=imag
          endif !iout

97        continue

          do iplan=1,ibpeplan(imag)

            bcvn=-bpetm(1,7,iplan,imag)*pi4inv

            bplan(1)=0.0d0
            bplan(2)=0.0d0
            bplan(3)=0.0d0

c transform everything to the nz=(0,0,1) system

            if (bcvn.eq.0.0d0) cycle

            if (ibpecorn(iplan,imag).gt.0) then

              ts(1:3,1:3)=bpetm(1:3,1:3,iplan,imag)
              tsinv(1:3,1:3)=bpetm(1:3,4:6,iplan,imag)

              xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
              yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
              zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

              do icorn=1,ibpecorn(iplan,imag)-1

                ip2=icorn+1

                r1(1)=bperot(1,icorn,iplan,imag)-xxrot
                r1(2)=bperot(2,icorn,iplan,imag)-yyrot
                r1(3)=bperot(3,icorn,iplan,imag)-zzrot

                r2(1)=bperot(1,ip2,iplan,imag)-xxrot
                r2(2)=bperot(2,ip2,iplan,imag)-yyrot
                r2(3)=bperot(3,ip2,iplan,imag)-zzrot

                if (abs(r1(1)-r2(1)).gt.tiny) then

                  a=(r2(2)-r1(2))/(r2(1)-r1(1))
                  b=r1(2)-a*r1(1)

                  if (abs(a).lt.tiny2) then
                    a=0.0d0
                    b=r1(2)
                  endif

                  z=r1(3)

                  call undumag_bpeq(r1(1),r2(1),a,b,z,qx,qy,qz,
     &              tiny,reverse,kwarn)

                  if (kwarn.eq.1) kwarn=0

                  if (kwarn.ne.0) bpebc(16,imag)=-kwarn

                  if (kwarn.ne.0) kwarni=kwarn

                  if (
     &                qx.ne.qx.or.qy.ne.qy.or.qz.ne.qz
     &                .or.
     &                (kwarn.ne.0.and.kwarn.ne.6)) then
                    ifail=2
                    goto 799
                  endif !qx,qy,qz,kwarn

                  bplan(1)=bplan(1)-qx*bcvn
                  bplan(2)=bplan(2)-qy*bcvn
                  bplan(3)=bplan(3)-qz*bcvn

                endif ! r1(1)
              enddo !icorn=1,ncorn

              blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
              blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
              blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

              if (
     &            blab(1).ne.blab(1)
     &            .or.
     &            blab(2).ne.blab(2)
     &            .or.
     &            blab(3).ne.blab(3)
     &            ) then
                write(lun6,*)"*** Error 3 in undumag_bpolyeder1: blab is not a number (NaN) ***"
                write(lun6,*)
     &            "imag,iplan,xin,yin,zin:",imag,iplan,xin,yin,zin
                write(lun6,*)"blab",blab
                write(lun6,*)"tsinv",tsinv
                stop
              endif

              bxout=bxout+blab(1)
              byout=byout+blab(2)
              bzout=bzout+blab(3)

            endif !ncorn

          enddo ! iplan=1,nplan

          if (iout.eq.-1) then
            kinside=imag
          endif !iout

        else !bpebc(8,imag) .eq. 1

c rectangular or cylindrical magnet
c check, if we are inside of magnet; we assume convex shape

          iout=-1
          inside=imag

          do iplan=1,ibpeplan(imag)

            dlab(1)=xx-bpemag(1,1,iplan,imag)
            dlab(2)=yy-bpemag(2,1,iplan,imag)
            dlab(3)=zz-bpemag(3,1,iplan,imag)

            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

            if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &          dlab(3)*vnormlab(3).gt.0.d0) then
              iout=1
              inside=0
              goto 911
            endif

          enddo !iplan

          if (iout.eq.-1) then
            kinside=imag
          endif !iout

911       continue

          vmaglab(1)=bpebc(4,imag)
          vmaglab(2)=bpebc(5,imag)
          vmaglab(3)=bpebc(6,imag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

          ts(1:3,1:3)=bpetm(1:3,1:3,1,imag)
          tsinv(1:3,1:3)=bpetm(1:3,4:6,1,imag)

          xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
          yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
          zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

          vmagrot(1)=
     &      ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
          vmagrot(2)=
     &      ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
          vmagrot(3)=
     &      ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

          xr(1)=bperot(1,1,1,imag)-xxrot
          xr(2)=bperot(1,2,1,imag)-xxrot
          yr(1)=bperot(2,1,1,imag)-yyrot
          yr(2)=bperot(2,3,1,imag)-yyrot
          zr(1)=bperot(3,1,1,imag)-zzrot
          zr(2)=bperot(3,1,3,imag)-zzrot

          if (abs(xr(2)-xr(1)).lt.tiny) then
c            write(lun6,*)'*** Error 4 in undumag_bpolyeder1: abs(xr(2)-xr(1)).lt.tiny'
c            write(lun6,*)imag,xx,yy,zz
c            stop
            kwarni=7
          endif

          if (abs(yr(2)-yr(1)).lt.tiny) then
            write(lun6,*)'*** Error 5 in undumag_bpolyeder1 abs(yr(2)-yr(1)).lt.tiny'
            write(lun6,*)imag,xx,yy,zz
            stop
          endif

          if (abs(zr(2)-zr(1)).lt.tiny) then
c            write(lun6,*)'*** Error 6 in undumag_bpolyeder1 abs(zr(2)-zr(1)).lt.tiny'
c            write(lun6,*)imag,xx,yy,zz
c            stop
            kwarni=8
          endif

          q(1,1)=0.0d0
          q(2,2)=0.0d0
          q(3,3)=0.0d0

          q(1,2)=1.0d0
          q(1,3)=1.0d0
          q(2,3)=1.0d0

          if (xr(1).eq.0.0d0) xr(1)=1.0d-15
          if (xr(2).eq.0.0d0) xr(2)=1.0d-15
          if (yr(1).eq.0.0d0) yr(1)=1.0d-15
          if (yr(2).eq.0.0d0) yr(2)=1.0d-15
          if (zr(1).eq.0.0d0) zr(1)=1.0d-15
          if (zr(2).eq.0.0d0) zr(2)=1.0d-15

          do i=1,2
            do j=1,2
              do k=1,2

                pow=dble((-1)**(i+j+k+1))
                sqr=sqrt(xr(i)**2+yr(j)**2+zr(k)**2)

                if (sqr.eq.0.0d0) then
                  write(lun6,*)"*** Error 7 in undumag_bpolyeder1: sqrt 0 "
                  stop
                endif

                q(1,1)=q(1,1)+pow*
c     &            (-1)**(i+j+k+1)*
     &            atan(
     &            yr(j)/xr(i)*zr(k)/sqr
c     &            sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
     &            )

                sqr=sqrt(yr(i)**2+xr(j)**2+zr(k)**2)

                if (sqr.eq.0.0d0) then
                  write(lun6,*) "*** Error 8 in undumag_bpolyeder1: sqr 0"
                  stop
                endif

                q(2,2)=q(2,2)+pow*
c     &            (-1)**(i+j+k+1)*
     &            atan(
     &            xr(j)/yr(i)*zr(k)/sqr
c     &            sqrt(yr(i)**2+xr(j)**2+zr(k)**2)
     &            )

                sqr=sqrt(zr(i)**2+yr(j)**2+xr(k)**2)

                if (sqr.eq.0.0d0) then
                  write(lun6,*)"*** Error 9 in undumag_bpolyeder1: sqr 0"
                  stop
                endif

                q(3,3)=q(3,3)+pow*
c     &            (-1)**(i+j+k+1)*
     &            atan(
     &            yr(j)/zr(i)*xr(k)/sqr
c     &            sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
     &            )

                dum=zr(k)+sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
                dume=(-1.0d0)**(i+j+k)

                if (dum.ne.0.0d0) then
                  if (dume.gt.0.0d0) then
                    q(1,2)=q(1,2)*dum
                  else
                    q(1,2)=q(1,2)/dum
                  endif
                endif

                dum=yr(k)+sqrt(xr(i)**2+zr(j)**2+yr(k)**2)

                if (dum.ne.0.0d0) then
                  if (dume.gt.0.0d0) then
                    q(1,3)=q(1,3)*dum
                  else
                    q(1,3)=q(1,3)/dum
                  endif
                endif

                dum=xr(k)+sqrt(zr(i)**2+yr(j)**2+xr(k)**2)

                if (dum.ne.0.0d0) then
                  if (dume.gt.0.0d0) then
                    q(2,3)=q(2,3)*dum
                  else
                    q(2,3)=q(2,3)/dum
                  endif
                endif

              enddo !k
            enddo !j
          enddo !i

          q(1,2)=log(q(1,2))
          q(1,3)=log(q(1,3))
          q(2,3)=log(q(2,3))

          q(2,1)=q(1,2)
          q(3,1)=q(1,3)
          q(3,2)=q(2,3)

          h(1)=
     &      -(q(1,1)*vmagrot(1)+q(1,2)*vmagrot(2)+q(1,3)*vmagrot(3))*
     &      pi4inv
          h(2)=
     &      -(q(2,1)*vmagrot(1)+q(2,2)*vmagrot(2)+q(2,3)*vmagrot(3))*
     &      pi4inv
          h(3)=
     &      -(q(3,1)*vmagrot(1)+q(3,2)*vmagrot(2)+q(3,3)*vmagrot(3))*
     &      pi4inv

          bplan(1)=h(1)
          bplan(2)=h(2)
          bplan(3)=h(3)

          if (
     &        bplan(1).ne.bplan(1)
     &        .or.
     &        bplan(2).ne.bplan(2)
     &        .or.
     &        bplan(3).ne.bplan(3)
     &        ) then
            write(lun6,*)"*** Error 10 in undumag_bpolyeder1: bplan is not a number (NaN) ***"
            write(lun6,*)
     &        "imag,xin,yin,zin:",imag,xin,yin,zin
            stop
          endif

          blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
          blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
          blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

          if (
     &        blab(1).ne.blab(1)
     &        .or.
     &        blab(2).ne.blab(2)
     &        .or.
     &        blab(3).ne.blab(3)
     &        ) then
            write(lun6,*)"*** Error 11 in undumag_bpolyeder1: blab is not a number (NaN) ***"
            write(lun6,*)
     &        "imag,xin,yin,zin:",imag,xin,yin,zin
            stop
          endif

          bxout=bxout+blab(1)
          byout=byout+blab(2)
          bzout=bzout+blab(3)

          if (iout.eq.-1) then
            kinside=imag
          endif !iout

        endif !(bpebc(8,imag).eq.1)

      endif !non-zero magnetization


9999  continue

      if (kwarni.ne.0) goto 799

      goto 787

799   continue

      call undumag_bpolyeder11(imag,xin-1.0d0*corrtiny,yin-1.0d0*corrtiny,zin-1.0d0*corrtiny,
     &  bxm,bym,bzm,ifailm)
      call undumag_bpolyeder11(imag,xin+1.0d0*corrtiny,yin+1.0d0*corrtiny,zin+1.0d0*corrtiny,
     &  bxp,byp,bzp,ifailp)

      if (ifailm.eq.0.and.ifailp.eq.0) then
        bx=(bxm+bxp)/2.0d0
        by=(bym+byp)/2.0d0
        bz=(bzm+bzp)/2.0d0
c          write(lun6,*)"Recovered, bx,by,bz:",sngl(bx),sngl(by),sngl(bz)
c          write(lun6,*)"Uncertainty:",sngl(bxout-bx),sngl(byout-by),sngl(bzout-bz)
        bxout=bx
        byout=by
        bzout=bz
        ifail=-kwarn
      else if (ifailm.eq.0) then
        bxout=bxm
        byout=bym
        bzout=bzm
        ifail=kwarn+10*ifailm
      else if (ifailp.eq.0) then
        bxout=bxp
        byout=byp
        bzout=bzp
        ifail=kwarn+100*ifailp
      endif

c      write(lun6,*)

      if (ifailm.eq.6.or.ifailp.eq.6) then
          write(lun6,*)
          write(lun6,*)"2pi jump: mag, x,y,z,bx,by,bz:",imag,xin*1000,yin*1000,zin*1000,
     &      bxout,byout,bzout
c        else
c          write(lun6,*)"--- Warning in undumag_bpolyeder1:", kwarni
c          print '(a,i7,6e12.4)',"mag, x,y,z,bx,by,bz:",imag,xin*1000,yin*1000,zin*1000,
c     &      bxout,byout,bzout
      endif

787   continue

c      if (ncwires+nrace.gt.0) then
c        call undumag_bcoils(xin,yin,zin,bx,by,bz,istat)
c        bxout=bxout+bx
c        byout=byout+by
c        bzout=bzout+bz
c        if (istat.ne.0) ifail=ifail+1000
c      endif

      return
      end
+DECK,undumag_relax_rec_lin.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  09.36.56  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  15.11.30  by  Michael Scheer
*CMZ :  0.00/13 28/07/2016  12.38.30  by  Michael Scheer
*CMZ :  0.00/09 25/06/2016  14.02.31  by  Michael Scheer
*CMZ :  0.00/07 22/06/2016  14.17.39  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.29.14  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/04 22/03/2016  15.36.44  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  09.58.20  by  Michael Scheer
*CMZ :  1.17/02 11/03/2016  16.48.04  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_relax_rec_lin

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

!      bpebc(1:3,imag) contains position of magnet imag
!      bpebc(4:6,imag) contains normalized magnetization vector of magnet imag

      implicit none

      double precision bn,bx,by,bz,hx,hy,hz,bc(3),hpar,hper,parmag,permag,
     &  x,y,z,tr(3,3),ti(3,3),bcrot(3),hrot(3),hold,h

      integer ifail,imag,iter,i,j

      hold=0.0d0
      niterrec=0

      if (perksi.eq.0.0d0) then

        kinside=-1
        do imag=1,nrec
          ! bpolyeder returns H, if inside magnet!
          call undumag_field(
     &      bpebc(1,imag)/1000.0d0,bpebc(2,imag)/1000.0d0,bpebc(3,imag)/1000.0d0,
     &      bc0(4,imag),bc0(5,imag),bc0(6,imag),ifail)
          hpar=
     &      bc0(1,imag)*bc0(4,imag)+
     &      bc0(2,imag)*bc0(5,imag)+
     &      bc0(3,imag)*bc0(6,imag)
          parmag=1.0d0/(1.0d0-parksi*hpar)
          bc0(7:9,imag)=bc0(7:9,imag)*parmag
        enddo !nrec

        bpebc(4:6,1:nrec)=bc0(7:9,1:nrec)
        kconvrec=1

      else !perksi.eq.0

        do iter=1,maxiterrec

          bc0(4:6,1:nrec)=bpebc(4:6,1:nrec)

          h=0.0d0
          kinside=-1
          do imag=1,nrec

            x=bpebc(1,imag)/1000.0d0
            y=bpebc(2,imag)/1000.0d0
            z=bpebc(3,imag)/1000.0d0

            ! bpolyeder returns H, if inside magnet!
            call undumag_field(x,y,z,hx,hy,hz,ifail)

c            write(lun6,*)imag,bc0(4:6,imag)
            call undumag_rotate(bc0(4:6,imag),tr,ti) ! tr rotates vector to z-axis

            !rotate such, that easy axis becomes z-axis

c            bcrot(1:3)=tr(1:3,1)*bc0(4,imag)+
c     &        tr(1:3,2)*bc0(5,imag)+
c     &        tr(1:3,3)*bc0(6,imag)

            hrot(1:3)=tr(1:3,1)*hx+tr(1:3,2)*hy+tr(1:3,3)*hz

            bcrot(1:2)=hrot(1:2)*perksi
            bcrot(3)=bc0(10,imag)+hrot(3)*parksi !bc0(10,imag) is bc norm.

            !rotate back
            bc0(4:6,imag)=ti(1:3,1)*bcrot(1)+
     &        ti(1:3,2)*bcrot(2)+
     &        ti(1:3,3)*bcrot(3)

c            write(lun6,*)imag
c            write(lun6,*)ti

          enddo !nrec

          bpebc(4:6,1:nrec)=bc0(4:6,1:nrec)

          niterrec=iter
          kinside=0

          hold=h
          h=0.0d0
          do i=1,nxconv
            call undumag_field(xconv(i),yconv,zconv,hx,hy,hz,ifail)
            h=h+hx**2+hy**2+hz**2
          enddo
          h=sqrt(h/nxconv)

          if (hold.ne.0.0d0) then
            if (abs(h/hold-1.0d0).lt.hconva) then
              kconvrec=1
              goto 9999
            endif
          endif

        enddo !iter

      endif !perksi.eq.0

9999  return
      end
+DECK,undumag_bpolyeder_matrix.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.00/03 24/04/2018  13.03.29  by  Michael Scheer
*CMZ :  1.25/00 08/03/2018  19.38.15  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  14.58.38  by  Michael Scheer
*CMZ :  1.15/11 20/04/2017  21.13.56  by  Michael Scheer
*CMZ :  1.15/10 13/04/2017  09.09.26  by  Michael Scheer
*CMZ :  1.15/07 05/04/2017  15.01.35  by  Michael Scheer
*CMZ :  1.11/03 16/01/2017  12.22.22  by  Michael Scheer
*CMZ :  1.10/02 28/11/2016  13.27.01  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  11.48.57  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.01.00  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.48.27  by  Michael Scheer
*CMZ :  0.00/03 04/05/2016  08.41.15  by  Michael Scheer
*CMZ :  0.00/02 02/05/2016  10.21.48  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.20.09  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  10.22.45  by  Michael Scheer
*CMZ :  1.17/06 31/03/2016  09.26.44  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.16.01  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  18.38.48  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bpolyeder_matrix(kimag,bxout,byout,bzout,ifail)

      use bpolyederf90m
      use undumagf90m
      use omp_lib
      use commandlinef90m

      implicit none

      double precision bxout,byout,bzout,xx,yy,zz,hi(3)
      double precision bci(3),bo(3),db(3)
      integer imag,ifail,kmag,idx,ical,kimag

      data ical/0/

      kmag=iabs(kimag)

      ifail=0

      bo=0.0d0
      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

+seq,matrixdebug,if=debugmatrix.

      do imag=1,nrec
        if (imag.eq.-kimag) cycle
        bci=bpebc(4:6,imag)
        if (bci(1).ne.bci(1).or.bci(2).ne.bci(2).or.bci(3).ne.bci(3)) then
          write(lun6,*)"*** Warning in undumag_bpolyeder_matrix: Magnetization is not a number (NaN) ***"
          write(lun6,*)"imag:",imag
          write(lun6,*)"Magnet is ignored!"
          cycle
        endif
        db=bci(1)*wwmatrix4(1:3,1,imag,kmag)
        bo=bo+db
        db=bci(2)*wwmatrix4(1:3,2,imag,kmag)
        bo=bo+db
        db=bci(3)*wwmatrix4(1:3,3,imag,kmag)
        bo=bo+db
      enddo !imag=1,nmag

      if (iterirontot.gt.0.or.kpreset.ne.0) then
        do imag=nrec+1,nmag
          if (imag.eq.-kimag) cycle
          bci=bpebc(4:6,imag)
          if (bci(1).ne.bci(1).or.bci(2).ne.bci(2).or.bci(3).ne.bci(3)) then
            write(lun6,*)"*** Warning in undumag_bpolyeder_matrix: Magnetization is not a number (NaN) ***"
            write(lun6,*)"imag:",imag
            write(lun6,*)"Magnet is ignored!"
            cycle
          endif
          db=bci(1)*wwmatrix4(1:3,1,imag,kmag)
          bo=bo+db
          db=bci(2)*wwmatrix4(1:3,2,imag,kmag)
          bo=bo+db
          db=bci(3)*wwmatrix4(1:3,3,imag,kmag)
          bo=bo+db
        enddo !imag=1,nmag
      endif

      bxout=bxout+bo(1)
      byout=byout+bo(2)
      bzout=bzout+bo(3)

      if (kbextern.ne.0) then
        bxout=bxout+bxex
        byout=byout+byex
        bzout=bzout+bzex
      endif

      if (ncwires.gt.0) then
        bxout=bxout+bpebc(18,kmag)
        byout=byout+bpebc(19,kmag)
        bzout=bzout+bpebc(20,kmag)
      endif

      return
      end
+DECK,undumag_field.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 12/04/2021  14.05.35  by  Michael Scheer
*CMZ :  2.02/00 21/01/2021  13.24.48  by  Michael Scheer
*CMZ :  2.01/08 14/08/2020  10.40.03  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.26.49  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  12.45.27  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  14.15.52  by  Michael Scheer
*CMZ :  1.23/03 19/09/2017  19.32.15  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  14.10.42  by  Michael Scheer
*CMZ :  1.15/11 19/04/2017  14.47.22  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  15.43.17  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  14.43.16  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  13.43.20  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.20.28  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  15.33.12  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  16.02.08  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  09.46.04  by  Michael Scheer
*CMZ :  1.17/13 07/04/2016  17.38.21  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.53.04  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.28.51  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.49.46  by  Michael Scheer
*-- Author :    Michael Scheer   03/04/2016
      subroutine undumag_field(x,y,z,bxout,byout,bzout,ifail)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

+seq,seqdebug.

      double precision x,y,z,hx,hy,hz,bxout,byout,bzout,xcut,bx,by,bz
      integer ifail,ifailin,kfail,linside

      integer :: ical=0
      save ical

c      kfail=iwarnbound
      ifailin=ifail
      ifail=0
c      kinside=0 ! use as flag, see undmag_end

      if (knomagmap.eq.0.and.knopolmap.eq.0) then
        kinside=0
      else
        kinside=-1
      endif

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      if (nrec.eq.0.and.kbextern.eq.0.and.ncwires.eq.0) then
        bxout=0.0d0
        byout=0.0d0
        bzout=0.0d0
        return
      endif

      linside=kinside

      if (nmag.ne.0) then

+self,if=msingle.
        if (ical.eq.0) then
          write(lun6,*)"*** Using undmag_bpolyeder_single(...) due to CMZ selection msingle ***"
          write(lun6,*)"*** CHECK TREATMENT OF COILS"
          stop
          ical=1
        endif
        linside=kinside
        call undumag_bpolyeder_single(x,y,z,bxout,byout,bzout,ifail)
        goto 111
+self.

        !x1y1z1
        kfail=ifailin
        call undumag_bpolyeder(x,y,z,bxout,byout,bzout,kfail)
        if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
        if (kinside.gt.0) then
          linside=kinside
          kinside=0
        endif

        if (ixsym.eq.0) then

          if (iysym.ne.0) then
            kfail=ifailin
            call undumag_bpolyeder(x,-y,z,hx,hy,hz,kfail)
            if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout-hz
          endif

          if (izsym.ne.0) then
            kfail=ifailin
            call undumag_bpolyeder(x,y,-z,hx,hy,hz,kfail)
            if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout+hx
            byout=byout+hy
            bzout=bzout-hz
          endif

          if (iysym.ne.0.and.izsym.ne.0) then
            kfail=ifailin
            call undumag_bpolyeder(x,-y,-z,hx,hy,hz,kfail)
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout+hz
          endif

        else !ixsym

          xcut=2.0d0*xsym-x

          !x2y1z1
          kfail=ifailin
          call undumag_bpolyeder(xcut,y,z,hx,hy,hz,kfail)
          if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          bxout=bxout-hx
          byout=byout+hy
          bzout=bzout+hz

          if (iysym.ne.0) then
            !x1y2z1
            kfail=ifailin
            call undumag_bpolyeder(x,-y,z,hx,hy,hz,kfail)
            if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout-hz
            !x2y1z1
            kfail=ifailin
            call undumag_bpolyeder(xcut,-y,z,hx,hy,hz,kfail)
            if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout+hx
            byout=byout+hy
            bzout=bzout-hz
          endif

          if (izsym.ne.0) then
            !x1y1z2
            kfail=ifailin
            call undumag_bpolyeder(x,y,-z,hx,hy,hz,kfail)
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
            bxout=bxout+hx
            byout=byout+hy
            bzout=bzout-hz
            !x2y1z2
            kfail=ifailin
            call undumag_bpolyeder(xcut,y,-z,hx,hy,hz,kfail)
            if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout-hz
          endif

          if (iysym.ne.0.and.izsym.ne.0) then
            !x2y2z2
            kfail=ifailin
            call undumag_bpolyeder(xcut,-y,-z,hx,hy,hz,kfail)
            if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout+hx
            byout=byout+hy
            bzout=bzout+hz
            !x1y2z2
            kfail=ifailin
            call undumag_bpolyeder(x,-y,-z,hx,hy,hz,kfail)
            if (ifail.ne.-1.or.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout+hz
          endif

        endif !ixsym

      endif !(nmag.ne.0)

111   continue

      if (Abs(bxout).lt.1.0d-15) bxout=0.0d0
      if (Abs(byout).lt.1.0d-15) byout=0.0d0
      if (Abs(bzout).lt.1.0d-15) bzout=0.0d0

c      if (iwarnbound.ne.kfail) kfail=100+ifail

      if (ncwires.gt.0) then
        call undumag_bcoils(x,y,z,bx,by,bz,ifail)
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
      endif

      if (kbextern.ne.0) then
        bxout=bxout+bxex
        byout=byout+byex
        bzout=bzout+bzex
      endif

      kinside=linside
      if (kinside.gt.0) ifail=ifail-20000

      return
      end
+DECK,undumag_bpolyplot.
*CMZ :  2.04/10 22/08/2023  12.11.10  by  Michael Scheer
*CMZ :  2.04/05 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  17.04.30  by  Michael Scheer
*CMZ :  2.02/02 29/06/2022  10.35.26  by  Michael Scheer
*CMZ :  2.02/01 30/01/2022  08.37.21  by  Michael Scheer
*-- Author :    Michael Scheer   22/10/2021
      subroutine undumag_bpolyplot

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      real xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,theta,pphi

      if (iunduplot.ne.0.and.nmagtot_t+ncwires.ne.0) then
        theta=unduplot_theta !plotting angle
        pphi=unduplot_phi   !plotting angle
        xplmin=xminpl
        xplmax=xmaxpl
        yplmin=yminpl
        yplmax=ymaxpl
        zplmin=zminpl
        zplmax=zmaxpl
        if (xminpl.eq.9999.0d0) xplmin=xmin_t-(xmax_t-xmin_t)*0.1
        if (xmaxpl.eq.9999.0d0) xplmax=xmax_t+(xmax_t-xmin_t)*0.1
        if (yminpl.eq.9999.0d0) yplmin=ymin_t-(ymax_t-ymin_t)*0.1
        if (ymaxpl.eq.9999.0d0) yplmax=ymax_t+(ymax_t-ymin_t)*0.1
        if (zminpl.eq.9999.0d0) zplmin=zmin_t-(zmax_t-zmin_t)*0.1
        if (zmaxpl.eq.9999.0d0) zplmax=zmax_t+(zmax_t-zmin_t)*0.1
        kunduplot_mode=1
        call clcmag_bpolyplot(iunduplot,xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &    theta,pphi,nwitems,ncwires,wire)
        kunduplot_mode=0
        call clcmag_bpolyplot(iunduplot,xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &    theta,pphi,nwitems,ncwires,wire)
      endif !iplot

      zminprof=zplmin
      zmaxprof=zplmax

      return
      end
+DECK,undumag_to_radia.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/00 09/01/2021  12.08.32  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  12.47.44  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  15.45.12  by  Michael Scheer
*CMZ :  1.25/04 04/04/2018  11.40.25  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.27.59  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.25.43  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  09.00.40  by  Michael Scheer
*CMZ :  1.23/02 11/09/2017  15.35.11  by  Michael Scheer
*CMZ :  1.18/01 08/06/2017  14.20.17  by  Michael Scheer
*CMZ :  1.15/10 11/04/2017  11.14.47  by  Michael Scheer
*CMZ :  1.15/00 24/03/2017  10.28.46  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  17.33.35  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  10.15.10  by  Michael Scheer
*CMZ :  1.11/03 13/01/2017  15.10.38  by  Michael Scheer
*CMZ :  1.11/00 03/01/2017  16.16.45  by  Michael Scheer
*-- Author :    Michael Scheer   12/12/2016
      subroutine undumag_to_radia

      use undumagf90m
      use bpolyederf90m
      use commandlinef90m
      use magnets_structure

! Interface to radia notebook. It writes the geometry to snipplets for RADIA
! Restriction:
! Isotropic materials must have a magnetization less then 0.01
!
! RADIA coordinate system: y is longitudinal, z is vertical
! UNDUMAG: x is longitudinal, y is vertical

      implicit none

+seq,phyconparam.

      double precision, dimension (:), allocatable :: x,y,z,brrec

      integer, dimension (:), allocatable :: khull,imatrec,imatiron,
     &  imatmagpol

      double precision :: gcen(3)

      real :: hfe,bfe

      integer ::
     &  nsymx,nsymy,nsymz,npoi,nmatfe,nlast,nfirst,nface,ncyl,ncolor,mater
     &  ,lunrad,lunfe,lmat,kproto,kpoi,k,ironmode,iron,imp,ipoi,imag,imat,istat
     &  ,ifound,i,iface,ieof,nbr,nUnduMag,nUnduPol,nMagPolTot,lenout,lunproc

      character(2048) cline,cbuff(10),cout
      character(64) chmat
      character(32) c32,c32x,c32y,c32z

      ncyl=0

      maxpoints=max(maxpoints,ncornmax*nplanmax)

      allocate(x(maxpoints),y(maxpoints),z(maxpoints),khull(maxpoints))
      allocate(brrec(nmagtot_t),imatrec(nmagtot_t),
     &  imatiron(nmagtot_t),imatmagpol(nmagtot_t))

      nbr=0
      nmatfe=0
      brrec=0.0d0
      imatrec=0

      do imag=1,nmagtot_t
        kproto=t_magcopy(imag)%kproto
        ifound=0
        if (t_magnets(kproto)%ispole.ne.0) then
          do i=1,nmatfe
            if (t_magnets(kproto)%imat.eq.imatiron(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) then
            cycle
          endif
          nmatfe=nmatfe+1
          imatiron(nmatfe)=t_magnets(kproto)%imat
          imatmagpol(imag)=nmatfe
        else
          do i=1,nbr
            if (brrec(i).eq.t_magcopy(imag)%brn.and.
     &          t_magnets(kproto)%imat.eq.imatrec(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) cycle
          nbr=nbr+1
          brrec(nbr)=t_magcopy(imag)%brn
          imatrec(nbr)=t_magnets(kproto)%imat
          imatmagpol(imag)=nbr
        endif
      enddo

      nsymx=1
      nsymy=1
      nsymz=1

      if (ixsymo.lt.0) nsymx=nsymx*2
      if (iysymo.lt.0) nsymy=nsymy*2
      if (izsymo.lt.0) nsymz=nsymz*2

      open(newunit=lunrad,file='undumag.nb')

      write(lunrad,*)' '
      write(lunrad,*)'(*-- Begin of lines generated by UNDUMAG --*)'
      write(lunrad,*)'(*-- Version ',trim(chuvers),' --*)'
      write(lunrad,*)' '
      write(lunrad,*)'<<Radia`; Off[General::"spell1"];'
      write(lunrad,*)' '
      write(cline,*)kundurun
      call util_string_trim(cline,nfirst,nlast)
      write(lunrad,*)'(*'
      call util_zeit_kommentar(lunrad,"Run: "//cline(nfirst:nlast))
      write(lunrad,*)'*)'

      write(lunrad,*)"(*"
      write(lunrad,*)"Comment: "//trim(unducomment)
      write(lunrad,*)"*)"
      write(lunrad,*)' '
      write(lunrad,*)'run = ',kundurun,";"
      write(lunrad,*)'comment = "'//trim(unducomment)//'";'
      write(lunrad,*)' '
      write(lunrad,*)'(* --- Variables of undumag.nam ---*)'
      write(lunrad,*)' '
      write(lunrad,*)'iUnduXsym = ',ixsymo,";"
      write(lunrad,*)'iUnduYsym = ',iysymo,";"
      write(lunrad,*)'iUnduZsym = ',izsymo,";"
      write(lunrad,*)' '
      write(lunrad,*)'UnduSymX = ',xsym,";"
      write(lunrad,*)' '
      write(lunrad,*)"kDraw = ",iunduplot,";"
      write(lunrad,*)"unduplot_theta = ",unduplot_theta,";"
      write(lunrad,*)"unduplot_phi = ",unduplot_phi,";"
      write(lunrad,*)' '

      write(c32x,*)xcenter
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXCenter = ",c32x," ;"
      write(c32x,*)xcentershift
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXCenterShift = ",c32x," ;"
      write(lunrad,*)' '
      write(c32x,*)utorqcenx
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenX = ",c32x," ;"
      write(c32x,*)utorqceny
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenY = ",c32x," ;"
      write(c32x,*)utorqcenz
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenZ = ",c32x," ;"
      write(lunrad,*)' '
      write(c32x,*)xmapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXMapMin = ",c32x," ;"
      write(c32x,*)xmapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduXMap = ",nxmap," ;"
      write(lunrad,*)' '
      write(c32x,*)ymapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduYMapMin = ",c32x," ;"
      write(c32x,*)ymapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduYMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduYMap = ",nymap," ;"
      write(lunrad,*)' '
      write(c32x,*)zmapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduZMapMin = ",c32x," ;"
      write(c32x,*)zmapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduZMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduZMap = ",nzmap," ;"
      write(lunrad,*)' '
      write(lunrad,*)' '
      write(lunrad,*)"nUnduNoPolMap = ",knopolmap," ;"
      write(lunrad,*)"nUnduNoMagMap = ",knomagmap," ;"
      write(lunrad,*)' '
+self,if=uvarrad.

      write(lunrad,*)' '
      write(lunrad,*)'(* --- Variables of undumag.clc ---*)'
      write(lunrad,*)' '

      do i=1,nvar_t
        write(lunrad,*) trim(t_variables(i)%cname),' = ',t_variables(i)%val,';'
      enddo !nvar_t
+self.,if=uvarrad.

      write(lunrad,*)' '
      write(lunrad,*)'(* --- Materials of undumag.clc ---*)'
      write(lunrad,*)' '

      do i=1,nbr
        imat=imatrec(i)
        write(c32,*)i
        if (matmaps(1,imat).eq.1) then
          if (matmaps(2,imat).eq.1) then
            write(c32x,'(f6.4)')bcmat(2,1,imat) !-1.0d0
            write(c32y,'(f6.4)')bcmat(3,1,imat) !-1.0d0
            write(c32z,'(g12.5)')brrec(i)
            write(lunrad,*)
     &        "UmatREC[" // trim(adjustl(c32)) // "] = radMatLin[{" //
     &        trim(adjustl(c32x)) // "," //
     &        trim(adjustl(c32y)) //
     &        "}," // trim(adjustl(c32z)) // "];"
          else
            print*,"*** Error in undumag_to_radia: mode",
     &        matmaps(2,imat), " not yet implemented for REC material ",imat
            print*,""
            stop "--- UNDUMAG aborted ---"
          endif
        else
          print*,"*** Error in undumag_to_radia: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          stop "--- UNDUMAG aborted ---"
        endif
      enddo

      do i=1,nmatfe
        imat=imatiron(i)
        write(c32,*)i
        if (matmaps(1,imat).eq.2) then
          write(lunrad,*)
     &      "UmatIron[" // trim(adjustl(c32)) // "] = radMatSatIso[{"
          do k=2,nclcmat
            read(clcmat(k),*)iron,lmat,ironmode,cbuff(1)
            if (iron.eq.imat) then
              open(newunit=lunfe,file=trim(cbuff(1)),status='old')
              ieof=0
              do while (ieof.eq.0)
                call util_skip_comment_end(lunfe,ieof)
                if (ieof.ne.0) exit
                read(lunfe,*) hfe,bfe
                write(lunrad,*)"{",hfe,",",bfe,"},"
              enddo
              backspace(lunrad)
              write(lunrad,*)"{",hfe,",",bfe,"}"
              close(lunfe)
            endif
          enddo
          write(lunrad,*)"}];"
        else
          print*,"*** Error in undumag_to_radia: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          stop "--- UNDUMAG aborted ---"
        endif
      enddo

      write(lunrad,*)' '
      write(lunrad,*)'(* --- Poles and magnets of undumag.clc ---*)'
      write(lunrad,*)' '

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        ! radObjPolyhdr[
        ! {
        !   {x1,y1,z1}, ..., {xn,yn,zn} Corners
        ! },
        ! {
        !   {f1n1,f1n2,...}, ...., {f2n1,f2n2,...} Faces
        ! },
        ! {mx,my,mz}:{0,0,0}]

        nface=t_magnets(kproto)%nface
        ncolor=t_magnets(kproto)%icol

        write(lunrad,*)"   ",trim(t_magcopy(imp)%cnam)//" = radObjPolyhdr["
        write(lunrad,*)"        { (* List of points *)"

        gcen=t_magcopy(imp)%gcen

        do kpoi=1,t_magnets(kproto)%nhull
          write(c32x,*)sngl(t_magnets(kproto)%xhull(kpoi)+gcen(1))
          call undumag_double_to_radia(c32x)
          write(c32y,*)sngl(t_magnets(kproto)%yhull(kpoi)+gcen(2))
          call undumag_double_to_radia(c32y)
          write(c32z,*)sngl(t_magnets(kproto)%zhull(kpoi)+gcen(3))
          call undumag_double_to_radia(c32z)
          if (kpoi.lt.t_magnets(kproto)%nhull) then
            write(lunrad,*)
     &        "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"
          else
            write(lunrad,*)
     &        "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
          endif
        enddo !kpoi

        write(lunrad,*)"        }, (* End of list of points *)"

        write(lunrad,*)"        { (* List of faces *)"

        kpoi=1
        do iface=1,nface
          npoi=t_magnets(kproto)%kface(kpoi)
          cline="         {"
          do ipoi=kpoi+1,kpoi+npoi
            call util_string_append_num(cline,t_magnets(kproto)%kface(ipoi),
     &        nfirst,nlast)
            if (ipoi.lt.kpoi+npoi) then
              call util_string_append(cline,',',nfirst,nlast)
            else
              call util_string_append(cline,'},',nfirst,nlast)
            endif
          enddo !ipoi
          if (iface.lt.nface) then
            write(lunrad,*)cline(1:nlast)
            call util_string_append(cline,'},',nfirst,nlast)
          else
            write(lunrad,*)cline(1:nlast-1)
          endif
          kpoi=kpoi+npoi+1
        enddo !nface

        write(lunrad,*)"        }, (* End of list of faces *)"

        if (t_magnets(kproto)%IsPole.eq.0) then
          write(c32x,*)t_magnets(kproto)%br(1)
          call undumag_double_to_radia(c32x)
          write(c32y,*)t_magnets(kproto)%br(2)
          call undumag_double_to_radia(c32y)
          write(c32z,*)t_magnets(kproto)%br(3)
          call undumag_double_to_radia(c32z)
          write(lunrad,*)"         {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
          mater = imatmagpol(imp)
          write(chmat,*)mater
          call util_string_trim(chmat,nfirst,nlast)
          chmat="UmatREC["//chmat(nfirst:nlast)//"]"
        else
          write(lunrad,*)"         {0,0,0}"
          write(lunrad,*)"       ];"
          mater = imatmagpol(imp)
          write(chmat,*)mater
          call util_string_trim(chmat,nfirst,nlast)
          chmat="UmatIron["//chmat(nfirst:nlast)//"]"
        endif !Pole/Mag

        if (t_magnets(kproto)%nzdiv*t_magnets(kproto)%nydiv*t_magnets(kproto)%nxdiv.gt.1) then
          write(lunrad,*)' '
          write(cline,*)
     &      "      radObjDivMag["//trim(adjustl(t_magcopy(imp)%cnam))//", {{",
     &      t_magnets(kproto)%nzdiv,",",
     &      sngl(t_magnets(kproto)%zfracdiv),"},",t_magnets(kproto)%nxdiv,
     &      ",{",t_magnets(kproto)%nydiv,",",
     &      sngl(t_magnets(kproto)%yfracdiv),"}},kxkykz->Numb];"
          call util_remove_double_blanks(cline,cout,lenout)
          write(lunrad,*)'       ',cout(1:lenout)
          write(lunrad,*)' '
        endif

        write(lunrad,*)" "
        write(lunrad,*)"       radMatApl["//trim(adjustl(t_magcopy(imp)%cnam))//","//
     &    trim(chmat)//"];"

        if (ncolor.eq.2) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{1,0,0},0.0001];"
        else if (ncolor.eq.3) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{0,1,0},0.0001];"
        else if (ncolor.eq.4) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{0,0,1},0.0001];"
        else if (ncolor.eq.5) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{1,1,0},0.0001];"
        else if (ncolor.eq.6) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{1,0,1},0.0001];"
        else if (ncolor.eq.7) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{0,1,1},0.0001];"
        endif

        write(lunrad,*)" "

      enddo !imp=1,nmagtot_t

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        if (t_magnets(kproto)%IsPole.eq.0) then

          nUnduMag=nUnduMag+1

          write(c32,*)nUnduMag
          write(lunrad,*)"       nUnduMag = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       UnduMag[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"

          nMagPolTot=nMagPolTot+1

          write(c32,*)nMagPolTot
          write(lunrad,*)"       nMagPolTot = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       AllMagPols[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"
          write(lunrad,*)" "

          if (t_magcopy(imp)%cnam.eq.chforcemag) then
            write(lunrad,*)' '
            write(lunrad,*)"       iForceTyp = 1;"
            write(c32,*)nUnduMag
            write(lunrad,*)"      nForce = " // trim(adjustl(c32)) //";"
            write(lunrad,*)' '
            write(lunrad,*)" "
          endif

        else

          nUnduPol=nUnduPol+1
          write(c32,*)nUnduPol
          write(lunrad,*)"       nUnduPol = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       UnduPol[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"

          nMagPolTot=nMagPolTot+1

          write(c32,*)nMagPolTot
          write(lunrad,*)"       nMagPolTot = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       AllMagPols[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"
          write(lunrad,*)" "

          if (t_magcopy(imp)%cnam.eq.chforcemag) then
            write(lunrad,*)' '
            write(lunrad,*)"       iForceTyp = 1;"
            write(c32,*)nUnduPol
            write(lunrad,*)"      nForce = " // trim(adjustl(c32)) //";"
            write(lunrad,*)' '
            write(lunrad,*)" "
          endif

        endif !Pole/Mag

      enddo !imp=1,nmagtot_t

      deallocate(brrec)

      write(lunrad,*)' '
      write(lunrad,*)'(*-- End of lines generated by UNDUMAG --*)'
      write(lunrad,*)' '

      write(lunrad,*)' '
      write(lunrad,*)'(*-- Reading undumag_proc.nb and appending to undumag.nb --*)'
      write(lunrad,*)' '

      open(newunit=lunproc,file='undumag_proc.nb',status='old', iostat=istat)

      if (istat.ne.0) then
        write(lun6,*)"*** Error in clcmag_to_radia: File undumag_proc.nb not found ***"
      else

        ieof=0
        cline=''

        do while (ieof.eq.0)
          read(lunproc,'(a)',iostat=ieof) cline
          if (ieof.eq.0) write(lunrad,'(a)') trim(cline)
        enddo
        close(lunproc)

      endif

      flush(lunrad)
      close(lunrad)

      return
      end
+DECK,undumag_force_parameters.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.25/00 08/03/2018  14.12.29  by  Michael Scheer
*CMZ :  1.22/00 04/07/2017  09.10.00  by  Michael Scheer
*CMZ :  1.11/01 09/01/2017  13.37.40  by  Michael Scheer
*-- Author :    Michael Scheer   06/01/2017
      subroutine undumag_force_parameters

      use bpolyederf90m
      use undumagf90m

      use commandlinef90m

      implicit none

      double precision val
      integer luni,last,istat,nbuff,ipos(2,3),nwords,ifound,i
      character(128) cline,cvar
      character(32) cw1,cw2,cw3
      character c1
      integer ic1
      equivalence (ic1,c1)

      open(newunit=luni,file='undumag.in')

      ifound=0
      ic1=0

      do while (.true.)
        read(luni,'(a)',end=9)cline
c        write(lun6,*)cline
        if (cline(1:25).eq.'* Results of undumag_calc') then
          ifound=1
          exit
        endif
      enddo
9     continue

      if (ifound.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Error in undumag_force_parameters: No results of undumag_calc found ***"
        write(lun6,*)
        stop
      endif

      do while (.true.)
        read(luni,'(a)')cline
        if (cline(1:8).eq.'*EndCalc') exit

        do i=1,128
          if (cline(i:i).eq.':') then
            ifound=i
            exit
          endif
        enddo

        if (ifound.ne.0) then
          cvar=cline(2:ifound-1)
          read(cline(ifound+1:128),*)val
c          write(lun6,*)cvar,val
        endif

        do i=1,len_trim(cvar)
          c1=cvar(i:i)
          if (ic1.ge.65.and.ic1.le.90) ic1=ic1+32
          cvar(i:i)=c1
        enddo

        if (cvar.eq.'iplforce') iplforce=val

        if (cvar.eq.'ubflenx') ubflenx=val
        if (cvar.eq.'ubfleny') ubfleny=val
        if (cvar.eq.'ubflenz') ubflenz=val

        if (cvar.eq.'ubfcenx') ubfcenx=val
        if (cvar.eq.'ubfceny') ubfceny=val
        if (cvar.eq.'ubfcenz') ubfcenz=val

        if (cvar.eq.'utorqcenx') utorqcenx=val
        if (cvar.eq.'utorqceny') utorqceny=val
        if (cvar.eq.'utorqcenz') utorqcenz=val

        if (cvar.eq.'mbforcex') mbforcex=val
        if (cvar.eq.'mbforcey') mbforcey=val
        if (cvar.eq.'mbforcez') mbforcez=val

        if (cvar.eq.'mfcolor') mfcolor=val
      enddo

      close(luni)

      return
      end
+DECK,undumag_duplicate_mags.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.01/02 26/04/2018  08.50.33  by  Michael Scheer
*CMZ :  1.23/01 07/08/2017  14.25.23  by  Michael Scheer
*CMZ :  1.22/02 27/07/2017  10.58.16  by  Michael Scheer
*CMZ :  1.19/00 16/06/2017  13.20.59  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  15.47.17  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  16.13.31  by  Michael Scheer
*-- Author :    Michael Scheer   16/01/2017
      subroutine undumag_duplicate_mags

      use bpolyederf90m
      use undumagf90m

      use commandlinef90m

      implicit none

! ibpecorn(iplan,imag)=ncorn
! ibpecol(imag) color index

! bpebc(1:3,... position x,y,z
! bpebc(4:6,... M vector, might be changed during relaxation
! bpebc(7,... length of M vector, might be changed during relaxation
! bpebc(8,... type
! bpebc(9,imag)=imat
! bpebc(10,imag) special magnet flag
! bpebc(11:13,imag) normalized M vector at the beginning, will survive
! bpebc(14,imag) length M vector at the beginning, will survive
! bpebc(15,imag) Mother volume

      integer imag,icorn,kcorn,ncorn,iplan,nplan,nfirst,nlast,
     &  mspecmag,nmago,lunlis,ieof

      character(1) c32a(32)
      character(32) c32,chsel
      equivalence (c32a,c32)

      bpebc(17,1:nmag)=0.0d0

      if (noduplis.ne.0) then
        open(newunit=lunlis,file="undumag_no_duplication.lis")
        do while (.true.)
          call util_skip_comment_end(lunlis,ieof)
          if (ieof.ne.0) exit
          read(lunlis,'(a)')chsel
          do imag=1,nmag
            write(chmoth,'(32a)')chmoths(1:32,imag)
            if (chmoth.eq.chsel) then
              bpebc(17,imag)=1
            endif
          enddo
        enddo
        close(lunlis)
      endif !(noduplis.ne.0) then

      nmago=nmag

      mspecmag=0
      do imag=1,nmag
        if (bpebc(10,imag).ne.0) then
          mspecmag=mspecmag+1
        endif
      enddo

      if (ixsym.lt.0) then

        do imag=1,nmag

          bpebc(17,nmag+imag)=bpebc(17,imag)

          bpebc(1:14,nmag+imag)=bpebc(1:14,imag)
          bpebc(15,nmag+imag)=nmag+imag
          chmags(1:32,nmag+imag)=chmags(1:32,imag)
          c32a=chmoths(1:32,imag)
          call util_string_trim(c32,nfirst,nlast)
          if (nlast-nfirst.gt.27) then
            write(lun6,*)
            write(lun6,*)"*** Error in undumag_duplicate_mags: Too long a name:"
            write(lun6,*)c32
            write(lun6,*)
          endif
          c32=c32(nfirst:nlast)//"x"
          chmoths(1:32,nmag+imag)=c32a

          bpebc(10,nmag+imag)=bpebc(10,imag)
          if (bpebc(10,nmag+imag).ne.0) then
            bpebc(10,nmag+imag)=bpebc(10,imag)+mspecmag
          endif

          bpebc(1,nmag+imag)=-bpebc(1,imag)
          bpebc(4,nmag+imag)=-bpebc(4,imag)
          bpebc(11,nmag+imag)=-bpebc(11,imag)

c          if (bpebc(17,imag).ne.0) then
c            bpebc(4:7,nmag+imag)=0.0d0
c          endif

          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              kcorn=ncorn-icorn+1
              bpemag(1,kcorn,iplan,nmag+imag)=
     &          -bpemag(1,icorn,iplan,imag)
              bpemag(2:3,kcorn,iplan,nmag+imag)=
     &          bpemag(2:3,icorn,iplan,imag)
            enddo
          enddo

          ibpeplan(nmag+imag)=ibpeplan(imag)
          ibpecol(nmag+imag)=ibpecol(imag)
          ibpecorn(1:nplanmax,nmag+imag)=ibpecorn(1:nplanmax,imag)

        enddo !nmag

        nmag=2*nmag
        mspecmag=2*mspecmag

      endif

      if (iysym.lt.0) then

        do imag=1,nmag

          bpebc(17,nmag+imag)=bpebc(17,imag)

          bpebc(1:14,nmag+imag)=bpebc(1:14,imag)
          bpebc(15,nmag+imag)=nmag+imag
          chmags(1:32,nmag+imag)=chmags(1:32,imag)
          c32a=chmoths(1:32,imag)
          call util_string_trim(c32,nfirst,nlast)
          if (nlast-nfirst.gt.27) then
            write(lun6,*)
            write(lun6,*)"*** Error in undumag_duplicate_mags: Too long a name:"
            write(lun6,*)c32
            write(lun6,*)
          endif
          c32=c32(nfirst:nlast)//"y"
          chmoths(1:32,nmag+imag)=c32a

          bpebc(10,nmag+imag)=bpebc(10,imag)
          if (bpebc(10,nmag+imag).ne.0) then
            bpebc(10,nmag+imag)=bpebc(10,imag)+mspecmag
          endif

          bpebc(2,nmag+imag)=-bpebc(2,imag)
          bpebc(4,nmag+imag)=-bpebc(4,imag)
          bpebc(6,nmag+imag)=-bpebc(6,imag)
          bpebc(12,nmag+imag)=-bpebc(12,imag)

c          if (bpebc(17,imag).ne.0) then
c            bpebc(4:7,nmag+imag)=0.0d0
c          endif

          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              kcorn=ncorn-icorn+1
              bpemag(1,kcorn,iplan,nmag+imag)=
     &          bpemag(1,icorn,iplan,imag)
              bpemag(2,kcorn,iplan,nmag+imag)=
     &          -bpemag(2,icorn,iplan,imag)
              bpemag(3,kcorn,iplan,nmag+imag)=
     &          bpemag(3,icorn,iplan,imag)
            enddo
          enddo

          ibpeplan(nmag+imag)=ibpeplan(imag)
          ibpecol(nmag+imag)=ibpecol(imag)
          ibpecorn(1:nplanmax,nmag+imag)=ibpecorn(1:nplanmax,imag)

        enddo !nmag

        nmag=2*nmag
        mspecmag=2*mspecmag

      endif

      if (izsym.lt.0) then

        do imag=1,nmag

          bpebc(17,nmag+imag)=bpebc(17,imag)

          bpebc(1:14,nmag+imag)=bpebc(1:14,imag)

          bpebc(10,nmag+imag)=bpebc(10,imag)
          if (bpebc(10,nmag+imag).ne.0) then
            bpebc(10,nmag+imag)=bpebc(10,imag)+mspecmag
          endif

          bpebc(3,nmag+imag)=-bpebc(3,imag)
          bpebc(6,nmag+imag)=-bpebc(6,imag)
          bpebc(13,nmag+imag)=-bpebc(13,imag)
          bpebc(15,nmag+imag)=nmag+imag
c          if (bpebc(17,imag).ne.0) then
c            bpebc(4:7,nmag+imag)=0.0d0
c          endif

          chmags(1:32,nmag+imag)=chmags(1:32,imag)
          c32a=chmoths(1:32,imag)
          call util_string_trim(c32,nfirst,nlast)
          if (nlast-nfirst.gt.27) then
            write(lun6,*)
            write(lun6,*)"*** Error in undumag_duplicate_mags: Too long a name:"
            write(lun6,*)c32
            write(lun6,*)
          endif
          c32=c32(nfirst:nlast)//"z"
          chmoths(1:32,nmag+imag)=c32a

          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              kcorn=ncorn-icorn+1
              bpemag(1:2,kcorn,iplan,nmag+imag)=
     &          bpemag(1:2,icorn,iplan,imag)
              bpemag(3,kcorn,iplan,nmag+imag)=
     &          -bpemag(3,icorn,iplan,imag)
            enddo
          enddo

          ibpeplan(nmag+imag)=ibpeplan(imag)
          ibpecol(nmag+imag)=ibpecol(imag)
          ibpecorn(1:nplanmax,nmag+imag)=ibpecorn(1:nplanmax,imag)

        enddo !nmag

        nmag=2*nmag

      endif !izsym

      do imag=nmago+1,nmag
        if (bpebc(17,imag).ne.0.0d0) then
          bpebc(4:7,imag)=0.0d0
        endif
      enddo

      do imag=1,nmago
        if (bpebc(17,imag).ne.0.0d0) then
          bpebc(17,imag)=-9999.0d0
        endif
      enddo

      return
      end
+DECK,undumag_dipoles.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.53.10  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  14.24.59  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.56.35  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.13.46  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  16.19.19  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.37.24  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/2017
      subroutine undumag_dipoles(xin,yin,zin,bxout,byout,bzout,kfail)

      use undumagf90m
      use bpolyederf90m

      use commandlinef90m

      implicit none

      double precision gcen(3),ri,rmin,rmax,riv(3),x,y,z,bn(3),b,
     &  bx,by,bz,bxd,byd,bzd,p(3),q,pr,rob,dlen,
     &  xin,yin,zin,bxout,byout,bzout,pn,bdx,bdy,bdz,corr

      integer imag,iplan,icorn,npoi,ifail,kfail,ical,itry,kmag,idip,moth

      save

c dipoles(1:3,imag)=gcen
c dipoles(4,imag)=pn
c dipoles(5:7,imag)=p/pn
c dipoles(8,imag)= selection flag
c dipoles(9,imag)= mother
c dipoles(10,imag)= imag
c dipoles(11:13,imag)= force on dipole
c dipoles(14:16,imag)= torque on dipole

      kfail=0

      if (ical.eq.0.or.kallodip.eq.0) then

        ndipoles=nmag
        if (ixsym.ne.0) ndipoles=ndipoles*2
        if (iysym.ne.0) ndipoles=ndipoles*2
        if (izsym.ne.0) ndipoles=ndipoles*2
        allocate(dipoles(16,ndipoles))
        dipoles=0.0d0
        kallodip=1
        ical=1

        kmag=nmag
        do imag=1,nmag

          if (bpebc(7,imag).eq.0.0d0) cycle

          moth=nint(bpebc(15,imag))
          dipoles(9,imag)=moth
          dipoles(10,imag)=imag

          bn=bpebc(4:6,imag)/bpebc(7,imag)

          npoi=0
          gcen=0.0d0

          do iplan=1,ibpeplan(imag)
            do icorn=1,ibpecorn(iplan,imag)-1
              npoi=npoi+1
              gcen(1:3)=gcen(1:3)+bpemag(1:3,icorn,iplan,imag)
c               write(lun6,*)imag,iplan,icorn,npoi,bpemag(1:3,icorn,iplan,imag)
            enddo !ncorn
          enddo !nplan

          gcen=gcen/npoi

          dipoles(1:3,imag)=gcen

          rmin=1.0d30
          rmax=-1.0d30
          do iplan=1,ibpeplan(imag)
            do icorn=1,ibpecorn(iplan,imag)
              riv(1:3)=bpemag(1:3,icorn,iplan,imag)-gcen
              ri=sqrt(riv(1)**2+riv(2)**2+riv(3)**2)
              if (ri.lt.rmin) rmin=ri
              if (ri.gt.rmax) rmax=ri
            enddo !ncorn
          enddo !nplan

          itry=0
1         rmax=rmax/2**itry

          rob=100.0d0*rmax
          dlen=rmin/2.0d0

          x=bpebc(1,imag)+bn(1)*rob
          y=bpebc(2,imag)+bn(2)*rob
          z=bpebc(3,imag)+bn(3)*rob

          call undumag_bpolyeder1(imag,x/1.0d3,y/1.0d3,z/1.0d3,bx,by,bz,ifail)
          if (ifail.ne.0) then
            write(lun6,*)"*** Warning in undumag_dipoles: Bad return from undumag_bolyeder1 ***"
            kfail=imag
          endif

          b=bx*bn(1)+by*bn(2)+bz*bn(3)
          q=b*rob**3/dlen
          p=dlen/2.0d0*q*bn

          pn=sqrt(p(1)**2+p(2)**2+p(3)**2)
          if (pn.eq.0.0d0) then
            if (rob.lt.rmax) then
              write(lun6,*)"*** Warning in undumag_dipoles, zero field ***"
              write(lun6,*)"*** Trying to recover, itry:",itry," ***"
              kfail=imag
              cycle
            endif
            itry=itry+1
            goto 1
          endif
          dipoles(4,imag)=pn
          dipoles(5:7,imag)=p/pn
          dipoles(8,imag)=bpebc(17,imag)

c           call undumag_dipole_field(imag,x/1.0d3,y/1.0d3,z/1.0d3,
c     &       bdx,bdy,bdz,kfail)
c
c           corr=
c     &       sqrt(bx**2+by**2+bz**2)/
c     &       sqrt(bdx**2+bdy**2+bdz**2)
c
c           write(lun6,*)"corr:",corr
c           dipoles(4,imag)=dipoles(4,imag)*corr

          if (nmag.ne.ndipoles) then
            if (ixsym.ne.0.and.iysym.ne.0.and.izsym.ne.0) then
              kmag=kmag+1 !xsym
              dipoles(1:7,kmag)=dipoles(1:7,imag)
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1,kmag)=-dipoles(1,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
              kmag=kmag+1 !ysym
              dipoles(1:7,kmag)=dipoles(1:7,imag)
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(2,imag)=-dipoles(2,kmag)
              dipoles(5,imag)=-dipoles(5,kmag)
              kmag=kmag+1 !zsym
              dipoles(1:7,kmag)=dipoles(1:7,imag)
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(9:10,kmag)=dipoles(9:10,imag)
              dipoles(3,kmag)=-dipoles(3,imag)
              dipoles(7,kmag)=-dipoles(7,imag)
              kmag=kmag+1 !ix + iy
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1:2,kmag)=-dipoles(1:2,imag)
              dipoles(3:7,kmag)=dipoles(3:7,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
              kmag=kmag+1 !ix + iz
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1,kmag)=-dipoles(1,imag)
              dipoles(2,kmag)=dipoles(2,imag)
              dipoles(3,kmag)=-dipoles(3,imag)
              dipoles(4,kmag)=dipoles(4,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
              dipoles(6,kmag)=dipoles(6,imag)
              dipoles(7,kmag)=-dipoles(7,imag)
              kmag=kmag+1 !iy + iz
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1,kmag)=dipoles(1,imag)
              dipoles(2,kmag)=-dipoles(2,imag)
              dipoles(3,kmag)=-dipoles(3,imag)
              dipoles(4,kmag)=dipoles(4,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
              dipoles(6,kmag)=dipoles(6,imag)
              dipoles(7,kmag)=-dipoles(7,imag)
              kmag=kmag+1 !iy + iy + iz
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1:3,kmag)=-dipoles(1:3,imag)
              dipoles(4,kmag)=dipoles(5,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
              dipoles(6,kmag)= dipoles(6,imag)
              dipoles(7,kmag)=-dipoles(7,imag)
            else if (ixsym.ne.0.and.iysym.ne.0) then
              kmag=kmag+1 !xsym
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1:7,kmag)=dipoles(1:7,imag)
              dipoles(1,kmag)=-dipoles(1,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
              kmag=kmag+1 !ysym
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1:7,imag)=dipoles(1:7,kmag)
              dipoles(2,imag)=-dipoles(2,kmag)
              dipoles(5,imag)=-dipoles(5,kmag)
              kmag=kmag+1 !ix + iy
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1:2,kmag)=-dipoles(1:2,imag)
              dipoles(3:7,kmag)=dipoles(3:7,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
            else if (ixsym.ne.0.and.izsym.ne.0) then
              kmag=kmag+1 !xsym
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1:7,kmag)=dipoles(1:7,imag)
              dipoles(1,kmag)=-dipoles(1,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
              kmag=kmag+1 !zsym
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(9:10,kmag)=dipoles(9:10,imag)
              dipoles(1:7,kmag)=dipoles(1:7,imag)
              dipoles(3,kmag)=-dipoles(3,imag)
              dipoles(7,kmag)=-dipoles(7,imag)
              kmag=kmag+1 !ix + iz
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(9:10,kmag)=dipoles(9:10,imag)
              dipoles(1,kmag)=-dipoles(1,imag)
              dipoles(2,kmag)=dipoles(2,imag)
              dipoles(3,kmag)=-dipoles(3,imag)
              dipoles(4,kmag)=dipoles(4,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
              dipoles(6,kmag)=dipoles(6,imag)
              dipoles(7,kmag)=-dipoles(7,imag)
            else if (iysym.ne.0.and.izsym.ne.0) then
              kmag=kmag+1 !ysym
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1:7,imag)=dipoles(1:7,kmag)
              dipoles(2,imag)=-dipoles(2,kmag)
              dipoles(5,imag)=-dipoles(5,kmag)
              kmag=kmag+1 !zsym
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(9:10,kmag)=dipoles(9:10,imag)
              dipoles(1:7,kmag)=dipoles(1:7,imag)
              dipoles(3,kmag)=-dipoles(3,imag)
              dipoles(7,kmag)=-dipoles(7,imag)
              kmag=kmag+1 !iy + iz
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(9:10,kmag)=dipoles(9:10,imag)
              dipoles(1,kmag)=dipoles(1,imag)
              dipoles(2,kmag)=-dipoles(2,imag)
              dipoles(3,kmag)=-dipoles(3,imag)
              dipoles(4,kmag)=dipoles(4,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
              dipoles(6,kmag)=dipoles(6,imag)
              dipoles(7,kmag)=-dipoles(7,imag)
            else if (ixsym.ne.0) then
              kmag=kmag+1 !xsym
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1:7,kmag)=dipoles(1:7,imag)
              dipoles(1,kmag)=-dipoles(1,imag)
              dipoles(5,kmag)=-dipoles(5,imag)
            else if (iysym.ne.0) then
              kmag=kmag+1 !ysym
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(1:7,imag)=dipoles(1:7,kmag)
              dipoles(2,imag)=-dipoles(2,kmag)
              dipoles(5,imag)=-dipoles(5,kmag)
            else if (izsym.ne.0) then
              kmag=kmag+1 !zsym
              dipoles(8,kmag)=dipoles(8,imag)
              dipoles(9:10,kmag)=dipoles(9:10,imag)
              dipoles(1:7,kmag)=dipoles(1:7,imag)
              dipoles(3,kmag)=-dipoles(3,imag)
              dipoles(7,kmag)=-dipoles(7,imag)
            endif
          endif !(nmag.ne.ndipoles) then

        enddo !nmag

      endif !ical

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      do idip=1,ndipoles
        if (dipoles(8,idip).lt.0.0d0) cycle
        call undumag_dipole_field(idip,xin,yin,zin,bx,by,bz,kfail)
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
      enddo !nmag

      return
      end
+DECK,undumag_force_dipoles.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.25/00 29/01/2018  11.03.33  by  Michael Scheer
*CMZ :  1.24/01 13/10/2017  08.16.08  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  14.26.18  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  08.44.11  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  09.27.56  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  12.25.04  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.16.46  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.55.27  by  Michael Scheer
*-- Author :    Michael Scheer   24/01/2017
      subroutine undumag_force_dipoles

      use undumagf90m
      use bpolyederf90m

      use commandlinef90m

      use commandlinef90m

      implicit none

      double precision :: eps=0.0001 !Meter
      double precision x,y,z,xm,xp,ym,yp,zm,zp,bxm,bym,bzm,bxp,byp,bzp,p(3),pn,
     &  dbxdx,dbxdy,dbxdz,
     &  dbydx,dbydy,dbydz,
     &  dbzdx,dbzdy,dbzdz

      integer imag,ifail,kmag,luno,kfail,moth,kmoth

      call util_zeit_kommentar(lun6,"Starting force calculations for dipole approximation")

      if (kallodip.ne.1) then
        x=0.0d0
        y=0.0d0
        z=0.0d0
        call undumag_dipoles_field(x,y,z,bxm,bym,bzm,ifail)
      endif

      fxdip=0.0d0
      fydip=0.0d0
      fzdip=0.0d0

      txdip=0.0d0
      tydip=0.0d0
      tzdip=0.0d0

      if (chforcemag.eq.'') goto 9999

      if (kforcemag.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_force_dipoles: Magnet ",
     &    trim(chforcemag),
     &    " not found ***"
        write(lun6,*)"*** Check undumag_magnets.lis ***"
        write(lun6,*)
        goto 9999
      endif

      kmoth=bpebc(15,kforcemag)
      do kmag=1,ndipoles
        moth=nint(dipoles(9,kmag))
        if (moth.eq.kmoth) then
          call undumag_force_dipoles_nos(kmag,kfail)
        endif
      enddo

 9999 continue

      write(lun6,*)
      write(lun6,*)'* FxDip [N], FyDip [N], FzDip [N]:'
      write(lun6,'(3f15.4)')fxdip,fydip,fzdip
      write(lun6,*)
      write(lun6,*)'* TxDip, TyDip, TzDip [Nmm]:'
      write(lun6,'(3f15.4)')txdip*1000.0d0,tydip*1000.0d0,tzdip*1000.0d0
      write(lun6,*)

      open(newunit=luno,file='undumag.dfr')
      write(luno,*)'* FxDip, FyDip, FzDip [N]:'
      write(luno,'(3f15.4)')fxdip,fydip,fzdip
      write(luno,*)'* TxDip, TyDip, TzDip [Nmm]:'
      write(luno,'(3f15.4)')txdip*1000.0d0,tydip*1000.0d0,tzdip*1000.0d0
      close(luno)

      call util_zeit_kommentar(lun6,"Force calculations for dipole approximation finished")

      return
      end
+DECK,undumag_magpol_index.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  08.58.09  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  18.56.39  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  16.09.36  by  Michael Scheer
*-- Author :    Michael Scheer   24/01/2017
      subroutine undumag_magpol_index(chmagpol,ind)

      use undumagf90m
      use bpolyederf90m

      use commandlinef90m

      implicit none

      integer imp,ic,ind,kcs,kc

      character(32) chmagpol
      character c1,c1s

      equivalence (kc,c1)
      equivalence (kcs,c1s)

      ind=0

      kc=0
      kcs=0
      do imp=1,nmagpols
        ind=1
        write(lun6,*)imp,chmagpols(1:32,imp)
        do ic=1,32
          c1=chmagpol(ic:ic)
          c1s=chmagpols(ic,imp)
          write(lun6,*)chmagpol(ic:ic),kc,imp,chmagpols(ic,imp),kcs
          if (chmagpols(ic,imp).ne.chmagpol(ic:ic)) then
            ind=0
            exit
          endif
        enddo
        if (ind.eq.1) then
          ind=imp
          exit
        endif
      enddo

 9999 continue
      return
      end
+DECK,undumag_dipole_field.
*CMZ :  1.17/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  10.58.57  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  09.36.52  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/2017
      subroutine undumag_dipole_field(idip,xin,yin,zin,bxout,byout,bzout,kfail)

c Calculates the field of the dipole idip at xin,yin,zin

      use undumagf90m
      use bpolyederf90m

      implicit none

      double precision gcen(3),ri,rmin,rmax,riv(3),x,y,z,bn(3),b,
     &  bx,by,bz,bxd,byd,bzd,p(3),q,pr,rob,dlen,
     &  xin,yin,zin,bxout,byout,bzout,rob2,rob3

      integer idip,iplan,icorn,npoi,ifail,kfail,ical

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      x=xin*1.0d3-dipoles(1,idip)
      y=yin*1.0d3-dipoles(2,idip)
      z=zin*1.0d3-dipoles(3,idip)

      p=dipoles(5:7,idip)*dipoles(4,idip)
      pr=p(1)*x+p(2)*y+p(3)*z
      rob2=x**2+y**2+z**2
      rob=sqrt(rob2)
      rob3=rob2*rob

      if (rob.gt.1.0d-6) then
        bxout=(3.0d0*pr*x/rob2-p(1))/rob3
        byout=(3.0d0*pr*y/rob2-p(2))/rob3
        bzout=(3.0d0*pr*z/rob2-p(3))/rob3
      else
        kfail=1
      endif

      return
      end
+DECK,undumag_force_dipoles_nos.
*CMZ :  2.01/03 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.24/01 12/10/2017  16.37.55  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  14.42.07  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  12.50.32  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  09.26.43  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  19.42.41  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.55.27  by  Michael Scheer
*-- Author :    Michael Scheer   24/01/2017
      subroutine undumag_force_dipoles_nos(kdip,ifail)

      use undumagf90m
      use bpolyederf90m

      implicit none

      double precision :: eps=0.0001 !Meter
      double precision x,y,z,xm,xp,ym,yp,zm,zp,bxm,bym,bzm,bxp,byp,bzp,p(3),pn,
     &  dbxdx,dbxdy,dbxdz,
     &  dbydx,dbydy,dbydz,
     &  dbzdx,dbzdy,dbzdz,
     &  dfxdip,dfydip,dfzdip,
     &  dtxdip,dtydip,dtzdip,bx,by,bz,bpebc17

      integer kdip,idip,ifail,kmag,moth,imag

      ifail=0
      if (kdip.lt.1.or.kdip.gt.ndipoles) then
        ifail=1
        return
      endif

      x=dipoles(1,kdip)/1000.0d0
      y=dipoles(2,kdip)/1000.0d0
      z=dipoles(3,kdip)/1000.0d0

      p=dipoles(4,kdip)*dipoles(5:7,kdip)/1000.0d0

      xp=x+eps
      xm=x-eps
      yp=y+eps
      ym=y-eps
      zp=z+eps
      zm=z-eps

      dfxdip=0.0d0
      dfydip=0.0d0
      dfzdip=0.0d0

      dtxdip=0.0d0
      dtydip=0.0d0
      dtzdip=0.0d0

      if (iforcedip.lt.0) then

        do idip=1,ndipoles

          if (dipoles(9,idip).eq.dipoles(9,kdip)) cycle

          call undumag_dipole_field(idip,xp,y,z,bxp,byp,bzp,ifail)
          call undumag_dipole_field(idip,xm,y,z,bxm,bym,bzm,ifail)
          dbxdx=(bxp-bxm)/(xp-xm)
          dbydx=(byp-bym)/(xp-xm)
          dbzdx=(bzp-bzm)/(xp-xm)

          call undumag_dipole_field(idip,x,yp,z,bxp,byp,bzp,ifail)
          call undumag_dipole_field(idip,x,ym,z,bxm,bym,bzm,ifail)
          dbxdy=(bxp-bxm)/(yp-ym)
          dbydy=(byp-bym)/(yp-ym)
          dbzdy=(bzp-bzm)/(yp-ym)

          call undumag_dipole_field(idip,x,y,zp,bxp,byp,bzp,ifail)
          call undumag_dipole_field(idip,x,y,zm,bxm,bym,bzm,ifail)
          dbxdz=(bxp-bxm)/(zp-zm)
          dbydz=(byp-bym)/(zp-zm)
          dbzdz=(bzp-bzm)/(zp-zm)

          dfxdip=dfxdip+p(1)*dbxdx+p(2)*dbydx+p(3)*dbzdx
          dfydip=dfydip+p(1)*dbxdy+p(2)*dbydy+p(3)*dbzdy
          dfzdip=dfzdip+p(1)*dbxdz+p(2)*dbydz+p(3)*dbzdz

          call undumag_dipole_field(idip,x,y,z,bx,by,bz,ifail)

          dtxdip=dtxdip+p(2)*bz-p(3)*by
          dtydip=dtydip+p(3)*bx-p(1)*bz
          dtzdip=dtzdip+p(1)*by-p(2)*bx

        enddo

      else !iforcedip>0 {

c        kmag=dipoles(10,kdip)
c        bpebc17=bpebc(17,kmag)
c        bpebc(17,kmag)=-1

        do imag=1,nmag

          moth=bpebc(15,imag)
          if (moth.eq.kforcemag) cycle

          call undumag_bpolyeder1_sym(imag,xp,y,z,bxp,byp,bzp,ifail)
          call undumag_bpolyeder1_sym(imag,xm,y,z,bxm,bym,bzm,ifail)
          dbxdx=(bxp-bxm)/(xp-xm)
          dbydx=(byp-bym)/(xp-xm)
          dbzdx=(bzp-bzm)/(xp-xm)

          call undumag_bpolyeder1_sym(imag,x,yp,z,bxp,byp,bzp,ifail)
          call undumag_bpolyeder1_sym(imag,x,ym,z,bxm,bym,bzm,ifail)
          dbxdy=(bxp-bxm)/(yp-ym)
          dbydy=(byp-bym)/(yp-ym)
          dbzdy=(bzp-bzm)/(yp-ym)

          call undumag_bpolyeder1_sym(imag,x,y,zp,bxp,byp,bzp,ifail)
          call undumag_bpolyeder1_sym(imag,x,y,zm,bxm,bym,bzm,ifail)
          dbxdz=(bxp-bxm)/(zp-zm)
          dbydz=(byp-bym)/(zp-zm)
          dbzdz=(bzp-bzm)/(zp-zm)

          dfxdip=dfxdip+p(1)*dbxdx+p(2)*dbydx+p(3)*dbzdx
          dfydip=dfydip+p(1)*dbxdy+p(2)*dbydy+p(3)*dbzdy
          dfzdip=dfzdip+p(1)*dbxdz+p(2)*dbydz+p(3)*dbzdz

          call undumag_bpolyeder1_sym(imag,x,y,z,bx,by,bz,ifail)

          dtxdip=dtxdip+p(2)*bz-p(3)*by
          dtydip=dtydip+p(3)*bx-p(1)*bz
          dtzdip=dtzdip+p(1)*by-p(2)*bx

        enddo

c        bpebc(17,kmag)=bpebc17

      endif !(iforcedip.lt.0) then

      ! Factor 10 maybe due to H in Tesla and m to mm somewhere !??

      dfxdip=10.0d0*dfxdip
      dfydip=10.0d0*dfydip
      dfzdip=10.0d0*dfzdip

      dtxdip=10.0d0*dtxdip
      dtydip=10.0d0*dtydip
      dtzdip=10.0d0*dtzdip

      dipoles(11,kdip)=dfxdip
      dipoles(12,kdip)=dfydip
      dipoles(13,kdip)=dfzdip

      dipoles(14,kdip)=dtxdip
      dipoles(15,kdip)=dtydip
      dipoles(16,kdip)=dtzdip

      fxdip=fxdip+dfxdip
      fydip=fydip+dfydip
      fzdip=fzdip+dfzdip

      txdip=txdip+dtxdip
      tydip=tydip+dtydip
      tzdip=tzdip+dtzdip

      return
      end
+DECK,undumag_dipoles_field.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.25/00 13/03/2018  13.43.22  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.53.10  by  Michael Scheer
*CMZ :  1.23/06 06/10/2017  14.14.51  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  14.24.59  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.06.15  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.56.35  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  13.01.19  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  14.17.21  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  16.35.25  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  16.19.19  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.37.24  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/2017
      subroutine undumag_dipoles_field(xin,yin,zin,bxout,byout,bzout,kfail)

      use undumagf90m
      use bpolyederf90m

      use commandlinef90m

      implicit none

      double precision gcen(3),ri,rmin,rmax,riv(3),x,y,z,bn(3),b,
     &  bx,by,bz,bxd,byd,bzd,p(3),q,pr,rob,dlen,r2,r3,
     &  xin,yin,zin,bxout,byout,bzout,pn,bdx,bdy,bdz,xm,ym,zm,dom

+self,if=cornpoles.
      double precision, dimension (:), allocatable :: xbuff,ybuff,zbuff
+self.,if=cornpoles.

      integer imag,iplan,icorn,npoi,ifail,kfail,ical,itry,kmag,idip,npoimax,
     &  nplan,ncorn,moth,istat

      save

c dipoles(1:3,imag)=gcen
c dipoles(4,imag)=pn
c dipoles(5:7,imag)=p/pn

      kfail=0

      if (ical.eq.0.or.kallodip.eq.0) then

        ndipoles=nmag
        if (ixsym.ne.0) ndipoles=ndipoles*2
        if (iysym.ne.0) ndipoles=ndipoles*2
        if (izsym.ne.0) ndipoles=ndipoles*2

        allocate(dipoles(16,ndipoles))

+self,if=cornpoles.
        allocate(xbuff(nplanmax*ncornmax))
        allocate(ybuff(nplanmax*ncornmax))
        allocate(zbuff(nplanmax*ncornmax))

        npoimax=0
        do imag=1,nmag
          npoi=0
          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)-1
            do icorn=1,ncorn
              npoi=npoi+1
              xbuff(npoi)=bpemag(1,icorn,iplan,imag)
              ybuff(npoi)=bpemag(2,icorn,iplan,imag)
              zbuff(npoi)=bpemag(3,icorn,iplan,imag)
            enddo !icorn
          enddo !iplan
          call util_weed_points(npoi,xbuff,ybuff,zbuff,0.001d0)
          if(npoi.gt.npoimax) npoimax=npoi
        enddo !imag

        allocate(ncornpoles(ndipoles))
        allocate(cornpoles(4,npoimax,ndipoles))

        do imag=1,nmag
          npoi=0
          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)-1
            do icorn=1,ncorn
              npoi=npoi+1
              xbuff(npoi)=bpemag(1,icorn,iplan,imag)
              ybuff(npoi)=bpemag(2,icorn,iplan,imag)
              zbuff(npoi)=bpemag(3,icorn,iplan,imag)
            enddo !icorn
          enddo !iplan
          call util_weed_points(npoi,xbuff,ybuff,zbuff,0.001d0)
           ncornpoles(imag)=npoi
           do icorn=1,npoi
             cornpoles(1,icorn,imag)=xbuff(icorn)
             cornpoles(2,icorn,imag)=ybuff(icorn)
             cornpoles(3,icorn,imag)=zbuff(icorn)
             cornpoles(4,icorn,imag)=0.0d0
           enddo
         enddo !imag

         call undumag_cornpoles_fit(nmag,npoimax,cornpoles,ifail)
         if (ifail.ne.0) then
           write(lun6,*)"*** Warning in undumag_dipoles: Bad return from undumag_cornpoles_fit ***"
         endif
         deallocate(xbuff,ybuff,zbuff)
+self.,if=cornpoles.

         dipoles=0.0d0
         kallodip=1
         ical=1

         kmag=nmag
         do imag=1,nmag

           if (bpebc(7,imag).eq.0.0d0) cycle

           bn=bpebc(4:6,imag) !*bc00(1:3,imag)
           b=sqrt(bn(1)**2+bn(2)**2+bn(3)**2)
           bn=bn/b

           npoi=0
           gcen=0.0d0

           do iplan=1,ibpeplan(imag)
             do icorn=1,ibpecorn(iplan,imag)-1
               npoi=npoi+1
               gcen(1:3)=gcen(1:3)+bpemag(1:3,icorn,iplan,imag)
c               write(lun6,*)imag,iplan,icorn,npoi,bpemag(1:3,icorn,iplan,imag)
             enddo !ncorn
           enddo !nplan

           gcen=gcen/npoi

           dipoles(1:3,imag)=gcen

           rmin=1.0d30
           rmax=-1.0d30
           do iplan=1,ibpeplan(imag)
             do icorn=1,ibpecorn(iplan,imag)
               riv(1:3)=bpemag(1:3,icorn,iplan,imag)-gcen
               ri=sqrt(riv(1)**2+riv(2)**2+riv(3)**2)
               if (ri.lt.rmin) rmin=ri
               if (ri.gt.rmax) rmax=ri
             enddo !ncorn
           enddo !nplan

           itry=0
1          rmax=rmax/2**itry

           rob=100.0d0*rmax
           dlen=rmin/2.0d0

           x=bpebc(1,imag)+bn(1)*rob
           y=bpebc(2,imag)+bn(2)*rob
           z=bpebc(3,imag)+bn(3)*rob

           call undumag_bpolyeder1(imag,x/1.0d3,y/1.0d3,z/1.0d3,bx,by,bz,ifail)
           if (ifail.ne.0) then
             write(lun6,*)"*** Warning in undumag_dipoles: Bad return from undumag_bolyeder1 ***"
             kfail=imag
           endif

           b=bx*bn(1)+by*bn(2)+bz*bn(3)
           q=b*rob**3/dlen
           p=dlen/2.0d0*q*bn

           pn=sqrt(p(1)**2+p(2)**2+p(3)**2)

           if (pn.eq.0.0d0) then
             if (rob.lt.rmax) then
               write(lun6,*)"*** Warning in undumag_dipoles, zero field ***"
               write(lun6,*)"*** Trying to recover, itry:",itry," ***"
               kfail=imag
               cycle
             endif
             itry=itry+1
             goto 1
           endif

           dipoles(4,imag)=pn
           dipoles(5:7,imag)=p/pn
           dipoles(8,imag)=bpebc(17,imag)
           moth=nint(bpebc(15,imag))
           dipoles(9,imag)=moth
           dipoles(10,imag)=imag

+self,if=-olddip.
           r2=rob**2
           r3=r2*rob

           xm=x/1000.0d0
           ym=y/1000.0d0
           zm=z/1000.0d0

           dom=(r2-3.0d0*(xm**2+ym**2+zm**2))*2.0d0

           p(1)=r3/dom*
     & (-bx*r2+3.0d0*bx*ym**2+3.0d0*bx*zm**2-3.0d0*by*xm*ym-3.0d0*bz*xm*zm)
           p(2)=r3/dom*
     & (-3.0d0*bx*xm*ym-by*r2+3.0d0*by*xm**2+3.0d0*by*zm**2-3.0d0*bz*ym*zm)
           p(3)=r3/dom*
     & (-3.0d0*bx*xm*zm-3.0d0*by*ym*zm-bz*r2+3.0d0*bz*xm**2+3.0d0*bz*ym**2)

           pn=sqrt(p(1)**2+p(2)**2+p(3)**2)

           dipoles(4,imag)=pn
           dipoles(5:7,imag)=-p/pn
+self.

           if (nmag.ne.ndipoles) then
             if (ixsym.ne.0.and.iysym.ne.0.and.izsym.ne.0) then
               kmag=kmag+1 !xsym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(1,kmag)=-dipoles(1,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               kmag=kmag+1 !ysym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(2,kmag)=-dipoles(2,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
               kmag=kmag+1 !zsym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(9:10,kmag)=dipoles(9:10,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(3,kmag)=-dipoles(3,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
               kmag=kmag+1 !ix + iy
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1,kmag)=-dipoles(1,imag)
               dipoles(2,kmag)=-dipoles(2,imag)
               dipoles(3,kmag)=dipoles(3,imag)
               dipoles(4,kmag)=dipoles(4,imag)
               dipoles(5,kmag)=dipoles(5,imag)
               dipoles(6,kmag)=dipoles(6,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
               kmag=kmag+1 !ix + iz
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1,kmag)=-dipoles(1,imag)
               dipoles(2,kmag)=dipoles(2,imag)
               dipoles(3,kmag)=-dipoles(3,imag)
               dipoles(4,kmag)=dipoles(4,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               dipoles(6,kmag)=dipoles(6,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
               kmag=kmag+1 !iy + iz
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1,kmag)=dipoles(1,imag)
               dipoles(2,kmag)=-dipoles(2,imag)
               dipoles(3,kmag)=-dipoles(3,imag)
               dipoles(4,kmag)=dipoles(4,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               dipoles(6,kmag)=dipoles(6,imag)
               dipoles(7,kmag)=dipoles(7,imag)
               kmag=kmag+1 !ix + iy + iz
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:3,kmag)=-dipoles(1:3,imag)
               dipoles(4,kmag)=dipoles(4,imag)
               dipoles(5,kmag)=dipoles(5,imag)
               dipoles(6,kmag)=dipoles(6,imag)
               dipoles(7,kmag)=dipoles(7,imag)
             else if (ixsym.ne.0.and.iysym.ne.0) then
               kmag=kmag+1 !xsym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(1,kmag)=-dipoles(1,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               kmag=kmag+1 !ysym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(2,kmag)=-dipoles(2,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
               kmag=kmag+1 !ix + iy
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:2,kmag)=-dipoles(1:2,imag)
               dipoles(3:6,kmag)=dipoles(3:6,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
             else if (ixsym.ne.0.and.izsym.ne.0) then
               kmag=kmag+1 !xsym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(1,kmag)=-dipoles(1,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               kmag=kmag+1 !zsym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(9:10,kmag)=dipoles(9:10,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(3,kmag)=-dipoles(3,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
               kmag=kmag+1 !ix + iz
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1,kmag)=-dipoles(1,imag)
               dipoles(2,kmag)=dipoles(2,imag)
               dipoles(3,kmag)=-dipoles(3,imag)
               dipoles(4,kmag)=dipoles(4,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               dipoles(6,kmag)=dipoles(6,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
             else if (iysym.ne.0.and.izsym.ne.0) then
               kmag=kmag+1 !ysym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(2,kmag)=-dipoles(2,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
               kmag=kmag+1 !zsym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(9:10,kmag)=dipoles(9:10,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(3,kmag)=-dipoles(3,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
               kmag=kmag+1 !iy + iz
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1,kmag)=dipoles(1,imag)
               dipoles(2,kmag)=-dipoles(2,imag)
               dipoles(3,kmag)=-dipoles(3,imag)
               dipoles(4,kmag)=dipoles(4,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               dipoles(6,kmag)=dipoles(6,imag)
               dipoles(7,kmag)=dipoles(7,imag)
             else if (ixsym.ne.0) then
               kmag=kmag+1 !xsym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(1,kmag)=-dipoles(1,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
             else if (iysym.ne.0) then
               kmag=kmag+1 !ysym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(2,kmag)=-dipoles(2,imag)
               dipoles(5,kmag)=-dipoles(5,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
             else if (izsym.ne.0) then
               kmag=kmag+1 !zsym
               dipoles(8,kmag)=dipoles(8,imag)
               dipoles(9:10,kmag)=dipoles(9:10,imag)
               dipoles(1:7,kmag)=dipoles(1:7,imag)
               dipoles(3,kmag)=-dipoles(3,imag)
               dipoles(7,kmag)=-dipoles(7,imag)
             endif
           endif !(nmag.ne.ndipoles) then

         enddo !nmag

      endif !ical

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      do idip=1,ndipoles
        if (dipoles(8,idip).lt.0.0d0) cycle
        call undumag_dipole_field(idip,xin,yin,zin,bx,by,bz,kfail)
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
      enddo !nmag

      if (kbextern.ne.0) then
        bxout=bxout+bxex
        byout=byout+byex
        bzout=bzout+bzex
      endif

      if (ncwires+nrace.gt.0) then
        call undumag_bcoils(xin,yin,zin,bx,by,bz,istat)
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
        if (istat.ne.0) kfail=kfail+1000
      endif

      return
      end
+DECK,undumag_bconv.
*CMZ :  1.25/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.02.37  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  16.59.02  by  Michael Scheer
*CMZ :  1.11/03 16/01/2017  12.22.22  by  Michael Scheer
*CMZ :  1.10/02 28/11/2016  13.27.01  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  11.48.57  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.01.00  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.48.27  by  Michael Scheer
*CMZ :  0.00/03 04/05/2016  08.41.15  by  Michael Scheer
*CMZ :  0.00/02 02/05/2016  10.21.48  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.20.09  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  10.22.45  by  Michael Scheer
*CMZ :  1.17/06 31/03/2016  09.26.44  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.16.01  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  18.38.48  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bconv(h)

      use bpolyederf90m
      use undumagf90m

      implicit none

      double precision h,hx,hy,hz
      integer mag,ix

      h=0.0d0

      do ix=1,nxconv
        hx=0.0d0
        hy=0.0d0
        hz=0.0d0
        do mag=1,nmag
          hx=hx+convmat(1,1,ix,mag)*bpebc(4,mag)
          hy=hy+convmat(2,1,ix,mag)*bpebc(5,mag)
          hz=hz+convmat(3,1,ix,mag)*bpebc(6,mag)
          hx=hx+convmat(1,2,ix,mag)*bpebc(4,mag)
          hy=hy+convmat(2,2,ix,mag)*bpebc(5,mag)
          hz=hz+convmat(3,2,ix,mag)*bpebc(6,mag)
          hx=hx+convmat(1,3,ix,mag)*bpebc(4,mag)
          hy=hy+convmat(2,3,ix,mag)*bpebc(5,mag)
          hz=hz+convmat(3,3,ix,mag)*bpebc(6,mag)
        enddo
        if (kbextern.ne.0) then
          hx=hx+bxex
          hy=hy+byex
          hz=hz+bzex
        endif
        if (ncwires.gt.0) then
          hx=hx+bxconvw(ix)
          hy=hy+byconvw(ix)
          hz=hz+bzconvw(ix)
        endif
        h=h+hx**2+hy**2+hz**2
      enddo

      h=sqrt(h/nxconv)

      return
      end
+DECK,undumag_bpolyeder11.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.01/08 14/08/2020  08.45.03  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.46.06  by  Michael Scheer
*CMZ :  1.15/02 31/03/2017  11.31.29  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  13.54.17  by  Michael Scheer
*CMZ :  1.14/00 17/03/2017  14.15.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  16.49.26  by  Michael Scheer
*CMZ :  1.13/02 08/03/2017  17.13.43  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  14.04.22  by  Michael Scheer
*CMZ :  1.11/03 16/01/2017  12.22.22  by  Michael Scheer
*CMZ :  1.11/00 13/12/2016  10.43.26  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.46.22  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.11.09  by  Michael Scheer
*CMZ :  0.00/13 08/08/2016  09.34.27  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  12.57.31  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.27  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.41.34  by  Michael Scheer
*CMZ :  1.17/11 06/04/2016  09.11.57  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.34.26  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  13.01.49  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  12.17.41  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bpolyeder11(imag,xin,yin,zin,bxout,byout,bzout,ifail)
c
c      Calculation of magnetic field of polyhedron according to
c      Oleb Chubar, Pascal Elleaume and Joel Chavanne
c      J. Synchrotron Rad. (1998) 5, 481-484
c
c Paper contains an error: The rotation matrix is wrong, since for nz=-1 the
c                          determinant is -1, which yields to errors??.


+seq,bpolyederf90u.
      use undumagf90m

      use commandlinef90m

      implicit none
+seq,seqdebug.
      double precision xin,yin,zin
     &  ,bxout,byout,bzout
      double precision r1(3),r2(3),dlab(3),blab(3)
      double precision ts(3,3),tsinv(3,3),bplan(3),bcvn,vnormlab(3)
      double precision xx,yy,zz,xxrot,yyrot,zzrot,xx00,xxsh
      double precision a,b,z,qx,qy,qz,qxp,qyp,qzp,qxm,qym,qzm,
     &  pi4inv,reverse,tiny2,
     &  bxm,bym,bzm,bxp,byp,bzp,xxm,yym,zzm,xxp,yyp,zzp,xx0,yy0,zz0,
     &  rr0,rrm
      double precision q(3,3),vmagrot(3),vmaglab(3),h(3),
     &  xr(2),yr(2),zr(2),dum,dume,pow,sqr

      double precision xmin,xmax,ymin,ymax,zmin,zmax,bx,by,bz

      parameter (pi4inv=0.0795774715459477d0)

      integer ical
      integer iout,itiny,iwtiny,jtiny
      integer imag,iplan,icorn,i,j,k,ip2,kwarn
      integer nx,ny,nz,ifail,ishim,ishima,iimag,nmag1,nmag2

      data ical/0/

      if (kudebug.eq.11) then
        write(lun6,*)"undumag_bpolyeder11 (kudebug=11):",imag,xin,yin,zin
      endif

      tiny2=tiny*tiny

      ifail=0

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

c      if (
c     &    xin.ge.outbox(1,1).and.xin.le.outbox(2,1)
c     &    .and.
c     &    yin.ge.outbox(1,2).and.yin.le.outbox(2,2)
c     &    .and.
c     &    zin.ge.outbox(1,3).and.zin.le.outbox(2,3)
c     &    ) return
			
      ifail=0

c calculate field at (xin,yin,zin)

      if (imag.eq.0) then
        write(lun6,*)'*** Error 1: undumag_bpolyeder11 called with imag=0! '
        stop
      endif !magmag.le.0

      if (bpebc(17,imag).lt.0.0d0) return

      xx=xin*1000.0d0
      xx00=xx
      yy=yin*1000.0d0
      zz=zin*1000.0d0

1     continue
      xxp=xx
      yyp=yy
      zzp=zz

      xx0=xx
      yy0=yy
      zz0=zz

      xxm=xx
      yym=yy
      zzm=zz

      itiny=0
      jtiny=0
      iwtiny=0

      q=0.0d0

      if (abs(xx00-bpebc(1,imag)).gt.window) goto 9999

      !non-zero magnetization and no virgin shim
      if (
     &    bpebc(7,imag).ne.0.0d0
     &    .and.bpebc(7,imag).ne.9999.0d0
     &    ) then

        if(bpebc(8,imag).eq.1) then !not rectangular nor cylindrical magnet

c check, if we are inside of magnet; we assume convex shape

          iout=-1
          inside=imag

          do iplan=1,ibpeplan(imag)

            dlab(1)=xx-bpemag(1,1,iplan,imag)
            dlab(2)=yy-bpemag(2,1,iplan,imag)
            dlab(3)=zz-bpemag(3,1,iplan,imag)

            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

            if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &          dlab(3)*vnormlab(3).gt.0.d0) then
              iout=1
              inside=0
              goto 97
            endif

          enddo !iplan

          if (iout.eq.-1) then
            kinside=imag
          endif !iout

97        continue

          do iplan=1,ibpeplan(imag)

            bcvn=-bpetm(1,7,iplan,imag)*pi4inv

            bplan(1)=0.d0
            bplan(2)=0.d0
            bplan(3)=0.d0

c transform everything to the nz=(0,0,1) system

            if (bcvn.eq.0.0d0) cycle

            if (ibpecorn(iplan,imag).gt.0) then

              ts(1:3,1:3)=bpetm(1:3,1:3,iplan,imag)
              tsinv(1:3,1:3)=bpetm(1:3,4:6,iplan,imag)
c              do i=1,3
c                do j=1,3
c                  ts(i,j)=bpetm(i,j,iplan,imag)
c                  tsinv(i,j)=bpetm(i,j+3,iplan,imag)
c                enddo
c              enddo

              xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
              yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
              zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

              do icorn=1,ibpecorn(iplan,imag)-1

                ip2=icorn+1

                r1(1)=bperot(1,icorn,iplan,imag)-xxrot
                r1(2)=bperot(2,icorn,iplan,imag)-yyrot
                r1(3)=bperot(3,icorn,iplan,imag)-zzrot

                r2(1)=bperot(1,ip2,iplan,imag)-xxrot
                r2(2)=bperot(2,ip2,iplan,imag)-yyrot
                r2(3)=bperot(3,ip2,iplan,imag)-zzrot

                if (abs(r1(1)-r2(1)).gt.tiny) then

                  a=(r2(2)-r1(2))/(r2(1)-r1(1))
                  b=r1(2)-a*r1(1)

                  if (abs(a).lt.tiny2) then
                    a=0.0d0
                    b=r1(2)
                  endif

                  z=r1(3)

                  call undumag_bpeq(r1(1),r2(1),a,b,z,qx,qy,qz,
     &              tiny,reverse,kwarn)

c                  if (bcvn.ne.0.0d0) then
                  if (
     &                qx.ne.qx.or.qy.ne.qy.or.qz.ne.qz
     &                .or.
     &                (kwarn.ne.0.and.kwarn.ne.6)) then
                    ifail=2
                    return
                  endif !qx,qy,qz,kwarn
c                    endif !bcvn

                  bplan(1)=bplan(1)-qx*bcvn
                  bplan(2)=bplan(2)-qy*bcvn
                  bplan(3)=bplan(3)-qz*bcvn

                endif
              enddo !icorn=1,ncorn

              blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
              blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
              blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

              if (
     &            blab(1).ne.blab(1)
     &            .or.
     &            blab(2).ne.blab(2)
     &            .or.
     &            blab(3).ne.blab(3)
     &            ) then
                write(lun6,*)"*** Error 3 in undumag_bpolyeder11: blab is not a number (NaN) ***"
                write(lun6,*)
     &            "imag,iplan,xin,yin,zin:",imag,iplan,xin,yin,zin
                write(lun6,*)"blab",blab
                write(lun6,*)"tsinv",tsinv
                stop
              endif

              bxout=bxout+blab(1)
              byout=byout+blab(2)
              bzout=bzout+blab(3)

            endif !ncorn

          enddo ! iplan=1,nplan

          if (iout.eq.-1) then
            kinside=imag
          endif !iout

        else !bpebc(8,imag) .eq. 1

c rectangular or cylindrical magnet
c check, if we are inside of magnet; we assume convex shape

          iout=-1
          inside=imag

          do iplan=1,ibpeplan(imag)

            dlab(1)=xx-bpemag(1,1,iplan,imag)
            dlab(2)=yy-bpemag(2,1,iplan,imag)
            dlab(3)=zz-bpemag(3,1,iplan,imag)

            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

            if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &          dlab(3)*vnormlab(3).gt.0.d0) then
              iout=1
              inside=0
              goto 911
            endif

          enddo !iplan

          if (iout.eq.-1) then
            kinside=imag
          endif !iout

911       continue

          vmaglab(1)=bpebc(4,imag)
          vmaglab(2)=bpebc(5,imag)
          vmaglab(3)=bpebc(6,imag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

          ts(1:3,1:3)=bpetm(1:3,1:3,1,imag)
          tsinv(1:3,1:3)=bpetm(1:3,4:6,1,imag)
c          do i=1,3
c            do j=1,3
c              ts(i,j)=bpetm(i,j,1,imag)
c              tsinv(i,j)=bpetm(i,j+3,1,imag)
c            enddo
c          enddo

          xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
          yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
          zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

          vmagrot(1)=
     &      ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
          vmagrot(2)=
     &      ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
          vmagrot(3)=
     &      ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

          xr(1)=bperot(1,1,1,imag)-xxrot
          xr(2)=bperot(1,2,1,imag)-xxrot
          yr(1)=bperot(2,1,1,imag)-yyrot
          yr(2)=bperot(2,3,1,imag)-yyrot
          zr(1)=bperot(3,1,1,imag)-zzrot
          zr(2)=bperot(3,1,3,imag)-zzrot

          if (abs(xr(2)-xr(1)).lt.tiny) then
c            write(lun6,*)'*** Error 4 in undumag_bpolyeder11: abs(xr(2)-xr(1)).lt.tiny'
c            write(lun6,*)imag,xx,yy,zz
c            stop
            kwarn=7
          endif

          if (abs(yr(2)-yr(1)).lt.tiny) then
c            write(lun6,*)'*** Error 5 in undumag_bpolyeder11 abs(yr(2)-yr(1)).lt.tiny'
c            write(lun6,*)imag,xx,yy,zz
c            stop
            kwarn=8
          endif

          if (abs(zr(2)-zr(1)).lt.tiny) then
c            write(lun6,*)'*** Error 6 in undumag_bpolyeder11 abs(zr(2)-zr(1)).lt.tiny'
c            write(lun6,*)imag,xx,yy,zz
c            stop
            kwarn=9
          endif

          q(1,1)=0.0d0
          q(2,2)=0.0d0
          q(3,3)=0.0d0

          q(1,2)=1.0d0
          q(1,3)=1.0d0
          q(2,3)=1.0d0

          if (xr(1).eq.0.0d0) xr(1)=1.0d-15
          if (xr(2).eq.0.0d0) xr(2)=1.0d-15
          if (yr(1).eq.0.0d0) yr(1)=1.0d-15
          if (yr(2).eq.0.0d0) yr(2)=1.0d-15
          if (zr(1).eq.0.0d0) zr(1)=1.0d-15
          if (zr(2).eq.0.0d0) zr(2)=1.0d-15

c          if (xr(1).eq.0.0d0.or.yr(1).eq.0.0d0.or.zr(1).eq.0.0d0
c     &        .or.xr(2).eq.0.0d0.or.yr(2).eq.0.0d0.or.zr(2).eq.0.0d0
c     &        ) then
c            xx=xx+tiny2
c            yy=yy+tiny2
c            zz=zz+tiny2
c            goto 1
c          endif

          do i=1,2
            do j=1,2
              do k=1,2

                pow=dble((-1)**(i+j+k+1))
                sqr=sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
                if (sqr.eq.0.0d0) then
                  write(lun6,*)"*** Error 7 in undumag_bpolyeder11: sqrt 0 "
                  stop
                endif

                q(1,1)=q(1,1)+pow*
c     &            (-1)**(i+j+k+1)*
     &            atan(
     &            yr(j)/xr(i)*zr(k)/sqr
c     &            sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
     &            )

                sqr=sqrt(yr(i)**2+xr(j)**2+zr(k)**2)
                if (sqr.eq.0.0d0) then
                  write(lun6,*) "*** Error 8 in undumag_bpolyeder11: sqr 0"
                  stop
                endif

                q(2,2)=q(2,2)+pow*
c     &            (-1)**(i+j+k+1)*
     &            atan(
     &            xr(j)/yr(i)*zr(k)/sqr
c     &            sqrt(yr(i)**2+xr(j)**2+zr(k)**2)
     &            )

                sqr=sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
                if (sqr.eq.0.0d0) then
                  write(lun6,*)"*** Error 9 in undumag_bpolyeder11: sqr 0"
                  stop
                endif

                q(3,3)=q(3,3)+pow*
c     &            (-1)**(i+j+k+1)*
     &            atan(
     &            yr(j)/zr(i)*xr(k)/sqr
c     &            sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
     &            )

                dum=zr(k)+sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
                dume=(-1.0d0)**(i+j+k)

                if (dum.ne.0.0d0) then
                  if (dume.gt.0.0d0) then
                    q(1,2)=q(1,2)*dum
                  else
                    q(1,2)=q(1,2)/dum
                  endif
                endif

                dum=yr(k)+sqrt(xr(i)**2+zr(j)**2+yr(k)**2)
                if (dum.ne.0.0d0) then
                  if (dume.gt.0.0d0) then
                    q(1,3)=q(1,3)*dum
                  else
                    q(1,3)=q(1,3)/dum
                  endif
                endif

                dum=xr(k)+sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
                if (dum.ne.0.0d0) then
                  if (dume.gt.0.0d0) then
                    q(2,3)=q(2,3)*dum
                  else
                    q(2,3)=q(2,3)/dum
                  endif
                endif

              enddo !k
            enddo !j
          enddo !i

          q(1,2)=log(q(1,2))
          q(1,3)=log(q(1,3))
          q(2,3)=log(q(2,3))

          q(2,1)=q(1,2)
          q(3,1)=q(1,3)
          q(3,2)=q(2,3)

          h(1)=
     &      -(q(1,1)*vmagrot(1)+q(1,2)*vmagrot(2)+q(1,3)*vmagrot(3))*
     &      pi4inv
          h(2)=
     &      -(q(2,1)*vmagrot(1)+q(2,2)*vmagrot(2)+q(2,3)*vmagrot(3))*
     &      pi4inv
          h(3)=
     &      -(q(3,1)*vmagrot(1)+q(3,2)*vmagrot(2)+q(3,3)*vmagrot(3))*
     &      pi4inv

          bplan(1)=h(1)
          bplan(2)=h(2)
          bplan(3)=h(3)

          if (
     &        bplan(1).ne.bplan(1)
     &        .or.
     &        bplan(2).ne.bplan(2)
     &        .or.
     &        bplan(3).ne.bplan(3)
     &        ) then
            write(lun6,*)"*** Error 10 in undumag_bpolyeder11: bplan is not a number (NaN) ***"
            write(lun6,*)
     &        "imag,xin,yin,zin:",imag,xin,yin,zin
            stop
          endif

          blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
          blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
          blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

          if (
     &        blab(1).ne.blab(1)
     &        .or.
     &        blab(2).ne.blab(2)
     &        .or.
     &        blab(3).ne.blab(3)
     &        ) then
            write(lun6,*)"*** Error 11 in undumag_bpolyeder11: blab is not a number (NaN) ***"
            write(lun6,*)
     &        "imag,xin,yin,zin:",imag,xin,yin,zin
            stop
          endif

          bxout=bxout+blab(1)
          byout=byout+blab(2)
          bzout=bzout+blab(3)

          if (iout.eq.-1) then
            kinside=imag
          endif !iout

        endif !(bpebc(8,imag).eq.1)

      endif !non-zero magnetization

9999  continue



      return
      end
+DECK,undumag_bpolyeder_corr.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.01/03 15/07/2019  11.55.46  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  13.35.13  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.55.33  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  08.44.13  by  Michael Scheer
*CMZ :  1.15/11 20/04/2017  16.01.40  by  Michael Scheer
*CMZ :  1.15/03 02/04/2017  15.55.59  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  17.59.10  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  13.53.21  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.31.38  by  Michael Scheer
*CMZ :  1.11/03 16/01/2017  12.22.22  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  09.47.59  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.07/00 23/09/2016  09.19.06  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.10.51  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.27.23  by  Michael Scheer
*CMZ :  0.00/13 28/07/2016  16.09.29  by  Michael Scheer
*CMZ :  0.00/09 06/07/2016  08.42.18  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  13.18.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.13  by  Michael Scheer
*CMZ :  0.00/01 25/04/2016  16.03.15  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.41.34  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  09.46.51  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  13.27.16  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.31.31  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  13.53.25  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  10.43.50  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  18.38.48  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bpolyeder_corr(xin,yin,zin,bxout,byout,bzout,ifail)
c
c      Calculation of magnetic field of polyhedron according to
c      Oleb Chubar, Pascal Elleaume and Joel Chavanne
c      J. Synchrotron Rad. (1998) 5, 481-484
c
c Paper contains an error: The rotation matrix is wrong, since for nz=-1 the
c                          determinant is -1, which yields to errors??.
+self,if=omp.
      use omp_lib
+self.
      use bpolyederf90m
      use undumagf90m

      use commandlinef90m

      implicit none
+seq,seqdebug.

      double precision xin,yin,zin,bxout,byout,bzout
      double precision r1(3),r2(3),dlab(3),blab(3)
      double precision ts(3,3),tsinv(3,3),bplan(3),bcvn,vnormlab(3)
      double precision xx,yy,zz,xxrot,yyrot,zzrot,xx00,xxsh
      double precision a,b,z,qx,qy,qz,qxp,qyp,qzp,qxm,qym,qzm,
     &  pi4inv,reverse,tiny2,
     &  bxm,bym,bzm,bxp,byp,bzp,rr0,rrm
      double precision q(3,3),vmagrot(3),vmaglab(3),h(3),
     &  xr(2),yr(2),zr(2),dum,dume,bo(3,nthreadp)

      double precision xmin,xmax,ymin,ymax,zmin,zmax,bx,by,bz

      parameter (pi4inv=0.0795774715459477d0)

      integer ical,kc
      integer itiny,iwtiny,jtiny
      integer imag,iplan,icorn,i,j,k,ip2,kwarn,ic
      integer nx,ny,nz,ifail,ishim,ishima,iimag,nmag1,nmag2,iout,
     &  kfail(nthreadp),kinsidelocal(nthreadp)

      integer nmaxth,ith

      save bo,nmaxth,ith,ical,kinsidelocal

      data ical/0/

      if (magmag.gt.0) then
        write(lun6,*)"*** Error: Call to undumag_bpolyeder_corr in undumag_bpolyeder_corr!"
        stop
      endif

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      tiny2=tiny*tiny

      ifail=0

c calculate field at (xin,yin,zin)

      if (magmag.lt.0) then
        return
      endif !magmag.le.0

c      if (xin.eq.0.0d0) return
      xx=xin*1000.0d0
      yy=yin*1000.0d0
      zz=zin*1000.0d0

      itiny=0
      jtiny=0
      iwtiny=0

      if (ical.eq.0) then
        nmaxth=1
        ith=1
+self,if=omp.
        nmaxth=nthreads
        nmaxth=OMP_GET_MAX_THREADS()
        if (nthreads.gt.0) nmaxth=min(nmaxth,nthreads,nthreadp)
        write(lun6,*)"Number of CPU cores used:",nmaxth
+self.
        bo=0.0d0
        ical=1
      endif

c      ical=ical+1
c      write(lun6,*)"eder",ical,nmaxth
      bo=0.0d0
      kinsidelocal=kinside
      kfail=0

+self,if=omp.
!$OMP PARALLEL NUM_THREADS(nmaxth) DEFAULT(PRIVATE) SHARED(kfail,iseqdebug,kinsidelocal,ical,bpetm,window,bpebc,bpemag,ibpeplan,ibpecorn,bperot,bo,iwarnbound,nwarnbound) FIRSTPRIVATE(nmag,itiny,jtiny,iwtiny,tiny,xx,yy,zz)
c      if (ical.eq.4) stop
      ith=OMP_GET_THREAD_NUM()+1
      bo(1:3,ith)=0.0d0
!$OMP DO
+self.
      do imag=1,nmag

        if (bpebc(17,imag).lt.0.0d0) then
          cycle
        endif

        if (abs(xx-bpebc(1,imag)).le.window) then

          !non-zero magnetization and no virgin shim
          if (bpebc(7,imag).ne.0.0d0.and.bpebc(7,imag).ne.9999.) then

            if(bpebc(8,imag).eq.1) then !not rectangular nor cylindrical magnet

c check, if we are inside of magnet; we assume convex shape
              if (kinsidelocal(ith).ne.-1) then

                iout=-1

                do iplan=1,ibpeplan(imag)

                  dlab(1)=xx-bpemag(1,1,iplan,imag)
                  dlab(2)=yy-bpemag(2,1,iplan,imag)
                  dlab(3)=zz-bpemag(3,1,iplan,imag)

                  vnormlab(1)=bpetm(1,8,iplan,imag)
                  vnormlab(2)=bpetm(2,8,iplan,imag)
                  vnormlab(3)=bpetm(3,8,iplan,imag)

                  if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &                dlab(3)*vnormlab(3).gt.0.d0) then
                    iout=1
                    goto 97
                  endif

                enddo !iplan

                if (iout.eq.-1) then
                  kinsidelocal(ith)=imag
                endif !iout

97              continue
              endif !inside?

              do iplan=1,ibpeplan(imag)

                bcvn=-bpetm(1,7,iplan,imag)*pi4inv
c                write(lun6,*)"undumag_bpolyeder_corr:",imag,iplan,bpetm(1,7,iplan,imag)

                bplan(1)=0.d0
                bplan(2)=0.d0
                bplan(3)=0.d0

c transform everything to the nz=(0,0,1) system

c                if (iseqdebug.ne.0) write(lun6,*)"bcvn:",bcvn
                if (bcvn.eq.0.0d0) cycle

                if (ibpecorn(iplan,imag).gt.0) then

                  ts(1:3,1:3)=bpetm(1:3,1:3,iplan,imag)
                  tsinv(1:3,1:3)=bpetm(1:3,4:6,iplan,imag)

c                  do i=1,3
c                    do j=1,3
c                      ts(i,j)=bpetm(i,j,iplan,imag)
c                      tsinv(i,j)=bpetm(i,j+3,iplan,imag)
c                    enddo
c                  enddo

                  xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
                  yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
                  zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

                  do icorn=1,ibpecorn(iplan,imag)-1

                    ip2=icorn+1

                    r1(1)=bperot(1,icorn,iplan,imag)-xxrot
                    r1(2)=bperot(2,icorn,iplan,imag)-yyrot
                    r1(3)=bperot(3,icorn,iplan,imag)-zzrot

                    r2(1)=bperot(1,ip2,iplan,imag)-xxrot
                    r2(2)=bperot(2,ip2,iplan,imag)-yyrot
                    r2(3)=bperot(3,ip2,iplan,imag)-zzrot

                    if (abs(r1(1)-r2(1)).gt.tiny) then

                      a=(r2(2)-r1(2))/(r2(1)-r1(1))
                      b=r1(2)-a*r1(1)

                      if (abs(a).lt.tiny2) then
                        a=0.0d0
                        b=r1(2)
                      endif

                      z=r1(3)
                      kwarn=0

                      call undumag_bpeq(r1(1),r2(1),a,b,z,qx,qy,qz,
     &                  tiny,reverse,kwarn)

c                      if (bcvn.ne.0.0d0) then
                      if (qx.ne.qx.or.qy.ne.qy.or.qz.ne.qz
     &                    .or.
     &                    (kwarn.ne.0.and.kwarn.ne.6)) then
                        kfail(ith)=imag
                        goto 799
                      endif !qx,qy,qz, kwarn

                      bplan(1)=bplan(1)-qx*bcvn
                      bplan(2)=bplan(2)-qy*bcvn
                      bplan(3)=bplan(3)-qz*bcvn
c                      endif !bcvn

                    endif
                  enddo !icorn=1,ncorn

                  blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
                  blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
                  blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

                  if (
     &                blab(1).ne.blab(1)
     &                .or.
     &                blab(2).ne.blab(2)
     &                .or.
     &                blab(3).ne.blab(3)
     &                ) then
                    write(lun6,*)"*** Error 3 in undumag_bpolyeder_corr: blab is not a number (NaN) ***"
                    write(lun6,*)
     &                "imag,iplan,xin,yin,zin:",imag,iplan,xin,yin,zin
                    write(lun6,*)"blab",blab
                    write(lun6,*)"tsinv",tsinv
                    stop
                  endif
                  bo(1,ith)=bo(1,ith)+blab(1)
                  bo(2,ith)=bo(2,ith)+blab(2)
                  bo(3,ith)=bo(3,ith)+blab(3)
                endif !ncorn

              enddo ! iplan=1,nplan

            else !bpebc(8,imag) .eq. 1

              if (kinsidelocal(ith).ne.-1) then

                iout=-1

                do iplan=1,ibpeplan(imag)

                  dlab(1)=xx-bpemag(1,1,iplan,imag)
                  dlab(2)=yy-bpemag(2,1,iplan,imag)
                  dlab(3)=zz-bpemag(3,1,iplan,imag)

                  vnormlab(1)=bpetm(1,8,iplan,imag)
                  vnormlab(2)=bpetm(2,8,iplan,imag)
                  vnormlab(3)=bpetm(3,8,iplan,imag)

c                  write(lun6,*)"x,dlab:",xx,dlab
c                  write(lun6,*)"vnormlablab:",vnormlab
                  if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &                dlab(3)*vnormlab(3).gt.0.d0) then
                    iout=1
                    goto 911
                  endif

                enddo !iplan

                if (iout.eq.-1) then
                  kinsidelocal(ith)=imag
                endif !iout

911             continue
              endif !inside?

c rectangular or cylindrical magnet
              vmaglab(1:3)=bpebc(4:6,imag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

              ts(1:3,1:3)=bpetm(1:3,1:3,1,imag)
              tsinv(1:3,1:3)=bpetm(1:3,4:6,1,imag)

              xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
              yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
              zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

              vmagrot(1)=
     &          ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
              vmagrot(2)=
     &          ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
              vmagrot(3)=
     &          ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

              xr(1)=bperot(1,1,1,imag)-xxrot
              xr(2)=bperot(1,2,1,imag)-xxrot
              yr(1)=bperot(2,1,1,imag)-yyrot
              yr(2)=bperot(2,3,1,imag)-yyrot
              zr(1)=bperot(3,1,1,imag)-zzrot
              zr(2)=bperot(3,1,3,imag)-zzrot

              if (xr(1).eq.0.0d0) xr(1)=1.0d-15
              if (xr(2).eq.0.0d0) xr(2)=1.0d-15
              if (yr(1).eq.0.0d0) yr(1)=1.0d-15
              if (yr(2).eq.0.0d0) yr(2)=1.0d-15
              if (zr(1).eq.0.0d0) zr(1)=1.0d-15
              if (zr(2).eq.0.0d0) zr(2)=1.0d-15

              q=0.0d0

              q(1,2)=1.0d0
              q(1,3)=1.0d0
              q(2,3)=1.0d0

c              if (xr(1).eq.0.0d0.or.yr(1).eq.0.0d0.or.zr(1).eq.0.0d0
c     &            .or.xr(2).eq.0.0d0.or.yr(2).eq.0.0d0.or.zr(2).eq.0.0d0
c     &            ) then
c                xx=xx+tiny2
cc                yy=yy+tiny2
c                zz=zz+tiny2
c                goto 1
c              endif

              do i=1,2
                do j=1,2
                  do k=1,2
                    q(1,1)=q(1,1)+
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                yr(j)/xr(i)*zr(k)/
     &                sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
     &                )

                    q(2,2)=q(2,2)+
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                xr(j)/yr(i)*zr(k)/
     &                sqrt(yr(i)**2+xr(j)**2+zr(k)**2)
     &                )

                     dum=
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                yr(j)/zr(i)*xr(k)/
     &                sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
     &                )
                    q(3,3)=q(3,3)+dum
c                    write(lun6,*)"--- imag,zzrot",imag,zzrot
c                    write(lun6,*)"i,j,k",i,j,k,xr(k),yr(j),zr(i)
c                    write(lun6,*)"xx,dum,q33",xx,dum,q(3,3)

                    dum=zr(k)+sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
                    dume=(-1.0d0)**(i+j+k)

                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(1,2)=q(1,2)*dum
                      else
                        q(1,2)=q(1,2)/dum
                      endif
                    endif

                    dum=yr(k)+sqrt(xr(i)**2+zr(j)**2+yr(k)**2)
                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(1,3)=q(1,3)*dum
                      else
                        q(1,3)=q(1,3)/dum
                      endif
                    endif

                    dum=xr(k)+sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(2,3)=q(2,3)*dum
                      else
                        q(2,3)=q(2,3)/dum
                      endif
                    endif

                  enddo !k
                enddo !j
              enddo !i

              q(1,2)=log(q(1,2))
              q(1,3)=log(q(1,3))
              q(2,3)=log(q(2,3))

              q(2,1)=q(1,2)
              q(3,1)=q(1,3)
              q(3,2)=q(2,3)

              h(1)=
     &          -(q(1,1)*vmagrot(1)+q(1,2)*vmagrot(2)+q(1,3)*vmagrot(3))*
     &          pi4inv
              h(2)=
     &          -(q(2,1)*vmagrot(1)+q(2,2)*vmagrot(2)+q(2,3)*vmagrot(3))*
     &          pi4inv
              h(3)=
     &          -(q(3,1)*vmagrot(1)+q(3,2)*vmagrot(2)+q(3,3)*vmagrot(3))*
     &          pi4inv

              bplan(1)=h(1)
              bplan(2)=h(2)
              bplan(3)=h(3)

c              write(lun6,*)"h============================:",h

              blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
              blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
              blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

              bo(1,ith)=bo(1,ith)+blab(1)
              bo(2,ith)=bo(2,ith)+blab(2)
              bo(3,ith)=bo(3,ith)+blab(3)

            endif !(bpebc(8,imag).eq.1)

          endif !non-zero magnetization

c        write(lun6,'(3g15.5)'),xin,imag,imag,bo(2,ith)

        endif !window
799     continue
      enddo !imag=1,nmag
+self,if=omp.
!$OMP END DO
!$OMP END PARALLEL
+self.

9999  continue


      do ic=1,nmaxth
        ifail=ifail+kfail(ic)
        bxout=bxout+bo(1,ic)
        byout=byout+bo(2,ic)
        bzout=bzout+bo(3,ic)
      enddo

      if (kinside.ne.-1) then
        kinside=0
        do ic=1,nmaxth
          kinside=kinside+kinsidelocal(ic)
          if (kinsidelocal(ic).ne.0) then
            do kc=1,nmaxth
              if (kc.eq.ic) cycle
              if (kinsidelocal(kc).ne.0) then
                write(lun6,*)kinsidelocal
              endif
            enddo
          endif
        enddo
      endif

      if (bxout.ne.bxout.or.byout.ne.byout.or.bzout.ne.bzout
     &  .or.bxout.gt.1.0d30
     &  .or.byout.gt.1.0d30
     &    .or.bzout.gt.1.0d30) then
        bxout=0.0d0
        byout=0.0d0
        bzout=0.0d0
        ifail=-1
      endif

      if (abs(bxout).le.1.0d-15) bxout=0.0d0
      if (abs(byout).le.1.0d-15) byout=0.0d0
      if (abs(bzout).le.1.0d-15) bzout=0.0d0

c      if (ical.gt.2) stop

      return
      end
+DECK,undumag_bpolyint.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  09.10.57  by  Michael Scheer
*CMZ :  1.17/08 24/05/2017  15.33.47  by  Michael Scheer
*CMZ :  1.17/07 23/05/2017  15.39.11  by  Michael Scheer
*CMZ :  1.17/02 08/03/2016  16.00.02  by  Michael Scheer
*CMZ :  1.15/01 24/04/2008  11.51.05  by  Michael Scheer
*CMZ :  1.15/00 26/10/2007  13.11.55  by  Michael Scheer
*CMZ :  1.12/16 01/06/2007  11.17.50  by  Michael Scheer
*CMZ :  1.12/02 14/07/2005  10.19.00  by  Michael Scheer
*CMZ :  1.10/03 19/08/2004  15.32.19  by  Michael Scheer
*CMZ :  1.10/02 19/08/2004  14.03.28  by  Michael Scheer
*CMZ :  1.10/01 17/08/2004  14.15.54  by  Michael Scheer
*CMZ :  2.00/00 17/08/2004  09.38.52  by  Michael Scheer
*CMZ :  1.02/02 11/08/2004  09.13.49  by  Michael Scheer
*CMZ :  1.02/01 09/08/2004  14.45.40  by  Michael Scheer
*CMZ :  1.02/00 28/07/2004  16.57.47  by  Michael Scheer
*-- Author :    Michael Scheer   27/07/2004
      subroutine undumag_bpolyint(imag,xint,yint,zint,
     &  vxint,vyint,vzint,
     &  bxint,byint,bzint,ifail)

c Literature: Elleaume, Chubar, Chavanne PAC97
c             Computing 3D Magnetic Fields form Insertion Devices

c calculates first magnetic integral for line defined by point
c      (xint,yint,zint) and vector (vxint,vyint,vzint)
c restrictions:
c     rectangular magnets only
c     line of integrations parallel to axis of block and block aligned to
c     axis of coordinate system (paper gives formulas for general
c     case of integration direction (not coded here))

c xint,yint,zint given in meter
c bxint,byint,bzint given in Tm

+seq,bpolyederf90u.
      use undumagf90m

      use commandlinef90m

      implicit none

+seq,bpolyeder,if=static.

      double precision xint,yint,zint,vxint,vyint,vzint,vnx,vny,vnz,vn,
     &  bxint,byint,bzint,
     &  vnxrot,vnyrot,vnzrot,
     &  vnxrota,vnyrota,vnzrota,
     &  xr(2),yr(2),zr(2),ts(3,3),
     &  tsinv(3,3),w(3),x12,x22,z12,z22,y12,y22

      double precision g(3,3),vmagrot(3),vmaglab(3),bint1(3),xxrot,yyrot,zzrot,
     &  xxint,yyint,zzint,tiny2,pi2inv,pi4inv,
     &  xmin,xmax,ymin,ymax,zmin,zmax,
     &  dlab(3),vnormlab(3)

      parameter (pi2inv=0.159154943091895d0)
      parameter (pi4inv=0.0795774715459477d0)

      integer ical,iwarn1
      integer kmag,i,k,nx,ny,nz,ifail,iout,imag
      integer iplan,ishim,ishima,nmag1,nmag2

      data ical/0/
      data iwarn1/0/

      if (imag.le.0) then
        write(lun6,*)'*** Error in undumag_bpolyint: Called with imag=0 ***'
        stop
      endif

      tiny2=tiny*tiny

      bxint=0.d0
      byint=0.d0
      bzint=0.d0

      ifail=-1

      if (
     &    xint.ge.outbox(1,1).and.xint.le.outbox(2,1)
     &    .and.
     &    yint.ge.outbox(1,2).and.yint.le.outbox(2,2)
     &    .and.
     &    zint.ge.outbox(1,3).and.zint.le.outbox(2,3)
     &    ) return

      ifail=0

      xxint=xint*1000.0d0
      yyint=yint*1000.0d0
      zzint=zint*1000.0d0

      vn=sqrt(vxint*vxint+vyint*vyint+vzint*vzint)

      vnx=vxint/vn
      vny=vyint/vn
      vnz=vzint/vn

      if (bpebc(7,imag).eq.0.0d0) return

      if(bpebc(8,imag).ne.-6.and.bpebc(8,imag).ne.-7) then !not rectangular magnet

        if (iwarn1.eq.0) then
          iwarn1=1
          write(lun6,*)'*** Warning in undumag_bpolyint: Non-rectangular magnet!'
          write(lun6,*)'***                      not yet implemented!'
          write(lun6,*)'***                      zero result returned'
          write(lun6,*)'*** FURTHER WARNINGS SUPPRESSED!!'
        endif !iwarn1

        ifail=-11

        return

      else !bpebc(8,imag).ne.-6

        iout=-1
        inside=1

        do iplan=1,ibpeplan(imag)

          dlab(1)=xxint-bpemag(1,1,iplan,imag)
          dlab(2)=yyint-bpemag(2,1,iplan,imag)
          dlab(3)=zzint-bpemag(3,1,iplan,imag)

          vnormlab(1)=bpetm(1,8,iplan,imag)
          vnormlab(2)=bpetm(2,8,iplan,imag)
          vnormlab(3)=bpetm(3,8,iplan,imag)

          if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &        dlab(3)*vnormlab(3).gt.0.d0) then
            iout=1
            inside=0
            goto 91
          endif

        enddo !iplan

        if (iout.ne.1) then
          ifail=3
          return
        endif

91      vmaglab(1)=bpebc(4,imag)
        vmaglab(2)=bpebc(5,imag)
        vmaglab(3)=bpebc(6,imag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

        do i=1,3
          do k=1,3
            ts(i,k)=bpetm(i,k,1,imag)
            tsinv(i,k)=bpetm(i,k+3,1,imag)
          enddo
        enddo

        xxrot=ts(1,1)*xxint+ts(1,2)*yyint+ts(1,3)*zzint
        yyrot=ts(2,1)*xxint+ts(2,2)*yyint+ts(2,3)*zzint
        zzrot=ts(3,1)*xxint+ts(3,2)*yyint+ts(3,3)*zzint

        vnxrot=ts(1,1)*vnx+ts(1,2)*vny+ts(1,3)*vnz
        vnyrot=ts(2,1)*vnx+ts(2,2)*vny+ts(2,3)*vnz
        vnzrot=ts(3,1)*vnx+ts(3,2)*vny+ts(3,3)*vnz

        vnxrota=abs(vnxrot)
        vnyrota=abs(vnyrot)
        vnzrota=abs(vnzrot)

        vmagrot(1)=
     &    ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
        vmagrot(2)=
     &    ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
        vmagrot(3)=
     &    ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

c dimensions of magnet

        w(1)=bperot(1,1,1,imag)-bperot(1,2,1,imag)
        w(2)=bperot(2,1,1,imag)-bperot(2,3,1,imag)
        w(3)=bperot(3,1,1,imag)-bperot(3,1,3,imag)

c distances from considered point to corners of magnet

        xr(1)=bperot(1,1,1,imag)-xxrot
        xr(2)=bperot(1,2,1,imag)-xxrot
        yr(1)=bperot(2,1,1,imag)-yyrot
        yr(2)=bperot(2,3,1,imag)-yyrot

        zr(1)=bperot(3,1,1,imag)-zzrot
        zr(2)=bperot(3,1,3,imag)-zzrot

        g=0.0d0

        if (vnxrota.lt.tiny2.and.vnyrota.lt.tiny2) then

          if (abs(xr(1)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: xr(1) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'xr(1)',xr(1)
            if (xr(1).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              xr(1)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              xr(1)=tiny2
            endif
            ifail=1
          endif


          if (abs(xr(2)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: xr(2) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'xr(2)',xr(2)
            if (xr(2).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              xr(2)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              xr(2)=tiny2
            endif
            ifail=1
          endif

          if (abs(yr(1)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: yr(1) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'yr(1)',yr(1)
            if (yr(1).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              yr(1)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              yr(1)=tiny2
            endif
            ifail=1
          endif

          if (abs(yr(2)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: yr(2) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'yr(2)',yr(2)
            if (yr(2).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              yr(2)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              yr(2)=tiny2
            endif
            ifail=1
          endif

          do i=1,2
            do k=1,2
              g(1,1)=g(1,1)+(-1)**(i+k)*atan(xr(i)/yr(k))
              g(2,2)=g(2,2)+(-1)**(i+k)*atan(yr(k)/xr(i))
            enddo !k
          enddo !i

          x12=xr(1)*xr(1)
          x22=xr(2)*xr(2)
          y12=yr(1)*yr(1)
          y22=yr(2)*yr(2)

          g(1,2)=w(3)*pi4inv*log((x12+y22)*(x22+y12)/((x12+y12)*(x22+y22)))
     &          *0.001d0 !Tmm -> Tm
          g(2,1)=g(1,2)

          g(1,1)=g(1,1)*w(3)*pi2inv
     &          *0.001d0 !Tmm -> Tm
          g(2,2)=g(2,2)*w(3)*pi2inv
     &          *0.001d0 !Tmm -> Tm

        else if (vnxrota.lt.tiny2.and.vnzrota.lt.tiny2) then

          if (abs(xr(1)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: xr(1) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'xr(1)',xr(1)
            if (xr(1).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              xr(1)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              xr(1)=tiny2
            endif
            ifail=1
          endif

          if (abs(xr(2)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: xr(2) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'xr(2)',xr(2)
            if (xr(2).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              xr(2)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              xr(2)=tiny2
            endif
            ifail=1
          endif

          if (abs(zr(1)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: zr(1) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'zr(1)',zr(1)
            if (zr(1).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              zr(1)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              zr(1)=tiny2
            endif
            ifail=1
          endif

          if (abs(zr(2)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: zr(2) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'zr(2)',zr(2)
            if (zr(2).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              zr(2)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              zr(2)=tiny2
            endif
            ifail=1
          endif

          do i=1,2
            do k=1,2
              g(1,1)=g(1,1)+(-1)**(i+k)*atan(xr(i)/zr(k))
              g(3,3)=g(3,3)+(-1)**(i+k)*atan(zr(k)/xr(i))
            enddo !k
          enddo !i

          x12=xr(1)*xr(1)
          x22=xr(2)*xr(2)
          z12=zr(1)*zr(1)
          z22=zr(2)*zr(2)

          g(1,3)=w(2)*pi4inv*log((x12+z22)*(x22+z12)/((x12+z12)*(x22+z22)))
     &          *0.001d0 !Tmm -> Tm
          g(3,1)=g(1,3)

          g(1,1)=g(1,1)*w(2)*pi2inv
     &          *0.001d0 !Tmm -> Tm
          g(3,3)=g(3,3)*w(2)*pi2inv
     &          *0.001d0 !Tmm -> Tm

        else if (vnyrota.lt.tiny2.and.vnzrota.lt.tiny2) then

          if (abs(yr(1)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: yr(1) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'yr(1)',yr(1)
            if (yr(1).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              yr(1)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              yr(1)=tiny2
            endif
            ifail=1
          endif

          if (abs(yr(2)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: yr(2) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'yr(2)',yr(2)
            if (yr(2).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              yr(2)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              yr(2)=tiny2
            endif
            ifail=1
          endif

          if (abs(zr(1)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: zr(1) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'zr(1)',zr(1)
            if (zr(1).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              zr(1)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              zr(1)=tiny2
            endif
            ifail=1
          endif

          if (abs(zr(2)).lt.tiny2) then
            write(lun6,*)'Warning in undumag_bpolyint: zr(2) too small'
            write(lun6,*)'magnet:',imag
            write(lun6,*)'zr(2)',zr(2)
            if (zr(2).lt.0.0d0) then
              write(lun6,*)'Set to',-tiny2
              zr(2)=-tiny2
            else
              write(lun6,*)'Set to',tiny2
              zr(2)=tiny2
            endif
            ifail=1
          endif

          do i=1,2
            do k=1,2
              g(2,2)=g(2,2)+(-1)**(i+k)*atan(yr(i)/zr(k))
              g(3,3)=g(3,3)+(-1)**(i+k)*atan(zr(k)/yr(i))
            enddo !k
          enddo !i

          y12=yr(1)*yr(1)
          y22=yr(2)*yr(2)
          z12=zr(1)*zr(1)
          z22=zr(2)*zr(2)

          g(2,3)=w(1)*pi4inv*log((y12+z22)*(y22+z12)/((y12+z12)*(y22+z22)))
     &          *0.001d0 !Tmm -> Tm
          g(3,2)=g(2,3)

          g(2,2)=g(2,2)*w(1)*pi2inv
     &          *0.001d0 !Tmm -> Tm
          g(3,3)=g(3,3)*w(1)*pi2inv
     &          *0.001d0 !Tmm -> Tm

        else ! vnxrot,vnyrot,vnzot parallel to an axis

          write(lun6,*)'*** Warning in undumag_bpolyint:'
          write(lun6,*)
     &      '*** line of integration not parallel to axis of coord.-system!'
          write(lun6,*)'*** not yet implemented!'
          write(lun6,*)'*** zero result returned'
          ifail=2
          return

        endif ! vnxrot,vnyrot,vnzrot parallel to an axis

        bint1(1)=(g(1,1)*vmagrot(1)+g(1,2)*vmagrot(2)+g(1,3)*vmagrot(3))
        bint1(2)=(g(2,1)*vmagrot(1)+g(2,2)*vmagrot(2)+g(2,3)*vmagrot(3))
        bint1(3)=(g(3,1)*vmagrot(1)+g(3,2)*vmagrot(2)+g(3,3)*vmagrot(3))

        bxint=tsinv(1,1)*bint1(1)+tsinv(1,2)*bint1(2)+tsinv(1,3)*bint1(3)
        byint=tsinv(2,1)*bint1(1)+tsinv(2,2)*bint1(2)+tsinv(2,3)*bint1(3)
        bzint=tsinv(3,1)*bint1(1)+tsinv(3,2)*bint1(2)+tsinv(3,3)*bint1(3)

      endif !(bpebc(8,imag).eq.1)

      return
      end
+DECK,undumag_parameter.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  1.25/00 08/03/2018  14.12.29  by  Michael Scheer
*CMZ :  1.22/00 04/07/2017  10.31.41  by  Michael Scheer
*CMZ :  1.11/01 09/01/2017  13.37.40  by  Michael Scheer
*-- Author :    Michael Scheer   06/01/2017
      subroutine undumag_parameter(cparin,val,istat)

      use bpolyederf90m
      use undumagf90m

      use commandlinef90m

      implicit none

      double precision val
      integer luni,last,istat,nbuff,ipos(2,3),nwords,ifound,i
      character(128) cline,cvar,cpar,cparin
      character(32) cw1,cw2,cw3
      integer ic1
      character c1
      equivalence (ic1,c1)

      istat=-1
      ic1=0
      cpar=cparin

      open(newunit=luni,file='undumag.in')

      ifound=0

      do while (.true.)
        read(luni,'(a)',end=9)cline
        if (cline(1:25).eq.'* Results of undumag_calc') then
          ifound=1
          exit
        endif
      enddo
9     continue

      if (ifound.eq.0) then
c        write(lun6,*)
c        write(lun6,*)"*** Warning in undumag_parameter: No results of undumag_calc found ***"
c        write(lun6,*)
        goto 9999
      endif

      ic1=0
      do i=1,len_trim(cpar)
        c1=cpar(i:i)
        if (ic1.ge.65.and.ic1.le.90) ic1=ic1+32
        cpar(i:i)=c1
      enddo

      do while (.true.)
        read(luni,'(a)',end=9999)cline
        if (cline(1:8).eq.'*EndCalc') exit

        ifound=0
        do i=1,128
          if (cline(i:i).eq.':') then
            ifound=i
            exit
          endif
        enddo

        if (ifound.ne.0) then
          cvar=cline(2:ifound-1)
          read(cline(ifound+1:128),*)val
        endif

        ic1=0
        do i=1,len_trim(cvar)
          c1=cvar(i:i)
          if (ic1.ge.65.and.ic1.le.90) ic1=ic1+32
          cvar(i:i)=c1
        enddo

        if (cvar.eq.cpar) then
          istat=0
          exit
        endif

      enddo

9999  close(luni)

      return
      end
+DECK,undumag_field_int.
*CMZ :  1.22/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.17/08 24/05/2017  15.33.47  by  Michael Scheer
*CMZ :  1.17/07 23/05/2017  15.39.11  by  Michael Scheer
*CMZ :  1.17/02 08/03/2016  16.00.02  by  Michael Scheer
*CMZ :  1.15/01 24/04/2008  11.51.05  by  Michael Scheer
*CMZ :  1.15/00 26/10/2007  13.11.55  by  Michael Scheer
*CMZ :  1.12/16 01/06/2007  11.17.50  by  Michael Scheer
*CMZ :  1.12/02 14/07/2005  10.19.00  by  Michael Scheer
*CMZ :  1.10/03 19/08/2004  15.32.19  by  Michael Scheer
*CMZ :  1.10/02 19/08/2004  14.03.28  by  Michael Scheer
*CMZ :  1.10/01 17/08/2004  14.15.54  by  Michael Scheer
*CMZ :  2.00/00 17/08/2004  09.38.52  by  Michael Scheer
*CMZ :  1.02/02 11/08/2004  09.13.49  by  Michael Scheer
*CMZ :  1.02/01 09/08/2004  14.45.40  by  Michael Scheer
*CMZ :  1.02/00 28/07/2004  16.57.47  by  Michael Scheer
*-- Author :    Michael Scheer   27/07/2004
      subroutine undumag_field_int(imag,xint,yint,zint,
     &  vxint,vyint,vzint,
     &  bxint,byint,bzint,ifail)

      use undumagf90m

      implicit none

      double precision xint,yint,zint,
     &  vxint,vyint,vzint,
     &  bxint,byint,bzint,bxi,byi,bzi

      integer imag,ifail,kfail

      bxint=0.0d0
      byint=0.0d0
      bzint=0.0d0

      kfail=0

      call  undumag_bpolyint(imag,xint,yint,zint,
     &  vxint,vyint,vzint,
     &  bxi,byi,bzi,ifail)
      if (ifail.ne.0) kfail=ifail

      bxint=bxint+bxi
      byint=byint+byi
      bzint=bzint+bzi

      if (iysym.ne.0) then
        call  undumag_bpolyint(imag,xint,-yint,zint,
     &    vxint,vyint,vzint,
     &    bxi,byi,bzi,ifail)
        if (ifail.ne.0) kfail=ifail
        bxint=bxint-bxi
        byint=byint+byi
        bzint=bzint-bzi
      endif

      if (izsym.ne.0) then
        call  undumag_bpolyint(imag,xint,yint,-zint,
     &    vxint,vyint,vzint,
     &    bxi,byi,bzi,ifail)
        if (ifail.ne.0) kfail=ifail
        bxint=bxint+bxi
        byint=byint+byi
        bzint=bzint-bzi
      endif

      if (iysym.ne.0.and.izsym.ne.0) then
        call  undumag_bpolyint(imag,xint,-yint,-zint,
     &    vxint,vyint,vzint,
     &    bxi,byi,bzi,ifail)
        if (ifail.ne.0) kfail=ifail
        bxint=bxint-bxi
        byint=byint+byi
        bzint=bzint+bzi
      endif

      if (ixsym.ne.0) then
        bxint=0.0d0
        byint=2.0d0*byint
        bzint=2.0d0*bzint
      endif !ixsym

      return
      end
+DECK,undumag_dipoles_int.
*CMZ :  1.23/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.22/02 04/08/2017  09.22.23  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.55.33  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.09.09  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  15.38.45  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.35.35  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  16.39.29  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.15.48  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.22.03  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  16.12.25  by  Michael Scheer
*CMZ :  1.18/00 02/06/2017  09.38.06  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  15.20.49  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  08.36.20  by  Michael Scheer
*CMZ :  1.17/06 18/05/2017  22.30.31  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  15.55.38  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  17.57.38  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.15.17  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  09.01.37  by  Michael Scheer
*CMZ :  1.15/07 04/04/2017  13.49.11  by  Michael Scheer
*CMZ :  1.15/05 03/04/2017  13.40.53  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.57.38  by  Michael Scheer
*CMZ :  1.15/03 02/04/2017  15.45.35  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.38.56  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  15.25.06  by  Michael Scheer
*CMZ :  1.15/00 27/03/2017  15.13.40  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  14.39.06  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.16.46  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.26.29  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.53.52  by  Michael Scheer
*CMZ :  1.11/04 23/01/2017  17.22.15  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.28  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.48.13  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.22.30  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.52.38  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.18.26  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.45.21  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.30.02  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.49.21  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.57.45  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.31.52  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  14.13.49  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  15.30.08  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  12.45.07  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.03.06  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.37.39  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  11.57.51  by  Michael Scheer
*CMZ :  0.00/11 18/07/2016  09.18.11  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.57.35  by  Michael Scheer
*CMZ :  0.00/09 28/06/2016  15.42.08  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/05 13/06/2016  12.45.02  by  Michael Scheer
*CMZ :  0.00/02 30/04/2016  13.12.13  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.02.34  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  15.51.06  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.38.32  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.40.54  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  15.11.21  by  Michael Scheer
*CMZ :  1.17/03 22/03/2016  07.59.20  by  Michael Scheer
*CMZ :  1.17/02 07/03/2016  16.32.54  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_dipoles_int(imag,y,z,byis,bzis,ifail)

      use bpolyederf90m
      use undumagf90m

      implicit none

+seq,seqdebug.

      double precision  y,z,byis,bzis
      double precision  dip2y,dip3z,y2z2,py,pz,pryz,byi,bzi

      integer ifail,kmag,imag

      byis=0.0d0
      bzis=0.0d0
      byi=0.0d0
      bzi=0.0d0

      ifail=0
      if (bpebc(17,imag).lt.0.0d0) return
      ifail=1

      dip2y=dipoles(2,imag)-y*1000.0d0
      dip3z=dipoles(3,imag)-z*1000.0d0

      y2z2=dip2y**2+dip3z**2
      py=dipoles(6,imag)*dipoles(4,imag)
      pz=dipoles(7,imag)*dipoles(4,imag)
      pryz=py*dip2y+pz*dip3z

      if (y2z2.ne.0.0d0) then
        byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &    -2.0d0/y2z2*py
        bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &    -2.0d0/y2z2*pz
        ifail=0
        byis=byis+byi
        bzis=bzis+bzi
      else
        ifail=1
        goto 999
      endif

      if (nmag.ne.ndipoles) then

        kmag=nmag+(imag-1)*(ndipoles/nmag-1)

        if (ixsym.ne.0.and.iysym.ne.0.and.izsym.ne.0) then
          kmag=kmag+1 !xsym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !ysym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !zsym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !ix + iy
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !ix + iz
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !iy + iz
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !iy + iy + iz
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
        else if (ixsym.ne.0.and.iysym.ne.0) then
          kmag=kmag+1 !xsym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !ysym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !ix + iy
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
        else if (ixsym.ne.0.and.izsym.ne.0) then
          kmag=kmag+1 !xsym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !zsym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !ix + iz
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
        else if (iysym.ne.0.and.izsym.ne.0) then
          kmag=kmag+1 !ysym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !zsym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
          kmag=kmag+1 !iy + iz
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
        else if (ixsym.ne.0) then
          kmag=kmag+1 !xsym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
        else if (iysym.ne.0) then
          kmag=kmag+1 !ysym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
        else if (izsym.ne.0) then
          kmag=kmag+1 !zsym
          dip2y=dipoles(2,kmag)-y*1000.0d0
          dip3z=dipoles(3,kmag)-z*1000.0d0
          y2z2=dip2y**2+dip3z**2
          py=dipoles(6,kmag)*dipoles(4,kmag)
          pz=dipoles(7,kmag)*dipoles(4,kmag)
          pryz=py*dip2y+pz*dip3z
          if (y2z2.ne.0.0d0) then
            byi=3.0d0*pryz*dip2y*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*py
            bzi=3.0d0*pryz*dip3z*2.0d0/3.0d0/y2z2**2*2.0d0
     &        -2.0d0/y2z2*pz
            ifail=0
            byis=byis+byi
            bzis=bzis+bzi
          else
            ifail=1
            goto 999
          endif
        endif
      endif !(nmag.ne.ndipoles) then

999   byis=byis/1000.0d0
      bzis=bzis/1000.0d0

      return
      end
+DECK,undumag_bintinf.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  12.59.53  by  Michael Scheer
*CMZ :  1.23/03 27/09/2017  09.16.22  by  Michael Scheer
*CMZ :  1.23/02 15/09/2017  21.47.55  by  Michael Scheer
*-- Author :    Michael Scheer   30/08/2017
      subroutine undumag_bintinf(x0in,y0in,z0in,vxin,vyin,vzin,
     &  bintxo,bintyo,bintzo,ifail)

      use bpolyederf90m
      use undumagf90m

      use commandlinef90m

      implicit none

      double precision, dimension (:,:,:), allocatable :: corn
      double precision, dimension (:,:), allocatable :: vnor,corny

      double precision bintxo,bintyo,bintzo,bintx,binty,bintz,
     &  bxi,byi,bzi,
     &  x,y,z,x0,y0,z0,vx,vy,vz,a1,b1,vn,vxin,vyin,vzin,
     &  ts(3,3),tsinv(3,3),r1(3),r2(3),bcx,bcy,bcz,
+self,if=debugb.
     &  bcn,bcxn,bcyn,bczn,
+self.
     &  x0in,y0in,z0in,v3(3),
     &  v3r(3),w3r(3),g(3),vni(3),v(3),vp(3)

      double precision ans,ans1,ans2,ans3,ans4,ans5,ans6,ans7,ans8,ans9,ans10,
     &  ans11,ans12,ans13

      double precision xl,xh,yl,yh,
     &  gxy,gyy,gzy,gxys,gyys,gzys,
     &  chargedens

      double precision :: eps=1.0d-7
+self,if=debugb.
      double precision bcxrot,bcyrot,bczrot,
     &  cdrx,cdry,cdrz,cdvx,cdvy,cdvz,
     &  currdenx,currdeny,currdenz,currden,
     &  vcmn,vcmvpx,vcmvpy,vcmvpz
+self.,if=debugb.

      integer lfail,kfail,ifail,imag,icorn,iplan,ncorn,nplan,i,j,ical

      ifail=0
      lfail=0
      bintxo=0.0d0
      bintyo=0.0d0
      bintzo=0.0d0

      vn=sqrt(vxin*vxin+vyin*vyin+vzin*vzin)

      if (vn.eq.0.0d0) then
        ifail=-1
        return
      endif

      x0=x0in*1000.0d0
      y0=y0in*1000.0d0
      z0=z0in*1000.0d0

      v(1)=vxin/vn
      v(2)=vyin/vn
      v(3)=vzin/vn

      if (
     &  abs(v(2)).gt.1.0d-6.or.abs(v(3)).gt.1.0d-6
c     &    .or.abs(y0in).gt.1.0d-6.or.abs(z0in).gt.1.0d-6
     &    ) then
        write(lun6,*)
     &    '*** Error in undumag_bintinf: Integration must be along x-axis ***'
        ifail=99
        return
      endif

      allocate (corn(3,ncornmax,nplanmax))
      allocate (corny(3,ncornmax))
      allocate (vnor(3,nplanmax))

      do imag=1,nmag

        bcx=bpebc(4,imag)
        bcy=bpebc(5,imag)
        bcz=bpebc(6,imag)

        if (abs(bcx).lt.eps.and.abs(bcy).lt.eps.and.abs(bcz).lt.eps) cycle

        nplan=ibpeplan(imag)

        do iplan=1,nplan
          ncorn=ibpecorn(iplan,imag)
          do icorn=1,ncorn
            corn(1,icorn,iplan)=bpemag(1,icorn,iplan,imag)
            corn(2,icorn,iplan)=bpemag(2,icorn,iplan,imag)-y0
            corn(3,icorn,iplan)=bpemag(3,icorn,iplan,imag)-z0
          enddo
          vnor(1:3,iplan)=bpetm(1:3,8,iplan,imag)
          vnor(1:3,iplan)=vnor(1:3,iplan)/
     &      sqrt(vnor(1,iplan)**2+vnor(2,iplan)**2+vnor(3,iplan)**2)
        enddo

        do iplan=1,nplan

          ! We rotate the plane for the integration such, that
          ! the normal vector is (0,0,1)

          vp=vnor(1:3,iplan)
          chargedens=-(bcx*vp(1)+bcy*vp(2)+bcz*vp(3))

c          if (abs(chargedens).lt.eps) cycle

          call util_matrix_to_rot_vec_to_z(vp,ts,ifail)
          do i=1,3
            do j=1,3
              tsinv(i,j)=ts(j,i)
            enddo
          enddo

          v3=vp
          v3r(1)=ts(1,1)*v3(1)+ts(1,2)*v3(2)+ts(1,3)*v3(3)
          v3r(2)=ts(2,1)*v3(1)+ts(2,2)*v3(2)+ts(2,3)*v3(3)
          v3r(3)=ts(3,1)*v3(1)+ts(3,2)*v3(2)+ts(3,3)*v3(3)
          vni=v3r


+self,if=debugb.
          currdenx=bcy*vp(3)-bcz*vp(2)
          currdeny=bcz*vp(1)-bcx*vp(3)
          currdenz=bcx*vp(2)-bcy*vp(1)
          currden=sqrt(currdenx**2+currdeny**2+currdenz**2)

          cdrx=ts(1,1)*currdenx+ts(1,2)*currdeny+ts(1,3)*currdenz
          cdry=ts(2,1)*currdenx+ts(2,2)*currdeny+ts(2,3)*currdenz
          cdrz=ts(3,1)*currdenx+ts(3,2)*currdeny+ts(3,3)*currdenz

          cdvx=currdeny*vzin-currdenz*vyin
          cdvy=currdenz*vxin-currdenx*vzin
          cdvz=currdenx*vyin-currdeny*vxin

          bcxrot=ts(1,1)*bcx+ts(1,2)*bcy+ts(1,3)*bcz
          bcyrot=ts(2,1)*bcx+ts(2,2)*bcy+ts(2,3)*bcz
          bczrot=ts(3,1)*bcx+ts(3,2)*bcy+ts(3,3)*bcz
+self.

          v3=v
          vx=ts(1,1)*v3(1)+ts(1,2)*v3(2)+ts(1,3)*v3(3)
          vy=ts(2,1)*v3(1)+ts(2,2)*v3(2)+ts(2,3)*v3(3)
          vz=ts(3,1)*v3(1)+ts(3,2)*v3(2)+ts(3,3)*v3(3)

+self,if=debugb.
          bcxn=bcx/sqrt(bcx**2+bcy**2+bcz**2)
          bcyn=bcy/sqrt(bcx**2+bcy**2+bcz**2)
          bczn=bcz/sqrt(bcx**2+bcy**2+bcz**2)

          vcmvpx=bcyn*vp(3)-bczn*vp(2)
          vcmvpy=bczn*vp(1)-bcxn*vp(3)
          vcmvpz=bcxn*vp(2)-bcyn*vp(1)

          vcmn=sqrt(vcmvpx**2+vcmvpy**2+vcmvpz**2)
          if (abs(vcmn).gt.eps) then
            vcmvpx=vcmvpx/vcmn
            vcmvpy=vcmvpy/vcmn
            vcmvpz=vcmvpz/vcmn
          endif
+self.
          ncorn=ibpecorn(iplan,imag) ! closed polygon

          do icorn=1,ncorn
            v3=corn(1:3,icorn,iplan)
            v3r(1)=ts(1,1)*v3(1)+ts(1,2)*v3(2)+ts(1,3)*v3(3)
            v3r(2)=ts(2,1)*v3(1)+ts(2,2)*v3(2)+ts(2,3)*v3(3)
            v3r(3)=ts(3,1)*v3(1)+ts(3,2)*v3(2)+ts(3,3)*v3(3)
            corny(1:3,icorn)=v3r
          enddo !ncorn

          ncorn=ncorn-1 !open polygon

          kfail=0
          gxys=0.0d0
          gyys=0.0d0
          gzys=0.0d0

          do icorn=1,ncorn

            v3r=corny(1:3,icorn)
            w3r=corny(1:3,icorn+1)

            if (abs(v3r(3)-w3r(3)).gt.eps) then
              write(lun6,*)"*** Warning in undumag_bintinf: Bad transformation of plane ***"
              write(lun6,*)"imag,iplan,icorn:",imag,iplan,icorn
              write(lun6,*)"(abs(v3r(3)-w3r(3)).gt.eps)",
     &          abs(v3r(3)-w3r(3)),eps
c              ifail=-2
c              goto 9999
            endif

            xl=v3r(1)
            yl=v3r(2)
            xh=w3r(1)
            yh=w3r(2)

            z=v3r(3)

            if (abs(xl-xh).lt.eps) cycle

            a1=(yh-yl)/(xh-xl)
            b1=yl-a1*xl

            if (a1.ne.0.0d0) then
              if (abs(vy).lt.eps.and.abs(vz).lt.eps) then
+self,if=debugb.
                write(lun6,*)"nur vx"
+self.
c                include 'g_nur_vx.f'
                gxy=0.0d0
                gyy=(-(2.0d0*(atan((a1*xh+b1)/z)*z-a1*xh)+(a1*xh+b1)*log((a1*xh+
     &            2.0d0*b1)*a1*xh+b1**2+z**2)-(2.0d0*(atan((a1*xl+b1)/z)*z-a1*xl)+(
     &            a1*xl+b1)*log((a1*xl+2.0d0*b1)*a1*xl+b1**2+z**2))))/(2.0d0*a1)
                gzy=(-(2.0d0*(a1*xh+b1)*atan((a1*xh+b1)/z)-log((a1*xh+2.0d0*b1)*a1*
     &            xh+b1**2+z**2)*z-(2.0d0*(a1*xl+b1)*atan((a1*xl+b1)/z)-log((a1*xl
     &            +2.0d0*b1)*a1*xl+b1**2+z**2)*z)))/(2.0d0*a1)

              else if (abs(vx).lt.eps.and.abs(vy).lt.eps) then
c              else if (vx.eq.0.0d0.and.vy.eq.0.0d0) then
+self,if=debugb.
                write(lun6,*)"nur vz"
+self.
c                include 'g_nur_vz.f'
                gxy=(-(2.0d0*(a1**2*xh+a1*b1+xh)*atan((a1*xh+b1)/xh)+log((a1*xh+
     &            2.0d0*b1)*a1*xh+b1**2+xh**2)*b1-(2.0d0*(a1**2*xl+a1*b1+xl)*atan((
     &            a1*xl+b1)/xl)+log((a1*xl+2.0d0*b1)*a1*xl+b1**2+xl**2)*b1)))/(2.0d0
     &            *(a1**2+1.0d0))
                gyy=(-((a1**2*xh+a1*b1+xh)*log((a1*xh+2.0d0*b1)*a1*xh+b1**2+xh**2
     &            )-(a1**2*xl+a1*b1+xl)*log((a1*xl+2.0d0*b1)*a1*xl+b1**2+xl**2)+
     &            2.0d0*((a1**2+1.0d0)*xl-atan((a1**2*xl+a1*b1+xl)/b1)*b1)-2.0d0*((a1
     &            **2+1.0d0)*xh-atan((a1**2*xh+a1*b1+xh)/b1)*b1)))/(2.0d0*(a1**2+1.0d0
     &            ))
                gzy=0.0d0

              else if (abs(vx).lt.eps.and.abs(vz).lt.eps) then
c              else if (vx.eq.0.0d0.and.vz.eq.0.0d0) then
+self,if=debugb.
                write(lun6,*)"nur vy"
+self.
c                include 'g_nur_vy.f'
                gxy=(2.0d0*atan(xh/z)*a1*z-2.0d0*atan(xl/z)*a1*z-log(xh**2+z**2)*b1
     &            +log(xl**2+z**2)*b1-2.0d0*a1*xh+2.0d0*a1*xl)/2.0d0
                gyy=0.0d0
                gzy=(-(2.0d0*atan(xh/z)*b1+log(xh**2+z**2)*a1*z-(2.0d0*atan(xl/z)*
     &            b1+log(xl**2+z**2)*a1*z)))/2.0d0
              else
c              include 'g.f'
                ans2=-(((b1*vy**3-b1*vy+2.0d0*vx*vy**2*xh+vy**2*vz*z+vz*z)*a1*vx-
     &            (vx*xh+vz*z)*(vy**2+vz**2)*vy-((vy**2+vz**2)*b1-a1**2*vx*vy*xh
     &            )*(vy+1.0d0)*(vy-1.0d0))*log((xh**2+z**2)*vy**2+vz**2*xh**2+(vx*z-
     &            2.0d0*vz*xh)*vx*z-(2.0d0*(vx*xh+vz*z)*vy+(vy+1.0d0)*(vy-1.0d0)*b1)*b1-
     &            ((a1*xh+2.0d0*b1)*(vy+1.0d0)*(vy-1.0d0)+2.0d0*(vx*xh+vz*z)*vy)*a1*xh)+
     &            2.0d0*((b1*vz-vy*z+a1*vx*z)*atan((((a1*xh+b1)*(vy+1.0d0)*(vy-1.0d0)+
     &            (2.0d0*vx*xh+vz*z)*vy)*a1+(b1*vy+vz*z)*vx-(vy**2+vz**2)*xh)/(b1*
     &            vz-vy*z+a1*vx*z))-(a1**2*vy**2-a1**2+2.0d0*a1*vx*vy-vy**2-vz**2)
     &            *xh)*vx*vy)
                ans1=2.0d0*(((a1**2*vy**2-a1**2-vy**2-vz**2)*xh+(b1*vy+vz*z)*vx+(
     &            (2.0d0*vx*xh+vz*z)*vy+(vy+1.0d0)*(vy-1.0d0)*b1)*a1)*atan(((a1*xh+b1)
     &            *(vy+1.0d0)*(vy-1.0d0)+(vx*xh+vz*z)*vy)/(vx*z-vz*xh))-((a1**2*vy**
     &            2-a1**2-vy**2-vz**2)*xl+(b1*vy+vz*z)*vx+((2.0d0*vx*xl+vz*z)*vy+(
     &            vy+1.0d0)*(vy-1.0d0)*b1)*a1)*atan(((a1*xl+b1)*(vy+1.0d0)*(vy-1.0d0)+(
     &            vx*xl+vz*z)*vy)/(vx*z-vz*xl)))*vz+((b1*vy**3-b1*vy+2.0d0*vx*vy**
     &            2*xl+vy**2*vz*z+vz*z)*a1*vx-(vx*xl+vz*z)*(vy**2+vz**2)*vy-((vy
     &            **2+vz**2)*b1-a1**2*vx*vy*xl)*(vy+1.0d0)*(vy-1.0d0))*log((xl**2+z
     &            **2)*vy**2+vz**2*xl**2+(vx*z-2.0d0*vz*xl)*vx*z-(2.0d0*(vx*xl+vz*z)
     &            *vy+(vy+1.0d0)*(vy-1.0d0)*b1)*b1-((a1*xl+2.0d0*b1)*(vy+1.0d0)*(vy-1.0d0)
     &            +2.0d0*(vx*xl+vz*z)*vy)*a1*xl)+2.0d0*((b1*vz-vy*z+a1*vx*z)*atan(((
     &            (a1*xl+b1)*(vy+1.0d0)*(vy-1.0d0)+(2.0d0*vx*xl+vz*z)*vy)*a1+(b1*vy+vz
     &            *z)*vx-(vy**2+vz**2)*xl)/(b1*vz-vy*z+a1*vx*z))-(a1**2*vy**2-a1
     &            **2+2.0d0*a1*vx*vy-vy**2-vz**2)*xl)*vx*vy+ans2
                gxy=ans1/(2.0d0*(a1**2*vy**2-a1**2+2.0d0*a1*vx*vy-vy**2-vz**2)*(vy+
     &            1.0d0)*(vy-1.0d0))
                ans1=((a1**2*vy**2-a1**2-vy**2-vz**2)*xl+(b1*vy+vz*z)*vx+((2.0d0*
     &            vx*xl+vz*z)*vy+(vy+1.0d0)*(vy-1.0d0)*b1)*a1)*log((xl**2+z**2)*vy**
     &            2+vz**2*xl**2+(vx*z-2.0d0*vz*xl)*vx*z-(2.0d0*(vx*xl+vz*z)*vy+(vy+
     &            1.0d0)*(vy-1.0d0)*b1)*b1-((a1*xl+2.0d0*b1)*(vy+1.0d0)*(vy-1.0d0)+2.0d0*(vx
     &            *xl+vz*z)*vy)*a1*xl)-2.0d0*((b1*vz-vy*z+a1*vx*z)*(atan((((a1*xh+
     &            b1)*(vy+1.0d0)*(vy-1.0d0)+(2.0d0*vx*xh+vz*z)*vy)*a1+(b1*vy+vz*z)*vx-
     &            (vy**2+vz**2)*xh)/(b1*vz-vy*z+a1*vx*z))-atan((((a1*xl+b1)*(vy+
     &            1.0d0)*(vy-1.0d0)+(2.0d0*vx*xl+vz*z)*vy)*a1+(b1*vy+vz*z)*vx-(vy**2+
     &            vz**2)*xl)/(b1*vz-vy*z+a1*vx*z)))-(a1**2*vy**2-a1**2+2.0d0*a1*vx
     &            *vy-vy**2-vz**2)*(xh-xl))-((a1**2*vy**2-a1**2-vy**2-vz**2)*xh+
     &            (b1*vy+vz*z)*vx+((2.0d0*vx*xh+vz*z)*vy+(vy+1.0d0)*(vy-1.0d0)*b1)*a1)
     &            *log((xh**2+z**2)*vy**2+vz**2*xh**2+(vx*z-2.0d0*vz*xh)*vx*z-(2.0d0
     &            *(vx*xh+vz*z)*vy+(vy+1.0d0)*(vy-1.0d0)*b1)*b1-((a1*xh+2.0d0*b1)*(vy+
     &            1.0d0)*(vy-1.0d0)+2.0d0*(vx*xh+vz*z)*vy)*a1*xh)
                gyy=ans1/(2.0d0*(a1**2*vy**2-a1**2+2.0d0*a1*vx*vy-vy**2-vz**2))
                ans4=2.0d0*((b1*vz-vy*z+a1*vx*z)*atan((((a1*xh+b1)*(vy+1.0d0)*(vy-
     &            1.0d0)+(2.0d0*vx*xh+vz*z)*vy)*a1+(b1*vy+vz*z)*vx-(vy**2+vz**2)*xh)
     &            /(b1*vz-vy*z+a1*vx*z))-(a1**2*vy**2-a1**2+2.0d0*a1*vx*vy-vy**2-
     &            vz**2)*xh)*vy*vz
                ans3=-(((b1*vy**3*vz-b1*vy*vz+2.0d0*vx*vy**2*vz*xl+vy**2*vz**2*z+
     &            vy**2*z+vz**2*z-z)*a1+(vx*vz**2*z+vx*z-vy**2*vz*xl-vz**3*xl)*
     &            vy+(a1**2*vy*xl+b1*vx)*(vy+1.0d0)*(vy-1.0d0)*vz)*log((xl**2+z**2)*
     &            vy**2+vz**2*xl**2+(vx*z-2.0d0*vz*xl)*vx*z-(2.0d0*(vx*xl+vz*z)*vy+(
     &            vy+1.0d0)*(vy-1.0d0)*b1)*b1-((a1*xl+2.0d0*b1)*(vy+1.0d0)*(vy-1.0d0)+2.0d0*
     &            (vx*xl+vz*z)*vy)*a1*xl)+2.0d0*((b1*vz-vy*z+a1*vx*z)*atan((((a1*
     &            xl+b1)*(vy+1.0d0)*(vy-1.0d0)+(2.0d0*vx*xl+vz*z)*vy)*a1+(b1*vy+vz*z)*
     &            vx-(vy**2+vz**2)*xl)/(b1*vz-vy*z+a1*vx*z))-(a1**2*vy**2-a1**2+
     &            2.0d0*a1*vx*vy-vy**2-vz**2)*xl)*vy*vz)+((b1*vy**3*vz-b1*vy*vz+
     &            2.0d0*vx*vy**2*vz*xh+vy**2*vz**2*z+vy**2*z+vz**2*z-z)*a1+(vx*vz
     &            **2*z+vx*z-vy**2*vz*xh-vz**3*xh)*vy+(a1**2*vy*xh+b1*vx)*(vy+
     &            1.0d0)*(vy-1.0d0)*vz)*log((xh**2+z**2)*vy**2+vz**2*xh**2+(vx*z-2.0d0
     &            *vz*xh)*vx*z-(2.0d0*(vx*xh+vz*z)*vy+(vy+1.0d0)*(vy-1.0d0)*b1)*b1-((
     &            a1*xh+2.0d0*b1)*(vy+1.0d0)*(vy-1.0d0)+2.0d0*(vx*xh+vz*z)*vy)*a1*xh)+
     &            ans4
                ans2=2.0d0*(((a1**2*vy**2-a1**2-vy**2-vz**2)*xh+(b1*vy+vz*z)*vx+(
     &            (2.0d0*vx*xh+vz*z)*vy+(vy+1.0d0)*(vy-1.0d0)*b1)*a1)*atan(((a1*xh+b1)
     &            *(vy+1.0d0)*(vy-1.0d0)+(vx*xh+vz*z)*vy)/(vx*z-vz*xh))-((a1**2*vy**
     &            2-a1**2-vy**2-vz**2)*xl+(b1*vy+vz*z)*vx+((2.0d0*vx*xl+vz*z)*vy+(
     &            vy+1.0d0)*(vy-1.0d0)*b1)*a1)*atan(((a1*xl+b1)*(vy+1.0d0)*(vy-1.0d0)+(
     &            vx*xl+vz*z)*vy)/(vx*z-vz*xl)))*vx+ans3
                ans1=-ans2
                gzy=ans1/(2.0d0*(a1**2*vy**2-a1**2+2.0d0*a1*vx*vy-vy**2-vz**2)*(vy+
     &            1.0d0)*(vy-1.0d0))
              endif
            else  !a1

              if (abs(vy).lt.eps.and.abs(vz).lt.eps) then
c              if (vy.eq.0.0d0.and.vz.eq.0.0d0) then
+self,if=debugb.
                write(lun6,*)"nur vx"
+self.
c                include 'g0_nur_vx.f'
                gxy=0.0d0
                gyy=(-(xh-xl)*log(yh**2+z**2))/2.0d0
                gzy=-(xh-xl)*atan(yh/z)

              else if (abs(vx).lt.eps.and.abs(vy).lt.eps) then
c              else if (vx.eq.0.0d0.and.vy.eq.0.0d0) then
+self,if=debugb.
                write(lun6,*)"nur vz"
+self.
c                include 'g0_nur_vz.f'
                gxy=(-(2.0d0*atan(yh/xh)*xh+log(xh**2+yh**2)*yh-(2.0d0*atan(yh/xl)*
     &            xl+log(xl**2+yh**2)*yh)))/2.0d0
                gyy=(-((log(xh**2+yh**2)-2.0d0)*xh+2.0d0*atan(xh/yh)*yh-((log(xl**2
     &            +yh**2)-2.0d0)*xl+2.0d0*atan(xl/yh)*yh)))/2.0d0
                gzy=0.0d0

              else if (abs(vx).lt.eps.and.abs(vz).lt.eps) then
c              else if (vx.eq.0.0d0.and.vz.eq.0.0d0) then
+self,if=debugb.
                write(lun6,*)"nur vy"
+self.
c                include 'g0_nur_vy.f'
                gxy=(-(log(xh**2+z**2)-log(xl**2+z**2))*yh)/2.0d0
                gyy=0.0d0
                gzy=-(atan(xh/z)-atan(xl/z))*yh
              else
c                include 'g0.f'
                gxy=(2.0d0*(((vy**2+vz**2)*xl-(vy*yh+vz*z)*vx)*atan(((vx*yh-vy*xl
     &            )*vx-(vy*z-vz*yh)*vz)/(vx*z-vz*xl))*vz-((vy**2+vz**2)*xl-(vy*z
     &            -vz*yh)*atan(((vy**2+vz**2)*xl-(vy*yh+vz*z)*vx)/(vy*z-vz*yh)))
     &            *vx*vy+((vy**2+vz**2)*xh-(vy*z-vz*yh)*atan(((vy**2+vz**2)*xh-(
     &            vy*yh+vz*z)*vx)/(vy*z-vz*yh)))*vx*vy-((vy**2+vz**2)*xh-(vy*yh+
     &            vz*z)*vx)*atan(((vx*yh-vy*xh)*vx-(vy*z-vz*yh)*vz)/(vx*z-vz*xh)
     &            )*vz)-((vx*yh-vy*xl)*vx-(vy*z-vz*yh)*vz)*(vy**2+vz**2)*log(((
     &            xl**2+z**2)*vy-2.0d0*vz*yh*z)*vy+(xl**2+yh**2)*vz**2-(2.0d0*(vy*yh
     &            +vz*z)*xl-(yh**2+z**2)*vx)*vx)+((vx*yh-vy*xh)*vx-(vy*z-vz*yh)*
     &            vz)*(vy**2+vz**2)*log(((xh**2+z**2)*vy-2.0d0*vz*yh*z)*vy+(xh**2+
     &            yh**2)*vz**2-(2.0d0*(vy*yh+vz*z)*xh-(yh**2+z**2)*vx)*vx))/(2.0d0*(
     &            vy**2+vz**2)*(vy+1.0d0)*(vy-1.0d0))
                gyy=(((vy**2+vz**2)*xl-(vy*yh+vz*z)*vx)*log(((xl**2+z**2)*vy-
     &            2.0d0*vz*yh*z)*vy+(xl**2+yh**2)*vz**2-(2.0d0*(vy*yh+vz*z)*xl-(yh**
     &            2+z**2)*vx)*vx)-2.0d0*((vy**2+vz**2)*xl-(vy*z-vz*yh)*atan(((vy**
     &            2+vz**2)*xl-(vy*yh+vz*z)*vx)/(vy*z-vz*yh)))+2.0d0*((vy**2+vz**2)
     &            *xh-(vy*z-vz*yh)*atan(((vy**2+vz**2)*xh-(vy*yh+vz*z)*vx)/(vy*z
     &            -vz*yh)))-((vy**2+vz**2)*xh-(vy*yh+vz*z)*vx)*log(((xh**2+z**2)
     &            *vy-2.0d0*vz*yh*z)*vy+(xh**2+yh**2)*vz**2-(2.0d0*(vy*yh+vz*z)*xh-(
     &            yh**2+z**2)*vx)*vx))/(2.0d0*(vy**2+vz**2))
                gzy=((vx*vy**2*vz*yh+vx*vy*vz**2*z+vx*vy*z-vx*vz*yh-vy**3*vz*xh
     &            -vy*vz**3*xh)*log(((xh**2+z**2)*vy-2.0d0*vz*yh*z)*vy+(xh**2+yh**
     &            2)*vz**2-(2.0d0*(vy*yh+vz*z)*xh-(yh**2+z**2)*vx)*vx)-(vx*vy**2*
     &            vz*yh+vx*vy*vz**2*z+vx*vy*z-vx*vz*yh-vy**3*vz*xl-vy*vz**3*xl)*
     &            log(((xl**2+z**2)*vy-2.0d0*vz*yh*z)*vy+(xl**2+yh**2)*vz**2-(2.0d0*
     &            (vy*yh+vz*z)*xl-(yh**2+z**2)*vx)*vx)-2.0d0*((vy**2+vz**2)*xl-(vy
     &            *z-vz*yh)*atan(((vy**2+vz**2)*xl-(vy*yh+vz*z)*vx)/(vy*z-vz*yh)
     &            ))*vy*vz-2.0d0*((vy**2+vz**2)*xl-(vy*yh+vz*z)*vx)*atan(((vx*yh-
     &            vy*xl)*vx-(vy*z-vz*yh)*vz)/(vx*z-vz*xl))*vx+2.0d0*((vy**2+vz**2)
     &            *xh-(vy*z-vz*yh)*atan(((vy**2+vz**2)*xh-(vy*yh+vz*z)*vx)/(vy*z
     &            -vz*yh)))*vy*vz+2.0d0*((vy**2+vz**2)*xh-(vy*yh+vz*z)*vx)*atan(((
     &            vx*yh-vy*xh)*vx-(vy*z-vz*yh)*vz)/(vx*z-vz*xh))*vx)/(2.0d0*(vy**2
     &            +vz**2)*(vy+1.0d0)*(vy-1.0d0))
              endif
            endif

            gxys=gxys+gxy
            gyys=gyys+gyy
            gzys=gzys+gzy

          enddo !ncorn

          if (kfail.ne.0) then
            ifail=kfail
          endif

+self,if=debugb.
          write(lun6,*)
          write(lun6,*)"iplan:",iplan
          write(lun6,*)
          write(lun6,*)"iplan, vnor:",iplan,vp
          write(lun6,*)"vx,vy,vz:",vx,vy,vz
          write(lun6,*)"chargedens:",chargedens
          write(lun6,*)"brot:",bcxrot,bcyrot,bczrot
          write(lun6,*)"cd:",currdenx,currdeny,currdenz
          write(lun6,*)
     &      "cdrx,cdry,cdrz:",
     &      cdrx,cdry,cdrz
          write(lun6,*)
     &      "cdvx,cdvy,cdvz:",
     &      cdvx,cdvy,cdvz
          write(lun6,*)"gxys,gyys,gzys:",gxys,gyys,gzys
+self.,if=debugb.

+self,if=-debugb.
          chargedens=chargedens/twopi
+self.
          g(1)=gxys
          g(2)=gyys
          g(3)=gzys

          ! We rotate back form the xy-plane

          bintx=tsinv(1,1)*g(1)+tsinv(1,2)*g(2)+tsinv(1,3)*g(3)
          binty=tsinv(2,1)*g(1)+tsinv(2,2)*g(2)+tsinv(2,3)*g(3)
          bintz=tsinv(3,1)*g(1)+tsinv(3,2)*g(2)+tsinv(3,3)*g(3)

          if (bintx.ne.bintx) then
            lfail=lfail+1
          else
            bintxo=bintxo+bintx*chargedens
          endif

          if (binty.ne.binty) then
            lfail=lfail+1
          else
            bintyo=bintyo+binty*chargedens
          endif

          if (bintz.ne.bintz) then
            lfail=lfail+1
          else
            bintzo=bintzo+bintz*chargedens
          endif

+self,if=debugb.
          write(lun6,*)
     &      "bintx,binty,bzintz:",
     &      bintx,binty,bintz
          write(lun6,*)
     &      "bintxo,bintyo,bzintzo:",
     &      bintxo,bintyo,bintzo
+self.
        enddo !nplan

      enddo !imag

      bintxo=bintxo/1000.0d0
      bintyo=bintyo/1000.0d0
      bintzo=bintzo/1000.0d0

9999  continue

      deallocate (corn,vnor,corny)

      if (lfail.ne.0) then
        print*
        print*,"*** Warning in undumag_bintinf: NaN found for at least one voxel ***"
        print*
        call sleep(3)
      endif

      ifail=ifail+lfail

      return
      end
+DECK,undumag_bintinf_sym.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/00 30/01/2021  17.58.42  by  Michael Scheer
*CMZ :  1.25/03 03/04/2018  08.28.50  by  Michael Scheer
*CMZ :  1.23/02 16/09/2017  10.37.45  by  Michael Scheer
*-- Author :    Michael Scheer   16/09/2017
      subroutine undumag_bintinf_sym(xint,yint,zint,vxint,vyint,vzint,
     &  bxint,byint,bzint,ifail)

      use undumagf90m

      implicit none

      double precision xint,yint,zint,
     &  vxint,vyint,vzint,
     &  bxint,byint,bzint,bxi,byi,bzi

      integer ifail,kfail

      bxint=0.0d0
      byint=0.0d0
      bzint=0.0d0

      kfail=0

      call  undumag_bintinf(xint,yint,zint,
     &  vxint,vyint,vzint,
     &  bxi,byi,bzi,ifail)

      if (ifail.ne.0) kfail=kfail+ifail

      bxint=bxint+bxi
      byint=byint+byi
      bzint=bzint+bzi

      if (iysym.ne.0) then
        call  undumag_bintinf(xint,-yint,zint,
     &    vxint,vyint,vzint,
     &    bxi,byi,bzi,ifail)
        if (ifail.ne.0) kfail=kfail+ifail
        bxint=bxint-bxi
        byint=byint+byi
        bzint=bzint-bzi
      endif

      if (izsym.ne.0) then
        call  undumag_bintinf(xint,yint,-zint,
     &    vxint,vyint,vzint,
     &    bxi,byi,bzi,ifail)
        if (ifail.ne.0) kfail=kfail+ifail
        bxint=bxint+bxi
        byint=byint+byi
        bzint=bzint-bzi
      endif

      if (iysym.ne.0.and.izsym.ne.0) then
        call  undumag_bintinf(xint,-yint,-zint,
     &    vxint,vyint,vzint,
     &    bxi,byi,bzi,ifail)
        if (ifail.ne.0) kfail=kfail+ifail
        bxint=bxint-bxi
        byint=byint+byi
        bzint=bzint+bzi
      endif

      if (ixsym.ne.0) then
        bxint=0.0d0
        byint=2.0d0*byint
        bzint=2.0d0*bzint
      endif !ixsym

      call undumag_bcoilsinf(yint,zint,byi,bzi,ifail)
      if (ifail.ne.0) kfail=kfail+ifail

      byint=byint+byi
      bzint=bzint+bzi

      ifail=kfail

      return
      end
+DECK,undumag_iron_residuals.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.00/01 12/04/2018  12.32.47  by  Michael Scheer
*CMZ :  1.25/00 30/01/2018  15.11.36  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  17.24.52  by  Michael Scheer
*-- Author :    Michael Scheer   21/09/2017
      subroutine undumag_residuals_iron

      use bpolyederf90m
      use undumagf90m

      use commandlinef90m

      implicit none

+seq,seqdebug.

      double precision bn,h3(3),h3n,femag
      integer ifail,mat,mapmode,nhz,imag,iwarn

      data iwarn/0/

      save iwarn

      hresidiron=0.0d0
      if (niron.eq.0) return

      do imag=nrec+1,nrec+niron

        bn=sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)

        mat=nint(bpebc(9,imag))
        mapmode=matmaps(3,mat)

        nhz=matmaps(4,mat)

        call undumag_bpolyeder_matrix(imag,h3(1),h3(2),h3(3),ifail)

        if (ifail.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_residuals_iron: Bad return from undumag_bpolyeder_matrix during calculations of residiuals ***"
          write(lun6,*)
        endif

        h3n=sqrt(h3(1)**2+h3(2)**2+h3(3)**2)

        if (mapmode.gt.0) then

          call util_interpol_linear(nhz,feh1,fem1,h3n,femag,ifail)
          if (ifail.ne.0) then
            write(lun6,*)
            write(lun6,*)"*** Warning in undumag_residuals_iron: Bad return from util_interpol_linear during calculations of residuals ***"
            write(lun6,*)
          endif
        else
          cycle
c          femag=bcmat(2,1,mat)
        endif

        hresidiron=hresidiron+(femag-bn)**2

      enddo

      hresidiron=sqrt(hresidiron/niron)

      return
      end
+DECK,undumag_fbfield.
*CMZ :  1.24/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.23/03 19/09/2017  19.32.15  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  14.10.42  by  Michael Scheer
*CMZ :  1.15/11 19/04/2017  14.47.22  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  15.43.17  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  14.43.16  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  13.43.20  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.20.28  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  15.33.12  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  16.02.08  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  09.46.04  by  Michael Scheer
*CMZ :  1.17/13 07/04/2016  17.38.21  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.53.04  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.28.51  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.49.46  by  Michael Scheer
*-- Author :    Michael Scheer   03/04/2016
      subroutine undumag_fbfield(iplan,x,y,z,bxout,byout,bzout,ifail)

c This subroutine should ony be called from undumag_force for a rectangular
c force box

      use bpolyederf90m
      use undumagf90m

      implicit none

+seq,seqdebug.

      double precision x,y,z,bxout,byout,bzout,bc(3)

      integer ifail,kino,iplan

      integer :: ical=0

      kino=kinside
      kinside=0

      call undumag_field(x,y,z,bxout,byout,bzout,ifail)

      if (kinside.gt.0) then
        bc=bpebc(4:6,kinside)
        if (iplan.eq.1.or.iplan.eq.3) then
          bxout=bxout+bc(1)
        else if (iplan.eq.2.or.iplan.eq.4) then
          byout=byout+bc(2)
        else if (iplan.eq.5.or.iplan.eq.6) then
          bzout=bzout+bc(3)
        endif
      endif

      kinside=kino

      return
      end
+DECK,undumag_bcoils.
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/00 26/02/2021  17.57.38  by  Michael Scheer
*CMZ :  2.01/08 14/08/2020  11.48.46  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  12.08.59  by  Michael Scheer
*CMZ :  2.00/02 17/04/2018  13.43.36  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  15.38.41  by  Michael Scheer
*CMZ :  2.00/00 09/04/2018  12.17.36  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.27.23  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  17.02.28  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  12.54.05  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.04.47  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.51.10  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_bcoils(xin,yin,zin,bxout,byout,bzout,istat)

      use undumagf90m

      implicit none

      double precision, dimension (:,:), allocatable :: wold
      double precision xin,yin,zin,bxout,byout,bzout,xsymmm

      integer istat,i,ical,lunfil,j,nallo,icoil,k,icold,ic

      data ical/0/

      save ical,xsymmm

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      istat=0

      ncoil=nwind+ncwires+nrace+ncrace+narc+ncarc+nthwir+nrbar

      if (ncoil.eq.0) return

      if (ical.eq.0.and.kwave.eq.0) then

        if (ncwires.gt.0) then
          icoil=nint(wire(11,ncwires))
        else
          icoil=0
        endif

        xsymmm=xsym*1000.0d0

        ncfila=ncwires

        if (nwind+nrace+ncrace+narc+ncarc+nthwir+nrbar.gt.0) then

          nwwind=0
          nwrace=0
          nwcrace=0
          nwarc=0
          nwcarc=0
          nwthwir=0
          nwrbar=0

          do i=1,ncrace
            if (crace(1,i).eq.0.0d0) cycle
            if (nint(crace(14,i)).le.0) crace(14,i)=1.0d0
            if (nint(crace(15,i)).le.0) crace(15,i)=1.0d0
            if (nint(crace(16,i)).le.0) crace(16,i)=1.0d0
            nwcrace=nwcrace+nint(4*crace(14,i)*crace(15,i)*(1+crace(16,i)))
          enddo

          do i=1,nrace
            if (race(1,i).eq.0.0d0) cycle
            if (nint(race(14,i)).le.0) race(14,i)=1.0d0
            if (nint(race(15,i)).le.0) race(15,i)=1.0d0
            if (nint(race(16,i)).le.0) race(16,i)=1.0d0
            nwrace=nwrace+nint(4*race(14,i)*race(15,i)*(1+race(16,i)))
          enddo

          do i=1,nwind
            if (wind(1,i).eq.0.0d0) cycle
            if (nint(wind(14,i)).le.0) wind(14,i)=1.0d0
            if (nint(wind(15,i)).le.0) wind(15,i)=1.0d0
            if (nint(wind(16,i)).le.0) wind(16,i)=1.0d0
            nwwind=nwwind+nint(4*wind(14,i)*wind(15,i)*(1+wind(16,i)))
          enddo

          do i=1,narc
            if (arc(1,i).eq.0.0d0) cycle
            if (nint(arc(9,i)).le.0) arc(9,i)=1.0d0
            if (nint(arc(10,i)).le.0) arc(10,i)=1.0d0
            if (nint(arc(11,i)).le.0) arc(11,i)=1.0d0
            nwarc=nwarc+nint(arc(9,i)*arc(10,i)*arc(11,i))
          enddo

          do i=1,nthwir
            if (thickwire(1,i).eq.0.0d0) cycle
            if (nint(thickwire(8,i)).le.0) thickwire(8,i)=1.0d0
            if (nint(thickwire(7,i)).le.0) thickwire(7,i)=1.0d0
            nwthwir=nwthwir+nint(thickwire(8,i)*thickwire(7,i))
          enddo

          do i=1,nrbar
            if (rectbar(1,i).eq.0.0d0) cycle
            if (nint(rectbar(8,i)).le.0) rectbar(8,i)=1.0d0
            if (nint(rectbar(9,i)).le.0) rectbar(9,i)=1.0d0
            nwrbar=nwrbar+nint(rectbar(8,i)*rectbar(9,i))
          enddo

          do i=1,ncarc
            if (carc(1,i).eq.0.0d0) cycle
            if (nint(carc(8,i)).le.0) carc(8,i)=1.0d0
            if (nint(carc(9,i)).le.0) carc(9,i)=1.0d0
            if (nint(carc(10,i)).le.0) carc(10,i)=1.0d0
            nwcarc=nwcarc+nint(carc(8,i)*carc(9,i)*carc(10,i))
          enddo

          nallo=ncfila+nwwind+nwrace+nwcrace+nwarc+nwcarc+nwrbar+nwthwir
+self,if=boilsym. Vorsicht, funktioniert nur begrenzt
          if (ixsym.ne.0) then
            nallo=nallo*2
          endif
          if (iysym.ne.0) then
            nallo=nallo*2
          endif
          if (izsym.ne.0) then
            nallo=nallo*2
          endif
+self.
          if (ncfila.gt.0) then
            allocate(wold(nwitems,ncfila))
            wold=wire
            deallocate(wire)
            allocate(wire(nwitems,nallo))
            wire(:,1:ncfila)=wold(:,1:ncfila)
            deallocate(wold)
          else
            allocate(wire(nwitems,nallo))
            wire=0.0d0
          endif

          do i=1,nwind
            if (wind(1,i).eq.0.0d0) cycle
            icoil=icoil+1
            call undumag_wind_to_fila(i,icoil)
          enddo

          do i=1,nrace
            if (race(1,i).eq.0.0d0) cycle
            icoil=icoil+1
            call undumag_race_to_fila(i,icoil)
          enddo

          do i=1,ncrace
            if (crace(1,i).eq.0.0d0) cycle
            icoil=icoil+1
            call undumag_crace_to_fila(i,icoil)
          enddo

          do i=1,narc
            if (arc(1,i).eq.0.0d0) cycle
            icoil=icoil+1
            call undumag_arc_to_fila(i,icoil)
          enddo

          do i=1,nrbar
            if (rectbar(1,i).eq.0.0d0) cycle
            icoil=icoil+1
            call undumag_bar_to_fila(i,icoil)
          enddo

          do i=1,ncarc
            if (carc(1,i).eq.0.0d0) cycle
            icoil=icoil+1
            call undumag_circ_arc_to_fila(i,icoil)
          enddo

          do i=1,nthwir
            if (thickwire(1,i).eq.0.0d0) cycle
            icoil=icoil+1
            call undumag_thwire_to_fila(i,icoil)
          enddo

        endif !coils

        if (ncwires.eq.0) return

        do i=1,ncwires
          do j=2,8
            if (abs(wire(j,i)).lt.1.0d-9) wire(j,i)=0.0d0
          enddo
        enddo

+self,if=boilsym. Vorsicht, funktioniert nur begrenzt
        if (ixsym.ne.0) then
          do i=1,ncwires
            j=i+ncwires
            if (wire(3,i).lt.xsymmm.and.wire(6,i).gt.xsymmm) then
              wire(6,i)=xsymmm
            else if (wire(3,i).gt.xsymmm.and.wire(6,i).lt.xsymmm) then
              wire(3,i)=xsymmm
            else if (wire(3,i).ge.xsymmm.and.wire(6,i).ge.xsymmm) then
              wire(3,i)=xsymmm
              wire(6,i)=xsymmm
              wire(2,i)=0.0d0
            endif
            wire(:,j)=wire(:,i)
            wire(3,j)=xsymmm+xsymmm-wire(6,i)
            wire(4:5,j)=wire(7:8,i)
            wire(6,j)=xsymmm+xsymmm-wire(3,i)
            wire(7:8,j)=wire(4:5,i)
          enddo
          ncwires=ncwires*2
        endif

        if (iysym.ne.0) then
          do i=1,ncwires
            j=i+ncwires
            wire(:,j)=wire(:,i)
            wire(4,j)=-wire(4,i)
            wire(7,j)=-wire(7,i)
          enddo
          ncwires=ncwires*2
        endif

c concept of wires:
        ! 1: type of coil
        ! 2: curr
        ! 3: x1
        ! 4: y1
        ! 5: z1
        ! 6: x2
        ! 7: y2
        ! 8: z2
        ! 9: color
        ! 10: number

        if (izsym.ne.0) then
          do i=1,ncwires
            j=i+ncwires
            if (wire(5,i).lt.0.0d0.and.wire(8,i).gt.0.0d0) then
              wire(8,i)=0.0d0
            else if (wire(5,i).gt.0.0d0.and.wire(8,i).lt.0.0d0) then
              wire(5,i)=0.0d0
            else if (wire(5,i).ge.0.0d0.and.wire(8,i).ge.0.0d0) then
              wire(5,i)=0.0d0 !z1
              wire(8,i)=0.0d0 !z2
              wire(2,i)=0.0d0 !curr
            endif
            wire(:,j)=wire(:,i)
            !wire(2,j) = -wire(2,i)
            wire(3:4,j)=wire(6:7,i)
            wire(5,j)=-wire(8,i)
            wire(6:7,j)=wire(3:4,i)
            wire(8,j)=-wire(5,i)
          enddo
          ncwires=ncwires*2
        endif
+self.
        nallo=0
        do i=1,ncwires
          if (wire(2,i).ne.0.0d0) nallo=nallo+1
        enddo

        allocate(wold(nwitems,ncwires))
        wold=wire
        deallocate(wire)
        allocate(wire(nwitems,nallo))

        nallo=0
        do i=1,ncwires
          if (wold(2,i).eq.0.0d0) cycle
          nallo=nallo+1
          wire(:,nallo)=wold(:,i)
        enddo
        ncwires=nallo
        deallocate(wold)

c concept of wires:
        ! 1: type of coil
        ! 2: curr
        ! 3: x1
        ! 4: y1
        ! 5: z1
        ! 6: x2
        ! 7: y2
        ! 8: z2
        ! 9: color
        ! 10: number coil in group
        ! 11: absolute coil number

        open(newunit=lunfil,file='undumag.fil')
        write(lunfil,'(a)')trim(cundutit)
        k=0
        icold=nint(wire(11,1))
        do i=1,ncwires
          k=k+1
          ic=nint(wire(11,i))
          write(lunfil,'(i5,7g15.5,3i5)')
     &      nint(wire(1,i)),wire(2:8,i),nint(wire(9,i)),k,ic
          if (icold.ne.ic) k=0
          icold=ic
        enddo
        close(lunfil)

        ical=1

      endif !ical

      if (ncwires.eq.0) return

+self,if=noompcoils.
      do i=1,ncwires
        if (wire(2,i).eq.0.0d0) cycle
        wire7(1)=wire(2,i)
        wire7(2:7)=wire(3:8,i)/1000.0d0
        call undumag_bwireana(wire7,xin,yin,zin,bx,by,bz)
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
      enddo

      if (abs(bxout).gt.10.0d0.or.abs(byout).gt.10.0d0.or.abs(bzout).gt.10.0d0) then
        print*,xin,yin,zin
      endif

      if (abs(bxout).lt.1.0d-9) bxout=0.0d0
      if (abs(byout).lt.1.0d-9) byout=0.0d0
      if (abs(bzout).lt.1.0d-9) bzout=0.0d0
+self,if=-noompcoils.
      call undumag_bcoils_omp(xin,yin,zin,bxout,byout,bzout,istat)
+self.

      if (bxout.ne.bxout.or.byout.ne.byout.or.bzout.ne.bzout) then
        print*," "
        print*,"*** Error in undumag_bcoils: Singularity hit for"
        print*,"x,y,z [mm]:", xin*1000.,yin*1000.,zin*1000.
        bxout = 9999.
        byout = 9999.
        bzout = 9999.
        istat=-1
      endif

      return
      end
+DECK,undumag_race_to_fila.
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 04/02/2021  15.09.44  by  Michael Scheer
*CMZ :  2.01/03 24/01/2019  10.41.25  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  11.55.41  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  14.48.44  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  16.51.35  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.53.23  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_race_to_fila(k,icoil)

      use undumagf90m

      use commandlinef90m

      implicit none

+seq,phyconparam.

      double precision, dimension (:), allocatable :: y,z

      double precision h,w,r,barl,curr,cw,vx,vy,vz,phi,alpha,cosa,sina,
     &  cosphi,sinphi,cosphi1,sinphi2,cosphi2,sinphi1,costhe,sinthe,
     &  xc,yc,zc,x0,y0,z0,dphi,dr,dy,ro,ri,xr1,zr1,xr2,zr2,dz,vn,
     &  xi,xo,zi,zo,wx,wy,wz,ux,uy,uz,rotmat(3,3),vnor(3),rmat(3,3)

      integer k,icoil,iw,ir,nz,ny,nphi,iphi,iy,iz,kolor,ical,istat,i,j,kold

      data ical/0/

      save ical,iw

      !rotate (vx,vy,vz) to y-axis

      if (ical.eq.0) then
        ical=1
      endif

      iw=ncwires
      kold=iw

      curr=race(1,k)

      x0=race(2,k)
      y0=race(3,k)
      z0=race(4,k)

      vx=race(5,k)
      vy=race(6,k)
      vz=race(7,k)

      vn=sqrt(vx**2+vy**2+vz**2)
      if (vn.eq.0.0d0) then
        write(lun6,*)
        write(lun6,*)"*** Error in undumag_race_to_fila: Zero normal vector for coil",k
        stop
      endif
      vx=vx/vn
      vy=vy/vn
      vz=vz/vn

      alpha=race(8,k)
      xo=race(9,k)/2.0d0
      zi=race(10,k)/2.0d0
      zo=race(11,k)/2.0d0
      ri=race(12,k)
      h=race(13,k)
      ny=race(14,k)
      nz=race(15,k)
      nphi=race(16,k)
      kolor=race(17,k)

      w=zo-zi
      xi=xo-w
      ro=ri+w

      yc=0.0d0

c      if (ri.lt.w) then
c        write(lun6,*)
c        write(lun6,*)"*** Warning in undumag_race_to_fila: Inner radius of coils is lower than the difference of outer and inner width ***"
c        stop
c      endif

      if (xi.lt.ri) then
        write(lun6,*)
        write(lun6,*)"*** Error in undumag_race_to_fila: The inner length is smaller than twice the inner radius ***"
        stop
      endif

      allocate(y(ny),z(nz))

      dphi=pi1/2.0d0/nphi
      dy=h/ny
      dz=w/nz

      do iz=1,nz
        z(iz)=zi+(iz-0.5d0)*dz
      enddo

      do iy=1,ny
        y(iy)=yc-h/2.0d0+(iy-0.5d0)*dy
      enddo

      cw=curr/(ny*nz)

      ! first x bar
      do iy=1,ny
        do iz=1,nz
          iw=iw+1
          wire(1,iw)=2 ! racetrack flag
          wire(2,iw)=cw
          wire(3,iw)=+xi-ri
          wire(4,iw)=+y(iy)
          wire(5,iw)=-z(iz)
          wire(6,iw)=-xi+ri
          wire(7,iw)=+y(iy)
          wire(8,iw)=-z(iz)
          wire(9,iw)=kolor
          wire(10,iw)=k ! racetrack number
          wire(11,iw)=icoil ! coil number
        enddo
      enddo

      ! first arc
      xc=-xi+ri
      zc=-zi+ri
      sinphi1=0.0d0
      cosphi1=1.0d0
      do iphi=1,nphi
        sinphi2=sin(iphi*dphi)
        cosphi2=cos(iphi*dphi)
        do iy=1,ny
          do iz=1,nz
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc-r*sinphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc-r*cosphi1
            wire(6,iw)=+xc-r*sinphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc-r*cosphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! racetrack number
            wire(11,iw)=icoil ! coil number
          enddo
        enddo
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      ! first z bar
      do iy=1,ny
        do iz=1,nz
          iw=iw+1
          wire(1,iw)=2 ! racetrack flag
          wire(2,iw)=cw
          wire(3,iw)=-xi-(iz-0.5d0)*dz
          wire(4,iw)=+y(iy)
          wire(5,iw)=-zi+ri
          wire(6,iw)=wire(3,iw)
          wire(7,iw)=+y(iy)
          wire(8,iw)=+zi-ri
          wire(9,iw)=kolor
          wire(10,iw)=k ! racetrack number
          wire(11,iw)=icoil ! coil number
        enddo
      enddo

      ! second arc
      xc=-xi+ri
      zc=zi-ri
      sinphi1=0.0d0
      cosphi1=1.0d0
      do iphi=1,nphi
        sinphi2=sin(iphi*dphi)
        cosphi2=cos(iphi*dphi)
        do iy=1,ny
          do iz=1,nz
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc-r*cosphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc+r*sinphi1
            wire(6,iw)=+xc-r*cosphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc+r*sinphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! racetrack number
            wire(11,iw)=icoil ! coil number
          enddo
        enddo
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      ! second x bar
      do iy=1,ny
        do iz=1,nz
          iw=iw+1
          wire(1,iw)=2 ! racetrack flag
          wire(2,iw)=cw
          wire(3,iw)=-xi+ri
          wire(4,iw)=+y(iy)
          wire(5,iw)=+z(iz)
          wire(6,iw)=+xi-ri
          wire(7,iw)=+y(iy)
          wire(8,iw)=+z(iz)
          wire(9,iw)=kolor
          wire(10,iw)=k ! racetrack number
          wire(11,iw)=icoil ! coil number
        enddo
      enddo

      ! third arc
      xc=xi-ri
      zc=zi-ri
      sinphi1=0.0d0
      cosphi1=1.0d0
      do iphi=1,nphi
        sinphi2=sin(iphi*dphi)
        cosphi2=cos(iphi*dphi)
        do iy=1,ny
          do iz=1,nz
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc+r*sinphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc+r*cosphi1
            wire(6,iw)=+xc+r*sinphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc+r*cosphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! racetrack number
            wire(11,iw)=icoil ! coil number
          enddo
        enddo
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      ! second z bar
      do iy=1,ny
        do iz=1,nz
          iw=iw+1
          wire(1,iw)=2 ! racetrack flag
          wire(2,iw)=cw
          wire(3,iw)=+xi+(iz-0.5d0)*dz
          wire(4,iw)=+y(iy)
          wire(5,iw)=+zi-ri
          wire(6,iw)=wire(3,iw)
          wire(7,iw)=+y(iy)
          wire(8,iw)=-zi+ri
          wire(9,iw)=kolor
          wire(10,iw)=k ! racetrack number
          wire(11,iw)=icoil ! coil number
        enddo
      enddo

      ! fourth arc
      xc=xi-ri
      zc=-zi+ri
      sinphi1=0.0d0
      cosphi1=1.0d0
      do iphi=1,nphi
        sinphi2=sin(iphi*dphi)
        cosphi2=cos(iphi*dphi)
        do iy=1,ny
          do iz=1,nz
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc+r*cosphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc-r*sinphi1
            wire(6,iw)=+xc+r*cosphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc-r*sinphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! racetrack number
            wire(11,iw)=icoil ! coil number
          enddo
        enddo
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo


      !rotate and translate coil

      vnor(1)=vx
      vnor(2)=vy
      vnor(3)=vz
      call util_rotate_vector_to_y_axis(vnor,rotmat,istat)

      do i=1,3
        do j=1,3
          rmat(i,j)=rotmat(j,i)
        enddo
      enddo

      cosa=cos(alpha/180.0d0*pi1)
      sina=sin(alpha/180.0d0*pi1)

      do i=kold+1,iw
        wx=cosa*wire(3,i)+sina*wire(5,i)
        wy=wire(4,i)
        wz=-sina*wire(3,i)+cosa*wire(5,i)
        wire(3:5,i)=rmat(1:3,1)*wx+rmat(1:3,2)*wy+rmat(1:3,3)*wz
        wx=wire(6,i)
        wy=wire(7,i)
        wz=wire(8,i)
        wx=cosa*wire(6,i)+sina*wire(8,i)
        wy=wire(7,i)
        wz=-sina*wire(6,i)+cosa*wire(8,i)
        wire(6:8,i)=rmat(1:3,1)*wx+rmat(1:3,2)*wy+rmat(1:3,3)*wz
        wire(3,i)=wire(3,i)+x0
        wire(4,i)=wire(4,i)+y0
        wire(5,i)=wire(5,i)+z0
        wire(6,i)=wire(6,i)+x0
        wire(7,i)=wire(7,i)+y0
        wire(8,i)=wire(8,i)+z0
      enddo

      deallocate(y,z)

      ncwires=iw

      return
      end
+DECK,undumag_brace.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  10.05.19  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_brace(krace,xin,yin,zin,bxout,byout,bzout)

      use undumagf90m

      use commandlinef90m

      implicit none

      double precision xin,yin,zin,bxout,byout,bzout,wire7(7),bx,by,bz

      integer istat,krace,iw

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0
      istat=0

      do iw=ncfila+1,ncwires
        if (wire(2,iw).eq.0.0d0.or.
     &    abs(wire(3,iw)-wire(6,iw))+abs(wire(4,iw)-wire(7,iw))+
     &    abs(wire(5,iw)-wire(8,iw)).lt.1.0d-9) cycle
        wire7(1)=wire(2,iw)
        wire7(2:7)=wire(3:8,iw)/1000.0d0
        call undumag_bwireana(wire7,xin,yin,zin,bx,by,bz)
        if (by.ne.by) then
          write(lun6,*)iw,wire7
          write(lun6,*)"Ende"
          stop
        endif
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
      enddo

      return
      end
+DECK,undumag_uout.
*CMZ :  1.25/00 22/08/2023  09.03.52  by  Michael Scheer
*-- Author :    Michael Scheer   14/03/2018
      subroutine undumag_uout

      use undumagf90m
+self,if=uout.
      implicit none

      double precision bx,by,bz
      integer istat

      uservar(1)=1.0d0
      call undumag_bcoils(0.0d0,0.0d0,0.0d0,bx,by,bz,istat)

+self.
      return
      end
+DECK,undumag_arc_to_fila.
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.00/03 23/04/2018  13.28.57  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  14.00.37  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.53.53  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.53.23  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_arc_to_fila(k,icoil)

      use undumagf90m

      implicit none

+seq,phyconparam.

      double precision xx,yy,zz,curr,xc,yc,zc,rc,ri,ro,r,w,h,rmat(3,3),phi,
     &  phi0,dphi,dy,dr,wx,wy,wz,sinphi1,cosphi1,sinphi2,cosphi2,cw

      integer k,icoil,iw,ir,iy,iphi,nr,ny,nphi,i,kolor

c The arc is created in the x-z-plane, than rotated and shifted

      iw=ncwires

      curr=arc(1,k)

      xc=arc(2,k)
      yc=arc(3,k)
      zc=arc(4,k)

      rc=arc(5,k)

      w=arc(6,k)
      h=arc(7,k)
      phi=arc(8,k)*pi1/180.0d0

      nr=arc(9,k)
      ny=arc(11,k)
      nphi=arc(10,k)

      kolor=arc(12,k)

      rmat(1,1:3)=arc(13:15,k)
      rmat(2,1:3)=arc(16:18,k)
      rmat(3,1:3)=arc(19:21,k)

      dphi=phi/nphi
      dy=h/ny
      dr=w/nr

      ri=rc-w/2.0d0
      ro=ri+w

      cw=curr/(ny*nr)

      phi0=-phi/2.0d0
      sinphi1=sin(phi0)
      cosphi1=cos(phi0)
      do iphi=1,nphi
        sinphi2=sin(phi0+dphi)
        cosphi2=cos(phi0+dphi)
        do iy=1,ny
          yy=-h/2.0d0+(iy-0.5d0)*dy
          do ir=1,nr
            r=ri+(ir-0.5d0)*dr
            iw=iw+1
            wire(1,iw)=4 !type arc
            wire(2,iw)=cw
            xx=r*cosphi1
            zz=r*sinphi1
            wire(3,iw)=xx
            wire(4,iw)=yy
            wire(5,iw)=zz
            xx=r*cosphi2
            zz=r*sinphi2
            wire(6,iw)=xx
            wire(7,iw)=yy
            wire(8,iw)=zz
            wire(9,iw)=kolor
            wire(10,iw)=k ! arctrack number
            wire(11,iw)=icoil ! coil number
          enddo
        enddo
        phi0=phi0+dphi
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      !rotate and translate arc

      do i=ncwires+1,iw
        wx=wire(3,i)
        wy=wire(4,i)
        wz=wire(5,i)
        wire(3,i)=rmat(1,1)*wx+rmat(1,2)*wy+rmat(1,3)*wz+xc
        wire(4,i)=rmat(2,1)*wx+rmat(2,2)*wy+rmat(2,3)*wz+yc
        wire(5,i)=rmat(3,1)*wx+rmat(3,2)*wy+rmat(3,3)*wz+zc
        wx=wire(6,i)
        wy=wire(7,i)
        wz=wire(8,i)
        wire(6,i)=rmat(1,1)*wx+rmat(1,2)*wy+rmat(1,3)*wz+xc
        wire(7,i)=rmat(2,1)*wx+rmat(2,2)*wy+rmat(2,3)*wz+yc
        wire(8,i)=rmat(3,1)*wx+rmat(3,2)*wy+rmat(3,3)*wz+zc
      enddo

      ncwires=iw

      return
      end
+DECK,undumag_barc.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  16.48.51  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  10.05.19  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_barc(krace,xin,yin,zin,bxout,byout,bzout)

      use undumagf90m

      use commandlinef90m

      implicit none

      double precision xin,yin,zin,bxout,byout,bzout,wire7(7),bx,by,bz

      integer istat,krace,iw

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0
      istat=0

      do iw=ncfila+1,ncwires
        if (wire(2,iw).eq.0.0d0.or.
     &    abs(wire(3,iw)-wire(6,iw))+abs(wire(4,iw)-wire(7,iw))+
     &    abs(wire(5,iw)-wire(8,iw)).lt.1.0d-9) cycle
        wire7(1)=wire(2,iw)
        wire7(2:7)=wire(3:8,iw)/1000.0d0
        call undumag_bwireana(wire7,xin,yin,zin,bx,by,bz)
        if (by.ne.by) then
          write(lun6,*)iw,wire7
          write(lun6,*)"Ende"
          stop
        endif
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
      enddo

      return
      end
+DECK,undumag_wplanes.
*CMZ :  1.25/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  10.05.19  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_wplanes(k,xin,yin,zin,bxout,byout,bzout)

      use undumagf90m

      implicit none

      double precision xin,yin,zin,bxout,byout,bzout,wire7(7),bx,by,bz

      integer istat,k,iw

      return
      end
+DECK,undumag_circ_arc_to_fila.
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  14.01.51  by  Michael Scheer
*CMZ :  1.25/02 20/03/2018  18.02.01  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.53.53  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.53.23  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_circ_arc_to_fila(k,icoil)

      use undumagf90m

      use commandlinef90m

      implicit none

+seq,phyconparam.

      double precision xx,yy,zz,curr,xc,yc,zc,rc,r,rmat(3,3),phi,
     &  phi0,dphi,dr,wx,wy,wz,sinphi1,cosphi1,sinphi2,cosphi2,cw,
     &  alpha,dalpha,x0,z0,sina,cosa,rwire

      integer k,icoil,iw,ir,ia,iphi,nr,nalpha,nphi,i,kolor

c The arc is created in the x-z-plane, than rotated and shifted

      iw=ncwires

      curr=carc(1,k)

      xc=carc(2,k)
      yc=carc(3,k)
      zc=carc(4,k)

      rc=carc(5,k)
      rwire=carc(6,k)
      if (rc.le.rwire) then
        write(lun6,*)"*** Error in undumag_circ_arc_to_fila: Radius of arc",k,
     &    " lower than radius of wire ***"
        stop
      endif

      phi=carc(7,k)*pi1/180.0d0

      nr=carc(8,k)
      nalpha=carc(9,k)
      nphi=carc(10,k)

      kolor=carc(11,k)

      rmat(1,1:3)=carc(12:14,k)
      rmat(2,1:3)=carc(15:17,k)
      rmat(3,1:3)=carc(18:20,k)

      dphi=phi/nphi
      dalpha=twopi1/nalpha
      dr=rwire/nr

      cw=curr/(nalpha*nr)

      phi0=-phi/2.0d0
      sinphi1=sin(phi0)
      cosphi1=cos(phi0)
      do iphi=1,nphi
        sinphi2=sin(phi0+dphi)
        cosphi2=cos(phi0+dphi)
        do ir=1,nr
          r=(ir-0.5d0)*dr
          do ia=1,nalpha
            alpha=(ia-1)*dalpha
            sina=sin(alpha)
            cosa=cos(alpha)
            iw=iw+1
            wire(1,iw)=5 !type circ-arc
            xx=rc+r*cosa
            yy=r*sina
            zz=0.0d0
            wire(2,iw)=cw
            wire(3,iw)=xx*cosphi1
            wire(4,iw)=yy
            wire(5,iw)=xx*sinphi1
            wire(6,iw)=xx*cosphi2
            wire(7,iw)=yy
            wire(8,iw)=xx*sinphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! arctrack number
            wire(11,iw)=icoil ! coil number
          enddo
        enddo
        phi0=phi0+dphi
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      !rotate and translate arc

      do i=ncwires+1,iw
        wx=wire(3,i)
        wy=wire(4,i)
        wz=wire(5,i)
        wire(3,i)=rmat(1,1)*wx+rmat(1,2)*wy+rmat(1,3)*wz+xc
        wire(4,i)=rmat(2,1)*wx+rmat(2,2)*wy+rmat(2,3)*wz+yc
        wire(5,i)=rmat(3,1)*wx+rmat(3,2)*wy+rmat(3,3)*wz+zc
        wx=wire(6,i)
        wy=wire(7,i)
        wz=wire(8,i)
        wire(6,i)=rmat(1,1)*wx+rmat(1,2)*wy+rmat(1,3)*wz+xc
        wire(7,i)=rmat(2,1)*wx+rmat(2,2)*wy+rmat(2,3)*wz+yc
        wire(8,i)=rmat(3,1)*wx+rmat(3,2)*wy+rmat(3,3)*wz+zc
      enddo

      ncwires=iw

      return
      end
+DECK,undumag_bcircarc.
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.25/02 20/03/2018  17.15.30  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  16.48.51  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  10.05.19  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_bcircarc(krace,xin,yin,zin,bxout,byout,bzout)

      use undumagf90m

      use commandlinef90m

      implicit none

      double precision xin,yin,zin,bxout,byout,bzout,wire7(7),bx,by,bz

      integer istat,krace,iw

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0
      istat=0

      do iw=ncfila+1,ncwires
        if (wire(2,iw).eq.0.0d0.or.
     &    abs(wire(3,iw)-wire(6,iw))+abs(wire(4,iw)-wire(7,iw))+
     &    abs(wire(5,iw)-wire(8,iw)).lt.1.0d-9) cycle
        wire7(1)=wire(2,iw)
        wire7(2:7)=wire(3:8,iw)/1000.0d0
        call undumag_bwireana(wire7,xin,yin,zin,bx,by,bz)
        if (by.ne.by) then
          write(lun6,*)iw,wire7
          write(lun6,*)"Ende"
          stop
        endif
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
      enddo

      return
      end
+DECK,undumag_crace_to_fila.
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  13.59.39  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  10.39.49  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  15.08.36  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  16.51.35  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.53.23  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_crace_to_fila(k,icoil)

      use undumagf90m

      use commandlinef90m

      implicit none

+seq,phyconparam.

      double precision, dimension (:,:,:), allocatable :: zy

      double precision hdum,w,r,barl,curr,rwire,cw,vx,vy,vz,phi,alpha,cosa,sina,
     &  cosphi,sinphi,cosphi1,sinphi2,cosphi2,sinphi1,costhe,sinthe,
     &  xc,yc,zc,x0,y0,z0,dphi,dr,dy,ro,ri,xr1,zr1,xr2,zr2,vn,
     &  xi,xo,zi,zo,wx,wy,wz,ux,uy,uz,rotmat(3,3),vnor(3),rmat(3,3),
     &  delta,ddelta,rr,xx,yy,zz,zcw

      integer k,icoil,iw,ir,nr,nphi,iphi,iy,iz,kolor,ical,istat,i,j,id,
     &  ndelta,iarc1,iarc2,jarc1,jarc2,ihalf1,ihalf2,jhalf1,jhalf2

      data ical/0/

      save ical,iw

      !rotate (vx,vy,vz) to y-axis

      if (ical.eq.0) then
        ical=1
      endif

      iw=ncwires

      curr=crace(1,k)

      x0=crace(2,k)
      y0=crace(3,k)
      z0=crace(4,k)

      vx=crace(5,k)
      vy=crace(6,k)
      vz=crace(7,k)

      vn=sqrt(vx**2+vy**2+vz**2)
      if (vn.eq.0.0d0) then
        write(lun6,*)
        write(lun6,*)"*** Error in undumag_crace_to_fila: Zero normal vector for coil",k
        stop
      endif
      vx=vx/vn
      vy=vy/vn
      vz=vz/vn

      alpha=crace(8,k)
      xo=crace(9,k)/2.0d0
      zi=crace(10,k)/2.0d0
      zo=crace(11,k)/2.0d0
      rwire=(zo-zi)/2.0d0
      ri=crace(12,k)
      hdum=crace(13,k)
      nr=crace(14,k)
      ndelta=crace(15,k)
      nphi=crace(16,k)
      kolor=crace(17,k)

      w=zo-zi
      xi=xo-w
      ro=ri+w

      yc=0.0d0

      if (ri.gt.zi) then
        write(lun6,*)
        write(lun6,*)"*** Error in undumag_crace_to_fila: Inner radius of coils is greater than the inner width ***"
        stop
      endif

      dr=rwire/nr
      dphi=pi1/2.0d0/nphi
      ddelta=twopi1/ndelta

      cw=curr/(nr*ndelta)

      allocate(zy(2,ndelta,nr))

      ! first x bar
      do ir=1,nr
        rr=(ir-0.5d0)*dr
        do id=1,ndelta
          delta=(id-1)*ddelta
          cosa=cos(delta)
          sina=sin(delta)
          iw=iw+1
          wire(1,iw)=3 ! cracetrack flag
          wire(2,iw)=cw
          wire(3,iw)=+xi-ri
          wire(4,iw)=rr*sina
          wire(5,iw)=-(zi+rwire+rr*cosa)
          zy(1,id,ir)=rr*cosa
          zy(2,id,ir)=rr*sina
          wire(6,iw)=-xi+ri
          wire(7,iw)=wire(4,iw)
          wire(8,iw)=wire(5,iw)
          wire(9,iw)=kolor
          wire(10,iw)=k ! cracetrack number
          wire(11,iw)=icoil ! coil number
        enddo
      enddo

      iarc1=iw+1

      ! first arc
      xc=-xi+ri
      zc=-zi+ri
      zcw=-zi-rwire
      sinphi1=0.0d0
      cosphi1=1.0d0
      do iphi=1,nphi
        sinphi2=sin(iphi*dphi)
        cosphi2=cos(iphi*dphi)
        do ir=1,nr
          do id=1,ndelta
            iw=iw+1
            yy=zy(2,id,ir)
            r=abs(zcw-zy(1,id,ir)-zc)
            xx=xc-r*sinphi1
            zz=zc-r*cosphi1
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=xx
            wire(4,iw)=yy
            wire(5,iw)=zz
            xx=xc-r*sinphi2
            zz=zc-r*cosphi2
            wire(6,iw)=xx
            wire(7,iw)=yy
            wire(8,iw)=zz
            wire(9,iw)=kolor
            wire(10,iw)=k ! cracetrack number
            wire(11,iw)=icoil ! coil number
          enddo
        enddo
        sinphi1=sinphi2
        cosphi1=cosphi2
      enddo

      iarc2=iw

      ! first z bar
      do ir=1,nr
        do id=1,ndelta
          iw=iw+1
          wire(1,iw)=2 ! cracetrack flag
          wire(2,iw)=cw
          wire(3:5,iw)=wire(6:8,iw-nr*ndelta)
          wire(6:7,iw)=wire(6:7,iw-nr*ndelta)
          wire(8,iw)=wire(8,iw-nr*ndelta)+2.0d0*(zi-ri)
          wire(9,iw)=kolor
          wire(10,iw)=k ! cracetrack number
          wire(11,iw)=icoil ! coil number
        enddo
      enddo

      ! second arc

      jarc1=iw+1
      jarc2=iw+iarc2-iarc1+1

      wire(1:11,jarc1:jarc2)=wire(1:11,iarc1:iarc2)

      xc=-xi+ri
      zc=-zi+ri

      do i=jarc1,jarc2
        xx=wire(3,i)-xc
        zz=wire(5,i)-zc
        wire(3,i)=zz+xc
        wire(5,i)=-xx-zc
        xx=wire(6,i)-xc
        zz=wire(8,i)-zc
        wire(6,i)=zz+xc
        wire(8,i)=-xx-zc
      enddo

      iw=jarc2

      ihalf1=ncwires+1
      ihalf2=iw
      jhalf1=iw+1
      jhalf2=iw+ihalf2-ihalf1+1

      wire(1:11,jhalf1:jhalf2)=wire(1:11,ihalf1:ihalf2)

      do i=jhalf1,jhalf2
        iw=iw+1
        xx=wire(3,i)
        zz=wire(5,i)
        wire(3,i)=-xx
        wire(5,i)=-zz
        xx=wire(6,i)
        zz=wire(8,i)
        wire(6,i)=-xx
        wire(8,i)=-zz
      enddo

      !rotate and translate coil

      vnor(1)=vx
      vnor(2)=vy
      vnor(3)=vz
      call util_rotate_vector_to_y_axis(vnor,rotmat,istat)

      do i=1,3
        do j=1,3
          rmat(i,j)=rotmat(j,i)
        enddo
      enddo

      cosa=cos(alpha/180.0d0*pi1)
      sina=sin(alpha/180.0d0*pi1)

      do i=ncwires+1,iw
        wx=cosa*wire(3,i)+sina*wire(5,i)
        wy=wire(4,i)
        wz=-sina*wire(3,i)+cosa*wire(5,i)
        wire(3:5,i)=rmat(1:3,1)*wx+rmat(1:3,2)*wy+rmat(1:3,3)*wz
        wx=wire(6,i)
        wy=wire(7,i)
        wz=wire(8,i)
        wx=cosa*wire(6,i)+sina*wire(8,i)
        wy=wire(7,i)
        wz=-sina*wire(6,i)+cosa*wire(8,i)
        wire(6:8,i)=rmat(1:3,1)*wx+rmat(1:3,2)*wy+rmat(1:3,3)*wz
        wire(3,i)=wire(3,i)+x0
        wire(4,i)=wire(4,i)+y0
        wire(5,i)=wire(5,i)+z0
        wire(6,i)=wire(6,i)+x0
        wire(7,i)=wire(7,i)+y0
        wire(8,i)=wire(8,i)+z0
      enddo

      ncwires=iw

      deallocate(zy)

      return
      end
+DECK,undumag_bar_to_fila.
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.00/03 20/04/2018  12.36.16  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  14.02.48  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  16.36.44  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  14.48.44  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  16.51.35  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.53.23  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_bar_to_fila(k,icoil)

      use undumagf90m

      implicit none

+seq,phyconparam.

      double precision w,h,xc,yc,zc,xx,yy,zz,rmat(3,3),x0,y0,z0,dz,dy,dl,
     &  curr,cw

      integer k,icoil,iw,nz,ny,kolor,iz,iy

      iw=ncwires

      curr=rectbar(1,k)

      x0=rectbar(2,k)
      y0=rectbar(3,k)
      z0=rectbar(4,k)

      dl=rectbar(5,k)
      w=rectbar(6,k)
      h=rectbar(7,k)
      nz=rectbar(8,k)
      ny=rectbar(9,k)
      kolor=rectbar(10,k)

      rmat(1,1:3)=rectbar(11:13,k)
      rmat(2,1:3)=rectbar(14:16,k)
      rmat(3,1:3)=rectbar(17:19,k)

      dy=h/ny
      dz=w/nz

      cw=curr/(ny*nz)

      xx=dl/2.0d0
      do iy=1,ny
        yy=-h/2.0d0+(iy-0.5d0)*dy
        do iz=1,nz
          iw=iw+1
          zz=-w/2.0d0+(iz-0.5d0)*dz
          wire(1,iw)=6 ! type bar
          wire(2,iw)=cw
          wire(3,iw)=-rmat(1,1)*xx+rmat(1,2)*yy+rmat(1,3)*zz+x0
          wire(4,iw)=-rmat(2,1)*xx+rmat(2,2)*yy+rmat(2,3)*zz+y0
          wire(5,iw)=-rmat(3,1)*xx+rmat(3,2)*yy+rmat(3,3)*zz+z0
          wire(6,iw)= rmat(1,1)*xx+rmat(1,2)*yy+rmat(1,3)*zz+x0
          wire(7,iw)= rmat(2,1)*xx+rmat(2,2)*yy+rmat(2,3)*zz+y0
          wire(8,iw)= rmat(3,1)*xx+rmat(3,2)*yy+rmat(3,3)*zz+z0
          wire(9,iw)=kolor
          wire(10,iw)=k ! number
          wire(11,iw)=icoil ! coil number
        enddo
      enddo

      ncwires=iw

      return
      end
+DECK,undumag_thwire_to_fila.
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  14.03.16  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  17.08.17  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  14.48.44  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  16.51.35  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.53.23  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_thwire_to_fila(k,icoil)

      use undumagf90m

      implicit none

+seq,phyconparam.

      double precision w,h,xc,yc,zc,xx,yy,zz,rmat(3,3),x0,y0,z0,dphi,dr,dl,
     &  curr,cw,phi,r

      integer k,icoil,iw,nr,nphi,kolor,ir,iphi

      iw=ncwires

      curr=thickwire(1,k)

      x0=thickwire(2,k)
      y0=thickwire(3,k)
      z0=thickwire(4,k)

      dl=thickwire(5,k)
      r=thickwire(6,k)
      nr=thickwire(7,k)
      nphi=thickwire(8,k)
      kolor=thickwire(9,k)

      rmat(1,1:3)=thickwire(10:12,k)
      rmat(2,1:3)=thickwire(13:15,k)
      rmat(3,1:3)=thickwire(16:18,k)

      dphi=twopi1/nphi
      dr=r/nr

      cw=curr/(nphi*nr)

      xx=dl/2.0d0
      do ir=1,nr
        r=(ir-0.5d0)*dr
        phi=-dphi
        do iphi=1,nphi
          iw=iw+1
          phi=phi+dphi
          yy=r*sin(phi)
          zz=r*cos(phi)
          wire(1,iw)=7 ! type thick wire
          wire(2,iw)=cw
          wire(3,iw)=-rmat(1,1)*xx+rmat(1,2)*yy+rmat(1,3)*zz+x0
          wire(4,iw)=-rmat(2,1)*xx+rmat(2,2)*yy+rmat(2,3)*zz+y0
          wire(5,iw)=-rmat(3,1)*xx+rmat(3,2)*yy+rmat(3,3)*zz+z0
          wire(6,iw)= rmat(1,1)*xx+rmat(1,2)*yy+rmat(1,3)*zz+x0
          wire(7,iw)= rmat(2,1)*xx+rmat(2,2)*yy+rmat(2,3)*zz+y0
          wire(8,iw)= rmat(3,1)*xx+rmat(3,2)*yy+rmat(3,3)*zz+z0
          wire(9,iw)=kolor
          wire(10,iw)=k ! number
          wire(11,iw)=icoil ! coil number
        enddo
      enddo

      ncwires=iw

      return
      end
+DECK,undumag_bcoilsinf.
*CMZ :  1.25/03 22/08/2023  09.03.52  by  Michael Scheer
*-- Author :    Michael Scheer   26/03/2018
      subroutine undumag_bcoilsinf(yin,zin,byint,bzint,istat)

      use undumagf90m

      implicit none

      double precision yin,zin,byint,bzint,byi,bzi,wire7(7)

      integer istat,iw

      istat=0

      byint=0.0d0
      bzint=0.0d0

      do iw=1,ncwires
        wire7(1)=wire(2,iw)
        wire7(2:7)=wire(3:8,iw)/1000.0d0
        call undumag_bwireinf(wire7,yin,zin,byi,bzi,istat)
        byint=byint+byi
        bzint=bzint+bzi
      enddo

      if (abs(byint).lt.1.0d-15) byint=0.0d0
      if (abs(bzint).lt.1.0d-15) bzint=0.0d0

      return
      end
+DECK,undumag_bpolyeder1_sym.
*CMZ :  2.01/03 22/08/2023  09.03.52  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bpolyeder1_sym(imag,x,y,z,bxout,byout,bzout,ifail)

+seq,bpolyederf90u.
      use undumagf90m

      implicit none

      double precision x,y,z,bxout,byout,bzout,xcut,hx,hy,hz
      integer imag,ifail,kfail,linside,ifailin

      ifailin=ifail
      ifail=0

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      call undumag_bpolyeder1(imag,x,y,z,bxout,byout,bzout,ifail)

      if (ixsym.eq.0) then

        if (iysym.ne.0) then
          kfail=ifailin
          call undumag_bpolyeder1(imag,x,-y,z,hx,hy,hz,kfail)
          ifail=ifail+kfail
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          bxout=bxout-hx
          byout=byout+hy
          bzout=bzout-hz
        endif

        if (izsym.ne.0) then
          kfail=ifailin
          call undumag_bpolyeder1(imag,x,y,-z,hx,hy,hz,kfail)
          ifail=ifail+kfail
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          bxout=bxout+hx
          byout=byout+hy
          bzout=bzout-hz
        endif

        if (iysym.ne.0.and.izsym.ne.0) then
          kfail=ifailin
          call undumag_bpolyeder1(imag,x,-y,-z,hx,hy,hz,kfail)
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          ifail=ifail+kfail
          bxout=bxout-hx
          byout=byout+hy
          bzout=bzout+hz
        endif

      else !ixsym

        xcut=2.0d0*xsym-x

        !x2y1z1
        kfail=ifailin
        call undumag_bpolyeder1(imag,xcut,y,z,hx,hy,hz,kfail)
        ifail=ifail+kfail
        if (kinside.gt.0) then
          linside=kinside
          kinside=0
        endif
        bxout=bxout-hx
        byout=byout+hy
        bzout=bzout+hz

        if (iysym.ne.0) then
          !x1y2z1
          kfail=ifailin
          call undumag_bpolyeder1(imag,x,-y,z,hx,hy,hz,kfail)
          ifail=ifail+kfail
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          bxout=bxout-hx
          byout=byout+hy
          bzout=bzout-hz
          !x2y1z1
          kfail=ifailin
          call undumag_bpolyeder1(imag,xcut,-y,z,hx,hy,hz,kfail)
          ifail=ifail+kfail
          bxout=bxout+hx
          byout=byout+hy
          bzout=bzout-hz
        endif

        if (izsym.ne.0) then
          !x1y1z2
          kfail=ifailin
          call undumag_bpolyeder1(imag,x,y,-z,hx,hy,hz,kfail)
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          ifail=ifail+kfail
          bxout=bxout+hx
          byout=byout+hy
          bzout=bzout-hz
          !x2y1z2
          kfail=ifailin
          call undumag_bpolyeder1(imag,xcut,y,-z,hx,hy,hz,kfail)
          ifail=ifail+kfail
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          bxout=bxout-hx
          byout=byout+hy
          bzout=bzout-hz
        endif

        if (iysym.ne.0.and.izsym.ne.0) then
          !x2y2z2
          kfail=ifailin
          call undumag_bpolyeder1(imag,xcut,-y,-z,hx,hy,hz,kfail)
          ifail=ifail+kfail
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          bxout=bxout+hx
          byout=byout+hy
          bzout=bzout+hz
          !x1y2z2
          kfail=ifailin
          call undumag_bpolyeder1(imag,x,-y,-z,hx,hy,hz,kfail)
          ifail=ifail+kfail
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          bxout=bxout-hx
          byout=byout+hy
          bzout=bzout+hz
        endif

      endif !ixsym

      return
      end
+DECK,undumag_bpolyeder_single.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.01/08 14/08/2020  07.33.39  by  Michael Scheer
*-- Author :    Michael Scheer   13/08/2020
      subroutine undumag_bpolyeder_single(xin,yin,zin,bxout,byout,bzout,ifail)

+self,if=omp.
      use omp_lib
+self.
      use bpolyederf90m
      use undumagf90m

      use commandlinef90m

      implicit none
+seq,seqdebug.

      double precision xin,yin,zin,bxout,byout,bzout,bo(3,nthreadp)


      integer nmaxth,ith,ifail,ic,imag,
     &  kfail(nthreadp),kinsidelocal(nthreadp)

c calculate field at (xin,yin,zin)

      if (magmag.lt.0) then
        return
      endif !magmag.le.0

      nmaxth=1
      ith=1
      nmaxth=nthreads
+self,if=omp.
      nmaxth=OMP_GET_MAX_THREADS()
      if (nthreads.gt.0) nmaxth=min(nmaxth,nthreads,nthreadp)
+self.
c        write(lun6,*)"Number of CPU cores used:",nmaxth

      bo=0.0d0
      kfail=0
      kinsidelocal=kinside

!$OMP PARALLEL NUM_THREADS(nmaxth) DEFAULT(PRIVATE)
!$OMP& SHARED(bo,kfail,kinsidelocal)
!$OMP& FIRSTPRIVATE(nmaxth,nmag,xin,yin,zin,magmag)
+self,if=-omp.
      ith=1
+self,if=omp.
      ith=OMP_GET_THREAD_NUM()+1
+self.
      bo(1:3,ith)=0.0d0
!$OMP DO

      do imag=1,nmag

        call undumag_bpolyeder1_sym(imag,xin,yin,zin,bxout,byout,bzout,ifail)

        if (ifail.ne.0) kfail(ith)=ifail
        if (kinside.ne.0) kinsidelocal(ith)=kinside

        bo(1,ith)=bo(1,ith)+bxout
        bo(2,ith)=bo(2,ith)+byout
        bo(3,ith)=bo(3,ith)+bzout

      enddo !imag=1,nmag

!$OMP END DO
!$OMP END PARALLEL

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      ifail=0
      kinside=0

      do ic=1,nmaxth
        ifail=ifail+kfail(ic)
        if (kinsidelocal(ic).ne.0) kinside=kinsidelocal(ic)
        bxout=bxout+bo(1,ic)
        byout=byout+bo(2,ic)
        bzout=bzout+bo(3,ic)
      enddo

      return
      end
+DECK,undumag_bcoils_omp.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.01/08 14/08/2020  10.22.50  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  12.08.59  by  Michael Scheer
*CMZ :  2.00/02 17/04/2018  13.43.36  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  15.38.41  by  Michael Scheer
*CMZ :  2.00/00 09/04/2018  12.17.36  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.27.23  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  17.02.28  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  12.54.05  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.04.47  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.51.10  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_bcoils_omp(xin,yin,zin,bxout,byout,bzout,istat)

      use omp_lib
      use undumagf90m

      implicit none

      double precision, dimension (:,:), allocatable :: wold
      double precision xin,yin,zin,bxout,byout,bzout,wire7(7,nthreadp),
     &  bx,by,bz,
     &  bo(3,nthreadp)

      integer istat,i,ith,nmaxth,nthreads

      character(2048) cline

      if (ncwires.eq.0) return

      istat=0
      bo=0.0d0

      nmaxth=1
+self,if=omp.
      nmaxth=OMP_GET_MAX_THREADS()
+self.
      if (nthreads.gt.0) nmaxth=min(nmaxth,nthreads)

!$OMP PARALLEL NUM_THREADS(nmaxth) DEFAULT(PRIVATE)
!$OMP& SHARED(bo,wire)
!$OMP& FIRSTPRIVATE(ncwires,xin,yin,zin)
!$OMP DO

      do i=1,ncwires

+self,if=-omp.
        ith=1
+self,if=omp.
        ith=OMP_GET_THREAD_NUM()+1
+self.
        if (wire(2,i).eq.0.0d0) cycle

        wire7(1,ith)=wire(2,i)
        wire7(2:7,ith)=wire(3:8,i)/1000.0d0

        call undumag_bwireana(wire7(1:7,ith),xin,yin,zin,bx,by,bz)

        bo(1,ith)=bo(1,ith)+bx
        bo(2,ith)=bo(2,ith)+by
        bo(3,ith)=bo(3,ith)+bz

      enddo

!$OMP END DO
!$OMP END PARALLEL

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      do ith=1,nmaxth
        bxout=bxout+bo(1,ith)
        byout=byout+bo(2,ith)
        bzout=bzout+bo(3,ith)
      enddo

      if (abs(bxout).lt.1.0d-9) bxout=0.0d0
      if (abs(byout).lt.1.0d-9) byout=0.0d0
      if (abs(bzout).lt.1.0d-9) bzout=0.0d0

      return
      end
+DECK,undumag_drop_zero_magnets.
*CMZ :  2.04/10 23/08/2023  14.26.17  by  Michael Scheer
*CMZ :  2.04/03 03/03/2023  11.23.27  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  14.26.12  by  Michael Scheer
*CMZ :  2.02/02 03/07/2022  15.34.20  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.49  by  Michael Scheer
*CMZ :  2.02/00 30/03/2021  15.24.45  by  Michael Scheer
*-- Author :    Michael Scheer   10/09/2020
      subroutine undumag_drop_zero_magnets(kfoundplanes,kecho,tiny)

      use commandlinef90m
      use commandlinef90m

      implicit none

      ! Drop zero magnetig items and apply coating to permanent magnets,
      ! i.e. shrinking of the magnet to the effective size

c loop over magnets, modules, and arrays {

      double precision coating,bc,xm,ym,zm,rmin,rmax,polhei,ang,r,dx,dy,dz,
     &  xbuff(1000),ybuff(1000),zbuff(1000),cen(3),chamf,tiny

      integer lunbpe, lunscr,ieof,nlines,iline,imat,istat,iend,ianf,i,npoints,
     &  ndl,itreat,nmodules,narrays,ipos(2,1000),ncom,nwords,nfirst,nlast,icomment,
     &  l,nbuff,materials(2,1000),nmat,n9999,kmat,lundat,nread,kcorn,nxdiv,nydiv,nzdiv,kcol,
     &  kfoundplanes,kblock,kblockch,kecho,icomread,iplan,nplan,icorn,ncorn,ios

      integer nshrink
      character(2) cshrink

      integer :: nmag=0

      character(512) cline,clinelower,cline1,cline2,cline3,cdum,cbuff(1000),
     &  cplan,comdum
      character(64) c64,chmag,chmoth

+seq,phyconparam.

+self,if=trace.
      print*
      print*,"-trace-: Entered undumag_drop_zero_magnets"
      print*,"kfoundplanes, kecho",kfoundplanes,kecho
+self.

      coating=0.0d0
      open(newunit=lunbpe,file=trim(Fclc))

      ieof=0

      cline=''
      cline1=''
      cline2=''
      cline3=''

      do while (ieof.eq.0)

        read(lunbpe,'(a)')cline
        cline=trim(adjustl(cline))
c        c64='*EndCalc'
        if (cline(1:8).eq.'*EndCalc') exit
c        call util_string_substring(cline,trim(c64),ianf,iend,istat)
c        if (istat.eq.0) exit

        c64='mcoating'
        clinelower=cline
        call util_lower_case(clinelower)
        call util_string_substring(clinelower,trim(c64),ianf,iend,istat)
c        write(lun6,*)trim(cline),istat
        if (istat.eq.0) then
          l=len_trim(cline)
          do i=2,l
            if (cline(i:i).eq.'=') exit
          enddo
          read(cline(i+1:l),*) coating
          if (coating.ne.0.0d0.and.kfoundplanes.ne.0) then
            write(lun6,*)" "
            write(lun6,*)"*** Warning: Coating option is not available for magnetic items defined by planes ***"
            write(lun6,*)" "
            call sleep(3)
          endif
          exit
        endif
      enddo

      close(lunbpe)

+self,if=trace.
      print*
      print*,"-trace-: Mark 1"
+self.

      open(newunit=lunbpe,file="undumag.in")
      open(newunit=lunscr,file='undumag.scr')

      nlines=0
      ieof=0
      n9999=0
      icomment=0
      imat=0

      do while (ieof.eq.0)

        read(lunbpe,'(a)',end=9,err=9)cline
        cline=trim(adjustl(cline))
        nlines=nlines+1
+self,if=trace.
        print*,"nlines:",nlines
+self.
        write(lunscr,'(a)')trim(cline)

        if (cline3(1:1).eq.'{') then
          icomment=1
          cycle
        endif

        if (cline(1:1).eq.'*'.or.cline(1:1).eq.'!'.or.icomment.eq.1) cycle

        if (cline(1:1).eq.'}') then
          icomment=0
          cycle
        endif

        c64='File'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)
        if (istat.eq.0) then
          read(lunbpe,'(a)',end=9,err=9)cline
          cline=trim(adjustl(cline))
          nread=0
          open(newunit=lundat,file=trim(cline),status='old')
          do while (istat.eq.0)
            call util_skip_comment_end(lundat,istat)
            if (istat.ne.0) then
              close(lundat)
              exit
            else
              nread=nread+1
              read(lundat,'(a)')cbuff(nread)
            endif
          enddo
          write(cline,*) nread
          call util_string_trim(cline,nfirst,nlast)
          write(lunscr,'(a)')cline(nfirst:nlast)
          nlines=nlines+1
          do i=1,nread
            nlines=nlines+1
            write(lunscr,'(a)')trim(cbuff(i))
          enddo
          cycle
        endif

        c64='-9999.'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)
        if (istat.eq.0) then
          n9999=n9999+1
          cycle
        endif

        if (n9999.eq.2) then
          read(cline,*) nmat
          n9999=3
          cycle
        endif

        if (n9999.eq.3.and.imat.lt.nmat) then
          imat=imat+1
          read(cline,*)materials(1:2,imat)
        endif

      enddo

9     continue
      flush(lunscr)
      close(lunscr)

+self,if=trace.
      print*
      print*,"-trace-: Mark 2"
      print*
+self.
      open(newunit=lunscr,file='undumag.scr')
      flush(lunbpe)
      close(lunbpe)

      open(newunit=lunbpe,file="undumag.in")

      itreat=0
      icomment=0
      icomread=-1

      do iline=1,nlines

        if (icomread.eq.0) icomread=1

        if (
     &    cline2(1:1).ne.'*'.and.cline2(1:1).ne.'!'.and.
     &    cline2(1:1).ne.'{'.and.cline2(1:1).ne.'}'
     &    ) cline1=cline2

        if (
     &    cline3(1:1).ne.'*'.and.cline3(1:1).ne.'!'.and.
     &    cline3(1:1).ne.'{'.and.cline3(1:1).ne.'}'
     &    ) cline2=cline3

        read(lunscr,'(a)',end=9999)cline3
        cline3=trim(adjustl(cline3))

        if (kecho.ne.0) print*,trim(cline3)

c        write(lun6,*)iline
c        write(lun6,*)trim(cline3)

        c64='*EndCalc'
        call util_string_substring(cline3,trim(c64),ianf,iend,istat)

        if (istat.eq.0) then
          itreat=1 !EndCalc marker found
          write(lunbpe,'(a)')trim(cline3)
          do while (cline3(1:1).eq.'*'.or.cline3(1:1).eq.'!')
            read(lunscr,'(a)')cline3
            cline3=trim(adjustl(cline3))
            write(lunbpe,'(a)')trim(cline3)
            icomread=0
          enddo
c          cycle
        endif

        if (cline3(1:1).eq.'{') icomment=1

        if (cline3(1:1).eq.'*'.or.cline3(1:1).eq.'!'.or.icomment.eq.1) then
          write(lunbpe,'(a)')trim(cline3)
          if (cline3(1:1).eq.'}') icomment=0
          cycle
        endif

        cdum=''

        if (itreat.eq.1.or.itreat.eq.6) then
          c64='-9999.'
          call util_string_substring(cline3,trim(c64),ianf,iend,istat)
          if (icomread.eq.1.and.istat.eq.0) then
            read(cline3,*,err=99)xm,ym,zm
            if (xm.eq.-9999.0d0.and.ym.eq.-9999.0d0.and.zm.eq.-9999.0d0) then
              itreat=itreat+1
              write(lunbpe,'(a)')trim(cline3)
              cycle
            endif
          endif !istat
99        continue
        else if (itreat.eq.2) then !read number of module blocks
          read(cline3,*)nmodules
          write(lunbpe,'(a)')trim(cline3)
          itreat=3
          cycle
        else if (itreat.eq.3) then !read module blocks
          backspace(lunscr)
          ndl=1
          do while (ndl.le.nmodules*4)
            read(lunscr,'(a)')cline
            cline=trim(adjustl(cline))
            if (cline(1:1).ne.'*'.and.cline(1:1).ne.'!') then
              ndl=ndl+1
            endif
            write(lunbpe,'(a)') trim(cline)
          enddo
          itreat=4
          cycle
        else if (itreat.eq.4) then !read number of arrays
          read(cline3,*)narrays
          itreat=5
          write(lunbpe,'(a)')trim(cline3)
          cycle
        else if (itreat.eq.5) then !read arrays
          backspace(lunscr)
          ndl=1
          do while (ndl.le.2)
            read(lunscr,'(a)')cline
            cline=trim(adjustl(cline))
            if (cline(1:1).ne.'*'.and.cline(1:1).ne.'!') then
              ndl=ndl+1
            endif
            write(lunbpe,'(a)') trim(cline)
          enddo
          itreat=6
          cycle
        endif !itreat


        !Old format with planes?
        if (icomread.eq.1.and.(itreat.eq.1.or.itreat.eq.6)) then
          read(cline3,*,iostat=ios) nplan,kcol,nxdiv,nydiv,nzdiv
          if (ios.eq.0.and.nplan.gt.0) then
            read(cline2,*) bc
            if (bc.ne.0.0d0) then
              write(lunbpe,'(a)')'*'
              nmag=nmag+1
              call util_string_split_sep(cline1,1000,ncom,ipos,'!',istat)
              if (ncom.gt.1) then
                comdum=cline1(ipos(1,2):ipos(2,2))
              endif
              cdum=cline1(ipos(1,1):ipos(2,1))
              call util_string_split_sep(cdum,1000,nwords,ipos,' ',istat)
              if (nwords.ne.5) then
                write(chmag,*) nmag
                chmag="mp_" // trim(adjustl(chmag))
                chmoth=chmag
                chmoth(1:1)="M"
                cline1=trim(cdum)//" "//adjustl(trim(chmag))//" "//adjustl(trim(chmoth))
                if (ncom.gt.1) cline1=trim(cline1) // " " // " "//trim(comdum)
              endif
              write(lunbpe,'(a)')trim(cline1)
              write(lunbpe,'(a)')trim(cline2)
              write(lunbpe,'(a)') trim(cline3)
            endif !bc
            do iplan=1,nplan
2             read(lunscr,'(a)') cplan
              if (cplan(1:1).eq.'{') then
                do while(cplan(1:1).ne.'}')
                  read(lunscr,'(a)') cplan
                enddo
              endif
              if (bc.ne.0.0d0) write(lunbpe,'(a)') trim(cplan)
              if (cplan(1:1).eq.'*') goto 2
              read(cplan,*) ncorn
              do icorn=1,ncorn
3               read(lunscr,'(a)') cplan
                if (cplan(1:1).eq.'{') then
                  do while(cplan(1:1).ne.'}')
                    read(lunscr,'(a)') cplan
                  enddo
                endif
                if (cplan(1:1).eq.'*') goto 3
                if (bc.ne.0.0d0) write(lunbpe,'(a)') trim(cplan)
              enddo !ncorn
            enddo !nplan
          endif !have planes
        endif

        c64='Cyl'
c        call util_string_substring(cline3,trim(c64),ianf,iend,istat)

        if (icomread.eq.1.and.cline3(1:3).eq.'Cyl') then

          read(cline1,*)cen
          read(cline2,*)bc,xm,ym,zm,imat

          if (imat.eq.0) then
            bc=0.0d0
            kmat=0
          else
            kmat=materials(2,imat)
          endif

          if (bc.ne.0.0d0) then
            write(lunbpe,'(a)')'*'
            nmag=nmag+1
            call util_string_split_sep(cline1,1000,ncom,ipos,'!',istat)
            if (ncom.gt.1) then
              comdum=cline1(ipos(1,2):ipos(2,2))
            endif
            cdum=cline1(ipos(1,1):ipos(2,1))
            call util_string_split_sep(cdum,1000,nwords,ipos,' ',istat)
            if (nwords.ne.5) then
              write(chmag,*) nmag
              chmag="mp_" // trim(adjustl(chmag))
              chmoth=chmag
              chmoth(1:1)="M"
              cline1=trim(cdum)//" "//adjustl(trim(chmag))//" "//adjustl(trim(chmoth))
              if (ncom.gt.1) cline1=trim(cline1) // " " // " "//trim(comdum)
            endif
            write(lunbpe,'(a)')trim(cline1)
            write(lunbpe,'(a)')trim(cline2)
            write(lunbpe,'(a)') trim(cline3)
          endif !bc

          ndl=1
          do while (ndl.le.4)
            read(lunscr,'(a)')cline
            cline=trim(adjustl(cline))
            if (cline(1:1).eq.'*'.or.cline(1:1).eq.'!') then
              cycle
            else
              ndl=ndl+1
            endif
            if (bc.ne.0.0d0.and.kmat.ne.0) then
              if (coating.ne.0.0d0.and.kmat.ne.2) then
                call util_string_split(cline,1000,nwords,ipos,istat)
                if (nwords.gt.4) cdum=cline(ipos(1,5):len_trim(cline))
                read(cline,*)rmin,rmax,polhei,ang
                r=(rmax-rmin)/2.0d0
                rmin=rmin+coating
                rmax=rmax-coating
                if (r.gt.0.0d0.and.abs(ang-twopi1).gt.2.0d0*coating/r)
     &            ang=ang-2.0d0*coating/r
                write(cline,*) rmin,rmax,polhei,ang
                write(lunbpe,'(a)') trim(cline)
                call util_string_trim(cline,nfirst,nlast)
                cline=cline(nfirst:nlast) // " " // trim(cdum)
              endif !coat
              write(lunbpe,'(a)') trim(cline)
            endif !bc
          enddo
          cycle
        endif

        kblockch=0

        c64='BlockUsChamf'
        call util_string_substring(cline3,trim(c64),ianf,iend,istat)
        if (icomread.eq.1.and.istat.eq.0) then
          kblockch=-1
          cline3='Corners ' // cline3(iend+1:len_trim(cline3))
        endif

        c64='BlockDsChamf'
        call util_string_substring(cline3,trim(c64),ianf,iend,istat)
        if (icomread.eq.1.and.istat.eq.0) then
          kblockch=1
          cline3='Corners ' // cline3(iend+1:len_trim(cline3))
        endif

        if (kblockch.ne.0) then

          read(cline1,*)cen
          read(cline2,*)bc,xm,ym,zm,imat

          if (imat.eq.0) then
            bc=0.0d0
            kmat=0
          else
            kmat=materials(2,imat)
          endif

          if (bc.ne.0.0d0) then
            write(lunbpe,'(a)')'*'
            nmag=nmag+1
            call util_string_split_sep(cline1,1000,ncom,ipos,'!',istat)
            if (ncom.gt.1) then
              comdum=cline1(ipos(1,2):ipos(2,2))
            endif
            cdum=cline1(ipos(1,1):ipos(2,1))
            call util_string_split_sep(cdum,1000,nwords,ipos,' ',istat)
            if (nwords.ne.5) then
              write(chmag,*) nmag
              chmag="mp_" // trim(adjustl(chmag))
              chmoth=chmag
              chmoth(1:1)="M"
              cline1=trim(cdum)//" "//adjustl(trim(chmag))//" "//adjustl(trim(chmoth))
              if (ncom.gt.1) cline1=trim(cline1) // " " // " "//trim(comdum)
            endif
            write(lunbpe,'(a)')trim(cline1)
            write(lunbpe,'(a)')trim(cline2)
            write(lunbpe,'(a)')trim(cline3)
          endif !bc

          ndl=1
          do while (ndl.le.1)
            read(lunscr,'(a)')cline
            cline=trim(adjustl(cline))
            if (cline(1:1).eq.'*'.or.cline(1:1).eq.'!') then
              cycle
            else
              ndl=ndl+1
            endif
            if (bc.ne.0.0d0) then
                call util_string_split(cline,1000,nwords,ipos,istat)
                if (nwords.gt.4) cdum=cline(ipos(1,5):len_trim(cline))
                read(cline,*)dx,dy,dz,chamf
                if (kmat.eq.2) then
                  call util_shrink_blockchamf(dx,dy,dz,chamf,kblockch,
     &              coating*0.0d0,nshrink,xbuff,ybuff,zbuff)
                else
                  call util_shrink_blockchamf(dx,dy,dz,chamf,kblockch,
     &              coating,nshrink,xbuff,ybuff,zbuff)
                endif
                write(cshrink,*) nshrink
                write(lunbpe,'(a)') "'" // trim(adjustl(cshrink)) // "'"
                do i=1,nshrink
                  write(lunbpe,*)xbuff(i),ybuff(i),zbuff(i)
                enddo
            endif !bc
          enddo !ndl
          cycle
        endif

        c64='BlockChamf'
        call util_string_substring(cline3,trim(c64),ianf,iend,istat)

        if (icomread.eq.1.and.istat.eq.0) then

          read(cline1,*)cen
          read(cline2,*)bc,xm,ym,zm,imat

          if (imat.eq.0) then
            bc=0.0d0
            kmat=0
          else
            kmat=materials(2,imat)
          endif

          if (bc.ne.0.0d0) then
            write(lunbpe,'(a)')'*'
            nmag=nmag+1
            call util_string_split_sep(cline1,1000,ncom,ipos,'!',istat)
            if (ncom.gt.1) then
              comdum=cline1(ipos(1,2):ipos(2,2))
            endif
            cdum=cline1(ipos(1,1):ipos(2,1))
            call util_string_split_sep(cdum,1000,nwords,ipos,' ',istat)
            if (nwords.ne.5) then
              write(chmag,*) nmag
              chmag="mp_" // trim(adjustl(chmag))
              chmoth=chmag
              chmoth(1:1)="M"
              cline1=trim(cdum)//" "//adjustl(trim(chmag))//" "//adjustl(trim(chmoth))
              if (ncom.gt.1) cline1=trim(cline1) // " " // " "//trim(comdum)
            endif
            write(lunbpe,'(a)')trim(cline1)
            write(lunbpe,'(a)')trim(cline2)
            cline3='Corners ' // cline3(iend+1:len_trim(cline3))
            write(lunbpe,'(a)')trim(cline3)
          endif !bc

          ndl=1
          do while (ndl.le.1)
            read(lunscr,'(a)')cline
            cline=trim(adjustl(cline))
            if (cline(1:1).eq.'*'.or.cline(1:1).eq.'!') then
              cycle
            else
              ndl=ndl+1
            endif
            if (bc.ne.0.0d0) then
                call util_string_split(cline,1000,nwords,ipos,istat)
                if (nwords.gt.4) cdum=cline(ipos(1,5):len_trim(cline))
                read(cline,*)dx,dy,dz,chamf
                if (kmat.eq.2) then
                  call util_shrink_blockchamf(dx,dy,dz,chamf,kblockch,
     &              coating*0.0d0,nshrink,xbuff,ybuff,zbuff)
                else
                  call util_shrink_blockchamf(dx,dy,dz,chamf,kblockch,
     &              coating,nshrink,xbuff,ybuff,zbuff)
                endif
                write(cshrink,*) nshrink
                write(lunbpe,'(a)') "'" // trim(adjustl(cshrink)) // "'"
                do i=1,nshrink
                  write(lunbpe,*)xbuff(i),ybuff(i),zbuff(i)
                enddo
            endif !bc
          enddo !ndl
          cycle
        endif

        kblock=0
        c64='Block'
        call util_string_substring(cline3,trim(c64),ianf,iend,istat)
        if (icomread.eq.1.and.(istat.eq.0.or.cline3(1:3).eq.'-6 ')) kblock=kblock+1
        call util_string_trim(cline3,nfirst,nlast)

        if (kblock.ne.0) then

          read(cline1,*)cen
          read(cline2,*)bc,xm,ym,zm,imat

          if (imat.eq.0) then
            bc=0.0d0
            kmat=0
          else
            kmat=materials(2,imat)
          endif

          if (bc.ne.0.0d0) then
            write(lunbpe,'(a)')'*'
            nmag=nmag+1
            call util_string_split_sep(cline1,1000,ncom,ipos,'!',istat)
            if (ncom.gt.1) then
              comdum=cline1(ipos(1,2):ipos(2,2))
            endif
            cdum=cline1(ipos(1,1):ipos(2,1))
            call util_string_split_sep(cdum,1000,nwords,ipos,' ',istat)
            if (nwords.ne.5) then
              write(chmag,*) nmag
              chmag="mp_" // trim(adjustl(chmag))
              chmoth=chmag
              chmoth(1:1)="M"
              cline1=trim(cdum)//" "//adjustl(trim(chmag))//" "//adjustl(trim(chmoth))
              if (ncom.gt.1) cline1=trim(cline1) // " " // " "//trim(comdum)
            endif
            write(lunbpe,'(a)')trim(cline1)
            write(lunbpe,'(a)')trim(cline2)
            write(lunbpe,'(a)') trim(cline3)
          endif !bc

          ndl=1
          do while (ndl.le.1)
            read(lunscr,'(a)')cline
            cline=trim(adjustl(cline))
            if (cline(1:1).eq.'*'.or.cline(1:1).eq.'!') then
              cycle
            else
              ndl=ndl+1
            endif
            if (bc.ne.0.0d0) then
              if (coating.ne.0.0d0.and.kmat.ne.2) then
                call util_string_split(cline,1000,nwords,ipos,istat)
                if (nwords.gt.3) cdum=cline(ipos(1,4):len_trim(cline))
                read(cline,*)dx,dy,dz
                write(cline,*)dx-2.0*coating,dy-2.0*coating,dz+2.0*coating
                call util_string_trim(cline,nfirst,nlast)
                cline=cline(nfirst:nlast) // " " // trim(cdum)
              endif !coat
              write(lunbpe,'(a)') trim(cline)
            endif !bc
          enddo !ndl
          cycle
        endif

        kcorn=0

        c64='Corners'
        call util_string_substring(cline3,trim(c64),ianf,iend,istat)
        if (icomread.eq.1.and.istat.eq.0) kcorn=1

        c64='File'
        call util_string_substring(cline3,trim(c64),ianf,iend,istat)
        if (icomread.eq.1.and.istat.eq.0) then
          kcorn=1
          cline3='Corners ' // cline3(iend+1:len_trim(cline3))
        endif

        if (kcorn.ne.0) then

          read(cline2,*)bc,xm,ym,zm,imat
          read(cline1,*)cen

          if (imat.eq.0) then
            bc=0.0d0
            kmat=0
          else
            kmat=materials(2,imat)
          endif

          if (bc.ne.0.0d0.and.imat.ne.0) then
            write(lunbpe,'(a)')'*'
            nmag=nmag+1
            call util_string_split_sep(cline1,1000,ncom,ipos,'!',istat)
            if (ncom.gt.1) then
              comdum=cline1(ipos(1,2):ipos(2,2))
            endif
            cdum=cline1(ipos(1,1):ipos(2,1))
            call util_string_split_sep(cdum,1000,nwords,ipos,' ',istat)
            if (nwords.ne.5) then
              write(chmag,*) nmag
              chmag="mp_" // trim(adjustl(chmag))
              chmoth=chmag
              chmoth(1:1)="M"
              cline1=trim(cdum)//" "//adjustl(trim(chmag))//" "//adjustl(trim(chmoth))
              if (ncom.gt.1) cline1=trim(cline1) // " " // " "//trim(comdum)
            endif
            write(lunbpe,'(a)')trim(cline1)
            write(lunbpe,'(a)')trim(cline2)
            write(lunbpe,'(a)') trim(cline3)
          endif !bc

          ndl=1
          nbuff=0
          do while (ndl.le.1)
            read(lunscr,'(a)')cline
            cline=trim(adjustl(cline))
            if (cline(1:1).eq.'*'.or.cline(1:1).eq.'!') then
              cycle
            else
              ndl=ndl+1
              read(cline,*)npoints
            endif
          enddo

          ndl=1
          do while (ndl.le.npoints)
            read(lunscr,'(a)')cline
            cline=trim(adjustl(cline))
            if (cline(1:1).eq.'*'.or.cline(1:1).eq.'!') then
              cycle
            else
              ndl=ndl+1
            endif
            if (bc.ne.0.0d0) then
              if (coating.ne.0.0d0.and.kmat.ne.2) then
                call util_string_split(cline,1000,nwords,ipos,istat)
                cbuff(ndl-1)=cline(1:ipos(2,3))
                read(cline,*)dx,dy,dz
                nbuff=nbuff+1
                xbuff(nbuff)=dx
                ybuff(nbuff)=dy
                zbuff(nbuff)=dz
                call util_string_trim(cline,nfirst,nlast)
                cline=cline(nfirst:nlast) // " " // trim(cdum)
              else !coating
                if (ndl.eq.2) then
                  write(cdum,*) npoints
                  call util_string_trim(cdum,nfirst,nlast)
                  write(lunbpe,'(a)') cdum(nfirst:nlast)
                endif
                write(lunbpe,'(a)') trim(cline)
              endif !coat
            endif
          enddo

          if (imat.ne.0.and.coating.ne.0.0d0.and.kmat.ne.2) then
            call util_shrink_xyz(nbuff,xbuff,ybuff,zbuff,cen,coating,tiny,
     &        nbuff,xbuff,ybuff,zbuff,istat)
            write(cdum,*) nbuff
            call util_string_trim(cdum,nfirst,nlast)
            write(lunbpe,'(a)') cdum(nfirst:nlast)
            do i=1,nbuff
              write(cline,*)xbuff(i),ybuff(i),zbuff(i)
              call util_string_trim(cline,nfirst,nlast)
              cline=cline(nfirst:nlast)
              write(lunbpe,'(a)') trim(cline)
            enddo
          endif !coating
          cycle
        endif

        if (itreat.eq.0.or.itreat.eq.7) write(lunbpe,'(a)') trim(cline3)

      enddo !nlines

9999  close(lunscr)

      flush(lunbpe)
      close(lunbpe)

+self,if=trace.
      print*,"-trace-: Leaving undumag_drop_zero_magnets"
+self.
      return
      end
+DECK,undumag_wind_to_fila.
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 11/03/2021  10.37.32  by  Michael Scheer
*CMZ :  2.01/03 24/01/2019  10.41.25  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  11.55.41  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  14.48.44  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  16.51.35  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.53.23  by  Michael Scheer
*-- Author :    Michael Scheer   08/03/2018
      subroutine undumag_wind_to_fila(k,icoil)

      use undumagf90m

      use commandlinef90m

      implicit none

+seq,phyconparam.

      double precision, dimension (:), allocatable :: y,z

      double precision h,w,r,barl,curr,cw,vx,vy,vz,phi,alpha,cosa,sina,
     &  cosphi,sinphi,cosphi1,sinphi2,cosphi2,sinphi1,costhe,sinthe,
     &  xc,yc,zc,x0,y0,z0,dphi,dr,dy,ro,ri,xr1,zr1,xr2,zr2,dz,vn,
     &  xi,xo,zi,zo,wx,wy,wz,ux,uy,uz,rotmat(3,3),vnor(3),rmat(3,3)

      integer k,icoil,iw,ir,nz,ny,nphi,iphi,iy,iz,kolor,ical,istat,i,j,kold

      data ical/0/

      save ical,iw

      !rotate (vx,vy,vz) to y-axis

      if (ical.eq.0) then
        ical=1
      endif

      iw=ncwires
      kold=iw

      curr=wind(1,k)*wind(18,k)*wind(19,k)

      x0=wind(2,k)
      y0=wind(3,k)
      z0=wind(4,k)

      vx=wind(5,k)
      vy=wind(6,k)
      vz=wind(7,k)

      vn=sqrt(vx**2+vy**2+vz**2)
      if (vn.eq.0.0d0) then
        write(lun6,*)
        write(lun6,*)"*** Error in undumag_wind_to_fila: Zero normal vector for coil",k
        stop
      endif
      vx=vx/vn
      vy=vy/vn
      vz=vz/vn

      alpha=wind(8,k)
      xo=wind(9,k)/2.0d0
      zi=wind(10,k)/2.0d0
      zo=wind(11,k)/2.0d0
      ri=wind(12,k)
      h=wind(13,k)
      ny=wind(14,k)
      nz=wind(15,k)
      nphi=wind(16,k)
      kolor=wind(17,k)

      w=zo-zi
      xi=xo-w
      ro=ri+w

      yc=0.0d0

      if (xi.lt.ri) then
        write(lun6,*)
        write(lun6,*)"*** Error in undumag_wind_to_fila: The inner length is smaller than twice the inner radius ***"
        stop
      endif

      allocate(y(ny),z(nz))

      dphi=pi1/2.0d0/nphi
      dy=h/ny
      dz=w/nz

      cw=curr/(ny*nz)

      do iy=1,ny

        y(iy)=yc-h/2.0d0+(iy-0.5d0)*dy

        do iz=1,nz

          z(iz)=zi+(iz-0.5d0)*dz

          ! first x bar
          iw=iw+1
          wire(1,iw)=8 ! windings flag
          wire(2,iw)=cw
          wire(3,iw)=+xi-ri
          wire(4,iw)=+y(iy)
          wire(5,iw)=-z(iz)
          wire(6,iw)=-xi+ri
          wire(7,iw)=+y(iy)
          wire(8,iw)=-z(iz)
          wire(9,iw)=kolor
          wire(10,iw)=k ! windings number
          wire(11,iw)=icoil ! coil number

          ! first arc
          xc=-xi+ri
          zc=-zi+ri
          sinphi1=0.0d0
          cosphi1=1.0d0
          do iphi=1,nphi
            sinphi2=sin(iphi*dphi)
            cosphi2=cos(iphi*dphi)
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc-r*sinphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc-r*cosphi1
            wire(6,iw)=+xc-r*sinphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc-r*cosphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! windings number
            wire(11,iw)=icoil ! coil number
            sinphi1=sinphi2
            cosphi1=cosphi2
          enddo

          ! first z bar
          iw=iw+1
          wire(1,iw)=8 ! windings flag
          wire(2,iw)=cw
          wire(3,iw)=-xi-(iz-0.5d0)*dz
          wire(4,iw)=+y(iy)
          wire(5,iw)=-zi+ri
          wire(6,iw)=wire(3,iw)
          wire(7,iw)=+y(iy)
          wire(8,iw)=+zi-ri
          wire(9,iw)=kolor
          wire(10,iw)=k ! windings number
          wire(11,iw)=icoil ! coil number

          ! second arc
          xc=-xi+ri
          zc=zi-ri
          sinphi1=0.0d0
          cosphi1=1.0d0
          do iphi=1,nphi
            sinphi2=sin(iphi*dphi)
            cosphi2=cos(iphi*dphi)
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc-r*cosphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc+r*sinphi1
            wire(6,iw)=+xc-r*cosphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc+r*sinphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! windings number
            wire(11,iw)=icoil ! coil number
            sinphi1=sinphi2
            cosphi1=cosphi2
          enddo

          ! second x bar
          iw=iw+1
          wire(1,iw)=8 ! windings flag
          wire(2,iw)=cw
          wire(3,iw)=-xi+ri
          wire(4,iw)=+y(iy)
          wire(5,iw)=+z(iz)
          wire(6,iw)=+xi-ri
          wire(7,iw)=+y(iy)
          wire(8,iw)=+z(iz)
          wire(9,iw)=kolor
          wire(10,iw)=k ! windings number
          wire(11,iw)=icoil ! coil number

          ! third arc
          xc=xi-ri
          zc=zi-ri
          sinphi1=0.0d0
          cosphi1=1.0d0
          do iphi=1,nphi
            sinphi2=sin(iphi*dphi)
            cosphi2=cos(iphi*dphi)
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc+r*sinphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc+r*cosphi1
            wire(6,iw)=+xc+r*sinphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc+r*cosphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! windings number
            wire(11,iw)=icoil ! coil number
            sinphi1=sinphi2
            cosphi1=cosphi2
          enddo

          ! second z bar
          iw=iw+1
          wire(1,iw)=8 ! windings flag
          wire(2,iw)=cw
          wire(3,iw)=+xi+(iz-0.5d0)*dz
          wire(4,iw)=+y(iy)
          wire(5,iw)=+zi-ri
          wire(6,iw)=wire(3,iw)
          wire(7,iw)=+y(iy)
          wire(8,iw)=-zi+ri
          wire(9,iw)=kolor
          wire(10,iw)=k ! windings number
          wire(11,iw)=icoil ! coil number

          ! fourth arc
          xc=xi-ri
          zc=-zi+ri
          sinphi1=0.0d0
          cosphi1=1.0d0
          do iphi=1,nphi
            sinphi2=sin(iphi*dphi)
            cosphi2=cos(iphi*dphi)
            iw=iw+1
            r=ri+(iz-0.5d0)*dz
            wire(1,iw)=2
            wire(2,iw)=cw
            wire(3,iw)=+xc+r*cosphi1
            wire(4,iw)=+y(iy)
            wire(5,iw)=+zc-r*sinphi1
            wire(6,iw)=+xc+r*cosphi2
            wire(7,iw)=+y(iy)
            wire(8,iw)=+zc-r*sinphi2
            wire(9,iw)=kolor
            wire(10,iw)=k ! windings number
            wire(11,iw)=icoil ! coil number
            sinphi1=sinphi2
            cosphi1=cosphi2
          enddo

        enddo !iz
      enddo !iy

      !rotate and translate coil

      vnor(1)=vx
      vnor(2)=vy
      vnor(3)=vz

      call util_rotate_vector_to_y_axis(vnor,rotmat,istat)

      do i=1,3
        do j=1,3
          rmat(i,j)=rotmat(j,i)
        enddo
      enddo

      cosa=cos(alpha/180.0d0*pi1)
      sina=sin(alpha/180.0d0*pi1)

      do i=kold+1,iw
        wx=cosa*wire(3,i)+sina*wire(5,i)
        wy=wire(4,i)
        wz=-sina*wire(3,i)+cosa*wire(5,i)
        wire(3:5,i)=rmat(1:3,1)*wx+rmat(1:3,2)*wy+rmat(1:3,3)*wz
        wx=wire(6,i)
        wy=wire(7,i)
        wz=wire(8,i)
        wx=cosa*wire(6,i)+sina*wire(8,i)
        wy=wire(7,i)
        wz=-sina*wire(6,i)+cosa*wire(8,i)
        wire(6:8,i)=rmat(1:3,1)*wx+rmat(1:3,2)*wy+rmat(1:3,3)*wz
        wire(3,i)=wire(3,i)+x0
        wire(4,i)=wire(4,i)+y0
        wire(5,i)=wire(5,i)+z0
        wire(6,i)=wire(6,i)+x0
        wire(7,i)=wire(7,i)+y0
        wire(8,i)=wire(8,i)+z0
      enddo

      deallocate(y,z)

      ncwires=iw

      return
      end
+DECK,undumag_read_clc.
*CMZ :  2.04/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/01 22/01/2023  13.04.45  by  Michael Scheer
*CMZ :  2.04/00 14/01/2023  14.39.42  by  Michael Scheer
*CMZ :  2.03/00 15/08/2022  12.39.08  by  Michael Scheer
*CMZ :  2.02/02 09/03/2022  09.42.30  by  Michael Scheer
*CMZ :  2.02/01 11/02/2022  08.28.50  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine undumag_read_clc

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      integer i,j,ieof,lunclc,istat,ipos(2,1000),nwords,
     &  lmat,nmat,l,ncorn,nfila,lunf

      character(512) cline,cword
      cundutit='* No User Comment'

      nclcbuff=0
      ncwires=0

      nwind=0
      nrace=0
      ncrace=0
      narc=0
      ncarc=0
      nrbar=0
      nthwir=0
      nmagcyl=0

      ntransrotcop=0
      transrotcop=0.0d0

      nmodule_t=0
      modegui=0

      open(newunit=lunclc,file=Fclc)

      do while (.true.)
        call util_skip_comment_end(lunclc,ieof)
        if (ieof.ne.0) exit
        read(lunclc,'(a)') cline
        !if (kechocalc.ne.0) print*,trim(cline)
        cline=adjustl(cline)
        if (cline(1:4).eq.'Mode') then
          call util_string_split(cline,1000,nwords,ipos,istat)
          if (nwords.gt.1) then
            if (cline(ipos(1,2):ipos(2,2)).eq.'Mirror') then
              modegui=3
            else if (cline(ipos(1,2):ipos(2,2)).eq.'Hybrid') then
              modegui=2
            else if (cline(ipos(1,2):ipos(2,2)).eq.'AppleII') then
              modegui=1
            endif
          endif
        endif
        if (cline(1:1).eq.'&') then
          call util_string_split(cline,1000,nwords,ipos,istat)
          if (cline(ipos(1,2):ipos(2,2)).eq.'User_Comment') then
            nclcbuff=nclcbuff+1
            !if (kechocalc.ne.0) print*,trim(cline)
            call util_skip_comment_end(lunclc,ieof)
            if (ieof.ne.0) exit
            cline=''
            unducomment=''
            read(lunclc,'(a)') cline
            nclcbuff=nclcbuff+1
            unducomment=trim(cline(1:512))
            usercom=adjustl(trim(unducomment))
            cundutit='* ' // adjustl(trim(unducomment))
            read(lunclc,'(a)') cline
            cycle ! to avoid confusion, if key words appear in comment
          endif
        endif
        if (len_trim(cline).eq.0) cycle
        nclcbuff=nclcbuff+1
      enddo

      allocate(
     &  magmodule(nclcbuff),
     &  clcbuff(nclcbuff),
     &  clcmag(nclcbuff),
     &  clcspec(nclcbuff),
     &  clcmat(nclcbuff),
     &  clcmod(nclcbuff),
     &  clccoil(nclcbuff),
     &  clccop(nclcbuff),
     &  clcvar(nclcbuff),
     &  clcinhom(nclcbuff)
     &  )

      rewind(lunclc)

      nclcbuff=0
      do while (.true.)
        ieof=0
        call util_skip_comment_end(lunclc,ieof)
        if (ieof.ne.0) exit
        read(lunclc,'(a)') cline
        cline=adjustl(cline)
        !print*,trim(cline)
        if (len_trim(cline).eq.0) cycle
        if (nclcbuff.gt.0.and.cline(1:1).eq.'&') then
          call util_string_split(cline,1000,nwords,ipos,istat)
          if (cline(ipos(1,2):ipos(2,2)).eq.'End') then
            nclcbuff=nclcbuff+1
            cline(1:1)='!'
            clcbuff(nclcbuff)=cline
            cycle
          endif
          if (clcbuff(nclcbuff)(1:1).eq.'&') then
            !print*,cline(ipos(1,2):ipos(2,2))
            !call util_break
            print*,"*** Error in undumag_read_clc: Missing data lines after"
            print*,trim(clcbuff(nclcbuff))
            stop
          endif
          if (cline(ipos(1,2):ipos(2,2)).eq.'User_Comment') then
            ieof=0
            call util_skip_comment_end(lunclc,ieof)
            if (ieof.ne.0) exit
            read(lunclc,'(a)') cline
            cycle
          endif
        endif
        nclcbuff=nclcbuff+1
        clcbuff(nclcbuff)=cline
      enddo

      close(lunclc)

      nclcmag=0
      nclcspec=0
      nclccoil=0
      nclcvar=0
      nclcmod=0
      nclcmat=0

      nmag_t=0
      niron_t=0
      ninhom_t=0

      i=0
      do while (i.lt.nclcbuff)

        i=i+1
        cline=clcbuff(i)
        if (kechocalc.ne.0) print*,trim(cline)
        call util_string_split(cline,1000,nwords,ipos,istat)

        if (cline(ipos(1,1):ipos(2,1)).eq.'&') then
          if (cline(ipos(1,2):ipos(2,2)).eq.'User_Comment') then
            i=i+1
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Inhomogeneity') then
            !call util_break
            ninhom_t=ninhom_t+1
            clcinhom(ninhom_t)=cline(ipos(1,2):ipos(2,2))
            i=i+1
            do while (.true.)
              !print*,i,trim(clcbuff(i))
              ninhom_t=ninhom_t+1
              clcinhom(ninhom_t)=clcbuff(i)
              if (kechocalc.ne.0) print*,trim(clcbuff(i))
              call util_string_split(clcinhom(ninhom_t),1000,nwords,ipos,istat)
              if (clcinhom(ninhom_t)(ipos(1,2):ipos(2,2)).eq.'End') exit
              i=i+1
            enddo
            !call util_break
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Pole' .or.
     &        cline(ipos(1,2):ipos(2,2)).eq.'Magnet') then
            nmag_t=nmag_t+1
            magmodule(nmag_t)=nmodule_t+1
            if (cline(ipos(1,2):ipos(2,2)).eq.'Pole') niron_t=niron_t+1
            nclcmag=nclcmag+1
            clcmag(nclcmag)=cline(ipos(1,2):ipos(2,2))
            i=i+1
            cline=clcbuff(i)
            if (kechocalc.ne.0) print*,trim(cline)
            call util_string_split(cline,1000,nwords,ipos,istat)
            if (
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockChamf'.or.
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockUsChamf'.or.
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockDsChamf'
     &          ) then
              do l=1,5
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Block') then
              do l=1,5
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Cylinder') then
              nmagcyl=nmagcyl+1
              do l=1,5
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Corners') then
              read(clcbuff(i+4),*) ncorn
              do l=1,5+ncorn
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'File') then
              do l=1,5
                nclcmag=nclcmag+1
                clcmag(nclcmag)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else
              print*,"*** Error in undumag_read_clc: Unknown magnet type in line"
              print*,trim(cline)
              stop
            endif
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Module') then
            nmodule_t=nmodule_t+1
            nclcmod=nclcmod+1
            clcmod(nclcmod)=clcbuff(i)
            do l=1,4
              i=i+1
              nclcmod=nclcmod+1
              clcmod(nclcmod)=clcbuff(i)
              if (kechocalc.ne.0) print*,trim(clcbuff(i))
            enddo
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Translate') then
            ntransrotcop=ntransrotcop+1
            if (ntransrotcop.gt.ntransrotcop_p) then
              stop "*** Error in undumag_read_clc: Too many remanence, translations, rotations changes, check parameter ntransrotcop_p ***"
            endif
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            ctransrotcop(ntransrotcop)=trim(clcbuff(i))
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            !read(clcbuff(i),*) transrotcop(1:3,ntransrotcop)
            transrotcop(1,ntransrotcop)=dble(i)
            transrotcop(8,ntransrotcop)=0.0d0
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Remanence') then
            ntransrotcop=ntransrotcop+1
            if (ntransrotcop.gt.ntransrotcop_p) then
              stop "*** Error in undumag_read_clc: Too many remanence, translations, rotations changes, check parameter ntransrotcop_p ***"
            endif
            transrotcop(8,ntransrotcop)=3.0d0
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            ctransrotcop(ntransrotcop)=trim(clcbuff(i))
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            transrotcop(1,ntransrotcop)=dble(i)
            !read(clcbuff(i),*) transrotcop(1:6,ntransrotcop)
          else if (cline(ipos(1,2):ipos(2,2)).eq.'Copy') then
            nclccop_t=nclccop_t+1
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            clccop(nclccop_t)=trim(clcbuff(i))
            ntransrotcop=ntransrotcop+1
            if (ntransrotcop.gt.ntransrotcop_p) then
              stop "*** Error in undumag_read_clc: Too many remanence, translations, rotations changes, check parameter ntransrotcop_p ***"
            endif
            transrotcop(8,ntransrotcop)=-dble(nclccop_t)
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            cline=clcbuff(i)
            call util_string_split(cline,1000,nwords,ipos,istat)
            cword=cline(ipos(1,1):ipos(2,1))
            ctransrotcop(ntransrotcop)=trim(cword)
          else if (
     &        cline(ipos(1,2):ipos(2,2)).eq.'Rotate'.or.
     &        cline(ipos(1,2):ipos(2,2)).eq.'Rotate_Shape') then
            ntransrotcop=ntransrotcop+1
            if (cline(ipos(1,2):ipos(2,2)).eq.'Rotate_Shape') then
              transrotcop(8,ntransrotcop)=1.0d0
            else
              transrotcop(8,ntransrotcop)=2.0d0
            endif
            if (ntransrotcop.gt.ntransrotcop_p) then
              stop "*** Error in undumag_read_clc: Too many remanence, translations, rotations changes, check parameter ntransrotcop_p ***"
            endif
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            ctransrotcop(ntransrotcop)=trim(clcbuff(i))
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            transrotcop(1,ntransrotcop)=dble(i)
            !read(clcbuff(i),*) transrotcop(1:3,ntransrotcop)
            i=i+1
            if (kechocalc.ne.0) print*,trim(clcbuff(i))
            !read(clcbuff(i),*) transrotcop(4:7,ntransrotcop)
          else if (
     &        cline(ipos(1,2):ipos(2,2)).eq.'Special_Magnet'.or.
     &        cline(ipos(1,2):ipos(2,2)).eq.'Special_Pole'
     &        ) then
            nclcspec=nclcspec+1
            clcspec(nclcspec)=cline(ipos(1,2):ipos(2,2))
            nspecmag_t=nspecmag_t+1
            if (cline(ipos(1,2):ipos(2,2)).eq.'Special_Pole') niron_t=niron_t+1
            i=i+1
            cline=clcbuff(i)
            call util_string_split(cline,1000,nwords,ipos,istat)
            if (
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockChamf'.or.
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockUsChamf'.or.
     &          cline(ipos(1,1):ipos(2,1)).eq.'BlockDsChamf'
     &          ) then
              do l=1,5
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Block') then
              do l=1,5
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Cylinder') then
              do l=1,4
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'Corners') then
              read(clcbuff(i+4),*) ncorn
              do l=1,5+ncorn
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else if (cline(ipos(1,1):ipos(2,1)).eq.'File') then
              do l=1,5
                nclcspec=nclcspec+1
                clcspec(nclcspec)=clcbuff(i)
                if (kechocalc.ne.0) print*,trim(clcbuff(i))
                i=i+1
              enddo
              i=i-1
            else
              print*,"*** Error in undumag_read_clc: Unknown magnet type in line"
              print*,trim(cline)
              stop
            endif !shape

          else if (cline(ipos(1,2):ipos(2,2)).eq.'Materials') then
            i=i+1
            cline=clcbuff(i)
            nclcmat=nclcmat+1
            clcmat(nclcmat)=clcbuff(i)
            if (kechocalc.ne.0) print*,trim(cline)
            read(cline,*) nmat
            do lmat=1,nmat
              nclcmat=nclcmat+1
              i=i+1
              clcmat(nclcmat)=clcbuff(i)
              if (kechocalc.ne.0) print*,trim(clcbuff(i))
            enddo !nmat

          else if (cline(ipos(1,2):ipos(2,2)).eq.'Coil') then

            ncoils_t=ncoils_t+1
            nclccoil=nclccoil+1
            clccoil(nclccoil)='Coil'
            i=i+1
            cline=clcbuff(i)
            if (kechocalc.ne.0) print*,trim(cline)

            call util_string_split(cline,1000,nwords,ipos,istat)
            nclccoil=nclccoil+1

            if (nwords.gt.1) then
              clccoil(nclccoil)=adjustl(trim(cline(ipos(1,1):ipos(2,2))))
            else
              clccoil(nclccoil)=adjustl(trim(cline(ipos(1,1):ipos(2,1))))
            endif

            cword=adjustl(trim(cline(ipos(1,1):ipos(2,1))))

            i=i+1
            nclccoil=nclccoil+1
            clccoil(nclccoil)=clcbuff(i)
            cline=clcbuff(i)
            if (kechocalc.ne.0) print*,trim(cline)

            if (cword.eq.'Filaments') then
              read(cline,*)nfila
              do l=1,nfila
                nclccoil=nclccoil+1
                i=i+1
                clccoil(nclccoil)=clcbuff(i)
              enddo
              ncwires=ncwires+nfila

            else if (cword.eq.'File') then

              call util_string_split(cline,1000,nwords,ipos,istat)
              cword=adjustl(trim(cline(ipos(1,1):ipos(2,1))))
              call util_unquote(cword)
              clccoil(nclccoil)=adjustl(trim(cword))
              open(newunit=lunf,file=trim(cword),status='old')
              nfila=0
              do while (.true.)
                call util_skip_comment_empty_end(lunf,ieof)
                if (ieof.ne.0) exit
                read(lunf,'(a)')cline
                nfila=nfila+1
              enddo
              close(lunf)
              ncwires=ncwires+nfila

            else if (
     &          cword.eq.'RectArc'.or.
     &          cword.eq.'CircArc'.or.
     &          cword.eq.'RectBar'.or.
     &          cword.eq.'ThickWire'
     &          ) then
              i=i+1
              nclccoil=nclccoil+1
              clccoil(nclccoil)=clcbuff(i)

            else if (
     &          cword.ne.'Rectangular'.and.
     &          cword.ne.'RectangCirc'.and.
     &          cword.ne.'RectWindings'
     &          ) then
              print*,""
              print*,"*** Error in undumag_read_clc: Unknown coil type in line"
              print*,trim(cline)
              stop
            endif

          else
            print*,""
            print*,"*** Error in undumag_read_clc: Unknown key-word in line"
            print*,trim(cline)
            stop
         endif ! &

        else if (cline(1:1).eq.'$') then

          !if (kechocalc.ne.0) print*,trim(cline)
          do j=2,len_trim(cline)-1
            if (cline(j:j).eq.'=') then
              nclcvar=nclcvar+1
              clcvar(nclcvar)=trim(cline(2:))
              exit
            endif
          enddo
        endif !c1
      enddo

      return
      end
+DECK,undumag_calc_new.
*CMZ :  2.04/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.03/00 13/07/2022  14.49.18  by  Michael Scheer
*CMZ :  2.02/01 20/01/2022  09.10.26  by  Michael Scheer
*CMZ :  2.02/00 30/03/2021  16.58.55  by  Michael Scheer
*CMZ :  2.01/08 28/07/2020  11.52.35  by  Michael Scheer
*CMZ :  2.01/05 21/07/2020  12.59.07  by  Michael Scheer
*CMZ :  1.25/00 24/01/2018  15.15.53  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  14.55.39  by  Michael Scheer
*CMZ :  1.11/01 09/01/2017  13.51.01  by  Michael Scheer
*CMZ :  1.11/00 06/12/2016  19.35.14  by  Michael Scheer
*CMZ :  1.10/02 25/11/2016  12.01.14  by  Michael Scheer
*CMZ :  1.10/00 11/11/2016  12.55.12  by  Michael Scheer
*CMZ :  1.02/00 22/08/2016  09.11.46  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  09.36.23  by  Michael Scheer
*CMZ :  0.00/09 30/06/2016  15.12.31  by  Michael Scheer
*CMZ :  0.00/05 10/06/2016  15.58.48  by  Michael Scheer
*CMZ :  0.00/04 11/05/2016  11.22.46  by  Michael Scheer
*-- Author :    Michael Scheer   10/05/2016
      subroutine undumag_calc_new(kecho)

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      integer i,kecho,k,luno,maxlen
      integer :: idebug=0

      double precision, dimension(:), allocatable :: par
      character(512) cline
      character(128), dimension(:), allocatable :: cpar
      character(128) :: c128,chvar

      allocate(par(nclcvar),cpar(nclcvar))

      if (kecho /= 0) then
        print*," "
        print*,"Entered undumag_calc_new:"
        print*," "
      endif

      do i=1,nclcvar
        cline=clcvar(i)
        if (kecho /= 0) print*,trim(cline)
        do k=1,len_trim(cline)
          if (cline(k:k) == '!') then
            cline=cline(1:k-1)
            exit
          endif
        enddo
        cline='$'//trim(cline)
        ! sort cpar by length
        call undumag_sort_cpar(nclcvar,nvar_t,cpar,par)
        call undumag_calc_cline(cline,nclcvar,nvar_t,par,cpar)
        if (idebug.ne.0) then
          print*,trim(cline)
          do k=1,nvar_t
            print*,nclcvar,k,par(k),trim(cpar(k))
          enddo
          !call util_break
        endif
      enddo

      if (idebug.ne.0) stop "Ende in UNDUMAG_CALC_NEW"

      call undumag_sort_cpar(nclcvar,nvar_t,cpar,par)

      allocate(t_variables(nvar_t))

      maxlen=0

      open(newunit=luno,file='undumag_variables.lis')
      do i=1,nvar_t
        t_variables(i)%val=par(i)
        t_variables(i)%cname=trim(cpar(i))
        maxlen=max(maxlen,len_trim(cpar(i)))
      enddo

      coating=-9999.0d0
      c128="coating"

      do i=1,nvar_t
        chvar=t_variables(i)%cname
        call util_lower_case(chvar)
        if (chvar.eq."coating".or.chvar.eq."mcoating")
     &    coating=t_variables(i)%val
        write(luno,*)
     &    i,t_variables(i)%cname(1:maxlen),t_variables(i)%val
      enddo
      flush(luno)
      close(luno)

      if (coating.eq.-9999.0d0) coating=0.0d0

      write(lun6,*)""
      write(lun6,*)"Coating of Magnets:",coating
      write(lun6,*)

      deallocate(par,cpar)

      return
      end
+DECK,clcmag_cut.
*CMZ :  2.04/08 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/06 04/08/2023  11.24.35  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  18.33.07  by  Michael Scheer
*CMZ :  2.02/01 19/01/2022  10.38.36  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_cut

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision, dimension (:,:,:), allocatable :: corn1,corn2
      integer, dimension (:), allocatable :: ncorn1,ncorn2

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface

      integer imag
+self,if=dumpvox.
      integer ivox,nvox,npoi
      type(T_Voxel) :: tvox
+self.

+self,if=trace.
      print*,"-trace-: Entered clcmag_cut"
+self.
      ! for the voxels xyz = gcen!
      ! xhull,yhull,zhull refer to gcen for voxels

      allocate(corn1(3,2*ncornmax,2*nplanmax),corn2(3,2*ncornmax,2*nplanmax))
      allocate(ncorn1(2*nplanmax),ncorn2(2*nplanmax))

      allocate(khull(2*ncornmax*nplanmax),kedge(4,2*ncornmax*nplanmax-2),
     &  kface(5*ncornmax*nplanmax))

      do imag=1,nmag_t+nspecmag_t
        if (t_magnets(imag)%ctype.ne.'Cylinder') then
          call clcmag_xcut(imag)
          call clcmag_ycut(imag)
          call clcmag_zcut(imag)
        endif
      enddo !nmag_t

      deallocate(corn1,corn2)

      call clcmag_voxels
      call clcmag_copy_voxels

+self,if=dumpvox.
      print*,"+self,if=dumpvox."
      do imag=1,nmag_t+nspecmag_t
        nvox=t_magnets(imag)%nvoxels
        do ivox=1,nvox
          tvox=t_magnets(imag)%t_voxels(ivox)
          npoi=tvox%nhull
          do i=1,npoi
            write(66,*)imag,ivox,i,tvox%hull(:,i)+tvox%gcen
          enddo
        enddo
      enddo
+self.

+self,if=trace.
      print*,"-trace-: Leaving clcmag_cut"
+self.
      return
      end
+DECK,clcmag_zcut.
*CMZ :  2.04/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.30.33  by  Michael Scheer
*CMZ :  2.04/02 25/02/2023  17.27.31  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  13.19.45  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  18.19.49  by  Michael Scheer
*CMZ :  2.02/02 15/02/2022  16.00.05  by  Michael Scheer
*CMZ :  2.02/01 23/01/2022  14.52.10  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_zcut(imag)

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      character(128) ctype

      double precision, dimension (:,:,:), allocatable :: corn1,corn2
      double precision, dimension (:), allocatable :: xh,yh,zh,xhc,yhc,zhc

      double precision x,y,z,
     &  x02(2),y02(2),z02(2),zdivmin,zdivmax,
     &  gcen(3),gcenv(3),xmin,xmax,ymin,ymax,zmin,zmax,
     &  dzdiv,zdiv,fracsum,zfracdiv,zfacdiv,volmag,vol

      integer, dimension (:), allocatable :: ncorn1,ncorn2

      integer :: idebug=0,
     &  i,j,l,n,ix,iy,iz,kz,imag,ip,npoi,iplan,icorn,
     &  nxdiv,nydiv,nzdiv,kcut,izdiv,klast,nplan,ncorn

      integer ifailhull,ifail,nhull,nedge,nface,kfacelast,nvox

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface

      type(T_Magnet) :: tmag
      type(T_Voxel) :: tvox

+self,if=trace.
      print*,"-trace-: Entered clcmag_zcut"
+self.

      if (idebug.gt.0) call util_break

      tmag=t_magnets(imag)

      gcen=t_magnets(imag)%gcen

      nxdiv=t_magnets(imag)%nxdiv
      nydiv=t_magnets(imag)%nydiv
      nzdiv=t_magnets(imag)%nzdiv

      if (idebug.eq.10) then
        do ix=1,nxdiv
          print*,ix,t_magnets(imag)%t_xcuts(ix)%volume
          do iy=1,nydiv
            print*,ix,iy,t_magnets(imag)%t_xycuts(ix,iy)%volume
          enddo
        enddo
        stop
      endif

      ctype=t_magnets(imag)%ctype

      if (idebug.lt.0) then
        print*,imag,tmag%cnam,tmag%cmoth,nxdiv,nydiv,nzdiv
      endif

      if (nzdiv.gt.1) then

        allocate(t_magnets(imag)%zdivs(nzdiv-1))

        fracsum=0.0d0
        ! zfracdiv**(nzdiv-1)=zfacdiv
        ! ln(zfracdiv)*(nzdiv-1)=ln(zfacdiv)
        zfacdiv=t_magnets(imag)%zfracdiv
        zdivmin=t_magnets(imag)%zmin
        zdivmax=t_magnets(imag)%zmax

        if (nzdiv.gt.1) then
          zfracdiv=exp(log(zfacdiv)/(nzdiv-1))
        else
          zfracdiv=1.0d0
        endif

        do izdiv=0,nzdiv-1
          fracsum=fracsum+zfracdiv**izdiv
        enddo

        dzdiv=(zdivmax-zdivmin)/fracsum*zfacdiv

        if (nzdiv.gt.1) t_magnets(imag)%zdivs(1)=zdivmin+dzdiv

        do iz=2,nzdiv-1
          dzdiv=dzdiv/zfracdiv
          t_magnets(imag)%zdivs(iz)=t_magnets(imag)%zdivs(iz-1)+dzdiv
        enddo

      endif

        allocate(corn1(3,2*ncornmax,2*nplanmax),corn2(3,2*ncornmax,2*nplanmax))
        allocate(ncorn1(2*nplanmax),ncorn2(2*nplanmax))
        allocate(
     &    xh(2*ncornmax*nplanmax),yh(2*ncornmax*nplanmax),zh(2*ncornmax*nplanmax),
     &    xhc(2*ncornmax*nplanmax),yhc(2*ncornmax*nplanmax),zhc(2*ncornmax*nplanmax))
        allocate(khull(2*ncornmax*nplanmax),kedge(4,2*ncornmax*nplanmax-2),
     &    kface(5*ncornmax*nplanmax))

      nvox=0

      do ix=1,nxdiv

        do iy=1,nydiv

          x02=0.0d0
          y02=0.0d0
          z02=0.0d0

          t_magnets(imag)%t_xycuts(ix,iy)%mzdiv=0

          tvox=t_magnets(imag)%t_xycuts(ix,iy)

          if (tvox%iydiv.eq.0) cycle

          if (idebug.lt.0) then
            print*,ix,iy,tvox%nface
          endif

          ncorn1=0
          ncorn2=0
          l=0

          if (nzdiv.gt.1) then

            do i=1,tvox%nface
              l=l+1
              n=tvox%kface(l)
              ncorn1(i)=n
              do j=1,n
                l=l+1
                ip=tvox%kface(l)
                x=tvox%xhull(ip)
                y=tvox%yhull(ip)
                z=tvox%zhull(ip)
                corn1(1,j,i)=x
                corn1(2,j,i)=y
                corn1(3,j,i)=z
              enddo
            enddo

          endif !iz

          gcenv=tvox%gcen

          kcut=0

          do iz=1,nzdiv-1

            zmin=1.0d30
            zmax=-1.0d30
            do iplan=1,nplanmax
              do icorn=1,ncorn1(iplan)
                z=corn1(3,icorn,iplan)+z02(1)
                if (z.lt.zmin) zmin=z
                if (z.gt.zmax) zmax=z
              enddo
            enddo

            zdiv=t_magnets(imag)%zdivs(iz)+gcen(3) !Labor
            zdiv=zdiv-gcenv(3) ! relative to gcenv, i.e. GCEN of voxel

            if (zdiv-zmin.le.cuttiny.or.zmax-zdiv.le.cuttiny) then
              if (idebug.gt.0) call util_break
              cycle
            endif

            kcut=1
            exit

          enddo !iz

          if (nzdiv.eq.1.or.kcut.eq.0) then

            nvox=nvox+1

            if (tvox%iydiv.eq.0) cycle

            nhull=tvox%nhull
            nedge=tvox%nedge
            nface=tvox%nface
            khull=tvox%khull
            kedge=tvox%kedge
            kface=tvox%kface

            allocate(t_magnets(imag)%t_xyzcuts(ix,iy,1)%xhull(nhull))
            allocate(t_magnets(imag)%t_xyzcuts(ix,iy,1)%yhull(nhull))
            allocate(t_magnets(imag)%t_xyzcuts(ix,iy,1)%zhull(nhull))
            allocate(t_magnets(imag)%t_xyzcuts(ix,iy,1)%khull(nhull))
            allocate(t_magnets(imag)%t_xyzcuts(ix,iy,1)%kedge(4,nedge))
            allocate(t_magnets(imag)%t_xyzcuts(ix,iy,1)%kface(kfacelast))

            t_magnets(imag)%t_xyzcuts(ix,iy,1)%nhull=nhull
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%khull=khull
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%nedge=nedge
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%kedge=kedge
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%nface=nface
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%kface=kface

            t_magnets(imag)%t_xyzcuts(ix,iy,1)%size=tvox%size
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%volume=tvox%volume

            t_magnets(imag)%t_xyzcuts(ix,iy,1)%xmin=tvox%xmin
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%xmax=tvox%xmax
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%ymin=tvox%ymin
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%ymax=tvox%ymax
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%zmin=tvox%zmin
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%zmax=tvox%zmax

            t_magnets(imag)%t_xyzcuts(ix,iy,1)%xyz=tvox%gcen
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%gcen=tvox%gcen

            do i=1,nhull
              t_magnets(imag)%t_xyzcuts(ix,iy,1)%xhull(i)=tvox%xhull(i)
              t_magnets(imag)%t_xyzcuts(ix,iy,1)%yhull(i)=tvox%yhull(i)
              t_magnets(imag)%t_xyzcuts(ix,iy,1)%zhull(i)=tvox%zhull(i)
            enddo

            t_magnets(imag)%t_xyzcuts(ix,iy,1)%ixdiv=ix
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%iydiv=iy
            t_magnets(imag)%t_xyzcuts(ix,iy,1)%izdiv=1
            t_magnets(imag)%kvoxels(ix,iy,1)=nvox

          else  !nzdiv.eq.1

            l=0
            ncorn1=0
            ncorn2=0

            do i=1,tvox%nface

              l=l+1

              n=tvox%kface(l)
              ncorn1(i)=n

              do j=1,n
                l=l+1
                ip=tvox%kface(l)
                x=tvox%xhull(ip)
                y=tvox%yhull(ip)
                z=tvox%zhull(ip)
                corn1(1,j,i)=x
                corn1(2,j,i)=y
                corn1(3,j,i)=z
              enddo !npoi

              ncorn1(i)=ncorn1(i)+1
              corn1(:,n+1,i)=corn1(:,1,i) ! for undumag_cut_magnet,
              ! the plane must be closed

            enddo !nface

            x02(2)=0.0d0
            y02(2)=0.0d0
            z02(2)=0.0d0

            !if (nzdiv.gt.1) zdiv=t_magnets(imag)%zdivs(1)+gcen(3)-gcenv(3)
            do iz=1,nzdiv-1

              nvox=nvox+1

              !zdiv=t_magnets(imag)%zdivs(iz)+gcen(3)-gcenv(3)+z02(1)

              zmin=1.0d30
              zmax=-1.0d30
              do iplan=1,nplanmax
                do icorn=1,ncorn1(iplan)
                  z=corn1(3,icorn,iplan)+z02(1)
                  if (z.lt.zmin) zmin=z
                  if (z.gt.zmax) zmax=z
                enddo
              enddo

              !dzdiv=t_magnets(imag)%zdivs(iz)-t_magnets(imag)%zmin
              !zdiv=zmin+z02(1)+dzdiv
              !zdiv=t_magnets(imag)%zdivs(iz)
              zdiv=t_magnets(imag)%zdivs(iz)+gcen(3) !Labor
              zdiv=zdiv-gcenv(3) ! relative to gcenv, i.e. GCEN of voxel

              klast=0

              if (zdiv-zmin.le.cuttiny.or.zmax-zdiv.le.cuttiny) then

                if (idebug.gt.0) call util_break
                klast=iz-1
                !cycle
                ! Hier ggf. clcmag_corn_to_vox benutzen, und auch unten
                goto 123

              else !(zmin.ge.zdiv.or.zmax.le.zdiv) then

                x02(1)=x02(2) !Labor
                y02(1)=y02(2)
                z02(1)=z02(2)

                call undumag_cut_magnet(imag,x02,y02,z02,
     &            2*nplanmax,2*ncornmax,
     &            ncorn1,corn1,ncorn2,corn2
     &            ,3,zdiv,hulltiny,ifail)

                if (ifail.ne.0) then
                  write(lun6,*)"*** Error in clcmag_zcut: Bad return from undumag_cut_magnet, magnet, ifail, mag, ixdiv, iydiv, izdiv, zdiv:",
     &              trim(t_magnets(imag)%cnam),ifail,imag,ix,iy," 1 ",zdiv
                  stop
                endif

                if (ncorn2(1).eq.0) then
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)=
     &              t_magnets(imag)%t_xycuts(ix,iy)
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%ixdiv=ix
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%iydiv=iy
                   t_magnets(imag)%t_xyzcuts(ix,iy,iz)%izdiv=iz
                  t_magnets(imag)%t_xycuts(ix,iy)%mzdiv=
     &              t_magnets(imag)%t_xycuts(ix,iy)%mzdiv+1
                  cycle
c                write(lun6,*) '*** Error in clcmag_zcut: No z-Cut for magnet, ixdiv, iydiv, izdiv ',
c     &            t_magnets(imag)%cnam,ixdiv,iydiv," 1"

                else !if (ncorn2(1).eq.0) then

                  npoi=0
                  do iplan=1,nplanmax
                    do icorn=1,ncorn1(iplan)
                      npoi=npoi+1
                      xh(npoi)=corn1(1,icorn,iplan)
                      yh(npoi)=corn1(2,icorn,iplan)
                      zh(npoi)=corn1(3,icorn,iplan)
                    enddo
                  enddo

                  call util_convex_hull_3d_overwrite(npoi,
     &              xh,yh,zh,khull,kedge,kface,nhull,nedge,nface,kfacelast,
     &              hulltiny,ifailhull)

                  allocate(t_magnets(imag)%t_xyzcuts(ix,iy,iz)%xhull(nhull))
                  allocate(t_magnets(imag)%t_xyzcuts(ix,iy,iz)%yhull(nhull))
                  allocate(t_magnets(imag)%t_xyzcuts(ix,iy,iz)%zhull(nhull))
                  allocate(t_magnets(imag)%t_xyzcuts(ix,iy,iz)%khull(nhull))

                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%xyz=gcenv+[x02(1),y02(1),z02(1)]
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%gcen=gcenv+[x02(1),y02(1),z02(1)]
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%nhull=nhull
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%khull=khull
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%nface=nface
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%kface=kface
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%kfacelast=kfacelast
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%nedge=nedge
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%kedge=kedge

                  xmin=1.0d30
                  xmax=-1.0d30
                  ymin=1.0d30
                  ymax=-1.0d30
                  zmin=1.0d30
                  zmax=-1.0d30

                  do i=1,nhull
                    t_magnets(imag)%t_xyzcuts(ix,iy,iz)%xhull(i)=xh(i)
                    t_magnets(imag)%t_xyzcuts(ix,iy,iz)%yhull(i)=yh(i)
                    t_magnets(imag)%t_xyzcuts(ix,iy,iz)%zhull(i)=zh(i)
                    if (xh(i).lt.xmin) xmin=xh(i)
                    if (xh(i).gt.xmax) xmax=xh(i)
                    if (yh(i).lt.ymin) ymin=yh(i)
                    if (yh(i).gt.ymax) ymax=yh(i)
                    if (zh(i).lt.zmin) zmin=zh(i)
                    if (zh(i).gt.zmax) zmax=zh(i)
                  enddo

                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%xmin=xmin
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%xmax=xmax
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%ymin=ymin
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%ymax=ymax
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%zmin=zmin
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%zmax=zmax

                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%size=
     &              [xmax-xmin,ymax-ymin,zmax-zmin]
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%ixdiv=ix
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%iydiv=iy
                  t_magnets(imag)%t_xyzcuts(ix,iy,iz)%izdiv=iz
                  t_magnets(imag)%t_xycuts(ix,iy)%mzdiv=
     &              t_magnets(imag)%t_xycuts(ix,iy)%mzdiv+1
                  t_magnets(imag)%kvoxels(ix,iy,iz)=nvox

                  ncorn1=ncorn2
                  corn1=corn2
                  x02(1)=x02(2)
                  y02(1)=y02(2)
                  z02(1)=z02(2)

                endif !(ncorn2(1).eq.0)

              endif !(zmin.ge.zdiv.or.zmax.le.zdiv) then

123           if (iz.eq.nzdiv-1.or.klast.ne.0) then
                nvox=nvox+1
                kz=iz+1
                if (klast.ne.0) then
                  kz=klast+1
                endif
                npoi=0
                do iplan=1,nplanmax
                  do icorn=1,ncorn1(iplan)
                    npoi=npoi+1
                    xh(npoi)=corn1(1,icorn,iplan)
                    yh(npoi)=corn1(2,icorn,iplan)
                    zh(npoi)=corn1(3,icorn,iplan)
                  enddo
                enddo

                call util_convex_hull_3d_overwrite(npoi,
     &            xh,yh,zh,khull,kedge,kface,nhull,nedge,nface,kfacelast,
     &            hulltiny,ifailhull)

                allocate(t_magnets(imag)%t_xyzcuts(ix,iy,kz)%xhull(nhull))
                allocate(t_magnets(imag)%t_xyzcuts(ix,iy,kz)%yhull(nhull))
                allocate(t_magnets(imag)%t_xyzcuts(ix,iy,kz)%zhull(nhull))
                allocate(t_magnets(imag)%t_xyzcuts(ix,iy,kz)%khull(nhull))
                allocate(t_magnets(imag)%t_xyzcuts(ix,iy,kz)%kedge(4,nedge))
                allocate(t_magnets(imag)%t_xyzcuts(ix,iy,kz)%kface(kfacelast))

                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%xyz=gcenv+[x02(1),y02(1),z02(1)]
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%gcen=gcenv+[x02(1),y02(1),z02(1)]
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%nhull=nhull
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%khull=khull
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%nface=nface
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%kface=kface
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%kfacelast=kfacelast
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%nedge=nedge
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%kedge=kedge

                xmin=1.0d30
                xmax=-1.0d30
                ymin=1.0d30
                ymax=-1.0d30
                zmin=1.0d30
                zmax=-1.0d30

                do i=1,nhull
                  t_magnets(imag)%t_xyzcuts(ix,iy,kz)%xhull(i)=xh(i)
                  t_magnets(imag)%t_xyzcuts(ix,iy,kz)%yhull(i)=yh(i)
                  t_magnets(imag)%t_xyzcuts(ix,iy,kz)%zhull(i)=zh(i)
                  if (xh(i).lt.xmin) xmin=xh(i)
                  if (xh(i).gt.xmax) xmax=xh(i)
                  if (yh(i).lt.ymin) ymin=yh(i)
                  if (yh(i).gt.ymax) ymax=yh(i)
                  if (zh(i).lt.zmin) zmin=zh(i)
                  if (zh(i).gt.zmax) zmax=zh(i)
                enddo

                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%size=[xmax-xmin,ymax-ymin,zmax-zmin]

                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%xmin=xmin
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%xmax=xmax
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%ymin=ymin
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%ymax=ymax
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%zmin=zmin
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%zmax=zmax

                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%ixdiv=ix
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%iydiv=iy
                t_magnets(imag)%t_xyzcuts(ix,iy,kz)%izdiv=kz
                t_magnets(imag)%t_xycuts(ix,iy)%mzdiv=
     &            t_magnets(imag)%t_xycuts(ix,iy)%mzdiv+1
                t_magnets(imag)%kvoxels(ix,iy,kz)=nvox

                exit

              endif ! klast

            enddo !nzdiv -1

          volmag=0.0d0

          do iz=1,nzdiv

            nhull=t_magnets(imag)%t_xyzcuts(ix,iy,iz)%nhull

            if (nhull.gt.0) then
              tvox=t_magnets(imag)%t_xyzcuts(ix,iy,iz)
              call util_volume(nhull,tvox%xhull,tvox%yhull,tvox%zhull,hulltiny,
     &          vol,ifail)
              if (ifail.ne.0) then
                write(lun6,*)"*** Error in clcmag_ycut: Bad return from util_volume, magnet, magnet number, ix,iy:",
     &            trim(tmag%cnam),imag,ix,iy
                stop
              endif
              t_magnets(imag)%t_xyzcuts(ix,iy,iz)%volume=vol
              volmag=volmag+vol
            else
              t_magnets(imag)%t_xyzcuts(ix,iy,iz)%volume=0.0d0
            endif

          enddo !iz

          vol=(volmag-t_magnets(imag)%t_xycuts(ix,iy)%volume)/
     &      t_magnets(imag)%t_xycuts(ix,iy)%volume

          if (abs(vol).gt.1.0d-9) then
            write(lun6,*)"*** Warning in clcmag_zcut: Sum of xyz-cut volumes differs from xy-cuts by (rel.):",vol
            write(lun6,*)"*** magnet, ixdiv, iydiv: ",trim(tmag%cnam),ix,iy
          endif

        endif !nzdiv.eq.1

      enddo !iy=1,nydiv

      enddo !nxdiv

!      if (nzdiv.gt.1) then
      deallocate(ncorn1,ncorn2,corn1,corn2,xh,yh,zh,xhc,yhc,zhc,kedge,kface)
!      endif

      t_magnets(imag)%nvoxels=nvox
      nvox_t=nvox_t+nvox

      if (idebug.gt.0) call util_break

+self,if=debzcut.
      open(unit=772,file="fort.772")
      do ix=1,nxdiv
        do iy=1,nydiv
          do iz=1,nzdiv
            tvox = t_magnets(imag)%t_xyzcuts(ix,iy,iz)
            if (tvox%ixdiv*tvox%iydiv*tvox%izdiv.eq.0) cycle
            do i=1,tvox%nhull
              write(772,*)
     &          ix,iy,iz,tvox%xhull(i),
     &          tvox%yhull(i),
     &          tvox%zhull(i),
     &          tvox%xhull(i)+tvox%gcen(1),
     &          tvox%yhull(i)+tvox%gcen(2),
     &          tvox%zhull(i)+tvox%gcen(3),
     &          tvox%xhull(i)+tmag%gcen(1),
     &          tvox%yhull(i)+tmag%gcen(2),
     &          tvox%zhull(i)+tmag%gcen(3)
            enddo
          enddo
        enddo
      enddo
      flush(772)
      close(772)
+self.

      volmag=0.0d0
      do ix=1,nxdiv
        do iy=1,nydiv
          do iz=1,nzdiv
            volmag=volmag+t_magnets(imag)%t_xyzcuts(ix,iy,iz)%volume
            !print*,"++++++++++++++++++++++++++++++++++++++++++++++++"
            !print*,ix,iy,iz
            !print*,"++++++++++++++++++++++++++++++++++++++++++++++++"
            l=1
            nplan=0
            do i=1,t_magnets(imag)%t_xyzcuts(ix,iy,iz)%kfacelast
              nplan=nplan+1
              ncorn=t_magnets(imag)%t_xyzcuts(ix,iy,iz)%kface(l)
              !print*,nplan,ncorn
              if (nplan.gt.nplanmax) then
                nplanmax=nplan
                call clcbuff_reallocate
              endif
              if (ncorn.gt.ncornmax) ncornmax=ncorn
              l=l+n+1
              if (nplan.eq.t_magnets(imag)%t_xyzcuts(ix,iy,iz)%nface) exit
            enddo
          enddo
        enddo
      enddo

      vol=(volmag-t_magnets(imag)%volume)/t_magnets(imag)%volume

      if (abs(vol).gt.1.0d-9) then
        write(lun6,*)"*** Warning in clcmag_zcut: Sum of xyz-cut volumes differs from magnet volume by (rel.): ",vol
        write(lun6,*)"*** magnet :",trim(tmag%cnam),imag
      endif

+self,if=trace.
      print*,"-trace-: Leaving clcmag_zcut"
+self.
      return
      end
+DECK,clcmag_ycut.
*CMZ :  2.04/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.22.55  by  Michael Scheer
*CMZ :  2.04/02 25/02/2023  18.03.22  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  13.49.55  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  18.19.49  by  Michael Scheer
*CMZ :  2.02/02 15/02/2022  15.59.51  by  Michael Scheer
*CMZ :  2.02/01 23/01/2022  14.50.54  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_ycut(imag)

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision, dimension (:,:,:), allocatable :: corn1,corn2
      double precision, dimension (:), allocatable :: xh,yh,zh,xhc,yhc,zhc

      double precision x,y,z,
     &  x02(2),y02(2),z02(2),ydivmin,ydivmax,
     &  gcen(3),gcenv(3),xmin,xmax,ymin,ymax,zmin,zmax,dydiv,ydiv,
     &  yfracdiv,fracsum,yfacdiv,vol,yvolmag

      integer, dimension (:), allocatable :: ncorn1,ncorn2

      integer :: idebug=0,
     &  i,j,l,n,ix,iy,ky,imag,ip,npoi,iplan,icorn,
     &  nxdiv,nydiv,nzdiv,kcut,klast

      integer :: ifailhull,ifail,nhull,nedge,nface,kfacelast,iydiv,ical=0

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface

      character(128) ctype

      type(T_Magnet) :: tmag
      type(T_Voxel) :: tvox

+self,if=trace.
      print*,"-trace-: Entered clcmag_ycut"
+self.

      if (idebug.ne.0) then
        call util_break
      endif

      ical=ical+1

      tmag=t_magnets(imag)
      gcen=t_magnets(imag)%gcen

      nxdiv=t_magnets(imag)%nxdiv
      nydiv=t_magnets(imag)%nydiv
      nzdiv=t_magnets(imag)%nzdiv

      ctype=t_magnets(imag)%ctype

+self,if=debycut.
      open(unit=770,file="fort.770")
      do i=1,t_magnets(imag)%nhull
        write(770,*)" 0 ",t_magnets(imag)%xhull(i),t_magnets(imag)%yhull(i),t_magnets(imag)%zhull(i)
      enddo
      do ix=1,nxdiv
        tvox = t_magnets(imag)%t_xcuts(ix)
        do i=1,tvox%nhull
          write(770,*)ix,tvox%xhull(i),tvox%yhull(i),tvox%zhull(i)
        enddo
      enddo
      flush(770)
      close(770)
      open(unit=699,file="fort.699")
      do i=1,t_magnets(imag)%nhull
        write(699,*)" 0 ",t_magnets(imag)%xhull(i)+gcen(1),
     &    t_magnets(imag)%yhull(i)+gcen(2),t_magnets(imag)%zhull(i)+gcen(3)
      enddo
      do ix=1,nxdiv
        tvox = t_magnets(imag)%t_xcuts(ix)
        do i=1,tvox%nhull
          write(699,*)ix,
     &      tvox%xhull(i)+tvox%gcen(1),
     &      tvox%yhull(i)+tvox%gcen(2),
     &      tvox%zhull(i)+tvox%gcen(3)
        enddo
      enddo
      flush(699)
      close(699)
+self.

      if (nydiv.gt.1) then

        allocate(t_magnets(imag)%ydivs(nydiv-1))

        fracsum=0.0d0
        ! yfracdiv**(nydiv-1)=yfacdiv
        ! ln(yfracdiv)*(nydiv-1)=ln(yfacdiv)
        yfacdiv=t_magnets(imag)%yfracdiv
        ydivmin=t_magnets(imag)%ymin
        ydivmax=t_magnets(imag)%ymax
        yfacdiv=t_magnets(imag)%yfracdiv

        if (nydiv.gt.1) then
          yfracdiv=exp(log(yfacdiv)/(nydiv-1))
        else
          yfracdiv=1.0d0
        endif
        do iydiv=0,nydiv-1
          fracsum=fracsum+yfracdiv**iydiv
        enddo

        dydiv=(ydivmax-ydivmin)/fracsum*yfacdiv
        t_magnets(imag)%ydivs(1)=ydivmin+dydiv

        if (idebug.ne.0) then
          call util_break
        endif

        do iy=2,nydiv-1
          dydiv=dydiv/yfracdiv
          t_magnets(imag)%ydivs(iy)=t_magnets(imag)%ydivs(iy-1)+dydiv !relative to gcen
        enddo

        allocate(corn1(3,2*ncornmax,2*nplanmax),corn2(3,2*ncornmax,2*nplanmax))
        allocate(ncorn1(2*nplanmax),ncorn2(2*nplanmax))
        allocate(
     &    xh(2*ncornmax*nplanmax),yh(2*ncornmax*nplanmax),zh(2*ncornmax*nplanmax),
     &    xhc(2*ncornmax*nplanmax),yhc(2*ncornmax*nplanmax),zhc(2*ncornmax*nplanmax))
        allocate(khull(2*ncornmax*nplanmax),kedge(4,2*ncornmax*nplanmax-2),
     &    kface(5*ncornmax*nplanmax))
      endif

      do ix=1,nxdiv

        tvox = t_magnets(imag)%t_xcuts(ix)
        t_magnets(imag)%t_xcuts(ix)%mydiv=0
        gcenv=tvox%gcen

        kcut=0

        !if (yfracdiv.gt.1) ydiv=t_magnets(imag)%ydivs(1)+gcen(2)-gcenv(2)

        do iy=1,nydiv-1
          ydiv=t_magnets(imag)%ydivs(iy)+gcen(2) !Labor
          ydiv=ydiv-gcenv(2) ! relative to gcenv
          if (ydiv-tvox%ymin.le.cuttiny.or.tvox%ymax-ydiv.le.cuttiny) cycle
          kcut=1
          exit
        enddo

        if (nydiv.eq.1.or.kcut.eq.0) then

          nhull=tvox%nhull
          nedge=tvox%nedge
          nface=tvox%nface
          khull=tvox%khull
          kedge=tvox%kedge
          kface=tvox%kface

          allocate(t_magnets(imag)%t_xycuts(ix,1)%khull(nhull))
          allocate(t_magnets(imag)%t_xycuts(ix,1)%xhull(nhull))
          allocate(t_magnets(imag)%t_xycuts(ix,1)%yhull(nhull))
          allocate(t_magnets(imag)%t_xycuts(ix,1)%zhull(nhull))
          allocate(t_magnets(imag)%t_xycuts(ix,1)%kedge(4,nedge))
          allocate(t_magnets(imag)%t_xycuts(ix,1)%kface(kfacelast))

          t_magnets(imag)%t_xycuts(ix,1)%nhull=nhull
          t_magnets(imag)%t_xycuts(ix,1)%khull=khull
          t_magnets(imag)%t_xycuts(ix,1)%nedge=nedge
          t_magnets(imag)%t_xycuts(ix,1)%kedge=kedge
          t_magnets(imag)%t_xycuts(ix,1)%nface=nface
          t_magnets(imag)%t_xycuts(ix,1)%kface=kface

          t_magnets(imag)%t_xycuts(ix,1)%size=tvox%size

          t_magnets(imag)%t_xycuts(ix,1)%xmin=tvox%xmin
          t_magnets(imag)%t_xycuts(ix,1)%xmax=tvox%xmax
          t_magnets(imag)%t_xycuts(ix,1)%ymin=tvox%ymin
          t_magnets(imag)%t_xycuts(ix,1)%ymax=tvox%ymax
          t_magnets(imag)%t_xycuts(ix,1)%zmin=tvox%zmin
          t_magnets(imag)%t_xycuts(ix,1)%zmax=tvox%zmax

          t_magnets(imag)%t_xycuts(ix,1)%xyz=tvox%gcen
          t_magnets(imag)%t_xycuts(ix,1)%gcen=tvox%gcen
          t_magnets(imag)%t_xycuts(ix,1)%volume=tvox%volume

          do i=1,nhull
            t_magnets(imag)%t_xycuts(ix,1)%xhull(i)=tvox%xhull(i)
            t_magnets(imag)%t_xycuts(ix,1)%yhull(i)=tvox%yhull(i)
            t_magnets(imag)%t_xycuts(ix,1)%zhull(i)=tvox%zhull(i)
          enddo

          t_magnets(imag)%t_xycuts(ix,1)%ixdiv=ix
          t_magnets(imag)%t_xycuts(ix,1)%iydiv=1
          t_magnets(imag)%t_xcuts(ix)%mydiv=1

        else  !nydiv.eq.1

          l=0
          ncorn1=0
          ncorn2=0

          do i=1,tvox%nface

            l=l+1

            n=tvox%kface(l)
            ncorn1(i)=n
+self,if=debycut.
            if (ix.eq.1) then
              open(unit=69,file='fort.69')
            else
              open(unit=69,file='fort.69',access='append')
            endif
+self.
            !corn1 is rel. to tvox%gcen
            do j=1,n
              l=l+1
              ip=tvox%kface(l)
              x=tvox%xhull(ip)
              y=tvox%yhull(ip)
              z=tvox%zhull(ip)
              corn1(1,j,i)=x
              corn1(2,j,i)=y
              corn1(3,j,i)=z
+self,if=debycut.
              write(69,*)ix,l,j,i,
     &          corn1(1,j,i)+tvox%gcen(1),
     &          corn1(2,j,i)+tvox%gcen(2),
     &          corn1(3,j,i)+tvox%gcen(3)
+self.
            enddo !npoi

            ncorn1(i)=ncorn1(i)+1
            corn1(:,n+1,i)=corn1(:,1,i) ! for undumag_cut_magnet,
            ! the plane must be closed
          enddo !nface

+self,if=debycut.
          flush(69)
          close(69)
+self.
          x02=0.0d0
          y02=0.0d0
          z02=0.0d0

          !if (nydiv.gt.1) ydiv=t_magnets(imag)%ydivs(1)+gcen(2)-gcenv(2)

          do iy=1,nydiv-1

            ydiv=t_magnets(imag)%ydivs(iy)+gcen(2) !Labor
            ydiv=ydiv-gcenv(2) ! relative to gcenv

            ymin=1.0d30
            ymax=-1.0d30
            do iplan=1,nplanmax
              do icorn=1,ncorn1(iplan)
                npoi=npoi+1
                y=corn1(2,icorn,iplan)+y02(1)
                if (y.lt.ymin) ymin=y
                if (y.gt.ymax) ymax=y
              enddo
            enddo

            klast=0

            if (ydiv-ymin.le.cuttiny.or.ymax-ydiv.le.cuttiny) then

              klast=iy-1
              goto 123

            else !if (ymin.ge.ydiv.or.ymax.le.ydiv)

              x02(1)=x02(2) ! relative to tvox%gcen
              y02(1)=y02(2)
              z02(1)=z02(2)

              call undumag_cut_magnet(imag,x02,y02,z02,
     &          2*nplanmax,2*ncornmax,
     &          ncorn1,corn1,ncorn2,corn2
     &          ,2,ydiv,hulltiny,ifail)

              if (idebug.ne.0) then
                call util_break
              endif

              if (ifail.ne.0) then
                write(lun6,*)"*** Error in clcmag_ycuts: Bad return from undumag_cut_magnet, magnet, ifail, mag, ixdiv, iydiv, ydiv:",
     &            trim(t_magnets(imag)%cnam),ifail,imag,ix,iy,ydiv
                stop
              endif

            endif !(ymin.ge.ydiv.or.ymax.le.ydiv)

            if (ncorn2(1).eq.0) then

              t_magnets(imag)%t_xycuts(ix,iy)=
     &          t_magnets(imag)%t_xcuts(ix)
              t_magnets(imag)%t_xycuts(ix,iy)%ixdiv=ix
              t_magnets(imag)%t_xycuts(ix,iy)%iydiv=iy
              cycle
c              write(lun6,*) '*** Error in clcmag_ycut: No y-Cut for magnet, ixdiv, iydiv: ',
c     &          t_magnets(imag)%cnam,ix,iy
c              stop

            else !if (ncorn2(1).eq.0) then

              ! Lower piece

              t_magnets(imag)%t_xcuts(ix)%mydiv=
     &          t_magnets(imag)%t_xcuts(ix)%mydiv+1

              npoi=0
              do iplan=1,nplanmax
                do icorn=1,ncorn1(iplan)
                  npoi=npoi+1
                  xh(npoi)=corn1(1,icorn,iplan)
                  yh(npoi)=corn1(2,icorn,iplan)
                  zh(npoi)=corn1(3,icorn,iplan)
                enddo
              enddo

              call util_convex_hull_3d_overwrite(npoi,
     &          xh,yh,zh,khull,kedge,kface,nhull,nedge,nface,kfacelast,
     &          hulltiny,ifailhull)

              allocate(t_magnets(imag)%t_xycuts(ix,iy)%xhull(nhull))
              allocate(t_magnets(imag)%t_xycuts(ix,iy)%yhull(nhull))
              allocate(t_magnets(imag)%t_xycuts(ix,iy)%zhull(nhull))

              t_magnets(imag)%t_xycuts(ix,iy)%xyz=gcenv+[x02(1),y02(1),z02(1)]
              ! t_magnets(imag)%t_xycuts(ix,iy)%gcen is in cutting plane, here
              t_magnets(imag)%t_xycuts(ix,iy)%gcen=gcenv+[x02(1),y02(1),z02(1)]
              t_magnets(imag)%t_xycuts(ix,iy)%nhull=nhull
              t_magnets(imag)%t_xycuts(ix,iy)%khull=khull
              t_magnets(imag)%t_xycuts(ix,iy)%nface=nface
              t_magnets(imag)%t_xycuts(ix,iy)%kface=kface
              t_magnets(imag)%t_xycuts(ix,iy)%kfacelast=kfacelast
              t_magnets(imag)%t_xycuts(ix,iy)%nedge=nedge
              t_magnets(imag)%t_xycuts(ix,iy)%kedge=kedge

              xmin=1.0d30
              xmax=-1.0d30
              ymin=1.0d30
              ymax=-1.0d30
              zmin=1.0d30
              zmax=-1.0d30

              do i=1,nhull
                t_magnets(imag)%t_xycuts(ix,iy)%xhull(i)=xh(i)
                t_magnets(imag)%t_xycuts(ix,iy)%yhull(i)=yh(i)
                t_magnets(imag)%t_xycuts(ix,iy)%zhull(i)=zh(i)
                if (xh(i).lt.xmin) xmin=xh(i)
                if (xh(i).gt.xmax) xmax=xh(i)
                if (yh(i).lt.ymin) ymin=yh(i)
                if (yh(i).gt.ymax) ymax=yh(i)
                if (zh(i).lt.zmin) zmin=zh(i)
                if (zh(i).gt.zmax) zmax=zh(i)
              enddo

              t_magnets(imag)%t_xycuts(ix,iy)%xmin=xmin
              t_magnets(imag)%t_xycuts(ix,iy)%xmax=xmax
              t_magnets(imag)%t_xycuts(ix,iy)%ymin=ymin
              t_magnets(imag)%t_xycuts(ix,iy)%ymax=ymax
              t_magnets(imag)%t_xycuts(ix,iy)%zmin=zmin
              t_magnets(imag)%t_xycuts(ix,iy)%zmax=zmax

              t_magnets(imag)%t_xycuts(ix,iy)%size=[xmax-xmin,ymax-ymin,zmax-zmin]
              t_magnets(imag)%t_xycuts(ix,iy)%ixdiv=ix
              t_magnets(imag)%t_xycuts(ix,iy)%iydiv=iy

              !corn2 is upper piece

              ncorn1=ncorn2
              corn1=corn2
              x02(1)=x02(2)
              y02(1)=y02(2)
              z02(1)=z02(2)

            endif !(ncorn2(1).eq.0)

123         continue

            if (iy.eq.nydiv-1.or.klast.ne.0) then

              ky=iy+1
              if (klast.ne.0) then
                ky=klast+1
              endif

              npoi=0

              do iplan=1,nplanmax
                do icorn=1,ncorn1(iplan)
                  npoi=npoi+1
                  xh(npoi)=corn1(1,icorn,iplan)
                  yh(npoi)=corn1(2,icorn,iplan)
                  zh(npoi)=corn1(3,icorn,iplan)
                enddo
              enddo

              call util_convex_hull_3d_overwrite(npoi,
     &          xh,yh,zh,khull,kedge,kface,nhull,nedge,nface,kfacelast,
     &          hulltiny,ifailhull)

              allocate(t_magnets(imag)%t_xycuts(ix,ky)%khull(nhull))
              allocate(t_magnets(imag)%t_xycuts(ix,ky)%xhull(nhull))
              allocate(t_magnets(imag)%t_xycuts(ix,ky)%yhull(nhull))
              allocate(t_magnets(imag)%t_xycuts(ix,ky)%zhull(nhull))
              allocate(t_magnets(imag)%t_xycuts(ix,ky)%kedge(4,nedge))
              allocate(t_magnets(imag)%t_xycuts(ix,ky)%kface(kfacelast))

              t_magnets(imag)%t_xycuts(ix,ky)%xyz=gcenv+[x02(1),y02(1),z02(1)]
              t_magnets(imag)%t_xycuts(ix,ky)%gcen=gcenv+[x02(1),y02(1),z02(1)]
              t_magnets(imag)%t_xycuts(ix,ky)%nhull=nhull
              t_magnets(imag)%t_xycuts(ix,ky)%khull=khull
              t_magnets(imag)%t_xycuts(ix,ky)%nface=nface
              t_magnets(imag)%t_xycuts(ix,ky)%kface=kface
              t_magnets(imag)%t_xycuts(ix,ky)%kfacelast=kfacelast
              t_magnets(imag)%t_xycuts(ix,ky)%nedge=nedge
              t_magnets(imag)%t_xycuts(ix,ky)%kedge=kedge

              xmin=1.0d30
              xmax=-1.0d30
              ymin=1.0d30
              ymax=-1.0d30
              zmin=1.0d30
              zmax=-1.0d30

              do i=1,nhull
                t_magnets(imag)%t_xycuts(ix,ky)%xhull(i)=xh(i)
                t_magnets(imag)%t_xycuts(ix,ky)%yhull(i)=yh(i)
                t_magnets(imag)%t_xycuts(ix,ky)%zhull(i)=zh(i)
                if (xh(i).lt.xmin) xmin=xh(i)
                if (xh(i).gt.xmax) xmax=xh(i)
                if (yh(i).lt.ymin) ymin=yh(i)
                if (yh(i).gt.ymax) ymax=yh(i)
                if (zh(i).lt.zmin) zmin=zh(i)
                if (zh(i).gt.zmax) zmax=zh(i)
              enddo

              t_magnets(imag)%t_xycuts(ix,ky)%xmin=xmin
              t_magnets(imag)%t_xycuts(ix,ky)%xmax=xmax
              t_magnets(imag)%t_xycuts(ix,ky)%ymin=ymin
              t_magnets(imag)%t_xycuts(ix,ky)%ymax=ymax
              t_magnets(imag)%t_xycuts(ix,ky)%zmin=zmin
              t_magnets(imag)%t_xycuts(ix,ky)%zmax=zmax

              t_magnets(imag)%t_xycuts(ix,ky)%size=[xmax-xmin,ymax-ymin,zmax-zmin]
              t_magnets(imag)%t_xycuts(ix,ky)%ixdiv=ix
              t_magnets(imag)%t_xycuts(ix,ky)%iydiv=ky

              t_magnets(imag)%t_xcuts(ix)%mydiv=
     &          t_magnets(imag)%t_xcuts(ix)%mydiv+1

              exit

            endif !(iy.eq.nydiv-1.or.klast.ne.0)

          enddo !iy=1,nydiv-1

        endif !nydiv.eq.1

        yvolmag=0.0d0

        do iy=1,nydiv

          nhull=t_magnets(imag)%t_xycuts(ix,iy)%nhull

          if (nhull.gt.0) then
            tvox=t_magnets(imag)%t_xycuts(ix,iy)
            call util_volume(nhull,tvox%xhull,tvox%yhull,tvox%zhull,hulltiny,
     &        vol,ifail)
            if (ifail.ne.0) then
              write(lun6,*)"*** Error in clcmag_ycut: Bad return from util_volume, magnet, magnet number, ix,iy:",
     &          trim(tmag%cnam),imag,ix,iy
              stop
            endif
            t_magnets(imag)%t_xycuts(ix,iy)%volume=vol
            yvolmag=yvolmag+vol
          else
            t_magnets(imag)%t_xycuts(ix,iy)%volume=0.0d0
          endif

        enddo

        vol=(yvolmag-t_magnets(imag)%t_xcuts(ix)%volume)/
     &    t_magnets(imag)%t_xcuts(ix)%volume

        if (abs(vol).gt.1.0d-9) then
          write(lun6,*)"*** Warning in clcmag_ycut: Sum of xy-cut volumes differs from magnet volume by (rel.):",vol
          write(lun6,*)"*** magnet, ixdiv:",trim(tmag%cnam),ix
        endif

      enddo !nxdiv

      if (nydiv.gt.1) then
        deallocate(corn1,corn2,xh,yh,zh,xhc,yhc,zhc,kedge,kface)
      endif

+self,if=debycut.
      open(unit=771,file="fort.771")
      do ix=1,nxdiv
        do iy=1,nydiv
          tvox = t_magnets(imag)%t_xycuts(ix,iy)
          if (tvox%ixdiv*tvox%iydiv.eq.0) cycle
          do i=1,tvox%nhull
            write(771,*)
     &        ix,iy,tvox%xhull(i),
     &        tvox%yhull(i),
     &        tvox%zhull(i),
     &        tvox%xhull(i)+tvox%gcen(1),
     &        tvox%yhull(i)+tvox%gcen(2),
     &        tvox%zhull(i)+tvox%gcen(3),
     &        tvox%xhull(i)+tmag%gcen(1),
     &        tvox%yhull(i)+tmag%gcen(2),
     &        tvox%zhull(i)+tmag%gcen(3)
          enddo
        enddo
      enddo
      flush(771)
      close(771)
+self.

      !call util_break

      yvolmag=0.0d0
      do ix=1,nxdiv
        do iy=1,nydiv
          yvolmag=yvolmag+t_magnets(imag)%t_xycuts(ix,iy)%volume
        enddo
      enddo
      vol=(yvolmag-t_magnets(imag)%volume)/t_magnets(imag)%volume

      if (abs(vol).gt.1.0d-9) then
        write(lun6,*)"*** Warning in clcmag_ycut: Sum of xy-cut volumes differs from magnet volume by (rel.): ",vol
        write(lun6,*)"*** magnet :",trim(tmag%cnam),imag
      endif

+self,if=trace.
      print*,"-trace-: Leaving clcmag_ycut"
+self.
      return
      end
+DECK,CLCMAG_XCUT.
*CMZ :  2.04/03 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  12.14.18  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  13.19.45  by  Michael Scheer
*CMZ :  2.04/00 16/01/2023  15.35.00  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  18.19.49  by  Michael Scheer
*CMZ :  2.02/02 15/02/2022  15.33.18  by  Michael Scheer
*CMZ :  2.02/01 19/01/2022  12.18.14  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_xcut(imag)

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      Type(t_voxel) tvox

      character(128) ctype

      double precision, dimension (:,:,:), allocatable :: corn1,corn2
      double precision, dimension (:), allocatable :: xh,yh,zh,xhc,yhc,zhc

      double precision x,y,z,
     &  x02(2),y02(2),z02(2),xdivmin,xdivmax,ydivmin,ydivmax,zdivmin,zdivmax,
     &  xdiv,dxdiv,gcen(3),xyz(3),xmin,xmax,ymin,ymax,zmin,zmax,dydiv,ydiv,
     &  zdiv,dzdiv,vol,xvolmag

      integer, dimension (:), allocatable :: ncorn1,ncorn2

      integer i,j,k,l,n,imag,ip,npoi,iplan,icorn,nxdiv,nydiv,nzdiv,ix,kx

      integer :: idebug=0,
     &  ifailhull,ifail,nhull,nedge,nface,kfacelast

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface

      type(T_Magnet) :: tmag

      if (idebug.gt.0) call util_break

+self,if=trace.
      print*,"-trace-: Entered clcmag_xcut"
+self.

      xmin=1.0d30
      xmax=-1.0d30
      ymin=1.0d30
      ymax=-1.0d30
      zmin=1.0d30
      zmax=-1.0d30

      do k=1,t_magnets(imag)%nhull
        if (t_magnets(imag)%xhull(k).lt.xmin) xmin=t_magnets(imag)%xhull(k)
        if (t_magnets(imag)%xhull(k).gt.xmax) xmax=t_magnets(imag)%xhull(k)
        if (t_magnets(imag)%yhull(k).lt.ymin) ymin=t_magnets(imag)%yhull(k)
        if (t_magnets(imag)%yhull(k).gt.ymax) ymax=t_magnets(imag)%yhull(k)
        if (t_magnets(imag)%zhull(k).lt.zmin) zmin=t_magnets(imag)%zhull(k)
        if (t_magnets(imag)%zhull(k).gt.zmax) zmax=t_magnets(imag)%zhull(k)
      enddo

      t_magnets(imag)%xmin=xmin
      t_magnets(imag)%xmax=xmax
      t_magnets(imag)%ymin=ymin
      t_magnets(imag)%ymax=ymax
      t_magnets(imag)%zmin=zmin
      t_magnets(imag)%zmax=zmax

      t_magnets(imag)%size(1)=xmax-xmin
      t_magnets(imag)%size(2)=ymax-ymin
      t_magnets(imag)%size(3)=zmax-zmin

      allocate(corn1(3,2*ncornmax,2*nplanmax),corn2(3,2*ncornmax,2*nplanmax))
      allocate(ncorn1(2*nplanmax),ncorn2(2*nplanmax))

      allocate(
     &  xh(2*ncornmax*nplanmax),yh(2*ncornmax*nplanmax),zh(2*ncornmax*nplanmax),
     &  xhc(2*ncornmax*nplanmax),yhc(2*ncornmax*nplanmax),zhc(2*ncornmax*nplanmax))

      allocate(khull(2*ncornmax*nplanmax),kedge(4,2*ncornmax*nplanmax-2),
     &  kface(5*ncornmax*nplanmax))

      t_magnets(imag)%mxdiv=0

      if (t_magnets(imag)%nxdiv.gt.0) then
        t_magnets(imag)%dxdiv=(t_magnets(imag)%xmax-t_magnets(imag)%xmin)/
     &    t_magnets(imag)%nxdiv
c        t_magnets(imag)%dxdiv=t_magnets(imag)%size(1)/t_magnets(imag)%nxdiv
      endif

      tmag=t_magnets(imag)

      gcen=tmag%gcen
+self,if=debxcut.
      do i=1,tmag%nhull
        write(99,*)i,
     &    tmag%xhull(i),
     &    tmag%yhull(i),
     &    tmag%zhull(i)
        write(98,*)i,
     &    tmag%xhull(i)+gcen(1),
     &    tmag%yhull(i)+gcen(2),
     &    tmag%zhull(i)+gcen(3)
        write(97,*)i,
     &    tmag%xhull(i)-gcen(1),
     &    tmag%yhull(i)-gcen(2),
     &    tmag%zhull(i)-gcen(3)
      enddo
+self.

      !call util_break

      xyz=tmag%xyz

      nxdiv=tmag%nxdiv
      nydiv=tmag%nydiv
      nzdiv=tmag%nzdiv

      xdivmin=tmag%xmin
      xdivmax=tmag%xmax
      dxdiv=tmag%dxdiv
      xdiv=xdivmin

      ydivmin=tmag%ymin
      ydivmax=tmag%ymax
      dydiv=tmag%dydiv

      ydiv=ydivmin

      zdivmin=tmag%zmin
      zdivmax=tmag%zmax
      dzdiv=tmag%dzdiv

      zdiv=zdivmin

      ctype=tmag%ctype

      if (nxdiv.eq.1) then

        nhull=tmag%nhull
        khull=tmag%khull
        nedge=tmag%nedge
        nface=tmag%nface
        kedge=tmag%kedge
        kface=tmag%kface

        allocate(t_magnets(imag)%t_xcuts(1)%xhull(nhull))
        allocate(t_magnets(imag)%t_xcuts(1)%yhull(nhull))
        allocate(t_magnets(imag)%t_xcuts(1)%zhull(nhull))
        allocate(t_magnets(imag)%t_xcuts(1)%khull(nhull))
        allocate(t_magnets(imag)%t_xcuts(1)%kedge(4,nedge))
        allocate(t_magnets(imag)%t_xcuts(1)%kface(kfacelast))

        t_magnets(imag)%t_xcuts(1)%nhull=nhull
        t_magnets(imag)%t_xcuts(1)%khull=khull
        t_magnets(imag)%t_xcuts(1)%nedge=nedge
        t_magnets(imag)%t_xcuts(1)%kedge=kedge
        t_magnets(imag)%t_xcuts(1)%nface=nface
        t_magnets(imag)%t_xcuts(1)%kface=kface

        t_magnets(imag)%t_xcuts(1)%size=tmag%size
        t_magnets(imag)%t_xcuts(1)%xmin=tmag%xmin
        t_magnets(imag)%t_xcuts(1)%xmax=tmag%xmax
        t_magnets(imag)%t_xcuts(1)%ymin=tmag%ymin
        t_magnets(imag)%t_xcuts(1)%ymax=tmag%ymax
        t_magnets(imag)%t_xcuts(1)%zmin=tmag%zmin
        t_magnets(imag)%t_xcuts(1)%zmax=tmag%zmax

        t_magnets(imag)%t_xcuts(1)%xyz=gcen
        t_magnets(imag)%t_xcuts(1)%gcen=gcen
        t_magnets(imag)%t_xcuts(1)%ixdiv=1
        t_magnets(imag)%t_xcuts(1)%volume=t_magnets(imag)%volume

        do i=1,nhull
          t_magnets(imag)%t_xcuts(1)%xhull(i)=tmag%xhull(i)
          t_magnets(imag)%t_xcuts(1)%yhull(i)=tmag%yhull(i)
          t_magnets(imag)%t_xcuts(1)%zhull(i)=tmag%zhull(i)
        enddo

      else !nxdiv.eq.1

        l=0
        ncorn1=0
        ncorn2=0

        xmin=1.0d30
        xmax=-1.0d30

        do i=1,tmag%nface

          l=l+1

          n=tmag%kface(l)
          ncorn1(i)=n

          do j=1,n
            l=l+1
            ip=tmag%kface(l)
            x=tmag%xhull(ip)
            y=tmag%yhull(ip)
            z=tmag%zhull(ip)
            corn1(1,j,i)=x
            corn1(2,j,i)=y
            corn1(3,j,i)=z
            if (x.lt.xmin) xmin=x
            if (x.gt.xmax) xmax=x
          enddo !npoi

          ncorn1(i)=ncorn1(i)+1
          corn1(:,n+1,i)=corn1(:,1,i) ! for undumag_cut_magnet,
          ! the plane must be closed

        enddo !nface

        x02(2)=0.0d0
        y02(2)=0.0d0
        z02(2)=0.0d0

        do ix=1,nxdiv-1

          xdiv=xdiv+dxdiv

          x02(1)=x02(2)
          y02(1)=y02(2)
          z02(1)=z02(2)

          call undumag_cut_magnet(imag,x02,y02,z02,
     &      2*nplanmax,2*ncornmax,
     &      ncorn1,corn1,ncorn2,corn2
     &      ,1,xdiv,hulltiny,ifail)

          if (ifail.ne.0) then
            write(lun6,*)"*** Error in clcmag_xcut: Bad return from undumag_cut_magnet, magnet, ifail, mag, ixdiv, xdiv:",
     &        trim(tmag%cnam),ifail,imag,ix,xdiv
            stop
          endif

          if (ncorn2(1).eq.0) then
            write(lun6,*) '*** Error in clcmag_xcut: No x-Cut for magnet ',tmag%cnam
            stop
          else

            xmin=1.0d30
            xmax=-1.0d30

            npoi=0
            do iplan=1,nplanmax
              do icorn=1,ncorn1(iplan)
                npoi=npoi+1
                xh(npoi)=corn1(1,icorn,iplan)
                yh(npoi)=corn1(2,icorn,iplan)
                zh(npoi)=corn1(3,icorn,iplan)
                x=xh(npoi)
                if (x.lt.xmin) xmin=x
                if (x.gt.xmax) xmax=x
              enddo
            enddo

            !print*,"nachher,xmin,xmax:)",xmin+x02(1),xmax+x02(1)
            !print*,x02
            !stop

            call util_convex_hull_3d_overwrite(npoi,
     &        xh,yh,zh,khull,kedge,kface,nhull,nedge,nface,kfacelast,
     &        hulltiny,ifailhull)

            allocate(t_magnets(imag)%t_xcuts(ix)%xhull(nhull))
            allocate(t_magnets(imag)%t_xcuts(ix)%yhull(nhull))
            allocate(t_magnets(imag)%t_xcuts(ix)%zhull(nhull))

            t_magnets(imag)%mxdiv=t_magnets(imag)%mxdiv+1

            t_magnets(imag)%t_xcuts(ix)%xyz=gcen+[x02(1),y02(1),z02(1)]
            t_magnets(imag)%t_xcuts(ix)%gcen=gcen+[x02(1),y02(1),z02(1)]
            t_magnets(imag)%t_xcuts(ix)%nhull=nhull
            t_magnets(imag)%t_xcuts(ix)%khull=khull
            t_magnets(imag)%t_xcuts(ix)%nface=nface
            t_magnets(imag)%t_xcuts(ix)%kface=kface
            t_magnets(imag)%t_xcuts(ix)%kfacelast=kfacelast
            t_magnets(imag)%t_xcuts(ix)%nedge=nedge
            t_magnets(imag)%t_xcuts(ix)%kedge=kedge
            t_magnets(imag)%t_xcuts(ix)%ixdiv=ix

            xmin=1.0d30
            xmax=-1.0d30
            ymin=1.0d30
            ymax=-1.0d30
            zmin=1.0d30
            zmax=-1.0d30

            do i=1,nhull
              t_magnets(imag)%t_xcuts(ix)%xhull(i)=xh(i)
              t_magnets(imag)%t_xcuts(ix)%yhull(i)=yh(i)
              t_magnets(imag)%t_xcuts(ix)%zhull(i)=zh(i)
              if (xh(i).lt.xmin) xmin=xh(i)
              if (xh(i).gt.xmax) xmax=xh(i)
              if (yh(i).lt.ymin) ymin=yh(i)
              if (yh(i).gt.ymax) ymax=yh(i)
              if (zh(i).lt.zmin) zmin=zh(i)
              if (zh(i).gt.zmax) zmax=zh(i)
            enddo

            t_magnets(imag)%t_xcuts(ix)%xmin=xmin
            t_magnets(imag)%t_xcuts(ix)%xmax=xmax
            t_magnets(imag)%t_xcuts(ix)%ymin=ymin
            t_magnets(imag)%t_xcuts(ix)%ymax=ymax
            t_magnets(imag)%t_xcuts(ix)%zmin=zmin
            t_magnets(imag)%t_xcuts(ix)%zmax=zmax

            t_magnets(imag)%t_xcuts(ix)%size=[xmax-xmin,ymax-ymin,zmax-zmin]

            ncorn1=ncorn2
            corn1=corn2
            x02(1)=x02(2)
            y02(1)=y02(2)
            z02(1)=z02(2)

            if (ix.eq.nxdiv-1) then
              kx=ix+1
              npoi=0
              do iplan=1,nplanmax
                do icorn=1,ncorn1(iplan)
                  npoi=npoi+1
                  xh(npoi)=corn1(1,icorn,iplan)
                  yh(npoi)=corn1(2,icorn,iplan)
                  zh(npoi)=corn1(3,icorn,iplan)
                enddo
              enddo

              call util_convex_hull_3d_overwrite(npoi,
     &          xh,yh,zh,khull,kedge,kface,nhull,nedge,nface,kfacelast,
     &          hulltiny,ifailhull)

              allocate(t_magnets(imag)%t_xcuts(kx)%xhull(nhull))
              allocate(t_magnets(imag)%t_xcuts(kx)%yhull(nhull))
              allocate(t_magnets(imag)%t_xcuts(kx)%zhull(nhull))
              allocate(t_magnets(imag)%t_xcuts(kx)%khull(nhull))
              allocate(t_magnets(imag)%t_xcuts(kx)%kedge(4,nedge))
              allocate(t_magnets(imag)%t_xcuts(kx)%kface(kfacelast))

              t_magnets(imag)%t_xcuts(kx)%xyz=gcen+[x02(1),y02(1),z02(1)]
              t_magnets(imag)%t_xcuts(kx)%gcen=gcen+[x02(1),y02(1),z02(1)]
              t_magnets(imag)%t_xcuts(kx)%nhull=nhull
              t_magnets(imag)%t_xcuts(kx)%khull=khull
              t_magnets(imag)%t_xcuts(kx)%nface=nface
              t_magnets(imag)%t_xcuts(kx)%kface=kface
              t_magnets(imag)%t_xcuts(kx)%kfacelast=kfacelast
              t_magnets(imag)%t_xcuts(kx)%nedge=nedge
              t_magnets(imag)%t_xcuts(kx)%kedge=kedge
              t_magnets(imag)%t_xcuts(kx)%ixdiv=kx

              xmin=1.0d30
              xmax=-1.0d30
              ymin=1.0d30
              ymax=-1.0d30
              zmin=1.0d30
              zmax=-1.0d30

              do i=1,nhull
                t_magnets(imag)%t_xcuts(kx)%xhull(i)=xh(i)
                t_magnets(imag)%t_xcuts(kx)%yhull(i)=yh(i)
                t_magnets(imag)%t_xcuts(kx)%zhull(i)=zh(i)
                if (xh(i).lt.xmin) xmin=xh(i)
                if (xh(i).gt.xmax) xmax=xh(i)
                if (yh(i).lt.ymin) ymin=yh(i)
                if (yh(i).gt.ymax) ymax=yh(i)
                if (zh(i).lt.zmin) zmin=zh(i)
                if (zh(i).gt.zmax) zmax=zh(i)
              enddo

              t_magnets(imag)%t_xcuts(kx)%size=[xmax-xmin,ymax-ymin,zmax-zmin]

              t_magnets(imag)%t_xcuts(kx)%xmin=xmin
              t_magnets(imag)%t_xcuts(kx)%xmax=xmax
              t_magnets(imag)%t_xcuts(kx)%ymin=ymin
              t_magnets(imag)%t_xcuts(kx)%ymax=ymax
              t_magnets(imag)%t_xcuts(kx)%zmin=zmin
              t_magnets(imag)%t_xcuts(kx)%zmax=zmax
              t_magnets(imag)%mxdiv=t_magnets(imag)%mxdiv+1

            endif !last cut

          endif !ncorn2, cut

        enddo !nxdiv -1

      endif !nxdiv.dq.1

+self,if=debxcut.
      do ix=1,nxdiv
        gcenv=t_magnets(imag)%t_xcuts(ix)%gcen
        do i=1,t_magnets(imag)%t_xcuts(ix)%nhull
          write(661,*) ix,
     &      t_magnets(imag)%t_xcuts(ix)%xhull(i),
     &      t_magnets(imag)%t_xcuts(ix)%yhull(i),
     &      t_magnets(imag)%t_xcuts(ix)%zhull(i),
     &      t_magnets(imag)%t_xcuts(ix)%xhull(i)+gcenv(1),
     &      t_magnets(imag)%t_xcuts(ix)%yhull(i)+gcenv(2),
     &      t_magnets(imag)%t_xcuts(ix)%zhull(i)+gcenv(3)
        enddo
      enddo
      !stop
+self.
      deallocate(corn1,corn2)

      xvolmag=0.0d0
      t_magnets(imag)%xvolume=0.0d0
      do ix=1,nxdiv
        nhull=t_magnets(imag)%t_xcuts(ix)%nhull
        if (nhull.gt.0) then
          tvox=t_magnets(imag)%t_xcuts(ix)
          call util_volume(nhull,tvox%xhull,tvox%yhull,tvox%zhull,hulltiny,
     &      vol,ifail)
          if (ifail.ne.0) then
            write(lun6,*)"*** Error in clcmag_xcut: Bad return from util_volume, magnet, magnet number, ixdiv: ",
     &        trim(tmag%cnam),imag,ix
            stop
          endif
          t_magnets(imag)%t_xcuts(ix)%volume=vol
        else
          t_magnets(imag)%t_xcuts(ix)%volume=0.0d0
        endif
        xvolmag=xvolmag+vol
      enddo

      vol=(xvolmag-t_magnets(imag)%volume)/t_magnets(imag)%volume

      if (abs(vol).gt.1.0d-9) then
        write(lun6,*)"*** Warning in clcmag_xcut: Sum of x-cut volumes differs from magnet volume by (rel.):",vol
        write(lun6,*)"Magnet: ",t_magnets(imag)%cnam
      endif

+self,if=trace.
      print*,"-trace-: Leaving clcmag_xcut"
+self.

      !call util_break

      return
      end
+DECK,clcmag_voxels.
*CMZ :  2.04/09 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  12.58.25  by  Michael Scheer
*CMZ :  2.04/07 09/08/2023  12.43.30  by  Michael Scheer
*CMZ :  2.04/06 04/08/2023  11.32.02  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  19.30.13  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.28.35  by  Michael Scheer
*CMZ :  2.04/00 09/12/2022  11.08.58  by  Michael Scheer
*CMZ :  2.02/01 29/01/2022  10.13.35  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2021
      subroutine clcmag_voxels

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      double precision br(3),volmag,gcen(3)
      integer imag,ix,iy,iz,nvox,k,luno,npoi,l,ipoi,iface
      integer :: idebug=0
c+self,if=voxcyl.
      integer iv
c+self.
      character(32) ctype

+self,if=trace.
      print*,"-trace-: Entered clcmag_voxels"
+self.
      if (iundugeo.ne.0) then
        open(newunit=luno,file='undumag_voxels.geo')
      endif

      do imag=1,nmag_t+nspecmag_t

        ctype=t_magnets(imag)%ctype

        volmag=0.0d0

        if (ctype.ne.'Cylinder') then
          allocate(t_magnets(imag)%t_voxels(t_magnets(imag)%nvoxels))
c+self,if=-voxcyl.
c        endif
c+self.

          nvox=0
          if (idebug.eq.1) then
            print*,"imag, ix, iy, iz, ixdiv, iydiv, izdiv, kvox, volume"
          else if (idebug.ge.2) then
            print*,"imag, nvoxels:",imag,t_magnets(imag)%nvoxels
          endif
          do iz=1,t_magnets(imag)%nzdiv
            do iy=1,t_magnets(imag)%nydiv
              do ix=1,t_magnets(imag)%nxdiv
                if (idebug.eq.1) then
                  print*,imag,ix,iy,iz,
     &              t_magnets(imag)%t_xyzcuts(ix,iy,iz)%ixdiv,
     &              t_magnets(imag)%t_xyzcuts(ix,iy,iz)%iydiv,
     &              t_magnets(imag)%t_xyzcuts(ix,iy,iz)%izdiv,
     &              t_magnets(imag)%t_xyzcuts(ix,iy,iz)%ixdiv,
     &              t_magnets(imag)%kvoxels(ix,iy,iz),
     &              t_magnets(imag)%t_xyzcuts(ix,iy,iz)%volume
                endif
                if (t_magnets(imag)%t_xyzcuts(ix,iy,iz)%ixdiv.eq.0.or.
     &            t_magnets(imag)%t_xyzcuts(ix,iy,iz)%iydiv.eq.0.or.
     &              t_magnets(imag)%t_xyzcuts(ix,iy,iz)%izdiv.eq.0) then
                  if (t_magnets(imag)%t_xyzcuts(ix,iy,iz)%volume.ne.0d0) then
                    print*,imag,ix,iy,iz
                    stop "Error 1 in clcmag_voxels"
                  endif
                  cycle
                endif
                kvox=t_magnets(imag)%kvoxels(ix,iy,iz)
                if (kvox.eq.0) then
                  if (t_magnets(imag)%t_xyzcuts(ix,iy,iz)%volume.ne.0d0) then
                    print*,imag,ix,iy,iz
                    stop "Error 2 in clcmag_voxels"
                  endif
                  cycle
                endif
                nvox=nvox+1
                t_magnets(imag)%t_voxels(nvox)=
     &            t_magnets(imag)%t_xyzcuts(ix,iy,iz)
                t_magnets(imag)%t_voxels(nvox)%ixdiv=ix
                t_magnets(imag)%t_voxels(nvox)%iydiv=iy
                t_magnets(imag)%t_voxels(nvox)%izdiv=iz
                t_magnets(imag)%t_voxels(nvox)%isBlock=
     &            t_magnets(imag)%isBlock
+self,if=-novol.
                call clcmag_voxel_volume(imag,nvox)
+self.
                l=0
                if (iundugeo.ne.0) then
                  do iface=1,t_magnets(imag)%t_voxels(nvox)%nface
                    l=l+1
                    npoi=t_magnets(imag)%t_voxels(nvox)%kface(l)
                    gcen=t_magnets(imag)%t_voxels(nvox)%gcen
                    do ipoi=1,npoi
                      l=l+1
                      k=t_magnets(imag)%t_voxels(nvox)%kface(l)
                      write(luno,*)imag,nvox,ix,iy,iz,iface,ipoi,
     &                  t_magnets(imag)%t_voxels(nvox)%xhull(k)+gcen(1),
     &                  t_magnets(imag)%t_voxels(nvox)%yhull(k)+gcen(2),
     &                  t_magnets(imag)%t_voxels(nvox)%zhull(k)+gcen(3),
     &                  gcen,
     &                  t_magnets(imag)%t_voxels(nvox)%volume
                    enddo
                  enddo
                endif
                volmag=volmag+t_magnets(imag)%t_voxels(nvox)%volume
                if (t_magnets(imag)%IsInhom.ne.0) then
                  call clcmag_br_inhom(imag,nvox,br)
                  t_magnets(imag)%t_voxels(nvox)%Br=br
                else
                  t_magnets(imag)%t_voxels(nvox)%Br=t_magnets(imag)%Br
                endif
                t_magnets(imag)%t_voxels(nvox)%IsPole=t_magnets(imag)%IsPole
              enddo
            enddo
          enddo

          t_magnets(imag)%nvoxels=nvox

          deallocate(t_magnets(imag)%t_xcuts,t_magnets(imag)%t_xycuts,
     &      t_magnets(imag)%t_xyzcuts)

c+self,if=voxcyl.
        else !(ctype.ne.'Cylinder') then

          nvox=
     &      t_magnets(imag)%nxdiv *
     &      t_magnets(imag)%nydiv *
     &      t_magnets(imag)%nzdiv

          do iv=1,nvox
            call clcmag_voxel_volume(imag,iv)
            volmag=volmag+t_magnets(imag)%t_voxels(iv)%volume
            if (t_magnets(imag)%IsInhom.ne.0) then
              call clcmag_br_inhom(imag,iv,br)
              t_magnets(imag)%t_voxels(iv)%Br=br
            else
              t_magnets(imag)%t_voxels(iv)%Br=t_magnets(imag)%Br
            endif
            t_magnets(imag)%t_voxels(iv)%IsPole=t_magnets(imag)%IsPole

            l=0
            if (iundugeo.ne.0) then
              do iface=1,t_magnets(imag)%t_voxels(iv)%nface
                l=l+1
                npoi=t_magnets(imag)%t_voxels(iv)%kface(l)
                gcen=t_magnets(imag)%t_voxels(iv)%gcen
                do ipoi=1,npoi
                  l=l+1
                  k=t_magnets(imag)%t_voxels(iv)%kface(l)
                  write(luno,*)imag,iv,ix,iy,iz,iface,ipoi,
     &              t_magnets(imag)%t_voxels(iv)%xhull(k)+gcen(1),
     &              t_magnets(imag)%t_voxels(iv)%yhull(k)+gcen(2),
     &              t_magnets(imag)%t_voxels(iv)%zhull(k)+gcen(3),
     &              gcen,
     &              t_magnets(imag)%t_voxels(iv)%volume
                enddo
              enddo
          endif

          enddo !nvox

        endif !(ctype.ne.'Cylinder') then

        t_magnets(imag)%nvoxels=nvox
        nvoxcopy_t=nvoxcopy_t+nvox

        !call clcmag_check_orient(imag)
c+self.

+self,if=-novol.
        if (abs((volmag-t_magnets(imag)%volume)/volmag).gt.1.0d-10.and.
     &      t_magnets(imag)%ctype.ne.'Cylinder') then
          write(lun6,*)'*** Warning in clcmag_voxels: Sum of volumes of voxels does not match the one of the magnet ',t_magnets(imag)%cnam
          write(lun6,*)"Rel. error :",(volmag-t_magnets(imag)%volume)/volmag
        endif
+self.
      enddo !imag

      if (iundugeo.ne.0) then
        flush(luno)
        close(luno)
      endif
+self,if=trace.
      print*,"-trace-: Leaving clcmag_voxels"
+self.

      return
      end
+DECK,undumag_ini_bpetm.
*CMZ :  2.04/03 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/02 24/02/2023  17.30.41  by  Michael Scheer
*CMZ :  2.02/01 28/12/2021  11.43.51  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine undumag_ini_bpetm

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

+seq,random.

      double precision rmag(3),vnormlab(3),r1(3),r1lab(3),vmaglab(3),
     &  p1(3),p2(3),p3(3),ts(3,3),tsinv(3,3),tz(3,3),ws(3,3),vx,vy,vn,
     &  ts1(3,3),ts1inv(3,3),sa,dum,ca,bc,q,qsign,r2(3),a,b

      integer im,i,iplan,nplan,j,icorn,ifail,ip2,imag
      integer :: idebug=0

      nmag=nvoxcopy_t

+self,if=debbpetm.
      open(unit=800,file="fort.800")
      do im=1,nmag
c center of magnet in lab

        rmag(1)=bpebc(1,im)
        rmag(2)=bpebc(2,im)
        rmag(3)=bpebc(3,im)

c magnetization vector in lab

        vmaglab(1)=bpebc(4,im)
        vmaglab(2)=bpebc(5,im)
        vmaglab(3)=bpebc(6,im)

        bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)

c        write(lun6,*)"im,rmag:",im,rmag

        nplan=ibpeplan(im)
        do iplan=1,nplan
          do icorn=1,ibpecorn(iplan,im)

            p1(1)=bpemag(1,icorn,iplan,im)
            p1(2)=bpemag(2,icorn,iplan,im)
            p1(3)=bpemag(3,icorn,iplan,im)

            write(800,*)im,iplan,icorn,p1
            if (im.eq.10) then
              write(801,*)p1
            endif

          enddo
        enddo
      enddo

      if (im.eq.10) flush(801)
      close(800)
      close(800)
+self.

+self.
      do im=1,nmag
c center of magnet in lab

        rmag(1)=bpebc(1,im)
        rmag(2)=bpebc(2,im)
        rmag(3)=bpebc(3,im)

c magnetization vector in lab

        vmaglab(1)=bpebc(4,im)
        vmaglab(2)=bpebc(5,im)
        vmaglab(3)=bpebc(6,im)

        bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)

c        write(lun6,*)"im,rmag:",im,rmag

        nplan=ibpeplan(im)
        do iplan=1,nplan

c three points defining plane (lab.-system)

          p1(1)=bpemag(1,1,iplan,im)
          p1(2)=bpemag(2,1,iplan,im)
          p1(3)=bpemag(3,1,iplan,im)

          p2(1)=bpemag(1,2,iplan,im)
          p2(2)=bpemag(2,2,iplan,im)
          p2(3)=bpemag(3,2,iplan,im)

          p3(1)=bpemag(1,3,iplan,im)
          p3(2)=bpemag(2,3,iplan,im)
          p3(3)=bpemag(3,3,iplan,im)

          call undumag_bpen(im,iplan,p1,p2,p3,vnormlab,ifail)

          if (ifail.ne.0) then
            write(lun6,*)"*** Error 13 in undumag_ini_bpetm: Failure in undumag_bpen, mag, plane:",
     &        im,iplan
            stop
          endif

c check if normal vector is perpendicular to magnetization vector
c if mag. vector is parallel, skip plane

          if (bc.ne.0.0d0) then
            dum=abs(
     &        (vnormlab(1)*vmaglab(1)+vnormlab(2)*vmaglab(2)+
     &        vnormlab(3)*vmaglab(3))
     &        /bc
     &        )
          else
            dum=0.0d0
          endif

            bpetm(1,7,iplan,im)=
     &        vmaglab(1)*vnormlab(1)+
     &        vmaglab(2)*vnormlab(2)+
     &        vmaglab(3)*vnormlab(3)
            bpetm(1,8,iplan,im)=vnormlab(1)
            bpetm(2,8,iplan,im)=vnormlab(2)
            bpetm(3,8,iplan,im)=vnormlab(3)

c get matrices ts and tsinv. Ts transforms vnormlab to (0,0,1)

            call undumag_bpet(vnormlab,ts,tsinv)

            if (bpebc(8,im).eq.-6) then

c for rectangular magnets, we rotate the plans such, that the edges coinside
c with the axis of the coord.-system.

c All planes are rotated to the system of the
c first plane

              if (iplan.eq.1) then
                ts1=ts
                ts1inv=tsinv
              else
                ts=ts1
                tsinv=ts1inv
              endif !(iplan.eq.1)

              do icorn=1,5

                r1lab(1)=bpemag(1,icorn,iplan,im)
                r1lab(2)=bpemag(2,icorn,iplan,im)
                r1lab(3)=bpemag(3,icorn,iplan,im)

                r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
                r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
                r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

                bperot(1,icorn,iplan,im)=r1(1)
                bperot(2,icorn,iplan,im)=r1(2)
                bperot(3,icorn,iplan,im)=r1(3)

              enddo !icorn=1,ncorn

              vx=bperot(1,2,iplan,im)-bperot(1,1,iplan,im)
              vy=bperot(2,2,iplan,im)-bperot(2,1,iplan,im)
              vn=sqrt(vx*vx+vy*vy)

              sa=vy/vn
              ca=vx/vn

              tz=ts

              ts(1,1)=ca
              ts(1,2)=sa
              ts(1,3)=0.0d0

              ts(2,1)=-sa
              ts(2,2)=ca
              ts(2,3)=0.0d0

              ts(3,1)=0.0d0
              ts(3,2)=0.0d0
              ts(3,3)=1.0d0

              call util_matrix_multiplication(3,3,3,ts,tz,ts,ws)

              do i=1,3
                do j=1,3
                  tsinv(i,j)=ts(j,i)
                enddo
              enddo

            endif ! if (bpebc(8,im).eq.-6)

            do i=1,3
              do j=1,3
                bpetm(i,j,iplan,im)=ts(i,j)
                bpetm(i,j+3,iplan,im)=tsinv(i,j)
              enddo
            enddo

        enddo !iplan

      enddo !imag

c transform everything to the nz=(0,0,1) system

      do imag=1,nmag

        qsign=0.0d0

        do iplan=1,ibpeplan(imag)

            do i=1,3
              do j=1,3
                ts(i,j)=bpetm(i,j,iplan,imag)
              enddo
            enddo

            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

            do icorn=1,ibpecorn(iplan,imag)

              r1lab(1)=bpemag(1,icorn,iplan,imag)
              r1lab(2)=bpemag(2,icorn,iplan,imag)
              r1lab(3)=bpemag(3,icorn,iplan,imag)

              r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
              r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
              r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

              bperot(1,icorn,iplan,imag)=r1(1)
              bperot(2,icorn,iplan,imag)=r1(2)
              bperot(3,icorn,iplan,imag)=r1(3)

            enddo !icorn=1,ncorn

            do icorn=1,ibpecorn(iplan,imag)-1

              ip2=icorn+1

              r1(1)=bperot(1,icorn,iplan,imag)
              r1(2)=bperot(2,icorn,iplan,imag)
              r1(3)=bperot(3,icorn,iplan,imag)

              r2(1)=bperot(1,ip2,iplan,imag)
              r2(2)=bperot(2,ip2,iplan,imag)
              r2(3)=bperot(3,ip2,iplan,imag)

c              write(lun6,*)imag,iplan,icorn,r1(1)-r2(1)
c              if (abs(r1(1)-r2(1)).gt.tiny) then
              if (r1(1)-r2(1).ne.0.0d0) then

                a=(r2(2)-r1(2))/(r2(1)-r1(1))
                b=r1(2)-a*r1(1)

              else

                a=0.0d0
                b=r1(2)

              endif !(abs(r1(1)-r2(1)).gt.tiny)

              q=-((a*r1(1)+ a*r2(1) + 2.0d0*b)*(r1(1) - r2(1)))/2.0d0

              if (idebug.ne.0) then
                print*,"imag,iplan,icorn,a,b,q:",imag,iplan,icorn,a,b,q
              endif

              qsign=qsign+q*(
     &           vnormlab(1)*bpebc(4,imag)
     &          +vnormlab(2)*bpebc(5,imag)
     &          +vnormlab(3)*bpebc(6,imag))

            enddo ! icorn

c          endif !(ibpecorn(iplan,imag).gt.0) then

        enddo ! iplan=1,nplan

        if (abs(qsign/bpebc(7,imag)).gt.1.0d-9.and.bpebc(8,imag).ne.-6) then
c not checked for rectangular magnets since ibpecorn not negative for
c planes with normal vector parallel to surface. Then they are not skipped
c for while calculation qsign
          write(lun6,*)
          write(lun6,*)
     &      '*** Warning in UNDUMAG_INI_BPETM: Sum of magnetic charge not zero ***'
          write(lun6,*)'magnet: ',imag
          write(lun6,*)

          write(lun6,*)"|Q/Br| (supposed to be lower then 1.0e-9:",abs(qsign/bpebc(7,imag))
        endif

      enddo ! imag=1,nmag

      return
      end
+DECK,undumag_ini_old.
*CMZ :  2.04/06 23/08/2023  16.15.38  by  Michael Scheer
*CMZ :  2.04/03 03/03/2023  14.44.40  by  Michael Scheer
*CMZ :  2.04/00 05/12/2022  15.18.35  by  Michael Scheer
*CMZ :  2.03/00 31/08/2022  08.10.44  by  Michael Scheer
*CMZ :  2.02/02 07/07/2022  17.49.27  by  Michael Scheer
*CMZ :  2.02/01 10/02/2022  09.16.42  by  Michael Scheer
*CMZ :  2.02/00 31/03/2021  20.30.51  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.27.23  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  16.04.15  by  Michael Scheer
*CMZ :  2.01/04 18/07/2019  13.56.54  by  Michael Scheer
*CMZ :  2.01/03 13/06/2019  15.03.29  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  14.56.07  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.15.25  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  14.30.21  by  Michael Scheer
*CMZ :  2.00/03 23/04/2018  17.47.12  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.39.07  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.09.03  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  16.25.38  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.30.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.59.20  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.35.49  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  19.08.03  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  13.53.24  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  11.50.12  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  18.37.06  by  Michael Scheer
*CMZ :  1.23/02 17/09/2017  11.21.15  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  16.23.00  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  14.53.35  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  08.50.03  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  11.30.39  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.56.28  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  12.48.09  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  13.11.48  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.31.54  by  Michael Scheer
*CMZ :  1.18/03 13/06/2017  15.30.31  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  14.09.42  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  09.19.34  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.04.28  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.55.08  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.22.37  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  12.23.38  by  Michael Scheer
*CMZ :  1.15/11 26/04/2017  11.23.30  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.22.06  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  14.32.29  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.29.10  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.46.33  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.15.21  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  19.50.52  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  11.26.05  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  09.16.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  10.00.53  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.14.36  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  15.40.55  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  16.37.53  by  Michael Scheer
*CMZ :  1.12/00 24/02/2017  08.47.15  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.24.23  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.18.36  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.27.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  10.13.44  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.40  by  Michael Scheer
*CMZ :  1.11/01 06/01/2017  13.46.07  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  15.56.40  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  15.36.58  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.12.02  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.10/00 01/11/2016  09.47.47  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.08.03  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  09.12.28  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  18.54.27  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.39.27  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.51.14  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.43.31  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.17  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.32.16  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.35.03  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.29.44  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.28  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  13.31.19  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.37.12  by  Michael Scheer
*CMZ :  1.02/02 12/09/2016  10.20.23  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.27.52  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  14.10.42  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  17.52.14  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.06.57  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.47  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.13.39  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  15.05.25  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  17.54.03  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  13.38.55  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.51.40  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.27.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.43  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  15.56.38  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.48.03  by  Michael Scheer
*CMZ :  1.17/15 19/04/2016  15.54.31  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  12.32.55  by  Michael Scheer
*CMZ :  1.17/13 08/04/2016  11.47.10  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.29.22  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  12.46.06  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.46.34  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.41.39  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.58.50  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.42.21  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine undumag_ini_old(kseg)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

! bpemag0(1:3,icorn,iplan,imag) = x,y,z relative to magnet center

! bpebc0(1:3,... position x,y,z
! bpebc0(4:6,... M vector
! bpebc0(7... type, e.g. -6 is rect. angular magnet, 1 polyeder

! ibpeplan(imag)=nplan
! ibpecorn(iplan,imag)=ncorn
! ibpecol(imag) color index

! bpebc(1:3,... position x,y,z
! bpebc(4:6,... M vector, might be changed during relaxation
! bpebc(7,... length of M vector, might be changed during relaxation
! bpebc(8,... type
! bpebc(9,imag)=imat
! bpebc(10,imag) special magnet flag
! bpebc(11:13,imag) normalized M vector at the beginning, will survive
! bpebc(14,imag) length M vector at the beginning, will survive
! bpebc(15,imag) Mother volume
! bpebc(16,imag) kill flag
! bpebc(17,imag) select flag
! bpebc(18:20,imag) external field and field of coils

+seq,phyconparam.
+seq,seqdebug.
+seq,random.

      double precision, dimension (:,:), allocatable :: bciron,bcrec,
     &  bpre16,bc0rec,bc0iron,displace

      double precision, dimension (:,:,:), allocatable :: corn1,corn2,
     &  bcpre
      double precision, dimension (:,:,:,:), allocatable ::
     &  bmagrec,brotrec, bpetmrec,
     &  bmagiron,brotiron, bpetmiron

      double precision bn,x,y,z,hx,hy,hz,bx,by,bz,hxo,hyo,hzo,hold,h,
     &  bci(3),bcj(3),xdiv,ydiv,zdiv,bc04(4),
     &  x1,x2,y1,y2,z1,z2,x3,x4,z3,z4,
     &  xdivmin,xdivmax,ydivmin,ydivmax,zdivmin,zdivmax,dxdiv,dydiv,dzdiv,
     &  x1div(10000),x2div(10000),y1div(10000),y2div(10000),
     &  z1div(10000),z2div(10000),xcen,ycen,zcen,
     &  xidiv(10000),yidiv(10000),zidiv(10000),bc8,bc9,bc10,bpebc15,bpe17,
     &  wind19(19),race17(17),arc21(21)

      double precision x0,y0,y0max,y0min,z0,bc,xm,ym,zm,rmag(3),vmaglab(3),
     &  vnormlab(3),r1(3),bdum,dum,r1lab(3),dx0,dx,dy,dz,x00,y00,z00,pel,
     &  dzdum,hmat,bcm,hmato,bcmo,dlab(3),vcorn(3),vmag(3),
     &  x02(2),y02(2),z02(2),gcen(3),vnor(3),dxfb,dyfb,dzfb,dxcon(100)

      double precision ts(3,3),tsinv(3,3),p1(3),p2(3),p3(3)
      double precision v1x,v1y,v1z,v2x,v2y,v2z,vsx,vsy,vsz,tiny2,rtiny
      double precision xmin,xmax,ymin,ymax,zmin,zmax,rmin,rmax,scalcur,
     &  dxsh,eps10,xx,yy,zz,xsymmm,xconvmm,dist,
     &  xminfb,yminfb,zminfb,xmaxfb,ymaxfb,zmaxfb,
     &  xxmin,xxmax,yymin,yymax,zzmin,zzmax

      double precision space,vspace(3),vbsym(3),rotmod(3,3),
     &  xmod,ymod,zmod,q,qsign,a,b,r2(3),det,
     &  xlen,ylen,ylenmax,ylenmin,zlen,vx,vy,vn,ca,sa,tz(3,3),ws(3,3)
     & ,ts1(3,3),ts1inv(3,3),xl,yl,zl,vz,r

      double precision, dimension (:,:,:,:), allocatable :: bpemag0,shuffle

      double precision
     &  bcx,bcy,bcz,yfracdiv,fracsum,yfacdiv,sinphi,cosphi,curr,
     &  xcwmin,xcwmax,radin,radout,ri,ro,dh,height,angle,rmat(3,3),dr,phi,dphi

      real g(100),color(3),xc,yc,zc,x21,y21,z21,cw
      integer mag,ix,iy,iz,icol,num,nr,nang,nangmin,nh,iphi,ir,ip,ih,kfoundplanes

      integer, dimension (:), allocatable :: ibpeplaniron, ibpeplanrec,
     &  ncorn1,ncorn2

      integer, dimension (:,:), allocatable :: ibpecorniron,ibpecornrec,
     &  mothdiv

      integer ifail,iterold,iron1,iron2,mat,lmat,jmag,ic,jc,
     &  ispec,iron,irec,kiron,nidiv,n1div,n2div,modediv,kplan,mspecmag,
     &  lunf,lunst,lunvox,lunvrml,moth,itype,motho,nmoth,nmotho,ipoimoth,
     &  ncount,imoth,kmoth,lun,ndisp,idisp,mothdis,moth0,mpoi,lunlis,
     &  lunfil,nlines,luncoi,kolor,lunmag,lunrn,kseg

      integer, dimension (:), allocatable :: ibpecolrec,ibpecoliron

      integer ntupp,imat
      parameter(ntupp=12)

      double precision, dimension (:,:), allocatable :: hull
      double precision, dimension (:), allocatable :: xhull,yhull,zhull
      double precision, dimension (:,:), allocatable :: xmoth,ymoth,zmoth
      double precision, dimension (:,:), allocatable :: xmothm,ymothm,zmothm
      double precision, dimension (:,:), allocatable :: xmothi,ymothi,zmothi

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface,npmoth,matmoth,
     &  nplanmoth,ncolmoth,ncolmothi,ncolmothm,npmothm,npmothi,
     &  matmothm,matmothi
      integer, dimension (:,:), allocatable :: khullmoth,kfacemoth

      real*8 htup(ntupp),val
      integer nhull,nedge,kfacelast,kcyl

      integer ntet,ifailhull,nface,next,npoi,npoimoth,ipoi,last
      real xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,theta,pphi,
     &  xp1,yp1,zp1,xp2,yp2,zp2

      integer iwarn,ifilemodus,iplot,imodu,imoduo,
     &  ilast,ifirst,nwords,i2cop,i1cop,i1mod,i2mod,i1moth,i2moth,
     &  nx,ny,nz,ncopies,
     &  nmagdo,nmagrect,nmagdivrect,nmagrectspec,nmagdivrectspec,
     &  nmagdiv,nmagspec,nmagdivspec,
     &  ndiv,idiv,nfediv,nmago,nsmag,nsmallo,
     &  ical,jplan,jcol,
     &  nplan,ncol,ncorn,nmodule,ncopy,
     &  ixdiv,iydiv,izdiv,nxdiv,nydiv,nzdiv,
     &  kmag1,kmag2,kdmag,kdmag1,kmag,
     &  imp,imag,ipol,npol,iplan,iedge,icorn,imodul,icopy,k,i,j,ip1,ip2,
     &  iflange,nflange,
     &  ipos(2,100),istat,ianf,iend,iover,ierr,
     &  nwfil,nwfilo,isleep,ifound,ieof,ise,idum,lunnam,lundum,lun76,
     &  lunmat,kmat,nmatpoi,nmatpoimax,mapmode,lunpre,ipre,npre,maxplan,
     &  imatfile,ispecmag,nmagmaxo,nfirst,nlast,lpos(2,4),nwordsmax,korn,
     &  kornmoth,iplanmoth,kpoi,nline,lunkill,kill,ix1,ix2,iy1,iy2,iz1,iz2

      integer :: ireallo=-1, ihullallo=0
      integer ncutpiece

      character(10) dtday,dttime,dtzone
      character c1
      integer idatetime(8),lunclc

      logical lexist

      character(32) c32,ch32,chmod,chcop,chmoth1,chsel
      character(1) c32a(32),chmoth1a(32)
      character(64) c64
      character(128) c128
      character(2048) cfile,cline,cline1
      equivalence(c32a,c32)

      character(32), dimension (:), allocatable :: chdisp

      equivalence (chmoth1a,chmoth1)

      data eps10/1.0d-10/

      modegui=0

+self,if=trace.
      print*,"-trace-: undumag_ini_old entered"
+self.

      open(newunit=lun,file="undumag.stat")
      write(lun,*)"1"
      flush(lun)
      close(lun)

+seq,unduver.

c+seq,phycon1.

      kfoundplanes=0
      ncornadd=0
      nplanadd=0

      nplanmax=0
      ncornmax=0

c      iwarnbound=0

1111  ireallo=ireallo+1

      ncutpiece=0

      if (ireallo.ne.0) then
        deallocate(ibpecol,bpebc,bpemag,bpemag0,shuffle,bpebc0,
     &    bperot,bpetm,bflange,ibpeplan,ibpeplano,ibpecorn,mothdiv)
        deallocate(corn1,corn2,ncorn1,ncorn2)
        deallocate(hull,khull,kface,kedge,xhull,yhull,zhull)
        deallocate(xmoth,ymoth,zmoth,npmoth,matmoth,ncolmoth)
        deallocate(xmothm,ymothm,zmothm,npmothm,matmothm,ncolmothm)
        deallocate(xmothi,ymothi,zmothi,npmothi,matmothi,ncolmothi)
        deallocate(chmoths,chmothso,chmags,chmagsm,chmothsm,chmagsi,chmothsi)
        deallocate(magcyl)
+self,if=chmagpols.
        deallocate(chmagpols)
+self.,if=chmagpols.
        deallocate(idamp8)
      endif

      nmag=0
      nmoth=0
      nmago=-1
      nmagmax=0
      kcyl=0

      nmagrect=0
      nmagdivrect=0
      nmagdiv=0

      iwarnsum=0
      maxpoints=0
      kallodip=0

+self,if=-nowarnings.
      if (ireallo.eq.0) open(newunit=lunwarn,file="undumag.war")
+self.,if=-nowarnings.

      nmatpoimax=0

      iterrectot=0
      iterirontot=0

      xmin=1.0d30
      xmax=-1.0d30
      ymin=1.0d30
      ymax=-1.0d30
      zmin=1.0d30
      zmax=-1.0d30

cdebug

      iseqdebug=0
      kwave=0

      if (ireallo.ne.0) close(lunnam)
      inquire(file=trim(Fnam),exist=lexist)
      if (lexist.eqv..false.) then
        write(lun6,*)""
        write(lun6,*)"*** Error in undumag_ini_old: File " // trim(Fnam) // " not found ***"
        write(lun6,*)"*** Program UNDUMAG aborted ***"
        stop
      endif

      open(newunit=lunnam,file=trim(Fnam),form='formatted',status='old')
      read(lunnam,undumagn)
      read(lunnam,randomn)
      close(lunnam)

      kcalcvars=1 !to avoid problems with undumag.in if coating is used

      if (hulltiny.le.0d0) hulltiny=1.0e-6

      ndivfby=max(ndivfboxy,1)

      if (matrix.eq.0) then
        write(lun6,*)"**************************************************************************************"
        write(lun6,*)"*         Matrix mode is compulsary for current version of UNDUMAG, switching it on  *"
        write(lun6,*)"**************************************************************************************"
        matrix=1
      endif

      if (kbextern.eq.0) then
        bxex=0.0d0
        byex=0.0d0
        bzex=0.0d0
      endif

      rcvthron=abs(rcvthron)
      if (rcvthron.eq.0.0d0) rcvthron=1.0d30

      ixsymo=ixsym
      iysymo=iysym
      izsymo=izsym

+self,if=trace.
      print*,"-trace-: Mark 1"
+self.
      if (irnmode.eq.1.or.irnmode.eq.2) then
        kundurun=0
        open(newunit=lundum,file="undumag.run",form='formatted',recl=512)
        read(lundum,*,end=197)kundurun
197     kundurun=kundurun+1
        close(lundum)
        if (irnmode.eq.2) irnseed(12)=irnseed(12)+kundurun
        call util_random_set_seed(irnsize,irnseed)
      else if (irnmode<0) then
        open(newunit=lunrn,file='undumag.seeds',status='old')
        read(lunrn,*) k
        do i=1,irnsize
          read(lunrn,*)k,irnseed(k)
        enddo
        close(lunrn)
        call util_random_set_seed(irnsize,irnseed)
      else
        call util_random_init(irnsize,irnseed)
      endif

+self,if=trace.
      print*,"-trace-: Mark 2"
+self.
      ndisp=0
      if (kdisplace.ne.0) then
        if (ixsym.gt.0.or.iysym.gt.0.or.izsym.gt.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_ini_old: kdisplace is set, but set-up is mirrored due to ixsym, iysym, or izsym ***"
          write(lun6,*)
        endif
        open(newunit=lun,file="undumag.dis",status="old")
        do while (.true.)
          call util_skip_comment_end(lun,ieof)
          read(lun,'(a)')cline
          ndisp=ndisp+1
        enddo
        rewind(lun)
        allocate(chdisp(ndisp))
        allocate(displace(18,ndisp))
        do i=1,ndisp
! displace(1:3,i) displacement of magnet
! displace(4:6,i) yrot, zrot, dphi of rotation around x-axis
! displace(7:9,i) change of magnetization
! displace(10:18,i)
          !mode: 0, apply changes as they are
          !mode: 1, apply changes with randomization
          call util_skip_comment(lun)
          read(lun,*)chdisp(i),displace(1:18,i)
          call util_random(9,g)
          do k=1,9
            if (displace(k+9,i).ne.0.0d0) displace(k,i)=displace(k,i)*g(k)
          enddo
        enddo
        close(lun)
      endif
+self,if=trace.
      print*,"-trace-: Mark 3"
+self.

      if (nchiiron.le.0) nchiiron=1
      nchimax=0
      if (chicut.eq.-9999.0d0) chicut=max(abs(hconv),1.0d-10)
      corrtiny=corrtiny/1000.0d0 ! mm->meter

      randoxa=abs(randox)
      randoya=abs(randoy)
      randoza=abs(randoz)
      randox10=randoxa/10.0d0
      randoy10=randoya/10.0d0
      randoz10=randoza/10.0d0

      ifsimpson=isimpson
      open(unit=99,file='.util_spline_or_simpson_integral.dat')
      write(99,*)isimpson
      if (isimpson.gt.0) then
        write(lun6,*)
        write(lun6,*)"*** Simpson integrations applied ***"
        write(lun6,*)
      endif
      close(99)

      hconva=abs(hconv)
      if (hconv.le.-1000.0d0) hconva=0.0d0

      if (dampiron.eq.0.0d0.or.dampiron.gt.1.0d0) then
        dampiron=1.0d0
      endif

      if (maxiteriron.eq.-9999.and.dampiron.lt.1.0d0) then
        maxiteriron=(log(0.001)/log(1.0d0-dampiron)+1)
      endif

      dampi=dampiron

      if (maxiteriron.eq.-9999) maxiteriron=1

      if (ireallo.ne.0) close(lunconv)
      if(kdumpconv.ne.0) open(newunit=lunconv,file="undumag.cnv")
+self,if=trace.
      print*,"-trace-: Mark 4"
+self.

      if (ireallo.eq.0.and.kcalcvars.ne.0) then
        call undumag_calc(kechocalc,kcalcvars)
      endif
+self,if=trace.
      print*,"-trace-: Mark 5"
+self.

      if (ireallo.eq.0) then
        c128="izsym"
        call undumag_parameter(c128,val,istat)
        if (istat.ne.0) then
          c128="iZsym"
          call undumag_parameter(c128,val,istat)
          if (istat.eq.0) izsym=nint(val)
        else
          izsym=nint(val)
        endif
        c128="iysym"
        call undumag_parameter(c128,val,istat)
        if (istat.ne.0) then
          c128="iYsym"
          call undumag_parameter(c128,val,istat)
          if (istat.eq.0) iysym=nint(val)
        else
          iysym=nint(val)
        endif
        c128="ixsym"
        call undumag_parameter(c128,val,istat)
        if (istat.ne.0) then
          c128="iXsym"
          call undumag_parameter(c128,val,istat)
          if (istat.eq.0) ixsym=nint(val)
        else
          ixsym=nint(val)
        endif
        if (perlen.eq.9999.0d0) then
          c128="perlen"
          call undumag_parameter(c128,perlen,istat)
          if (istat.ne.0) then
            c128="Perlen"
            call undumag_parameter(c128,perlen,istat)
            if (istat.ne.0) then
              c128="PerLen"
              call undumag_parameter(c128,perlen,istat)
            endif
          endif
          if (istat.ne.0) then
            write(lun6,*)
            write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_parameter for PerLen ***"
            write(lun6,*)"Make sure, that " // trim(Fclc) // " contains parameter or variable PerLen!"
            write(lun6,*)
            stop
          else
            write(lun6,*)
            write(lun6,*)"Period length read from " // trim(Fclc) // ":",sngl(perlen)
            write(lun6,*)
            if (perlen.le.0.0d0) then
              perlen=100.0d0
              write(lun6,*)
              write(lun6,*)"*** Warning in undumag_ini_old:Zero or negative period-length found ***"
              write(lun6,*)"*** Set to 100 ***"
              write(lun6,*)
            endif
          endif
        endif
      endif
+self,if=trace.
      print*,"-trace-: Mark 6"
+self.

      if (dedgefb.eq.0.0d0) dedgefb=0.02d0

      if (iforce.ne.0.and.dedgefb.le.corrtiny) then
        write(lun6,*)""
        write(lun6,*)"*** Warning in undumag_ini_old: Dedgefb is not greater than corrtiny "
        write(lun6,*)""
      endif

      ubflenx=ubflenx+2.0d0*dedgefb
      ubfleny=ubfleny+2.0d0*dedgefb
      ubflenz=ubflenz+2.0d0*dedgefb

      if (iforce.lt.0) then
+self,if=trace.
        print*,"-trace-: Calling undumag_force_parameters"
+self.
        call undumag_force_parameters
+self,if=trace.
        print*,"-trace-: Passed undumag_force_parameters"
+self.
      endif

      if (iforce.ne.9999) then

        if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
        if (utorqceny.eq.9999.0d0) utorqceny=ubfceny
        if (utorqcenz.eq.9999.0d0) utorqcenz=ubfcenz

        bfcenxmm=ubfcenx
        bfcenymm=ubfceny
        bfcenzmm=ubfcenz
        bflenxmm=ubflenx
        bflenymm=ubfleny
        bflenzmm=ubflenz
        torqcenxmm=utorqcenx
        torqcenymm=utorqceny
        torqcenzmm=utorqcenz
        bfcenx=ubfcenx/1000.0d0
        bfceny=ubfceny/1000.0d0
        bfcenz=ubfcenz/1000.0d0
        bflenx=ubflenx/1000.0d0
        bfleny=ubfleny/1000.0d0
        bflenz=ubflenz/1000.0d0
        torqcenx=utorqcenx/1000.0d0
        torqceny=utorqceny/1000.0d0
        torqcenz=utorqcenz/1000.0d0
        jplforce=iplforce
        if (iforce.eq.0) then
          mbforcex=0
          mbforcey=0
          mbforcez=0
        endif
        nbforcx=mbforcex
        nbforcy=mbforcey
        nbforcz=mbforcez
        iforcol=mfcolor
        forcol=iforcol
        forxpl(1)=bfcenxmm-bflenxmm/2.
        forxpl(2)=bfcenxmm+bflenxmm/2.
        forypl(1)=bfcenymm-bflenymm/2.
        forypl(2)=bfcenymm+bflenymm/2.
        forzpl(1)=bfcenzmm-bflenzmm/2.
        forzpl(2)=bfcenzmm+bflenzmm/2.

      endif !(iforce.ne.9999) then

      xsymmm=xsym
      if (xsymmm.eq.9999.0d0) xsymmm=xcenter
      if (xsym.ne.9999.0d0) xsym=xsym/1000.0d0

      window=uwindow
      kdebug=kudebug

      if (window.le.0.0d0) window=1.0d30

      tiny=1.1d-6
      tiny=corrtiny
      tiny2=tiny*tiny

+self,if=trace.
      print*,"-trace-: Mark 6"
+self.
      scalcur=1.0d0

      TWOPI=2.0D0*PI1

      filebpe='undumag.in'

      iallowin=1
      iplot=iunduplot
      nthreads=nuthreads
      theta=unduplot_theta !plotting angle
      pphi=unduplot_phi   !plotting angle

      lunbpe=98
+self,if=trace.
      print*,"-trace-: Mark 7"
+self.
      close(lunbpe)

+self,if=trace.
      print*,"-trace-: Calling undumag_drop_zero_magnets"
+self.
      call undumag_drop_zero_magnets(kfoundplanes,kechocalc,hulltiny)
+self,if=trace.
      print*,"-trace-: Passed undumag_drop_zero_magnets"
+self.

      open(unit=lunbpe,file=filebpe,form='formatted',status='old')

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,'(a)')usercom
      unducomment=usercom

      if (ireallo.eq.0) then

        kundurun=0
        jcomment=kcomment
        jrunnum=krunnum
        jdate=kdate

        call date_and_time(dtday,dttime,dtzone,idatetime)

        open(newunit=lundum,file="undumag.run",form='formatted',recl=512)
        read(lundum,*,end=97)kundurun
97      kundurun=kundurun+1
        rewind(lundum)
        write(lundum,*) kundurun,trim(usercom),' ',
     &    dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
        close(lundum)
        open(newunit=lundum,file="undumag.runs",form='formatted',recl=512,
     &    access='append')
        write(lundum,*) kundurun,trim(usercom),' ',
     &    dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
        close(lundum)

        open(newunit=lunst,file="undumag.sta")
        write(lunst,*)kundurun,konv,iwarnsum
        write(lunst,*)"undumag_ini_old"
        close(lunst)

        write(lun6,*) "Run:",
     &    kundurun,"      ",
     &    dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)

        write(lun6,*) "User comment: ",trim(usercom)

      endif !(ireallo.eq.0) then

c loop over magnets, modules, and arrays {

11    call util_skip_comment_end(lunbpe,ieof)

      if (nmago.eq.-9.and.ieof.ne.0) then
        goto 992 ! end of magnet section
      endif

      read(lunbpe,'(a)')cline
      if (kechocalc.ne.0) write(lun6,*)trim(cline)

      read(cline,*)x0,y0,z0

      if (x0.eq.-9999..and.y0.eq.-9999..and.z0.eq.-9999.) then
        goto 992 ! end of magnet section
      endif

      nmag=nmag+1
      nmoth=nmoth+1

c get dimensions

      call util_skip_comment_end(lunbpe,ieof)
      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif
      read(lunbpe,*)bc,xm,ym,zm,imat

      if (imat.eq.0) bc=0.0d0

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,'(a)')cline
      if (kechocalc.ne.0) then
        write(lun6,*)trim(cline)
      endif

      c64='Cyl'
      call util_string_substring(cline,trim(c64),ianf,iend,istat)
      if (istat.eq.0) then
        !Cylinder
        read(cline(4:len_trim(cline)),*)ncol
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)radin,radout,height,angle,nr,nang,nh
        if (angle.gt.360.0d0) angle=360.0d0
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(1,1:3)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(2,1:3)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(3,1:3)
        nplan=-11
        if (bc.ne.0.0d0) nmagcyl=nmagcyl+1

      else ! Cyl

        c64='Block'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)

        if (istat.ne.0) then
          c64='File'
          call util_string_substring(cline,trim(c64),ianf,iend,istat)
          if (istat.ne.0) then
            c64='Corners'
            call util_string_substring(cline,trim(c64),ianf,iend,istat)
            if (istat.ne.0) then
              read(cline,*)nplan,ncol
            else
              !Corners
c            nplan=-10
              cline(ianf:iend)=' -10   '
              read(cline,*)nplan,ncol
            endif
          else
            !File with corners
            nplan=-9
            cline(ianf:iend)=' -9 '
          endif
        else
          !Block
          nplan=-6
          read(cline(iend+1:len_trim(cline)),*)ncol
          cline(ianf:iend)=' -6  '
        endif
      endif ! Cyl

      if (nplan.gt.0.and.nplan.gt.nplanmax) then
        kfoundplanes=1
        nplanmax=nplan
      endif

      if ((nplan.eq.-11.or.nplan.eq.-1.or.nplan.eq.-6.or.nplan.eq.-7).and.
     &    nplanmax.lt.6) then
        if (nplanmax.lt.6) nplanmax=6
        if (ncornmax.lt.5) ncornmax=5
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
      else if (nplan.eq.-9.or.nplan.eq.-10) then

        if (kechocalc.ne.0) then
          write(lun6,*)trim(cline)
        endif

        read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        call util_skip_comment_end(lunbpe,ieof)

        if (nplan.eq.-9) then

          if (kechocalc.ne.0) then
            write(lun6,*)trim(cline)
          endif
          read(lunbpe,*)cline

          open(newunit=lundum,file=trim(cline))

          npoi=0
          last=1

          do while (last.gt.0)
            call util_read_line(lundum,cline,last)
            if (last.gt.0) then
              npoi=npoi+1
            endif
          enddo

          if (maxpoints.eq.0) then
            maxpoints=100
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else if (npoi.gt.maxpoints) then
            if (ihullallo.ne.0) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
            endif
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          endif

          rewind(lundum)

          do ipoi=1,npoi
            call util_skip_comment_end(lundum,ieof)
            read(lundum,*)hull(1:3,ipoi)
          enddo

          close(lundum)

        else if (nplan.eq.-10) then

          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          read(lunbpe,*)npoi

          if (maxpoints.eq.0) then
            maxpoints=100
            ihullallo=1
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          else if (npoi.gt.maxpoints) then
            if (ihullallo.ne.0) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
            endif
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          endif

          do ipoi=1,npoi
            call util_skip_comment_end(lunbpe,ieof)
            if (kechocalc.ne.0) then
              read(lunbpe,'(a)')cline
              write(lun6,*)trim(cline)
              backspace(lunbpe)
            endif
            read(lunbpe,*)hull(1:3,ipoi)
          enddo

        endif !nplan.eq.-9/-10

        if (npoi.lt.4) then
          write(lun6,*)"*** Error in undumag_ini_old: Less data than four points on file ***",
     &      trim(cline)
          stop
        endif

        xhull(1:npoi)=hull(1,1:npoi)
        yhull(1:npoi)=hull(2,1:npoi)
        zhull(1:npoi)=hull(3,1:npoi)

        call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &    nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
+self,if=trace.
        print*,"-trace-: Passed util_convex_hull_3d"
+self.

        if (ifailhull.ne.0.or.nhull.lt.4) then
          write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &      trim(cline)
          stop
        endif

c        khull(1:kfacelast)=kface(1:kfacelast)

        nmagdiv=nmagdiv+nxdiv*nydiv*nzdiv

        next=1
        do iplan=1,nface
          ncorn=kface(next)
          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
          next=next+ncorn+1
        enddo
        if (nface.gt.nplanmax) nplanmax=nface

      else if (ireallo.eq.0.and.abs(nplan).gt.nplanmax) then
        nplanmax=abs(nplan)+3
        ncornmax=5
      endif !nplan .eq. -9/-10

      if (nplan.ne.-11.and.nplan.ne.-9.and.nplan.ne.-10) then
        nxdiv=1
        nydiv=1
        nzdiv=1
      endif

      if (nplan.gt.0) then

        ! normal polyhedron

c        backspace(lunbpe)
c        read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (kechocalc.ne.0) then
          write(lun6,*)trim(cline)
        endif

        read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif


        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        nmagdiv=nmagdiv+nxdiv*nydiv*nzdiv

        npoi=0
        do iplan=1,nplan

          call util_skip_comment_end(lunbpe,ieof)
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          read(lunbpe,*)ncorn

          if (ncorn.lt.3) then
            write(lun6,*)
            write(lun6,*)'*** ERROR IN undumag_ini_old: Too few points'
            write(lun6,*)'Magnet, plane: ',nmag,iplan
            write(lun6,*)
            stop
          endif

          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1

          do icorn=1,ncorn
            call util_skip_comment_end(lunbpe,ieof)
            if (kechocalc.ne.0) then
              read(lunbpe,'(a)')cline
              write(lun6,*)trim(cline)
              backspace(lunbpe)
            endif
            read(lunbpe,*)x0,y0,z0
            npoi=npoi+1
          enddo

        enddo !nplan

        if (maxpoints.eq.0) then
          maxpoints=100
          allocate(hull(3,maxpoints))
          allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
          allocate(khull(maxpoints))
          allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          ihullallo=1
        else if (npoi.gt.maxpoints) then
          if (ihullallo.ne.0) then
            deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
          endif
          maxpoints=npoi
          allocate(hull(3,maxpoints))
          allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
          allocate(khull(maxpoints))
          allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
        endif

      else if (nplan.eq.-9.or.nplan.eq.-10) then

        continue

      else if (nplan.eq.-6) then

        ncorn=4
        if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
        ncorn=ncorn+1

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif

        read(lunbpe,*,iostat=ieof)xlen,ylen,zlen,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        nmagdivrect=nmagdivrect+nxdiv*nydiv*nzdiv
        nmagrect=nmagrect+1

      else if (nplan.eq.-11) then

        ncorn=4
        if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
        ncorn=ncorn+1

        nangmin=1+abs(angle)/(90.0d0+tiny)

        if (nang.lt.nangmin) nang=nangmin
        if (nr.lt.1) nr=1
        if (nh.lt.1) nh=1

        nmagdiv=nmagdiv+nr*nang*nh

      else !(nplan.eq.-6)

        write(lun6,*) '*** Error in undumag_ini_old: Bad number of planes'
        write(lun6,*) '*** Magnet:', nmag
        write(lun6,*)'*** Program aborted ***'
        stop

      endif !nplan.gt.0

      goto 11

992   continue ! end of magnet section

      if (nmago.eq.-9.or.nmago.eq.-9999.or.nmago.eq.-8888) then
        close(lunbpe)
        lunbpe=98
      endif !nmago

      call util_skip_comment_end(lunbpe,ieof)
      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif
      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,*)nmodule

      if (nmodule.le.0) then
        write(lun6,*)'*** Error in undumag_ini_old: Number of modules is zero'
        stop
      endif

      ncopies=0
      nmotho=nmoth
      nmoth=0
      do imodul=1,nmodule

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)xmod,ymod,zmod

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(1,1),rotmod(1,2),rotmod(1,3)

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(2,1),rotmod(2,2),rotmod(2,3)

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(3,1),rotmod(3,2),rotmod(3,3)

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)ncopy

        call util_skip_comment_end(lunbpe,ieof)

        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)space,vspace(1),vspace(2),vspace(3)
        call util_vnorm(3,vspace,vspace)

        call util_skip_comment_end(lunbpe,ieof)

        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)vbsym(1),vbsym(2),vbsym(3)

        ncopies=ncopies+ncopy*(nmagdiv+nmagdivrect)
        nmoth=nmoth+nmotho*ncopy

      enddo !imodul=1,nmodule

      nmagmax=nmagmax+ncopies

c Special magnets

      nspecmag=0
      nmagrectspec=0
      nmagdivrectspec=0
      nmagdivspec=0

      x0=-1.0d30
      y0=-1.0d30
      z0=-1.0d30

1     call util_skip_comment(lunbpe)

      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif
      read(lunbpe,*)x0,y0,z0
      if (x0.eq.-9999..and.y0.eq.-9999..and.z0.eq.-9999.) goto 993

      nspecmag=nspecmag+1

      call util_skip_comment_end(lunbpe,ieof)
      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif
      read(lunbpe,*)bc,xm,ym,zm,imat
      if (imat.eq.0) bc=0.0d0

      call util_skip_comment_end(lunbpe,ieof)
      if (kechocalc.ne.0) then
        write(lun6,*)trim(cline)
      endif
      read(lunbpe,'(a)')cline

      c64='Cyl'
      call util_string_substring(cline,trim(c64),ianf,iend,istat)
      if (istat.eq.0) then
        !Cylinder
        read(cline(4:len_trim(cline)),*)ncol
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)radin,radout,height,angle,nr,nang,nh
        if (angle.gt.360.0d0) angle=360.0d0
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(1,1:3)
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(2,1:3)
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rmat(3,1:3)
        ncornmax=5
        nplanmax=6
        nplan=-11

      else ! Cyl

        c64='Block'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)
        if (istat.ne.0) then
          c64='File'
          call util_string_substring(cline,trim(c64),ianf,iend,istat)
          if (istat.ne.0) then
            c64='Corners'
            call util_string_substring(cline,trim(c64),ianf,iend,istat)
            if (istat.ne.0) then
c            c64='Corners'
c            call util_string_substring(cline,trim(c64),ianf,iend,istat)
              read(cline,*)nplan,ncol
            else
c            nplan=-10
              cline(ianf:iend)=' -10   '
              read(cline,*)nplan,ncol
            endif
          else
            nplan=-9
            cline(ianf:iend)=' -9 '
          endif
        else
          nplan=-6
          cline(ianf:iend)=' -6  '
        endif

      endif ! Cyl

      if (nplan.gt.0) then

c        backspace(lunbpe)
c        read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (kechocalc.ne.0) then
          write(lun6,*)trim(cline)
        endif

        read(cline,*,iostat=ieof)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        nmagdivspec=nmagdivspec+nxdiv*nydiv*nzdiv

        if (nplan.gt.0.and.nplan.gt.nplanmax) nplanmax=nplan

        if ((nplan.eq.-1.or.nplan.eq.-6.or.nplan.eq.-7).and.nplanmax.lt.6) then
          if (ireallo.eq.0.and.nplanmax.lt.6) nplanmax=6
          if (ireallo.eq.0.and.ncornmax.lt.5) ncornmax=5
        endif

        npoi=0
        do iplan=1,nplan

          call util_skip_comment_end(lunbpe,ieof)
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          read(lunbpe,*)ncorn

          if (ncorn.lt.3) then
            write(lun6,*)
            write(lun6,*)'*** ERROR IN undumag_ini_old: Too few points'
            write(lun6,*)'Magnet, plane: ',nmag,iplan
            write(lun6,*)
            stop
          endif

          do icorn=1,ncorn
            call util_skip_comment_end(lunbpe,ieof)
            if (kechocalc.ne.0) then
              read(lunbpe,'(a)')cline
              write(lun6,*)trim(cline)
              backspace(lunbpe)
            endif
            read(lunbpe,*)xx,yy,zz
            npoi=npoi+1
          enddo

          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1

          ncorn=ncorn+1

        enddo !nplan

        if (maxpoints.eq.0) then
          maxpoints=100
          allocate(hull(3,maxpoints))
          allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
          allocate(khull(maxpoints))
          allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          ihullallo=1
        else if (npoi.gt.maxpoints) then
          if (ihullallo.ne.0) then
            deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
          endif
          maxpoints=npoi
          allocate(hull(3,maxpoints))
          allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
          allocate(khull(maxpoints))
          allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
        endif

      else if (nplan.eq.-9.or.nplan.eq.-10) then
cxxxxxxxxxxx

c        backspace(lunbpe)
c        read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (kechocalc.ne.0) then
          write(lun6,*)trim(cline)
        endif

        read(cline,*,iostat=ieof)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        call util_skip_comment_end(lunbpe,ieof)

        if (nplan.eq.-9) then
          read(lunbpe,*)cline
          if (kechocalc.ne.0) then
            write(lun6,*)trim(cline)
          endif
          open(newunit=lundum,file=trim(cline))

          npoi=0
          last=1

          do while (last.gt.0)
            call util_read_line(lundum,cline,last)
            if (last.gt.0) then
              npoi=npoi+1
            endif
          enddo

          if (maxpoints.eq.0) then
            maxpoints=100
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else if (npoi.gt.maxpoints) then
            if (ihullallo.ne.0) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
            endif
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          endif

          rewind(lundum)

          do ipoi=1,npoi
            call util_skip_comment_end(lundum,ieof)
            read(lundum,*)hull(1:3,ipoi)
          enddo

          close(lundum)

        else if (nplan.eq.-10) then

          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          read(lunbpe,*)npoi

          if (maxpoints.eq.0) then
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else if (npoi.gt.maxpoints) then
            if (ihullallo.ne.0) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
            endif
            maxpoints=npoi
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
          endif

          do ipoi=1,npoi
            call util_skip_comment_end(lunbpe,ieof)
            if (kechocalc.ne.0) then
              read(lunbpe,'(a)')cline
              write(lun6,*)trim(cline)
              backspace(lunbpe)
            endif
            read(lunbpe,*)hull(1:3,ipoi)
          enddo

        endif

        if (npoi.lt.4) then
          write(lun6,*)"*** Error in undumag_ini_old: Less data than four points on file ***",
     &      trim(cline)
          stop
        endif

        xhull(1:npoi)=hull(1,1:npoi)
        yhull(1:npoi)=hull(2,1:npoi)
        zhull(1:npoi)=hull(3,1:npoi)
        call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &    nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
        if (ifailhull.ne.0.or.nhull.lt.4) then
          write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &      trim(cline)
          stop
        endif

c        khull(1:kfacelast)=kface(1:kfacelast)

        nmagdivspec=nmagdivspec+nxdiv*nydiv*nzdiv
        next=1

        do iplan=1,nface
          ncorn=kface(next)
          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
          next=next+ncorn+1
        enddo

        if (nface.gt.nplanmax) nplanmax=nface

      else if (nplan.eq.-6) then

        ncorn=4
        if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
        ncorn=ncorn+1

        call util_skip_comment_end(lunbpe,ieof)
        if (kechocalc.ne.0) then
          read(lunbpe,'(a)')cline
          write(lun6,*)trim(cline)
          backspace(lunbpe)
        endif

        read(lunbpe,*,iostat=ieof)xlen,ylen,zlen,nxdiv,nydiv,nzdiv,yfacdiv
        if (ieof.ne.0) then
          yfacdiv=1.0d0
        endif

        if (nxdiv.lt.1) nxdiv=1
        if (nydiv.lt.1) nydiv=1
        if (nzdiv.lt.1) nzdiv=1

        nmagdivrectspec=nmagdivrectspec+nxdiv*nydiv*nzdiv
        nmagrectspec=nmagrectspec+1

      else if (nplan.eq.-11) then

        ncorn=4
        if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
        ncorn=ncorn+1

        if (nang.lt.nangmin) nang=nangmin
        if (nr.lt.1) nr=1
        if (nh.lt.1) nh=1

        nmagdivspec=nmagdivspec+nr*nang*nh

      else !(nplan.eq.-6)

        write(lun6,*) '*** Error in undumag_ini_old: Bad value of number of planes'
        write(lun6,*) '*** Magnet:', nmag
        write(lun6,*)'*** Program aborted ***'
        stop

      endif !nplan.gt.0

      goto 1

993   continue

      mspecmag=nmagdivspec+nmagdivrectspec
      if (ireallo.eq.0.and.nmagrectspec.gt.0.and.nplanmax.lt.6) nplanmax=6

      call util_skip_comment(lunbpe)
      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif

      call util_skip_comment(lunbpe)

      if (kechocalc.ne.0) then
        read(lunbpe,'(a)')cline
        write(lun6,*)trim(cline)
        backspace(lunbpe)
      endif

+self,if=trace.
      print*,"-trace-: Going to material files"
+self.

      read(lunbpe,*)nmatfiles

      bcmo=-1.0d30
      hmato=-1.0d30
      do imatfile=1,nmatfiles
        call util_skip_comment(lunbpe)
        read(lunbpe,*) imat,lmat,mapmode,cfile
        nmatpoi=0
        open(newunit=lunmat,file=trim(cfile),status='old')
114     call util_skip_comment_end(lunmat,ieof)
        if (ieof.ne.0) goto 994
        read(lunmat,*)hmat,bcm
c        if (bcm.ne.bcmo.or.hmato.ne.hmat) then
        if (bcm.ne.bcmo) then
          nmatpoi=nmatpoi+1
c          hmato=hmat
c          bcmo=bcm
        endif
        hmato=hmat
        bcmo=bcm
        if (nmatpoi.gt.nmatpoimax) nmatpoimax=nmatpoi
        goto 114
994     close(lunmat)
      enddo

c loop over magnets, modules, and arrays }

      !nmag is number primary magnets, without special ones and modules

      nmagmaxo=nmagmax
      nsmag=max(nmag,nmagmax)+mspecmag
      nsmallo=nsmag

      if (ixsym.lt.0) then
        nsmag=2*nsmag
        nmoth=2*nmoth
      endif
      if (iysym.lt.0) then
        nsmag=2*nsmag
        nmoth=2*nmoth
      endif
      if (izsym.lt.0) then
        nsmag=2*nsmag
        nmoth=2*nmoth
      endif

      allocate(
     &  chmoths(32,nsmag+nmoth),
     &  chmothso(32,nsmag+nmoth),
     &  chmags(32,nsmag),
     &  chmagsm(32,nsmag),chmothsm(32,nsmag),
     &  chmagsi(32,nsmag),chmothsi(32,nsmag)
+self,if=chmagpols.
     &  ,chmagpols(32,nsmag)
+self.,if=chmagpols.
     &  )

      allocate(bpebc0(7,nsmag))
      allocate(bpebc(20,nsmag))
      bpebc=0.0d0
      allocate(bpemag(3,ncornmax,nplanmax,nsmag))
      allocate(bpemag0(3,ncornmax,nplanmax,nsmag))
      allocate(shuffle(6,ncornmax,nplanmax,nsmag))
      allocate(bperot(3,ncornmax,nplanmax,nsmag))
      allocate(bpetm(3,8,nplanmax,nsmag))
      bpetm=0.0d0
      allocate(bflange(7,(ncornmax)*(nplanmax)))

      allocate(ibpeplan(nsmag))
      allocate(ibpeplano(nsmag))
      allocate(ibpecol(nsmag))
      allocate(ibpecorn(nplanmax,nsmag),mothdiv(4,nsmag))

      allocate(corn1(3,2*ncornmax,2*nplanmax),
     &  corn2(3,2*ncornmax,2*nplanmax))
      allocate(ncorn1(2*nplanmax),ncorn2(2*nplanmax))

      allocate(idamp8(nsmag))

      mothdiv=1

      rewind(lunbpe)

      write(lun6,*)
      write(lun6,*)'Setup read first time from undumag.in to get dimensions'
      write(lun6,*)'Starting rereading and performing segmentations and geometry setup'
      write(lun6,*)
cdebug
      if (maxpoints.lt.8) maxpoints=8

      if (ixsymo.ne.0) then
        nspecmag=2*nspecmag
      endif
       if (iysymo.ne.0) then
        nspecmag=2*nspecmag
      endif
       if (izsymo.ne.0) then
        nspecmag=2*nspecmag
      endif

      nsmallo=max(nsmallo,nmoth+nspecmag)

      allocate(xmoth(maxpoints,nsmallo),
     &  ymoth(maxpoints,nsmallo),
     &  zmoth(maxpoints,nsmallo),
     &  npmoth(nsmallo),
     &  matmoth(nsmallo),
     &  ncolmoth(nsmallo)
     &  )
      allocate(xmothm(maxpoints,nsmallo),
     &  ymothm(maxpoints,nsmallo),
     &  zmothm(maxpoints,nsmallo),
     &  npmothm(nsmallo),
     &  matmothm(nsmallo),
     &  ncolmothm(nsmallo)
     &  )
      allocate(xmothi(maxpoints,nsmallo),
     &  ymothi(maxpoints,nsmallo),
     &  zmothi(maxpoints,nsmallo),
     &  npmothi(nsmallo),
     &  matmothi(nsmallo),
     &  ncolmothi(nsmallo)
     &  )

      allocate(magcyl(nmagcyl,2))

      nmoth=0
      if (ixsymo.ne.0) then
        nspecmag=nspecmag/2
      endif
       if (iysymo.ne.0) then
         nspecmag=nspecmag/2
      endif
       if (izsymo.ne.0) then
         nspecmag=nspecmag/2
      endif

c read and store data

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,'(a)')usercom

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,*)x0,y0,z0

      nmagmax=0
      kmag1=1
      kmag2=nmag
      kcyl=0

      if (nmago.eq.-1) then
        backspace(lunbpe)
      endif

      if (ireallo.ne.0) close(lun76)
      open(newunit=lun76,file="undumag.pla")

      nmoth=0
      nmagdo=nmag
cdebug
      do imag=1,nmagdo


        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,'(a)') cline
        call util_string_split_sep(cline,100,nwords,ipos,'!',istat)
        cline=cline(ipos(1,1):ipos(2,1))
        call util_string_split_sep(cline,100,nwords,ipos,' ',istat)

        if (nwords.eq.5) then
          read(cline,*)x00,y00,z00,chmag,chmoth
        else
          read(cline,*)x00,y00,z00
          write(chmag,*) imag
          call util_string_trim(chmag,nfirst,nlast)
          chmag="mag_" // chmag(nfirst:nlast)
          chmoth="Mag_" // chmag(nfirst:nlast)
        endif

        ifound=0
        do kmag=1,nmagmax
          ifound=1
          do ic=1,32
            if (chmags(ic,kmag).ne.chmag(ic:ic)) then
              ifound=0
              exit
            endif
          enddo
          if (ifound.eq.1) exit
        enddo

        if (ifound.ne.0) then
          write(lun6,*)"*** Error in undumag_ini_old: Duplicate magnet name: ",chmag
          stop
        endif

        nmagmax=nmagmax+1
        nmoth=nmoth+1

        c32=chmoth
        write(chmoths(1:32,nmagmax),'(a)')c32a(1:32)
        c32=chmag
        write(chmags(1:32,nmagmax),'(a)')c32a(1:32)

        bpebc(15,nmagmax)=nmagmax
        bpebc15=bpebc(15,nmagmax)
        mothdiv(1,nmagmax)=bpebc15

        bpebc0(1,nmagmax)=x00
        bpebc0(2,nmagmax)=y00
        bpebc0(3,nmagmax)=z00

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)bc,xm,ym,zm,imat !magnetization vector M

        if (imat.eq.0) bc=0.0d0

        bpebc(9,nmagmax)=imat
        bpebc(10,nmagmax)=0

        bdum=sqrt(xm*xm+ym*ym+zm*zm)

        if (bdum.eq.0.0d0.and.abs(bc).gt.0.01) then
          write(lun6,*)
          write(lun6,*)'*** Error in undumag_ini_old: Bad magnetization vector'
          write(lun6,*)'Magnet ',imag
          write(lun6,*)
          stop
        endif

c        call util_skip_comment_end(lunbpe,ieof)
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,'(a)')cline

        c64='Cyl'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)
        if (istat.eq.0) then
          !Cylinder
          read(cline(4:len_trim(cline)),*)ncol
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)radin,radout,height,angle,nr,nang,nh
          if (angle.gt.360.0d0) angle=360.0d0
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(1,1:3)
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(2,1:3)
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(3,1:3)
          nplan=-11

        else ! Cyl

          c64='Block'
          call util_string_substring(cline,trim(c64),ianf,iend,istat)
          if (istat.ne.0) then
            c64='File'
            call util_string_substring(cline,trim(c64),ianf,iend,istat)
            if (istat.ne.0) then
              c64='Corners'
              call util_string_substring(cline,trim(c64),ianf,iend,istat)
              if (istat.ne.0) then
c              c64='Corners'
c              call util_string_substring(cline,trim(c64),ianf,iend,istat)
                read(cline,*)nplan,ncol
              else
                nplan=-10
                cline(ianf:iend)=' -10   '
                read(cline,*)nplan,ncol
              endif
            else
              nplan=-9
              cline(ianf:iend)=' -9 '
            endif
          else
            cline(ianf:iend)=' -6  '
            read(cline,*)nplan,ncol
          endif

        endif !Cyl

        if (nplan.gt.0.or.nplan.eq.-9) then
c          backspace(lunbpe)
c          read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv

          read(cline,*,iostat=ieof)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          if (ieof.ne.0) then
            yfacdiv=1.0d0
          endif

          if (nxdiv.lt.1) nxdiv=1
          if (nydiv.lt.1) nydiv=1
          if (nzdiv.lt.1) nzdiv=1

        endif

        bdum=bc/bdum

        bpebc0(4,nmagmax)=xm*bdum
        bpebc0(5,nmagmax)=ym*bdum
        bpebc0(6,nmagmax)=zm*bdum

        ibpecol(nmagmax)=ncol
        ibpeplano(nmagmax)=nplan
        ibpeplan(nmagmax)=nplan

        if (nplan.gt.0.or.nplan.eq.-9.or.nplan.eq.-10) then

c          backspace(lunbpe)
c          read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
c          read(cline,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          if (ieof.ne.0) then
            yfacdiv=1.0d0
          endif


          if (nxdiv.lt.1) nxdiv=1
          if (nydiv.lt.1) nydiv=1
          if (nzdiv.lt.1) nzdiv=1

          nmag=nmag+nxdiv*nydiv*nzdiv-1
          kmag2=kmag2+nxdiv*nydiv*nzdiv-1

          bpebc0(7,nmagmax)=1

          xdivmin=1.0d30
          xdivmax=-1.0d30
          ydivmin=1.0d30
          ydivmax=-1.0d30
          zdivmin=1.0d30
          zdivmax=-1.0d30

          ncorn1=0
          ncorn2=0

          fracsum=0.0d0
          ! yfracdiv**(nydiv-1)=yfacdiv
          ! ln(yfracdiv)*(nydiv-1)=ln(yfacdiv)
          if (nydiv.gt.1) then
            yfracdiv=exp(log(yfacdiv)/(nydiv-1))
          else
            yfracdiv=1.0d0
          endif
          do iydiv=0,nydiv-1
            fracsum=fracsum+yfracdiv**iydiv
          enddo

          if (nplan.eq.-9.or.nplan.eq.-10) then
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

c            backspace(lunbpe)
c            read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
c            read(cline,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
            read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
            if (ieof.ne.0) then
              yfacdiv=1.0d0
            endif


            if (nxdiv.lt.1) nxdiv=1
            if (nydiv.lt.1) nydiv=1
            if (nzdiv.lt.1) nzdiv=1

            call util_skip_comment_end(lunbpe,ieof)

            if (nplan.eq.-9) then

              read(lunbpe,*)cline
              open(newunit=lundum,file=trim(cline))

              last=1
              npoi=0
              gcen=0.0d0

              do while (last.gt.0)
                call util_read_line(lundum,cline,last)
                if (last.gt.0) then
                  npoi=npoi+1
                endif
              enddo

              if (maxpoints.eq.0) then
                maxpoints=100
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                ihullallo=1
              else if (npoi.gt.maxpoints) then
                if (ihullallo.ne.0) then
                  deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                endif
                maxpoints=npoi
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
              endif

              rewind(lundum)

c              nmoth=nmagmax
              do ipoi=1,npoi
                call util_skip_comment_end(lundum,ieof)
                read(lundum,*)hull(1:3,ipoi)
                gcen=gcen+bpebc0(1:3,nmagmax)+hull(1:3,ipoi)
              enddo

              close(lundum)

            else if (nplan.eq.-10) then

              read(lunbpe,*)npoi

              if (maxpoints.eq.0) then
                maxpoints=100
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                ihullallo=1
              else if (npoi.gt.maxpoints) then
                if (ihullallo.ne.0) then
                  deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                endif
                maxpoints=npoi
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
              endif

              gcen=0.0d0
c              nmoth=nmagmax
              do ipoi=1,npoi
                call util_skip_comment_end(lunbpe,ieof)
                read(lunbpe,*)hull(1:3,ipoi)
                gcen=gcen+bpebc0(1:3,nmagmax)+hull(1:3,ipoi)
              enddo

            endif !nplan.eq.-9/-10

            gcen=gcen/npoi

            xhull(1:npoi)=hull(1,1:npoi)
            yhull(1:npoi)=hull(2,1:npoi)
            zhull(1:npoi)=hull(3,1:npoi)

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &          trim(cline)
              stop
            endif

            gcen=0.0d0
            do ipoi=1,nhull
              korn=khull(nhull)
              gcen=gcen+bpebc0(1:3,nmagmax)+hull(1:3,ipoi)
            enddo
            gcen=gcen/nhull
c            khull(1:kfacelast)=kface(1:kfacelast)

            ibpeplano(nmagmax)=nface
            ibpeplan(nmagmax)=nface

            npmoth(nmoth)=npoi
            matmoth(nmoth)=imat
            ncolmoth(nmoth)=ibpecol(nmagmax)
            do ipoi=1,npoi
              xmoth(ipoi,nmoth)=bpebc0(1,nmagmax)+hull(1,ipoi)
              ymoth(ipoi,nmoth)=bpebc0(2,nmagmax)+hull(2,ipoi)
              zmoth(ipoi,nmoth)=bpebc0(3,nmagmax)+hull(3,ipoi)
              hull(1:3,ipoi)=bpebc0(1:3,nmagmax)+hull(1:3,ipoi)-gcen
            enddo

            bpebc0(1:3,nmagmax)=gcen

            x00=bpebc0(1,nmagmax)
            y00=bpebc0(2,nmagmax)
            z00=bpebc0(3,nmagmax)

            next=1
+self,if=debug.
            open(unit=97)
+self.,if=debug.
            do iplan=1,nface

              ncorn=kface(next)

              ncorn=ncorn+1
              ibpecorn(iplan,nmagmax)=ncorn

              do icorn=1,ncorn

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                if (icorn.lt.ncorn) then

                  x0=hull(1,kface(next+icorn))
                  y0=hull(2,kface(next+icorn))
                  z0=hull(3,kface(next+icorn))

                  if (x0.lt.xdivmin) xdivmin=x0
                  if (x0.gt.xdivmax) xdivmax=x0
                  if (y0.lt.ydivmin) ydivmin=y0
                  if (y0.gt.ydivmax) ydivmax=y0
                  if (z0.lt.zdivmin) zdivmin=z0
                  if (z0.gt.zdivmax) zdivmax=z0

                  bpemag0(1,icorn,iplan,nmagmax)=x0
                  bpemag0(2,icorn,iplan,nmagmax)=y0
                  bpemag0(3,icorn,iplan,nmagmax)=z0

                  write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 0"

                  corn1(1,icorn,iplan)=x0
                  corn1(2,icorn,iplan)=y0
                  corn1(3,icorn,iplan)=z0
+self,if=debug.
                  !w97
                  write(97,*)"-99999. ",ireallo," -99999. ",nmagmax,iplan,icorn,
     &              sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,nmagmax))
+self.

                else ! icorn.lt.ncorn

                  bpemag0(1,icorn,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                  bpemag0(2,icorn,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                  bpemag0(3,icorn,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)

                endif ! icorn.lt.ncorn

              enddo !icorn

              ncorn1(iplan)=ncorn

              next=next+ncorn ! here, ncorn is already increamented by 1

            enddo !nface
+self,if=debug.
            close(97)
+self.,if=debug.

            nplan=nface

cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

          else ! nplan.eq.-9

            ! magnet definition by planes

            npoi=0

            do iplan=1,nplan

              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)ncorn

              ncorn=ncorn+1
              ibpecorn(iplan,nmagmax)=ncorn

              do icorn=1,ncorn

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                if (icorn.lt.ncorn) then

                  call util_skip_comment_end(lunbpe,ieof)
                  read(lunbpe,*)x0,y0,z0

                  bpemag0(1,icorn,iplan,nmagmax)=x0
                  bpemag0(2,icorn,iplan,nmagmax)=y0
                  bpemag0(3,icorn,iplan,nmagmax)=z0

                  npoi=npoi+1

                  if (maxpoints.eq.0) then
                    maxpoints=100
                    allocate(hull(3,maxpoints))
                    allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                    allocate(khull(maxpoints))
                    allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                    ihullallo=1
                  else if (npoi.gt.maxpoints) then
                    if (ihullallo.ne.0) then
                      deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                    endif
                    maxpoints=npoi
                    allocate(hull(3,maxpoints))
                    allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                    allocate(khull(maxpoints))
                    allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                  endif

                  xhull(npoi)=x00+x0
                  yhull(npoi)=y00+y0
                  zhull(npoi)=z00+z0

                  write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 0"

                else ! icorn.lt.ncorn

                  bpemag0(1,icorn,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                  bpemag0(2,icorn,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                  bpemag0(3,icorn,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)

                endif ! icorn.lt.ncorn

              enddo !icorn

              ncorn1(iplan)=ncorn

            enddo !nplan

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &          trim(cline)
              stop
            endif

            gcen=0.0d0
            npmoth(nmoth)=nhull
            matmoth(nmoth)=imat
            ncolmoth(nmoth)=ibpecol(nmagmax)
            do ipoi=1,nhull
              kpoi=khull(ipoi)
              x0=xhull(kpoi)
              y0=yhull(kpoi)
              z0=zhull(kpoi)
              xmoth(ipoi,nmoth)=x0
              ymoth(ipoi,nmoth)=y0
              zmoth(ipoi,nmoth)=z0
              gcen(1)=gcen(1)+x0
              gcen(2)=gcen(2)+y0
              gcen(3)=gcen(3)+z0
            enddo

            gcen=gcen/nhull

            do iplan=1,nplan
              ncorn=ncorn1(iplan)
              do icorn=1,ncorn
                bpemag0(1:3,icorn,iplan,nmagmax)=bpebc0(1:3,nmagmax)+
     &            bpemag0(1:3,icorn,iplan,nmagmax)-gcen
                corn1(1:3,icorn,iplan)=bpemag0(1:3,icorn,iplan,nmagmax)
c                write(lun6,*)nmagmax,iplan,icorn,corn1(1:3,icorn,iplan)
              enddo !icorn
            enddo !nplan

            ! sort points such that normal vectors of planes points outside
            call undumag_sortcorn(2*ncornmax,2*nplanmax,
     &        nplan,ncorn1,corn1,corn2,tiny2,ifail)

            if (ifail.ne.0) then
              write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_sortcorn for magnet ",nmagmax
              stop
            else
              do iplan=1,nplan
                ncorn=ncorn1(iplan)
                do icorn=1,ncorn
                  bpemag0(1:3,icorn,iplan,nmagmax)=corn2(1:3,icorn,iplan)
                enddo !icorn
              enddo !nplan
            endif

            x00=gcen(1)
            y00=gcen(2)
            z00=gcen(3)

            bpebc0(1:3,nmagmax)=gcen

            do iplan=1,nplan

              ncorn=ncorn1(iplan)

              do icorn=1,ncorn-1

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                x0=bpemag0(1,icorn,iplan,nmagmax)
                y0=bpemag0(2,icorn,iplan,nmagmax)
                z0=bpemag0(3,icorn,iplan,nmagmax)

                if (x0.lt.xdivmin) xdivmin=x0
                if (x0.gt.xdivmax) xdivmax=x0
                if (y0.lt.ydivmin) ydivmin=y0
                if (y0.gt.ydivmax) ydivmax=y0
                if (z0.lt.zdivmin) zdivmin=z0
                if (z0.gt.zdivmax) zdivmax=z0

                corn1(1,icorn,iplan)=x0 !Relative
                corn1(2,icorn,iplan)=y0
                corn1(3,icorn,iplan)=z0

                write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 1"

              enddo !icorn
            enddo !nplan

          endif ! nplan.eq.-9

          x02(2)=x00
          y02(2)=y00
          z02(2)=z00

          bc04=bpebc0(4:7,nmagmax)
          bc9=bpebc(9,nmagmax)
          bc10=bpebc(10,nmagmax)

          dxdiv=(xdivmax-xdivmin)/nxdiv
          xdiv=bpebc0(1,nmagmax)+xdivmin !Labor

          bpebc15=bpebc(15,nmagmax)
          mothdiv(1,nmagmax)=bpebc15

          do ic=1,32
            chmag(ic:ic)=chmags(ic,nmagmax)
            chmoth(ic:ic)=chmoths(ic,nmagmax)
          enddo

          ncutpiece=ncutpiece+1
cdebug ixdiv 1
          do ixdiv=1,nxdiv-1

            xdiv=xdiv+dxdiv

            x02(1)=x02(2) !Labor
            y02(1)=y02(2)
            z02(1)=z02(2)

            call undumag_cut_magnet(nmagmax,x02,y02,z02, !debug 1
     &        2*nplanmax,2*ncornmax,
     &        ncorn1,corn1,ncorn2,corn2
     &        ,1,xdiv,hulltiny,ifail)
            if (ifail.ne.0) then
              write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, ixdiv, xdiv:",
     &          ifail,nmagmax,ixdiv,xdiv
              stop
            endif

c?            nmagmax=nmagmax-1

            if (ncorn2(1).gt.0) then

+self,if=debug.
              write(lun6,*)
              write(lun6,*)"ireallo, x-cut for magnet:",ireallo,nmagmax
+self.
              ! Magnet has been cut

              ! First piece

c?              nmagmax=nmagmax+1

              ncutpiece=ncutpiece+1

              bpebc(15,nmagmax)=bpebc15
              mothdiv(1,nmagmax)=bpebc15

              mothdiv(2,nmagmax)=ixdiv

              do ic=1,32
                chmags(ic,nmagmax)=chmag(ic:ic)
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo

              bpebc(9,nmagmax)=bc9
              bpebc(10,nmagmax)=bc10

              bpebc0(1,nmagmax)=x02(1)
              bpebc0(2,nmagmax)=y02(1)
              bpebc0(3,nmagmax)=z02(1)

              bpebc0(4:7,nmagmax)=bc04

              nplan=0
              do i=1,2*nplanmax
                if (ncorn1(i).gt.0) then
                  nplan=nplan+1
                endif
              enddo

              if (nplan.gt.nplanmax) then
                nplanmax=nplan
                goto 1111
              endif

              ibpecol(nmagmax)=ncol
              ibpeplan(nmagmax)=nplan
              ibpeplano(nmagmax)=nplan

+self,if=debug.
              open(unit=97,access='append')
+self.,if=debug.
              do iplan=1,nplan
                ncorn=ncorn1(iplan)
                ibpecorn(iplan,nmagmax)=ncorn+1
                if (ncorn+1.gt.ncornmax) then
                  ncornmax=ncorn+1
                  goto 1111
                endif
                do icorn=1,ncorn
                  bpemag0(1:3,icorn,iplan,nmagmax)=
     &              corn1(1:3,icorn,iplan)
+self,if=debug.
                  !w97
                  write(97,*)"11 ",ireallo,xdiv,nmagmax,iplan,icorn,
     &              sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,nmagmax))
+self.
                enddo
                ncorn=ncorn+1
                bpemag0(1:3,ncorn,iplan,nmagmax)=
     &            corn1(1:3,1,iplan) !debug 1
              enddo
+self,if=debug.
              close(97)
+self.,if=debug.

              !{ check orientation of planes

              kdmag=nmagmax

              x0=0.0d0
              y0=0.0d0
              z0=0.0d0

              i=0
              nplan=ibpeplan(kdmag)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,kdmag)-1
                do icorn=1,ncorn
                  i=i+1
                  x0=x0+bpemag0(1,icorn,iplan,kdmag)
                  y0=y0+bpemag0(2,icorn,iplan,kdmag)
                  z0=z0+bpemag0(3,icorn,iplan,kdmag)
                enddo ! icorn
              enddo !iplan

              x0=x0/i
              y0=y0/i
              z0=z0/i
+self,if=debug.
              write(lun6,*)"First piece:",kdmag
+self.
              do iplan=1,nplan

                p1(1)=bpemag0(1,1,iplan,kdmag)
                p1(2)=bpemag0(2,1,iplan,kdmag)
                p1(3)=bpemag0(3,1,iplan,kdmag)

                p2(1)=bpemag0(1,2,iplan,kdmag)
                p2(2)=bpemag0(2,2,iplan,kdmag)
                p2(3)=bpemag0(3,2,iplan,kdmag)

                p3(1)=bpemag0(1,3,iplan,kdmag)
                p3(2)=bpemag0(2,3,iplan,kdmag)
                p3(3)=bpemag0(3,3,iplan,kdmag)

                call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)

                if (ifail.ne.0) then
                  write(lun6,*)"*** Error 1 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &              kdmag,iplan
                  stop
                endif

                ! does normal vector point outside?

                vsx=bpemag0(1,1,iplan,kdmag)-x0
                vsy=bpemag0(2,1,iplan,kdmag)-y0
                vsz=bpemag0(3,1,iplan,kdmag)-z0

                if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,kdmag)=ncorn

                  do icorn=1,ncorn
                    corn1(1:3,icorn,iplan)=
     &                bpemag0(1:3,icorn,iplan,kdmag)
                  enddo

                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,ncorn+1-icorn,iplan)
                  enddo

                endif

              enddo !nplan
              !} check orientation of planes

              ! Second piece

              nmagmax=nmagmax+1
+self,if=debug.
              write(lun6,*)"Second piece:",nmagmax
+self.

              bpebc(15,nmagmax)=bpebc15
              mothdiv(1,nmagmax)=bpebc15

              mothdiv(2,nmagmax)=ixdiv+1

              do ic=1,32
                chmags(ic,nmagmax)=chmag(ic:ic)
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo

              bpebc(9,nmagmax)=bc9
              bpebc(10,nmagmax)=bc10

              bpebc0(1,nmagmax)=x02(2)
              bpebc0(2,nmagmax)=y02(2)
              bpebc0(3,nmagmax)=z02(2)

              bpebc0(4:7,nmagmax)=bc04

              nplan=0
              do i=1,2*nplanmax
                if (ncorn2(i).gt.0) then
                  nplan=nplan+1
                endif
              enddo

              if (nplan.gt.nplanmax) then
                nplanmax=nplan
                goto 1111
              endif

              ibpeplan(nmagmax)=nplan
              ibpeplano(nmagmax)=nplan
              ibpecol(nmagmax)=ncol

+self,if=debug.
              open(unit=97,access='append')
+self.,if=debug.
              do iplan=1,nplan
                ncorn=ncorn2(iplan)
                if (ncorn+1.gt.ncornmax) then
                  ncornmax=ncorn+1
                  goto 1111
                endif
                ibpecorn(iplan,nmagmax)=ncorn+1
                do icorn=1,ncorn
                  bpemag0(1:3,icorn,iplan,nmagmax)=
     &              corn2(1:3,icorn,iplan)
+self,if=debug.
                  !w97
                  write(97,*)"22 ",ireallo,xdiv,nmagmax,iplan,icorn,
     &              sngl(corn2(1:3,icorn,iplan)+bpebc0(1:3,nmagmax))
+self.
                enddo
                ncorn=ncorn+1
                bpemag0(1:3,ncorn,iplan,nmagmax)=
     &            corn2(1:3,1,iplan) !debug 1
              enddo
+self,if=debug.
              close(97)
+self.,if=debug.

              ncorn1=0
              corn1=0.0d0
              ncorn1=ncorn2
              corn1=corn2

              !{ check orientation of planes

              x0=0.0d0
              y0=0.0d0
              z0=0.0d0

              i=0
              nplan=ibpeplan(nmagmax)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,nmagmax)-1
                do icorn=1,ncorn
                  i=i+1
                  x0=x0+bpemag0(1,icorn,iplan,nmagmax)
                  y0=y0+bpemag0(2,icorn,iplan,nmagmax)
                  z0=z0+bpemag0(3,icorn,iplan,nmagmax)
                enddo ! icorn
              enddo !iplan

              x0=x0/i
              y0=y0/i
              z0=z0/i

              do iplan=1,nplan

                p1(1)=bpemag0(1,1,iplan,nmagmax)
                p1(2)=bpemag0(2,1,iplan,nmagmax)
                p1(3)=bpemag0(3,1,iplan,nmagmax)

                p2(1)=bpemag0(1,2,iplan,nmagmax)
                p2(2)=bpemag0(2,2,iplan,nmagmax)
                p2(3)=bpemag0(3,2,iplan,nmagmax)

                p3(1)=bpemag0(1,3,iplan,nmagmax)
                p3(2)=bpemag0(2,3,iplan,nmagmax)
                p3(3)=bpemag0(3,3,iplan,nmagmax)

                call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                if (ifail.ne.0) then
                  write(lun6,*)"*** Error 2 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &              nmagmax,iplan
                  stop
                endif

                ! does normal vector point outside?

                vsx=bpemag0(1,1,iplan,nmagmax)-x0
                vsy=bpemag0(2,1,iplan,nmagmax)-y0
                vsz=bpemag0(3,1,iplan,nmagmax)-z0

                if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,nmagmax)=ncorn

                  do icorn=1,ncorn
                    corn1(1:3,icorn,iplan)=
     &                bpemag0(1:3,icorn,iplan,nmagmax)
                  enddo

                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,nmagmax)=
     &                corn1(1:3,ncorn+1-icorn,iplan)
                  enddo

                endif

              enddo !nplan
              !} check orientation of planes

            endif !cut

          enddo !nxdiv

          dydiv=(ydivmax-ydivmin)/fracsum*yfacdiv
c          dydiv=(ydivmax-ydivmin)/nydiv

          do kdmag1=nmagmax-nxdiv+1,nmagmax

            ncorn1=0
            corn1=0.0d0
            ncorn2=0
            corn2=0.0d0

            nplan=ibpeplan(kdmag1)

            ydivmin=1.0d30
            ydivmax=-1.0d30
+self,if=debug.
            open(unit=97,access='append')
+self.,if=debug.
            do iplan=1,nplan
              ncorn=ibpecorn(iplan,kdmag1)
              ncorn1(iplan)=ncorn
              do icorn=1,ncorn
                corn1(1:3,icorn,iplan)=bpemag0(1:3,icorn,iplan,kdmag1)
+self,if=debug.
                  !w97
                write(97,*)"-9999. ",ireallo," -9999. ",kdmag1,iplan,icorn,
     &            sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,kdmag1))
+self.
                if (corn1(2,icorn,iplan).lt.ydivmin)
     &            ydivmin=corn1(2,icorn,iplan)
                if (corn1(2,icorn,iplan).gt.ydivmax)
     &            ydivmax=corn1(2,icorn,iplan)
              enddo
            enddo
+self,if=debug.
            close(97)
+self.,if=debug.

            dydiv=(ydivmax-ydivmin)/fracsum*yfacdiv
            ydiv=bpebc0(2,kdmag1)+ydivmin
c            ydiv=bpebc0(2,kdmag1)+ydivmax

            x02(2)=bpebc0(1,kdmag1)
            y02(2)=bpebc0(2,kdmag1)
            z02(2)=bpebc0(3,kdmag1)
cdebug iydiv 1
            do iydiv=1,nydiv-1

              if (iydiv.eq.1) then
                kdmag=kdmag1
              else
                kdmag=nmagmax
              endif

              ydiv=ydiv+dydiv
c              ydiv=ydiv-dydiv

              !Labor
              x02(1)=x02(2)
              y02(1)=y02(2)
              z02(1)=z02(2)

c              if (ireallo.eq.4.and.kdmag.eq.4) then
+self,if=debug.
              write(lun6,*)"ireallo, iydiv, ydiv:",ireallo,iydiv,ydiv
              open(unit=97,access='append')
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,kdmag)
                do icorn=1,ncorn
                  !w97
                  write(97,*)"0 ",ireallo,ydiv,kdmag,iplan,icorn,
     &              sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,kdmag))
                enddo
              enddo
c              endif
              close(97)
+self.

              call undumag_cut_magnet(kdmag,x02,y02,z02, !debug 2
     &          2*nplanmax,2*ncornmax,
     &          ncorn1,corn1,ncorn2,corn2
     &          ,2,ydiv,hulltiny,ifail)

              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, iydiv, ydiv:",
     &            ifail,kdmag,iydiv,ydiv
                stop
              endif

              !kdmag is mother

c              ncutpiece=ncutpiece+1
              if (ncorn2(1).gt.0) then
                ! Magnet has been cut

+self,if=debug.
                write(lun6,*)"y-cut for magnet:",kdmag
+self.
                ncutpiece=ncutpiece+1

                ! First piece, replaces mother

                bpebc(15,kdmag)=bpebc15
                mothdiv(1,kdmag)=bpebc15
                mothdiv(3,kdmag)=iydiv

                do ic=1,32
                  chmags(ic,kdmag)=chmag(ic:ic)
                  chmoths(ic,kdmag)=chmoth(ic:ic)
                enddo

                bpebc(9,kdmag)=bc9
                bpebc(10,kdmag)=bc10

                bpebc0(1,kdmag)=x02(1)
                bpebc0(2,kdmag)=y02(1)
                bpebc0(3,kdmag)=z02(1)

                bpebc0(4:7,kdmag)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                if (nplan.gt.nplanmax) then
                  nplanmax=nplan
                  goto 1111
                endif

                ibpecol(kdmag)=ncol
                ibpeplan(kdmag)=nplan
                ibpeplano(kdmag)=nplan

+self,if=debug.
                open(unit=97,access='append')
+self.,if=debug.
                do iplan=1,nplan
                  ncorn=ncorn1(iplan)
                  if (ncorn+1.gt.ncornmax) then
                    ncornmax=ncorn+1
                    goto 1111
                  endif
                  ibpecorn(iplan,kdmag)=ncorn+1
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,icorn,iplan)
+self,if=debug.
                  !w97
                    write(97,*)"1 ",ireallo,ydiv,kdmag,iplan,icorn,
     &                sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,kdmag))
+self.
                  enddo
                  ncorn=ncorn+1
                  bpemag0(1:3,ncorn,iplan,kdmag)=
     &              corn1(1:3,1,iplan) !debug 2
                enddo
+self,if=debug.
                close(97)
+self.,if=debug.

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                do iplan=1,ibpeplan(kdmag)
                  do icorn=1,ibpecorn(iplan,kdmag)-1
                    i=i+1
                    x0=x0+bpemag0(1,icorn,iplan,kdmag)
                    y0=y0+bpemag0(2,icorn,iplan,kdmag)
                    z0=z0+bpemag0(3,icorn,iplan,kdmag)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(kdmag)

                  p1(1)=bpemag0(1,1,iplan,kdmag)
                  p1(2)=bpemag0(2,1,iplan,kdmag)
                  p1(3)=bpemag0(3,1,iplan,kdmag)

                  p2(1)=bpemag0(1,2,iplan,kdmag)
                  p2(2)=bpemag0(2,2,iplan,kdmag)
                  p2(3)=bpemag0(3,2,iplan,kdmag)

                  p3(1)=bpemag0(1,3,iplan,kdmag)
                  p3(2)=bpemag0(2,3,iplan,kdmag)
                  p3(3)=bpemag0(3,3,iplan,kdmag)

                  call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)

                  if (ifail.ne.0) then
                    write(lun6,*)
                    write(lun6,*)"*** Error 3 in undumag_ini_old: Failure in undumag_bpen"
                    write(lun6,*)"mag, plane:",kdmag,iplan
                    write(lun6,*)
                    do icorn=1,ibpecorn(iplan,kdmag)
                      write(lun6,*)icorn,bpemag0(1:3,icorn,iplan,kdmag)
                    enddo
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag0(1,1,iplan,kdmag)-x0
                  vsy=bpemag0(2,1,iplan,kdmag)-y0
                  vsz=bpemag0(3,1,iplan,kdmag)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn1(iplan)
                    ibpecorn(iplan,kdmag)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                   bpemag0(1:3,icorn,iplan,kdmag)
                    enddo

                    do icorn=1,ncorn
                      bpemag0(1:3,icorn,iplan,kdmag)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ! Second piece

                nmagmax=nmagmax+1
+self,if=debug.
                write(lun6,*)"Second piece:",nmagmax
+self.

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15
                mothdiv(3,nmagmax)=iydiv+1

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=bc9
                bpebc(10,nmagmax)=bc10

                bpebc0(1,nmagmax)=x02(2)
                bpebc0(2,nmagmax)=y02(2)
                bpebc0(3,nmagmax)=z02(2)

                bpebc0(4:7,nmagmax)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn2(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                if (nplan.gt.nplanmax) then
                  nplanmax=nplan
                  goto 1111
                endif

                ibpeplan(nmagmax)=nplan
                ibpeplano(nmagmax)=nplan
                ibpecol(nmagmax)=ncol

+self,if=debug.
                open(unit=97,access='append')
+self.,if=debug.
                do iplan=1,nplan
                  ncorn=ncorn2(iplan)
                  if (ncorn+1.gt.ncornmax) then
                    ncornmax=ncorn+1
                    goto 1111
                  endif
                  ibpecorn(iplan,nmagmax)=ncorn+1
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,nmagmax)=
     &                corn2(1:3,icorn,iplan)
+self,if=debug.
                  !w97
                    write(97,*)"2 ",ireallo,ydiv,kdmag,iplan,icorn,
     &                sngl(corn2(1:3,icorn,iplan)+bpebc0(1:3,nmagmax))
+self.
                  enddo
                  ncorn=ncorn+1
                  bpemag0(1:3,ncorn,iplan,nmagmax)=
     &              corn2(1:3,1,iplan) !debug 2
                enddo
+self,if=debug.
                close(97)
+self.,if=debug.

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                do iplan=1,ibpeplan(nmagmax)
                  do icorn=1,ibpecorn(iplan,nmagmax)-1
                    i=i+1
                    x0=x0+bpemag0(1,icorn,iplan,nmagmax)
                    y0=y0+bpemag0(2,icorn,iplan,nmagmax)
                    z0=z0+bpemag0(3,icorn,iplan,nmagmax)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(nmagmax)

                  p1(1)=bpemag0(1,1,iplan,nmagmax)
                  p1(2)=bpemag0(2,1,iplan,nmagmax)
                  p1(3)=bpemag0(3,1,iplan,nmagmax)

                  p2(1)=bpemag0(1,2,iplan,nmagmax)
                  p2(2)=bpemag0(2,2,iplan,nmagmax)
                  p2(3)=bpemag0(3,2,iplan,nmagmax)

                  p3(1)=bpemag0(1,3,iplan,nmagmax)
                  p3(2)=bpemag0(2,3,iplan,nmagmax)
                  p3(3)=bpemag0(3,3,iplan,nmagmax)

                  call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 4 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                nmagmax,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag0(1,1,iplan,nmagmax)-x0
                  vsy=bpemag0(2,1,iplan,nmagmax)-y0
                  vsz=bpemag0(3,1,iplan,nmagmax)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn2(iplan)
                    ibpecorn(iplan,nmagmax)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag0(1:3,icorn,iplan,nmagmax)
                    enddo

                    do icorn=1,ncorn
                      bpemag0(1:3,icorn,iplan,nmagmax)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ncorn1=0
                corn1=0.0d0
                ncorn1=ncorn2
                corn1=corn2

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ydivmin=1.0d30
                ydivmax=-1.0d30
                do iplan=1,nplan
                  do icorn=1,ncorn
                    if (corn1(2,icorn,iplan).lt.ydivmin)
     &                ydivmin=corn1(2,icorn,iplan)
                    if (corn1(2,icorn,iplan).gt.ydivmax)
     &                ydivmax=corn1(2,icorn,iplan)
                  enddo
                enddo

              endif !cut

              dydiv=dydiv/yfracdiv

            enddo !nydiv

          enddo !kdmag1

          dzdiv=(zdivmax-zdivmin)/nzdiv

          do kdmag1=nmagmax-nxdiv*nydiv+1,nmagmax

            ncorn1=0
            corn1=0.0d0
            ncorn2=0
            corn2=0.0d0

            nplan=ibpeplan(kdmag1)

            zdivmin=1.0d30
            zdivmax=-1.0d30
            do iplan=1,nplan
              ncorn=ibpecorn(iplan,kdmag1)
              ncorn1(iplan)=ncorn
              do icorn=1,ncorn
                corn1(1:3,icorn,iplan)=bpemag0(1:3,icorn,iplan,kdmag1)
c                write(lun6,*)kdmag1,icorn,iplan,corn1(1:3,icorn,iplan)
                if (corn1(3,icorn,iplan).lt.zdivmin)
     &            zdivmin=corn1(3,icorn,iplan)
                if (corn1(3,icorn,iplan).gt.zdivmax)
     &            zdivmax=corn1(3,icorn,iplan)
              enddo
            enddo

            zdiv=bpebc0(3,kdmag1)+zdivmin

            x02(2)=bpebc0(1,kdmag1)
            y02(2)=bpebc0(2,kdmag1)
            z02(2)=bpebc0(3,kdmag1)

cdebug izdiv 1
            do izdiv=1,nzdiv-1

              if (izdiv.eq.1) then
                kdmag=kdmag1
              else
                kdmag=nmagmax
              endif

              zdiv=zdiv+dzdiv

              x02(1)=x02(2)
              y02(1)=y02(2)
              z02(1)=z02(2)

              call undumag_cut_magnet(kdmag,x02,y02,z02, !debug 3
     &          2*nplanmax,2*ncornmax,
     &          ncorn1,corn1,ncorn2,corn2
     &          ,3,zdiv,hulltiny,ifail)

              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, ixdiv, iydiv, izdiv, zdiv:",
     &            ifail,kdmag,ixdiv,iydiv,izdiv
                stop
              endif
c              write(lun6,*)"Nachher:",z02

              !kdmag is mother

c              ncutpiece=ncutpiece+1
              if (ncorn2(1).gt.0) then
                ! Magnet has been cut

                ncutpiece=ncutpiece+1
+self,if=debug.
                write(lun6,*)"z-cut for magnet:",kdmag
+self.

                ! First piece, replaces mother

                bpebc(15,kdmag)=bpebc15
                mothdiv(1,kdmag)=bpebc15
                mothdiv(4,kdmag)=izdiv

                do ic=1,32
                  chmags(ic,kdmag)=chmag(ic:ic)
                  chmoths(ic,kdmag)=chmoth(ic:ic)
                enddo

                bpebc(9,kdmag)=bc9
                bpebc(10,kdmag)=bc10

                bpebc0(1,kdmag)=x02(1)
                bpebc0(2,kdmag)=y02(1)
                bpebc0(3,kdmag)=z02(1)

                bpebc0(4:7,kdmag)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                if (nplan.gt.nplanmax) then
                  nplanmax=nplan
                  goto 1111
                endif

                ibpecol(kdmag)=ncol
                ibpeplan(kdmag)=nplan
                ibpeplano(kdmag)=nplan

                do iplan=1,nplan
                  ncorn=ncorn1(iplan)
                  if (ncorn+1.gt.ncornmax) then
                    ncornmax=ncorn+1
                    goto 1111
                  endif
                  ibpecorn(iplan,kdmag)=ncorn+1
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag0(1:3,ncorn,iplan,kdmag)=
     &              corn1(1:3,1,iplan) !debug 3
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                nplan=ibpeplan(kdmag)
                do iplan=1,nplan
                  ncorn=ibpecorn(iplan,kdmag)-1
                  do icorn=1,ncorn
                    i=i+1
                    x0=x0+bpemag0(1,icorn,iplan,kdmag)
                    y0=y0+bpemag0(2,icorn,iplan,kdmag)
                    z0=z0+bpemag0(3,icorn,iplan,kdmag)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(kdmag)

                  p1(1)=bpemag0(1,1,iplan,kdmag)
                  p1(2)=bpemag0(2,1,iplan,kdmag)
                  p1(3)=bpemag0(3,1,iplan,kdmag)

                  p2(1)=bpemag0(1,2,iplan,kdmag)
                  p2(2)=bpemag0(2,2,iplan,kdmag)
                  p2(3)=bpemag0(3,2,iplan,kdmag)

                  p3(1)=bpemag0(1,3,iplan,kdmag)
                  p3(2)=bpemag0(2,3,iplan,kdmag)
                  p3(3)=bpemag0(3,3,iplan,kdmag)

                  call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 5 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                kdmag,iplan
                    write(lun6,*)"icorn,x,y,z:"
                    do icorn=1,ibpecorn(iplan,kdmag)
                      write(lun6,*)icorn,bpemag0(1:3,icorn,iplan,kdmag)
                    enddo
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag0(1,1,iplan,kdmag)-x0
                  vsy=bpemag0(2,1,iplan,kdmag)-y0
                  vsz=bpemag0(3,1,iplan,kdmag)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn1(iplan)
                    ibpecorn(iplan,kdmag)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag0(1:3,icorn,iplan,kdmag)
                    enddo

                    do icorn=1,ncorn
                      bpemag0(1:3,icorn,iplan,kdmag)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ! Second piece

                nmagmax=nmagmax+1
+self,if=debug.
                write(lun6,*)"Second piece:",nmagmax
+self.

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15
                mothdiv(4,nmagmax)=izdiv+1

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=bc9
                bpebc(10,nmagmax)=bc10

                bpebc0(1,nmagmax)=x02(2)
                bpebc0(2,nmagmax)=y02(2)
                bpebc0(3,nmagmax)=z02(2)

                bpebc0(4:7,nmagmax)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn2(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                if (nplan.gt.nplanmax) then
                  nplanmax=nplan
                  goto 1111
                endif

                ibpeplan(nmagmax)=nplan
                ibpeplano(nmagmax)=nplan
                ibpecol(nmagmax)=ncol

                do iplan=1,nplan
                  ncorn=ncorn2(iplan)
                  if (ncorn+1.gt.ncornmax) then
                    ncornmax=ncorn+1
                    goto 1111
                  endif
                  ibpecorn(iplan,nmagmax)=ncorn+1
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,nmagmax)=
     &                corn2(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag0(1:3,ncorn,iplan,nmagmax)=
     &              corn2(1:3,1,iplan) !debug 3
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                do iplan=1,ibpeplan(nmagmax)
                  do icorn=1,ibpecorn(iplan,nmagmax)-1
                    i=i+1
                    x0=x0+bpemag0(1,icorn,iplan,nmagmax)
                    y0=y0+bpemag0(2,icorn,iplan,nmagmax)
                    z0=z0+bpemag0(3,icorn,iplan,nmagmax)
c                    write(37,*)"3 ",nmagmax,iplan,icorn,
c     &                sngl(bpemag0(1,icorn,iplan,nmagmax)+bpebc0(1,nmagmax)),
c     &                sngl(bpemag0(2,icorn,iplan,nmagmax)+bpebc0(2,nmagmax)),
c     &                sngl(bpemag0(3,icorn,iplan,nmagmax)+bpebc0(3,nmagmax))
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(nmagmax)

                  p1(1)=bpemag0(1,1,iplan,nmagmax)
                  p1(2)=bpemag0(2,1,iplan,nmagmax)
                  p1(3)=bpemag0(3,1,iplan,nmagmax)

                  p2(1)=bpemag0(1,2,iplan,nmagmax)
                  p2(2)=bpemag0(2,2,iplan,nmagmax)
                  p2(3)=bpemag0(3,2,iplan,nmagmax)

                  p3(1)=bpemag0(1,3,iplan,nmagmax)
                  p3(2)=bpemag0(2,3,iplan,nmagmax)
                  p3(3)=bpemag0(3,3,iplan,nmagmax)

                  call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 6 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                nmagmax,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag0(1,1,iplan,nmagmax)-x0
                  vsy=bpemag0(2,1,iplan,nmagmax)-y0
                  vsz=bpemag0(3,1,iplan,nmagmax)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn2(iplan)
                    ibpecorn(iplan,nmagmax)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag0(1:3,icorn,iplan,nmagmax)
                    enddo

                    do icorn=1,ncorn
                      bpemag0(1:3,icorn,iplan,nmagmax)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ncorn1=0
                corn1=0.0d0
                ncorn1=ncorn2
                corn1=corn2

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                zdivmin=1.0d30
                zdivmax=-1.0d30
                do iplan=1,nplan
                  do icorn=1,ncorn
                    if (corn1(3,icorn,iplan).lt.zdivmin)
     &                zdivmin=corn1(3,icorn,iplan)
                    if (corn1(3,icorn,iplan).gt.zdivmax)
     &                zdivmax=corn1(3,icorn,iplan)
                  enddo
                enddo

              endif !cut

            enddo !nzdiv

          enddo !kdmag1

        else if (nplan.eq.-11) then

          ncorn=4
          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
          ncorn=ncorn+1

          if (nang.lt.nangmin) nang=nangmin
          if (nr.lt.1) nr=1
          if (nh.lt.1) nh=1

! cyl magnet, i.e. nplan=-11{

          kcyl=kcyl+1
          magcyl(kcyl,1)=nmagmax

          if (radin.lt.tiny) radin=tiny

          x00=bpebc0(1,nmagmax)
          y00=bpebc0(2,nmagmax)
          z00=bpebc0(3,nmagmax)

          npmoth(nmoth)=8
          matmoth(nmoth)=imat
          ncolmoth(nmoth)=ibpecol(nmagmax)

          ip=0
          dphi=angle/nang*grarad1
          dr=(radout-radin)/nr
          dh=height/nh
          r=radin
          do ir=1,2
            h=-height/2.0d0
            do ih=1,2
              phi=-angle/2.0d0*grarad1
              do iphi=1,2
                ip=ip+1
                x1=r*sin(phi)
                y1=h
                z1=r*cos(phi)
                xmoth(ip,nmoth)=rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1+x00
                ymoth(ip,nmoth)=rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1+y00
                zmoth(ip,nmoth)=rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1+z00
                phi=angle/2.0d0*grarad1
              enddo
              h=height/2.0d0
            enddo
            r=radout
          enddo

          jplan=ibpeplano(nmagmax)

          if (ihullallo.eq.0) then
            maxpoints=8
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else
            if (maxpoints.lt.8) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
              maxpoints=8
              allocate(hull(3,maxpoints))
              allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
              allocate(khull(maxpoints))
              allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            endif
          endif

          r=radin+dr/2.0d0
          do ir=1,nr
            h=-height/2.0d0+dh/2.0d0
            do ih=1,nh
              phi=-angle/2.0d0*grarad1+dphi/2.0d0
              do iphi=1,nang

                x0=r*sin(phi)
                y0=h
                z0=r*cos(phi)

                ri=r-dr/2.0d0
                ro=r+dr/2.0d0

                y1=y0-dh/2.0d0
                y2=y0+dh/2.0d0

                x1=ri*sin(phi-dphi/2.0d0)
                z1=ri*cos(phi-dphi/2.0d0)
                x2=ro*sin(phi-dphi/2.0d0)
                z2=ro*cos(phi-dphi/2.0d0)
                x3=ro*sin(phi+dphi/2.0d0)
                z3=ro*cos(phi+dphi/2.0d0)
                x4=ri*sin(phi+dphi/2.0d0)
                z4=ri*cos(phi+dphi/2.0d0)

                xhull(1)=rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1
                yhull(1)=rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1
                zhull(1)=rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1

                xhull(2)=rmat(1,1)*x2+rmat(1,2)*y1+rmat(1,3)*z2
                yhull(2)=rmat(2,1)*x2+rmat(2,2)*y1+rmat(2,3)*z2
                zhull(2)=rmat(3,1)*x2+rmat(3,2)*y1+rmat(3,3)*z2

                xhull(3)=rmat(1,1)*x3+rmat(1,2)*y1+rmat(1,3)*z3
                yhull(3)=rmat(2,1)*x3+rmat(2,2)*y1+rmat(2,3)*z3
                zhull(3)=rmat(3,1)*x3+rmat(3,2)*y1+rmat(3,3)*z3

                xhull(4)=rmat(1,1)*x4+rmat(1,2)*y1+rmat(1,3)*z4
                yhull(4)=rmat(2,1)*x4+rmat(2,2)*y1+rmat(2,3)*z4
                zhull(4)=rmat(3,1)*x4+rmat(3,2)*y1+rmat(3,3)*z4

                xhull(5)=rmat(1,1)*x1+rmat(1,2)*y2+rmat(1,3)*z1
                yhull(5)=rmat(2,1)*x1+rmat(2,2)*y2+rmat(2,3)*z1
                zhull(5)=rmat(3,1)*x1+rmat(3,2)*y2+rmat(3,3)*z1

                xhull(6)=rmat(1,1)*x2+rmat(1,2)*y2+rmat(1,3)*z2
                yhull(6)=rmat(2,1)*x2+rmat(2,2)*y2+rmat(2,3)*z2
                zhull(6)=rmat(3,1)*x2+rmat(3,2)*y2+rmat(3,3)*z2

                xhull(7)=rmat(1,1)*x3+rmat(1,2)*y2+rmat(1,3)*z3
                yhull(7)=rmat(2,1)*x3+rmat(2,2)*y2+rmat(2,3)*z3
                zhull(7)=rmat(3,1)*x3+rmat(3,2)*y2+rmat(3,3)*z3

                xhull(8)=rmat(1,1)*x4+rmat(1,2)*y2+rmat(1,3)*z4
                yhull(8)=rmat(2,1)*x4+rmat(2,2)*y2+rmat(2,3)*z4
                zhull(8)=rmat(3,1)*x4+rmat(3,2)*y2+rmat(3,3)*z4

                npoi=8
                call util_convex_hull_3d(npoi,xhull,yhull,zhull,
     &            khull,kedge,kface,
     &            nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
                if (ifailhull.ne.0.or.nhull.lt.4) then
                  write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &              trim(cline)
                  stop
                endif

                ibpeplano(nmagmax)=nface
                ibpeplan(nmagmax)=nface

                next=1

                gcen=0.0d0
                k=0
                do iplan=1,nface

                  ncorn=kface(next)

                  ncorn=ncorn+1
                  ibpecorn(iplan,nmagmax)=ncorn

                  do icorn=1,ncorn

                    if (icorn.lt.ncorn) then
                      ip=kface(next+icorn)
                      bpemag0(1,icorn,iplan,nmagmax)=xhull(ip)+x00
                      bpemag0(2,icorn,iplan,nmagmax)=yhull(ip)+y00
                      bpemag0(3,icorn,iplan,nmagmax)=zhull(ip)+z00

                      k=k+1
                      gcen(1)=gcen(1)+xhull(ip)+x00
                      gcen(2)=gcen(2)+yhull(ip)+y00
                      gcen(3)=gcen(3)+zhull(ip)+z00

c                      write(99,*)nmagmax,iplan,icorn,bpemag0(1:3,icorn,iplan,nmagmax)
                    else ! icorn.lt.ncorn

                      bpemag0(1,icorn,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                      bpemag0(2,icorn,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                      bpemag0(3,icorn,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)

                    endif ! icorn.lt.ncorn

                  enddo !icorn

                  next=next+ncorn ! here, ncorn is already increamented by 1

                enddo !nface

                gcen=gcen/k

               do iplan=1,nface
                 ncorn=ibpecorn(iplan,nmagmax)
                  do icorn=1,ncorn
                    bpemag0(1:3,icorn,iplan,nmagmax)=
     &                bpemag0(1:3,icorn,iplan,nmagmax)-gcen(1:3)
                  enddo !icorn
                enddo !nface

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15

                mothdiv(2,nmagmax)=ir
                mothdiv(3,nmagmax)=iy
                mothdiv(4,nmagmax)=iphi

                c32=chmag
                write(chmags(1:32,nmagmax),'(a)')c32a(1:32)
                c32=chmoth
                write(chmoths(1:32,nmagmax),'(a)')c32a(1:32)

                bpebc(9,nmagmax)=imat
                bpebc(10,nmagmax)=0

                ibpeplano(nmagmax)=jplan

                bpebc0(1:3,nmagmax)=gcen(1:3)

                x1=xm*bdum
                y1=ym*bdum
                z1=zm*bdum

                bpebc0(4,nmagmax)=
     &            rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1
                bpebc0(5,nmagmax)=
     &            rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1
                bpebc0(6,nmagmax)=
     &            rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1

                bpebc0(7,nmagmax)=1
                ibpeplan(nmagmax)=6
                ibpecol(nmagmax)=ncol

                phi=phi+dphi

                nmagmax=nmagmax+1
              enddo
              h=h+dh
            enddo !ih
            r=r+dr
          enddo !ir

          nmagmax=nmagmax-1
          magcyl(kcyl,2)=nmagmax
          ncutpiece=ncutpiece+nr*nang*nh

! cyl magnet, i.e. nplan=-11}

        else ! :nplan>0

! rectangular magnet, i.e. nplan=-6{

          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*,iostat=ieof) xlen,ylen,zlen, nxdiv,nydiv,nzdiv,yfacdiv
          if (ieof.ne.0) then
            yfacdiv=1.0d0
          endif

cdebug
          npmoth(nmoth)=8
          matmoth(nmoth)=imat
          ncolmoth(nmoth)=ibpecol(nmagmax)
          xmoth(1,nmoth)=x00-xlen/2.0d0
          ymoth(1,nmoth)=y00-ylen/2.0d0
          zmoth(1,nmoth)=z00-zlen/2.0d0

          xmoth(2,nmoth)=x00+xlen/2.0d0
          ymoth(2,nmoth)=y00-ylen/2.0d0
          zmoth(2,nmoth)=z00-zlen/2.0d0

          xmoth(3,nmoth)=x00+xlen/2.0d0
          ymoth(3,nmoth)=y00+ylen/2.0d0
          zmoth(3,nmoth)=z00-zlen/2.0d0

          xmoth(4,nmoth)=x00-xlen/2.0d0
          ymoth(4,nmoth)=y00+ylen/2.0d0
          zmoth(4,nmoth)=z00-zlen/2.0d0

          xmoth(5,nmoth)=x00-xlen/2.0d0
          ymoth(5,nmoth)=y00-ylen/2.0d0
          zmoth(5,nmoth)=z00+zlen/2.0d0

          xmoth(6,nmoth)=x00+xlen/2.0d0
          ymoth(6,nmoth)=y00-ylen/2.0d0
          zmoth(6,nmoth)=z00+zlen/2.0d0

          xmoth(7,nmoth)=x00+xlen/2.0d0
          ymoth(7,nmoth)=y00+ylen/2.0d0
          zmoth(7,nmoth)=z00+zlen/2.0d0

          xmoth(8,nmoth)=x00-xlen/2.0d0
          ymoth(8,nmoth)=y00+ylen/2.0d0
          zmoth(8,nmoth)=z00+zlen/2.0d0

          nmag=nmag+nxdiv*nydiv*nzdiv-1
          kmag2=kmag2+nxdiv*nydiv*nzdiv-1

          dx=xlen/nxdiv

          fracsum=0.0d0
          ! yfracdiv**(nydiv-1)=yfacdiv
          ! ln(yfracdiv)*(nydiv-1)=ln(yfacdiv)
          if (nydiv.gt.1) then
            yfracdiv=exp(log(yfacdiv)/(nydiv-1))
          else
            yfracdiv=1.0d0
          endif
          do iydiv=0,nydiv-1
            fracsum=fracsum+yfracdiv**iydiv
          enddo

          dz=zlen/nzdiv

          x00=bpebc0(1,nmagmax)-xlen/2.0d0-dx/2.0d0
          y00=bpebc0(2,nmagmax)+ylen/2.0d0
          z00=bpebc0(3,nmagmax)-zlen/2.0d0-dz/2.0d0

          jplan=ibpeplano(nmagmax)

          nmagmax=nmagmax-1

          ncutpiece=ncutpiece+1
cdebug ixdiv 2
          do ixdiv=1,nxdiv
            x0=x00+dx*ixdiv
            y0=y00
            dy=ylen/fracsum
cdebug iydiv 2
            do iydiv=1,nydiv

              y0=y0-dy/2.0d0

cdebug izdiv 2
              do izdiv=1,nzdiv

                z0=z00+dz*izdiv

                nmagmax=nmagmax+1
                ncutpiece=ncutpiece+1

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15

                mothdiv(2,nmagmax)=ixdiv
                mothdiv(3,nmagmax)=iydiv
                mothdiv(4,nmagmax)=izdiv

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=imat
                bpebc(10,nmagmax)=0

                ibpeplano(nmagmax)=jplan

                bpebc0(1,nmagmax)=x0
                bpebc0(2,nmagmax)=y0
                bpebc0(3,nmagmax)=z0

                bpebc0(4,nmagmax)=xm*bdum
                bpebc0(5,nmagmax)=ym*bdum
                bpebc0(6,nmagmax)=zm*bdum

                bpebc0(7,nmagmax)=-6
                ibpeplan(nmagmax)=6
                ibpecol(nmagmax)=ncol

                iplan=1
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=2
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=3
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=4
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=5
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=-dz/2.0d0

                iplan=6
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=3
                bpemag0(1,icorn,iplan,nmagmax)=-dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=2
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=+dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0
                icorn=1
                bpemag0(1,icorn,iplan,nmagmax)=+dx/2.0d0
                bpemag0(2,icorn,iplan,nmagmax)=-dy/2.0d0
                bpemag0(3,icorn,iplan,nmagmax)=+dz/2.0d0

                do iplan=1,6
                  bpemag0(1,5,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                  bpemag0(2,5,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                  bpemag0(3,5,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)
                enddo !iplan

                do iplan=1,6
                  bpemag0(1,5,iplan,nmagmax)=bpemag0(1,1,iplan,nmagmax)
                  bpemag0(2,5,iplan,nmagmax)=bpemag0(2,1,iplan,nmagmax)
                  bpemag0(3,5,iplan,nmagmax)=bpemag0(3,1,iplan,nmagmax)
                enddo !iplan

              enddo !nzdiv

              y0=y0-dy/2.0d0
              dy=dy*yfracdiv

            enddo !nydiv
          enddo !nxdiv
! rectangular magnet, i.e. nplan=-6}

        endif !nplan>0

        if (ncutpiece.lt.nmagmax) then
          nmagmax=ncutpiece
          nmag=ncutpiece
        endif

      enddo !nmagdo

      kmag2=nmagmax

      call util_skip_comment_end(lunbpe,ieof)
      if (ieof.eq.0) then
        read(lunbpe,*)x0,y0,z0
      endif

      if (nmago.eq.-99) then
        close(lunbpe)
        lunbpe=98
      endif !nmago

      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,*)nmodule

      if (nmodule.le.0) then
        write(lun6,*)'*** Error in undumag_ini_old: Number of modules is zero'
        stop
      endif

c      nmagmax=nmagmaxo-nmag*ncopy
      nmagmax=nmagmaxo-ncopies
      nmoth=0

      chmothso=chmoths
      do imodul=1,nmodule

        write(chmod,*)imodul
        call util_string_trim(chmod,i1mod,i2mod)

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)xmod,ymod,zmod

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(1,1),rotmod(1,2),rotmod(1,3)

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(2,1),rotmod(2,2),rotmod(2,3)

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)rotmod(3,1),rotmod(3,2),rotmod(3,3)

        call util_determinante(3,rotmod,det,ifail)

        if (ifail.ne.0.or.abs(abs(det)-1.0d0).gt.tiny) then
          write(lun6,*)
     &      '*** Error in undumag_ini_old: Bad rotation matrix'
          write(lun6,*)'magnet, plane: ',imag,iplan
          stop
        endif

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)ncopy

        call util_skip_comment_end(lunbpe,ieof)

        read(lunbpe,*)space,vspace(1),vspace(2),vspace(3)

        call util_vnorm(3,vspace,vspace)

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)vbsym(1),vbsym(2),vbsym(3)

        do icopy=1,ncopy

          write(chcop,*)icopy
          call util_string_trim(chcop,i1cop,i2cop)

          do moth=1,nmotho

            nmoth=nmoth+1
            chmoths(1:32,nmoth)=chmothso(1:32,moth)
c            write(lun6,*)imodul,icopy,moth,chmoths(1:32,4)

            npmoth(nmoth)=npmoth(moth)
            matmoth(nmoth)=matmoth(moth)
            ncolmoth(nmoth)=ncolmoth(moth)
            xmoth(1:npmoth(nmoth),nmoth)=xmoth(1:npmoth(moth),moth)
     &        +(icopy-1)*space*vspace(1)
            ymoth(1:npmoth(nmoth),nmoth)=ymoth(1:npmoth(moth),moth)
     &        +(icopy-1)*space*vspace(2)
            zmoth(1:npmoth(nmoth),nmoth)=zmoth(1:npmoth(moth),moth)
     &        +(icopy-1)*space*vspace(3)

          enddo
        enddo !ncopy

        do icopy=1,ncopy

          write(chcop,*)icopy
          call util_string_trim(chcop,i1cop,i2cop)

          do imag=kmag1,kmag2

            nmagmax=nmagmax+1

            ibpecol(nmagmax)=ibpecol(imag)
            ibpeplan(nmagmax)=ibpeplan(imag)
            ibpeplano(nmagmax)=ibpeplano(imag)

            x0=xmod+bpebc0(1,imag)
     &        +(icopy-1)*space*vspace(1)
            y0=ymod+bpebc0(2,imag)
     &        +(icopy-1)*space*vspace(2)
            z0=zmod+bpebc0(3,imag)
     &        +(icopy-1)*space*vspace(3)

            bpebc(1,nmagmax)=x0
            bpebc(2,nmagmax)=y0
            bpebc(3,nmagmax)=z0

            bpebc(4,nmagmax)=bpebc0(4,imag)*vbsym(1)
            bpebc(5,nmagmax)=bpebc0(5,imag)*vbsym(2)
            bpebc(6,nmagmax)=bpebc0(6,imag)*vbsym(3)

            bc=sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
            bpebc(7,nmagmax)=bc

            bpebc(8,nmagmax)=bpebc0(7,imag)
            bpebc15=bpebc(15,imag)

            mothdiv(1:4,nmagmax)=mothdiv(1:4,imag)

            motho=nint(bpebc15)
            moth=nint(bpebc15)
            if (icopy.gt.1) moth=nmotho+(imodul-1)*ncopy+icopy-1
c            moth=nmotho+(imodul-1)*ncopy+icopy-1
c            write(lun6,*)imag,nmagmax,motho,moth

c            if (icopy.gt.1) then
            do ic=1,32
              chmoth(ic:ic)=chmothso(ic,motho)
            enddo
c              write(lun6,*)chmoth
c              write(lun6,*)chmod
c              write(lun6,*)chcop
            call util_string_trim(chmoth,i1moth,i2moth)
            if (i2moth-i1moth+1+i2cop-i1cop+1+i2mod-i1mod+1+2.gt.32) then
              write(lun6,*)
              write(lun6,*)"*** Error in undumag_ini_old: Too long a magnet name: ",
     &          chmoth
              write(lun6,*)"UNDUMAG ABORTED"
              stop
            endif

            if (bpebc(15,nmagmax).eq.0) then
              bpebc(15,nmagmax)=nmagmax
            endif

            if (icopy.gt.1) then
              chmoth=chmoth(i1moth:i2moth)//"_"//chmod(i1mod:i2mod)//
     &          "_"//chcop(i1cop:i2cop)
              do ic=1,32
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo
            else
              chmoths(1:32,nmagmax)=chmothso(1:32,moth)
            endif

            chmags(1:32,nmagmax)=chmags(1:32,imag)

            bpebc(9,nmagmax)=bpebc(9,imag)
            bpebc(10,nmagmax)=0

            vmag=bpebc(1:3,nmagmax)

            bpebc(1,nmagmax)=
     &        rotmod(1,1)*vmag(1)+
     &        rotmod(1,2)*vmag(2)+
     &        rotmod(1,3)*vmag(3)

            bpebc(2,nmagmax)=
     &        rotmod(2,1)*vmag(1)+
     &        rotmod(2,2)*vmag(2)+
     &        rotmod(2,3)*vmag(3)

            bpebc(3,nmagmax)=
     &        rotmod(3,1)*vmag(1)+
     &        rotmod(3,2)*vmag(2)+
     &        rotmod(3,3)*vmag(3)

            do iplan=1,ibpeplan(nmagmax)

              ibpecorn(iplan,nmagmax)=ibpecorn(iplan,imag)

              do icorn=1,ibpecorn(iplan,nmagmax)

                bpemag(1,icorn,iplan,nmagmax)=x0+
     &            bpemag0(1,icorn,iplan,imag)
                bpemag(2,icorn,iplan,nmagmax)=y0+
     &            bpemag0(2,icorn,iplan,imag)
                bpemag(3,icorn,iplan,nmagmax)=z0+
     &            bpemag0(3,icorn,iplan,imag)

c rotation of magnet

                vcorn(1:3)=bpemag(1:3,icorn,iplan,nmagmax)

                bpemag(1,icorn,iplan,nmagmax)=
     &            rotmod(1,1)*vcorn(1)+
     &            rotmod(1,2)*vcorn(2)+
     &            rotmod(1,3)*vcorn(3)

                bpemag(2,icorn,iplan,nmagmax)=
     &            rotmod(2,1)*vcorn(1)+
     &            rotmod(2,2)*vcorn(2)+
     &            rotmod(2,3)*vcorn(3)

                bpemag(3,icorn,iplan,nmagmax)=
     &            rotmod(3,1)*vcorn(1)+
     &            rotmod(3,2)*vcorn(2)+
     &            rotmod(3,3)*vcorn(3)

                vcorn(1:3)=bpemag(1:3,icorn,iplan,nmagmax)

                if (bc.ne.0.0d0.and.vcorn(1).lt.xmin) xmin=vcorn(1)
                if (bc.ne.0.0d0.and.vcorn(1).gt.xmax) xmax=vcorn(1)
                if (bc.ne.0.0d0.and.vcorn(2).lt.ymin) ymin=vcorn(2)
                if (bc.ne.0.0d0.and.vcorn(2).gt.ymax) ymax=vcorn(2)
                if (bc.ne.0.0d0.and.vcorn(3).lt.zmin) zmin=vcorn(3)
                if (bc.ne.0.0d0.and.vcorn(3).gt.zmax) zmax=vcorn(3)

              enddo !icorn

              if (det.lt.0.0d0) then

                do icorn=1,ibpecorn(iplan,nmagmax)
                  ip1=ibpecorn(iplan,nmagmax)-icorn+1
                  shuffle(1,ip1,iplan,nmagmax)=bpemag(1,icorn,iplan,nmagmax)
                  shuffle(2,ip1,iplan,nmagmax)=bpemag(2,icorn,iplan,nmagmax)
                  shuffle(3,ip1,iplan,nmagmax)=bpemag(3,icorn,iplan,nmagmax)
                enddo !icorn

                do icorn=1,ibpecorn(iplan,nmagmax)
                  bpemag(1,icorn,iplan,nmagmax)=
     &              shuffle(1,icorn,iplan,nmagmax)
                  bpemag(2,icorn,iplan,nmagmax)=
     &              shuffle(2,icorn,iplan,nmagmax)
                  bpemag(3,icorn,iplan,nmagmax)=
     &              shuffle(3,icorn,iplan,nmagmax)
                enddo !icorn

              endif !det

            enddo !iplan

          enddo !imag

        enddo !icopy

      enddo !imodul=1,nmodul

      nmag=nmagmax !without special magnets

      allocate(bcmat(3,nmatpoimax,nmatfiles))
      bcmat=0.0d0

      allocate(feh1(nmatpoimax))
      allocate(fem1(nmatpoimax))

      if (isplinefm.ne.0) then
        allocate(fespl1(nmatpoimax))
        allocate(ufespl1(nmatpoimax))
        allocate(fewspl1(nmatpoimax))
        allocate(fewspl2(nmatpoimax))
        allocate(fewspl3(nmatpoimax))
        allocate(fewspl4(nmatpoimax))
      endif

      kmag1=nmagmax+1
      kmag2=nmagmax+nspecmag

* Special magnets
cdebug
      do ispecmag=1,nspecmag

        nmoth=nmoth+1

        nmagmax=nmagmax+1
        bpebc(15,nmagmax)=nmagmax
        bpebc15=bpebc(15,nmagmax)
        mothdiv(1,nmagmax)=bpebc15

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,'(a)') cline
        call util_string_split_sep(cline,100,nwords,ipos,'!',istat)
        cline=cline(ipos(1,1):ipos(2,1))
        call util_string_split_sep(cline,100,nwords,ipos,' ',istat)

        if (nwords.eq.5) then
          read(cline,*)x00,y00,z00,chmag,chmoth
        else
          read(cline,*)x00,y00,z00
          write(chmag,*) ispecmag
          call util_string_trim(chmag,nfirst,nlast)
          chmag="smag_" // chmag(nfirst:nlast)
          chmoth="sMag_" // chmag(nfirst:nlast)
        endif

        ifound=0
        do kmag=1,nmagmax
          ifound=1
          do ic=1,32
            if (chmags(ic,kmag).ne.chmag(ic:ic)) then
              ifound=0
              exit
            endif
          enddo
          if (ifound.eq.1) exit
        enddo

        if (ifound.ne.0) then
          write(lun6,*)"*** Error in undumag_ini_old: Duplicate magnet name: ",chmag
          stop
        endif

        do ic=1,32
           chmags(ic,nmagmax)=chmag(ic:ic)
           chmoths(ic,nmagmax)=chmoth(ic:ic)
        enddo

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*)bc,xm,ym,zm,imat !magnetization vector M

        if (imat.eq.0) bc=0.0d0

        bpebc(9,nmagmax)=imat
        bpebc(10,nmagmax)=ispecmag

        bdum=sqrt(xm*xm+ym*ym+zm*zm)

        if (bdum.eq.0.0d0.and.abs(bc).gt.0.01) then
          write(lun6,*)
          write(lun6,*)'*** Error in undumag_ini_old: Bad magnetization vector'
          write(lun6,*)'Magnet ',imag
          write(lun6,*)
          stop
        endif

        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,'(a)')cline

        c64='Cyl'
        call util_string_substring(cline,trim(c64),ianf,iend,istat)

        if (istat.eq.0) then
          !Cylinder
          read(cline(4:len_trim(cline)),*)ncol
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)radin,radout,height,angle,nr,nang,nh
          if (angle.gt.360.0d0) angle=360.0d0
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(1,1:3)
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(2,1:3)
          if (kechocalc.ne.0) then
            read(lunbpe,'(a)')cline
            write(lun6,*)trim(cline)
            backspace(lunbpe)
          endif
          call util_skip_comment_end(lunbpe,ieof)
          read(lunbpe,*)rmat(3,1:3)
          nplan=-11
          if (bc.ne.0.0d0) nmagcyl=nmagcyl+1

        else ! Cyl

          c64='Block'
          call util_string_substring(cline,trim(c64),ianf,iend,istat)
          if (istat.ne.0) then
            c64='File'
            call util_string_substring(cline,trim(c64),ianf,iend,istat)
            if (istat.ne.0) then
              c64='Corners'
              call util_string_substring(cline,trim(c64),ianf,iend,istat)
              if (istat.ne.0) then
c              c64='Corners'
c              call util_string_substring(cline,trim(c64),ianf,iend,istat)
                read(cline,*)nplan,ncol
              else
                nplan=-10
                cline(ianf:iend)=' -10   '
                read(cline,*)nplan,ncol
              endif
            else
              nplan=-9
              cline(ianf:iend)=' -9 '
            endif
          else
            nplan=-6
            cline(ianf:iend)=' -6  '
          endif

c        call util_skip_comment_end(lunbpe,ieof)
c        read(lunbpe,*)nplan,ncol
          read(cline,*)nplan,ncol

        endif !Cyl

        bdum=bc/bdum

        bpebc0(1,nmagmax)=x00
        bpebc0(2,nmagmax)=y00
        bpebc0(3,nmagmax)=z00

        bpebc0(4,nmagmax)=xm*bdum
        bpebc0(5,nmagmax)=ym*bdum
        bpebc0(6,nmagmax)=zm*bdum

        bpebc0(7,nmagmax)=nplan

        ibpecol(nmagmax)=ncol
        ibpeplano(nmagmax)=nplan
        ibpeplan(nmagmax)=nplan

        if (nplan.gt.0.or.nplan.eq.-9.or.nplan.eq.-10) then

          bpebc(1,nmagmax)=x00
          bpebc(2,nmagmax)=y00
          bpebc(3,nmagmax)=z00

          bpebc(4,nmagmax)=xm*bdum
          bpebc(5,nmagmax)=ym*bdum
          bpebc(6,nmagmax)=zm*bdum

          bpebc(7,nmagmax)=bc
          bpebc(8,nmagmax)=1

c          backspace(lunbpe)
c          read(lunbpe,*)nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          read(cline,*,iostat=ieof) nplan,ncol,nxdiv,nydiv,nzdiv,yfacdiv
          if (ieof.ne.0) then
            yfacdiv=1.0d0
          endif

          if (nxdiv.lt.1) nxdiv=1
          if (nydiv.lt.1) nydiv=1
          if (nzdiv.lt.1) nzdiv=1

          nspecmag=nspecmag+nxdiv*nydiv*nzdiv-1
          kmag2=kmag2+nxdiv*nydiv*nzdiv-1

          xdivmin=1.0d30
          xdivmax=-1.0d30
          ydivmin=1.0d30
          ydivmax=-1.0d30
          zdivmin=1.0d30
          zdivmax=-1.0d30

          ncorn1=0
          ncorn2=0

          gcen=0.0d0
          npoi=0

          fracsum=0.0d0
          ! yfracdiv**(nydiv-1)=yfacdiv
          ! ln(yfracdiv)*(nydiv-1)=ln(yfacdiv)
          if (nydiv.gt.1) then
            yfracdiv=exp(log(yfacdiv)/(nydiv-1))
          else
            yfracdiv=1.0d0
          endif
          do iydiv=0,nydiv-1
            fracsum=fracsum+yfracdiv**iydiv
          enddo

          if (nplan.gt.0) then
            ! magnet definition by planes

            npoi=0

            do iplan=1,nplan

              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)ncorn

              ncorn=ncorn+1

              ibpecorn(iplan,nmagmax)=ncorn

              do icorn=1,ncorn

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                if (icorn.lt.ncorn) then

                  call util_skip_comment_end(lunbpe,ieof)
                  read(lunbpe,*)x0,y0,z0

                  bpemag(1,icorn,iplan,nmagmax)=x0
                  bpemag(2,icorn,iplan,nmagmax)=y0
                  bpemag(3,icorn,iplan,nmagmax)=z0

                  npoi=npoi+1

                  xhull(npoi)=x00+x0
                  yhull(npoi)=y00+y0
                  zhull(npoi)=z00+z0

                  write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 0"

                else ! icorn.lt.ncorn

                  bpemag(1,icorn,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                  bpemag(2,icorn,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                  bpemag(3,icorn,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)

                endif ! icorn.lt.ncorn

                vcorn(1:3)=bpemag(1:3,icorn,iplan,nmagmax)

              enddo !icorn

              ncorn1(iplan)=ncorn

            enddo !iplan

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &          trim(cline)
              stop
            endif

            gcen=0.0d0
            npmoth(nmoth)=nhull
            matmoth(nmoth)=imat
            ncolmoth(nmoth)=ibpecol(nmagmax)
            do ipoi=1,nhull
              kpoi=khull(ipoi)
              x0=xhull(kpoi)
              y0=yhull(kpoi)
              z0=zhull(kpoi)
              xmoth(ipoi,nmoth)=x0
              ymoth(ipoi,nmoth)=y0
              zmoth(ipoi,nmoth)=z0
              gcen(1)=gcen(1)+x0
              gcen(2)=gcen(2)+y0
              gcen(3)=gcen(3)+z0
            enddo

            gcen=gcen/nhull

            ibpeplan(nmagmax)=nplan

            do iplan=1,nplan
              ncorn=ncorn1(iplan)
              do icorn=1,ncorn
                bpemag(1:3,icorn,iplan,nmagmax)=bpebc(1:3,nmagmax)+
     &            bpemag(1:3,icorn,iplan,nmagmax)-gcen
                corn1(1:3,icorn,iplan)=bpemag(1:3,icorn,iplan,nmagmax)
              enddo !icorn
            enddo !nplan

            ! sort points such that normal vectors of planes points outside
            call undumag_sortcorn(2*ncornmax,2*nplanmax,
     &        nplan,ncorn1,corn1,corn2,tiny,ifail)

            if (ifail.ne.0) then
              write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_sortcorn for magnet ",nmagmax
              stop
            else
              do iplan=1,nplan
                ncorn=ncorn1(iplan)
                do icorn=1,ncorn
                  bpemag(1:3,icorn,iplan,nmagmax)=corn2(1:3,icorn,iplan)
                enddo !icorn
              enddo !nplan
            endif

          else if (nplan.eq.-9.or.nplan.eq.-10) then
cxxxxxxxxxx

            call util_skip_comment_end(lunbpe,ieof)

            if (nplan.eq.-9) then

              read(lunbpe,*)cline
              open(newunit=lundum,file=trim(cline))

              npoi=0
              last=1
              gcen=0.0d0

              do while (last.gt.0)
                call util_read_line(lundum,cline,last)
                if (last.gt.0) then
                  npoi=npoi+1
                endif
              enddo

              if (maxpoints.eq.0) then
                maxpoints=100
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                ihullallo=1
              else if (npoi.gt.maxpoints) then
                if (ihullallo.ne.0) then
                  deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                endif
                maxpoints=npoi
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
              endif

              rewind(lundum)

              do ipoi=1,npoi
                call util_skip_comment_end(lundum,ieof)
                read(lundum,*)hull(1:3,ipoi)
                gcen=gcen+bpebc(1:3,nmagmax)+hull(1:3,ipoi)
              enddo

              close(lundum)

            else if (nplan.eq.-10) then

              read(lunbpe,*)npoi

              if (maxpoints.eq.0) then
                maxpoints=100
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
                ihullallo=1
              else if (npoi.gt.maxpoints) then
                if (ihullallo.ne.0) then
                  deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
                endif
                maxpoints=npoi
                allocate(hull(3,maxpoints))
                allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
                allocate(khull(maxpoints))
                allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
              endif

              do ipoi=1,npoi
                call util_skip_comment_end(lunbpe,ieof)
                read(lunbpe,*)hull(1:3,ipoi)
                gcen=gcen+bpebc(1:3,nmagmax)+hull(1:3,ipoi)
              enddo

            endif

            xhull(1:npoi)=hull(1,1:npoi)
            yhull(1:npoi)=hull(2,1:npoi)
            zhull(1:npoi)=hull(3,1:npoi)

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &          trim(cline)
              stop
            endif

            gcen=0.0d0
            do ipoi=1,nhull
              korn=khull(nhull)
              gcen=gcen+bpebc(1:3,nmagmax)+hull(1:3,ipoi)
            enddo
            gcen=gcen/nhull

c            khull(1:kfacelast)=kface(1:kfacelast)

            bpebc0(7,nmagmax)=nface
            ibpeplano(nmagmax)=nface
            ibpeplan(nmagmax)=nface

            npmoth(nmoth)=npoi
            matmoth(nmoth)=imat
            ncolmoth(nmoth)=ibpecol(nmagmax)
            do ipoi=1,npoi
              xmoth(ipoi,nmoth)=bpebc(1,nmagmax)+hull(1,ipoi)
              ymoth(ipoi,nmoth)=bpebc(2,nmagmax)+hull(2,ipoi)
              zmoth(ipoi,nmoth)=bpebc(3,nmagmax)+hull(3,ipoi)
              hull(1:3,ipoi)=bpebc(1:3,nmagmax)+hull(1:3,ipoi)-gcen
            enddo

c            bpebc(1:3,nmagmax)=gcen

            x00=bpebc(1,nmagmax)
            y00=bpebc(2,nmagmax)
            z00=bpebc(3,nmagmax)

            next=1
            do iplan=1,nface

              ncorn=kface(next)

              ncorn=ncorn+1
              ibpecorn(iplan,nmagmax)=ncorn

              do icorn=1,ncorn

                if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

                if (icorn.lt.ncorn) then

                  x0=hull(1,kface(next+icorn))
                  y0=hull(2,kface(next+icorn))
                  z0=hull(3,kface(next+icorn))

                  if (x0.lt.xdivmin) xdivmin=x0
                  if (x0.gt.xdivmax) xdivmax=x0
                  if (y0.lt.ydivmin) ydivmin=y0
                  if (y0.gt.ydivmax) ydivmax=y0
                  if (z0.lt.zdivmin) zdivmin=z0
                  if (z0.gt.zdivmax) zdivmax=z0

                  bpemag(1,icorn,iplan,nmagmax)=x0
                  bpemag(2,icorn,iplan,nmagmax)=y0
                  bpemag(3,icorn,iplan,nmagmax)=z0

                  write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 0"

                  corn1(1,icorn,iplan)=x0
                  corn1(2,icorn,iplan)=y0
                  corn1(3,icorn,iplan)=z0

                else ! icorn.lt.ncorn

                  bpemag(1,icorn,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                  bpemag(2,icorn,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                  bpemag(3,icorn,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)

                endif ! icorn.lt.ncorn

              enddo !icorn

              ncorn1(iplan)=ncorn

              next=next+ncorn ! here, ncorn is already increamented by 1

            enddo !nface

            nplan=nface

cxxxxxxxxxxxxxx

          endif !nplan

          x00=gcen(1)
          y00=gcen(2)
          z00=gcen(3)

          bpebc(1:3,nmagmax)=gcen

          do iplan=1,nplan

            ncorn=ncorn1(iplan)

            do icorn=1,ncorn-1

              if (icorn.eq.1) write(lun76,'(a,i5)')"*",ncorn-1

              x0=bpemag(1,icorn,iplan,nmagmax)
              y0=bpemag(2,icorn,iplan,nmagmax)
              z0=bpemag(3,icorn,iplan,nmagmax)

              if (x0.lt.xdivmin) xdivmin=x0
              if (x0.gt.xdivmax) xdivmax=x0
              if (y0.lt.ydivmin) ydivmin=y0
              if (y0.gt.ydivmax) ydivmax=y0
              if (z0.lt.zdivmin) zdivmin=z0
              if (z0.gt.zdivmax) zdivmax=z0

              corn1(1,icorn,iplan)=x0
              corn1(2,icorn,iplan)=y0
              corn1(3,icorn,iplan)=z0

              write(lun76,*) x0,y0,z0,nmagmax,iplan,icorn," 1"
c                write(lun6,*)iplan,icorn,sngl(corn1(1:3,icorn,iplan))
            enddo !icorn

          enddo !nplan

          x02(2)=x00
          y02(2)=y00
          z02(2)=z00

          bc04=bpebc(4:7,nmagmax)
          bc8=bpebc(8,nmagmax)
          bc9=bpebc(9,nmagmax)
          bc10=bpebc(10,nmagmax)

          bpebc15=bpebc(15,nmagmax)
          mothdiv(1,nmagmax)=bpebc15

          do ic=1,32
            chmag(ic:ic)=chmags(ic,nmagmax)
            chmoth(ic:ic)=chmoths(ic,nmagmax)
          enddo

          dxdiv=(xdivmax-xdivmin)/nxdiv
          xdiv=bpebc(1,nmagmax)+xdivmin

          ncutpiece=ncutpiece+1
cdebug ixdiv 3
          do ixdiv=1,nxdiv-1

            xdiv=xdiv+dxdiv

            x02(1)=x02(2)
            y02(1)=y02(2)
            z02(1)=z02(2)

            call undumag_cut_magnet(nmagmax,x02,y02,z02, !debug 4
     &        2*nplanmax,2*ncornmax,
     &        ncorn1,corn1,ncorn2,corn2
     &        ,1,xdiv,hulltiny,ifail)
            if (ifail.ne.0) then
              write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, ixdiv, xdiv:",
     &          ifail, nmagmax,ixdiv,xdiv
              stop
            endif

c?            nmagmax=nmagmax-1

c            ncutpiece=ncutpiece+1
            if (ncorn2(1).gt.0) then
              ! Magnet has been cut

              ! First piece
              ncutpiece=ncutpiece+1

c?              nmagmax=nmagmax+1

              bpebc(8,nmagmax)=bc8
              bpebc(15,nmagmax)=bpebc15

              mothdiv(1,nmagmax)=bpebc15
              mothdiv(2,nmagmax)=ixdiv

              do ic=1,32
                chmags(ic,nmagmax)=chmag(ic:ic)
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo

              bpebc(9,nmagmax)=bc9
              bpebc(10,nmagmax)=bc10

              bpebc(1,nmagmax)=x02(1)
              bpebc(2,nmagmax)=y02(1)
              bpebc(3,nmagmax)=z02(1)

              bpebc(4:7,nmagmax)=bc04

              nplan=0
              do i=1,2*nplanmax
                if (ncorn1(i).gt.0) then
                  nplan=nplan+1
                endif
              enddo

              ibpecol(nmagmax)=ncol
              ibpeplan(nmagmax)=nplan
              ibpeplano(nmagmax)=nplan

              do iplan=1,nplan
                ncorn=ncorn1(iplan)
                ibpecorn(iplan,nmagmax)=ncorn+1
                do icorn=1,ncorn
                  bpemag(1:3,icorn,iplan,nmagmax)=
     &              corn1(1:3,icorn,iplan)
                enddo
                ncorn=ncorn+1
                bpemag(1:3,ncorn,iplan,nmagmax)=
     &            corn1(1:3,1,iplan) !debug 4
              enddo

              !{ check orientation of planes

              kdmag=nmagmax

              x0=0.0d0
              y0=0.0d0
              z0=0.0d0

              i=0
              nplan=ibpeplan(kdmag)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,kdmag)-1
                do icorn=1,ncorn
                  i=i+1
                  x0=x0+bpemag(1,icorn,iplan,kdmag)
                  y0=y0+bpemag(2,icorn,iplan,kdmag)
                  z0=z0+bpemag(3,icorn,iplan,kdmag)
                enddo ! icorn
              enddo !iplan

              x0=x0/i
              y0=y0/i
              z0=z0/i

              do iplan=1,ibpeplan(kdmag)

                p1(1)=bpemag(1,1,iplan,kdmag)
                p1(2)=bpemag(2,1,iplan,kdmag)
                p1(3)=bpemag(3,1,iplan,kdmag)

                p2(1)=bpemag(1,2,iplan,kdmag)
                p2(2)=bpemag(2,2,iplan,kdmag)
                p2(3)=bpemag(3,2,iplan,kdmag)

                p3(1)=bpemag(1,3,iplan,kdmag)
                p3(2)=bpemag(2,3,iplan,kdmag)
                p3(3)=bpemag(3,3,iplan,kdmag)

                call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)
                if (ifail.ne.0) then
                  write(lun6,*)"*** Error 7 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &              kdmag,iplan
                  stop
                endif

                ! does normal vector point outside?

                vsx=bpemag(1,1,iplan,kdmag)-x0
                vsy=bpemag(2,1,iplan,kdmag)-y0
                vsz=bpemag(3,1,iplan,kdmag)-z0

                if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,kdmag)=ncorn

                  do icorn=1,ncorn
                    corn1(1:3,icorn,iplan)=
     &                bpemag(1:3,icorn,iplan,kdmag)
                  enddo

                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,ncorn+1-icorn,iplan)
                  enddo

                endif

              enddo !nplan
              !} check orientation of planes

              ! Second piece

              nmagmax=nmagmax+1
+self,if=debug.
              write(lun6,*)"Second piece:",nmagmax
+self.

              bpebc(8,nmagmax)=bc8
              bpebc(9,nmagmax)=bc9
              bpebc(15,nmagmax)=bpebc15

              mothdiv(1,nmagmax)=bpebc15
              mothdiv(2,nmagmax)=ixdiv+1

              do ic=1,32
                chmags(ic,nmagmax)=chmag(ic:ic)
                chmoths(ic,nmagmax)=chmoth(ic:ic)
              enddo

              bpebc(10,nmagmax)=bc10

              bpebc(1,nmagmax)=x02(2)
              bpebc(2,nmagmax)=y02(2)
              bpebc(3,nmagmax)=z02(2)

              bpebc(4:7,nmagmax)=bc04

              nplan=0
              do i=1,2*nplanmax
                if (ncorn2(i).gt.0) then
                  nplan=nplan+1
                endif
              enddo

              ibpeplan(nmagmax)=nplan
              ibpeplano(nmagmax)=nplan
              ibpecol(nmagmax)=ncol

              do iplan=1,nplan
                ncorn=ncorn2(iplan)
                ibpecorn(iplan,nmagmax)=ncorn+1
                do icorn=1,ncorn
                  bpemag(1:3,icorn,iplan,nmagmax)=
     &              corn2(1:3,icorn,iplan)
                enddo
                ncorn=ncorn+1
                bpemag(1:3,ncorn,iplan,nmagmax)=
     &            corn2(1:3,1,iplan) !debug 4
              enddo

              ncorn1=0
              corn1=0.0d0
              ncorn1=ncorn2
              corn1=corn2

              !{ check orientation of planes

              x0=0.0d0
              y0=0.0d0
              z0=0.0d0

              i=0
              nplan=ibpeplan(nmagmax)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,nmagmax)-1
                do icorn=1,ncorn
                  i=i+1
                  x0=x0+bpemag(1,icorn,iplan,nmagmax)
                  y0=y0+bpemag(2,icorn,iplan,nmagmax)
                  z0=z0+bpemag(3,icorn,iplan,nmagmax)
                enddo ! icorn
              enddo !iplan

              x0=x0/i
              y0=y0/i
              z0=z0/i

              do iplan=1,ibpeplan(nmagmax)

                p1(1)=bpemag(1,1,iplan,nmagmax)
                p1(2)=bpemag(2,1,iplan,nmagmax)
                p1(3)=bpemag(3,1,iplan,nmagmax)

                p2(1)=bpemag(1,2,iplan,nmagmax)
                p2(2)=bpemag(2,2,iplan,nmagmax)
                p2(3)=bpemag(3,2,iplan,nmagmax)

                p3(1)=bpemag(1,3,iplan,nmagmax)
                p3(2)=bpemag(2,3,iplan,nmagmax)
                p3(3)=bpemag(3,3,iplan,nmagmax)

                call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                if (ifail.ne.0) then
                  write(lun6,*)"*** Error 8 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &              nmagmax,iplan
                  stop
                endif

                ! does normal vector point outside?

                vsx=bpemag(1,1,iplan,nmagmax)-x0
                vsy=bpemag(2,1,iplan,nmagmax)-y0
                vsz=bpemag(3,1,iplan,nmagmax)-z0

                if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,nmagmax)=ncorn

                  do icorn=1,ncorn
                    corn1(1:3,icorn,iplan)=
     &                bpemag(1:3,icorn,iplan,nmagmax)
                  enddo

                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,nmagmax)=
     &                corn1(1:3,ncorn+1-icorn,iplan)
                  enddo

                endif

              enddo !nplan
              !} check orientation of planes

            endif !cut

          enddo !nxdiv

c          dydiv=(ydivmax-ydivmin)/nydiv

          do kdmag1=nmagmax-nxdiv+1,nmagmax

            x02(2)=bpebc(1,kdmag1)
            y02(2)=bpebc(2,kdmag1)
            z02(2)=bpebc(3,kdmag1)

            ncorn1=0
            corn1=0.0d0
            ncorn2=0
            corn2=0.0d0

            nplan=ibpeplan(kdmag1)

            ydivmin=1.0d30
            ydivmax=-1.0d30

            do iplan=1,nplan
              ncorn=ibpecorn(iplan,kdmag1)
              ncorn1(iplan)=ncorn
              do icorn=1,ncorn
                corn1(1:3,icorn,iplan)=bpemag(1:3,icorn,iplan,kdmag1)
                if (corn1(2,icorn,iplan).lt.ydivmin)
     &            ydivmin=corn1(2,icorn,iplan)
                if (corn1(2,icorn,iplan).gt.ydivmax)
     &            ydivmax=corn1(2,icorn,iplan)
              enddo
            enddo

            dydiv=(ydivmax-ydivmin)/fracsum*yfacdiv
            ydiv=bpebc(2,kdmag1)+ydivmin

cdebug iydiv 3
            do iydiv=1,nydiv-1

              if (iydiv.eq.1) then
                kdmag=kdmag1
              else
                kdmag=nmagmax
              endif

              ydiv=ydiv+dydiv
c              ydiv=ydiv-dydiv

              x02(1)=x02(2)
              y02(1)=y02(2)
              z02(1)=z02(2)

              call undumag_cut_magnet(kdmag,x02,y02,z02,  !debug 5
     &          2*nplanmax,2*ncornmax,
     &          ncorn1,corn1,ncorn2,corn2
     &          ,2,ydiv,hulltiny,ifail)
              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, iydiv, ydiv:",
     &            ifail, kdmag,iydiv,ydiv
                stop
              endif

              !kdmag is mother

c              ncutpiece=ncutpiece+1
              if (ncorn2(1).gt.0) then
                ! Magnet has been cut
                ncutpiece=ncutpiece+1

                ! First piece, replaces mother

                bpebc(8,nmagmax)=bc8
                bpebc(9,kdmag)=bc9
                bpebc(15,kdmag)=bpebc15

                mothdiv(1,kdmag)=bpebc15
                mothdiv(3,kdmag)=iydiv

                do ic=1,32
                  chmags(ic,kdmag)=chmag(ic:ic)
                  chmoths(ic,kdmag)=chmoth(ic:ic)
                enddo

                bpebc(10,kdmag)=bc10

                bpebc(1,kdmag)=x02(1)
                bpebc(2,kdmag)=y02(1)
                bpebc(3,kdmag)=z02(1)

                bpebc(4:7,kdmag)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ibpecol(kdmag)=ncol
                ibpeplan(kdmag)=nplan
                ibpeplano(kdmag)=nplan

                do iplan=1,nplan
                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,kdmag)=ncorn+1
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag(1:3,ncorn,iplan,kdmag)=
     &              corn1(1:3,1,iplan) !debug 5
                enddo

+self,if=debug.
              write(lun6,*)"ireallo, iydiv, ydiv:",ireallo,iydiv,ydiv
              open(unit=97,access='append')
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,kdmag)
                do icorn=1,ncorn
                  !w97
                  write(97,*)" 222 ",ireallo,ydiv,kdmag,iplan,icorn,
     &              sngl(corn1(1:3,icorn,iplan)+bpebc0(1:3,kdmag))
                enddo
              enddo
c              endif
              close(97)
+self.
                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                nplan=ibpeplan(kdmag)
                do iplan=1,nplan
                  ncorn=ibpecorn(iplan,kdmag)-1
                  do icorn=1,ncorn
                    i=i+1
                    x0=x0+bpemag(1,icorn,iplan,kdmag)
                    y0=y0+bpemag(2,icorn,iplan,kdmag)
                    z0=z0+bpemag(3,icorn,iplan,kdmag)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(kdmag)

                  p1(1)=bpemag(1,1,iplan,kdmag)
                  p1(2)=bpemag(2,1,iplan,kdmag)
                  p1(3)=bpemag(3,1,iplan,kdmag)

                  p2(1)=bpemag(1,2,iplan,kdmag)
                  p2(2)=bpemag(2,2,iplan,kdmag)
                  p2(3)=bpemag(3,2,iplan,kdmag)

                  p3(1)=bpemag(1,3,iplan,kdmag)
                  p3(2)=bpemag(2,3,iplan,kdmag)
                  p3(3)=bpemag(3,3,iplan,kdmag)

                  call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 9 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                kdmag,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag(1,1,iplan,kdmag)-x0
                  vsy=bpemag(2,1,iplan,kdmag)-y0
                  vsz=bpemag(3,1,iplan,kdmag)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn1(iplan)
                    ibpecorn(iplan,kdmag)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                   bpemag(1:3,icorn,iplan,kdmag)
                    enddo

                    do icorn=1,ncorn
                      bpemag(1:3,icorn,iplan,kdmag)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ! Second piece

                nmagmax=nmagmax+1
+self,if=debug.
              write(lun6,*)"Second piece:",nmagmax
+self.

                bpebc(8,nmagmax)=bc8
                bpebc(15,nmagmax)=bpebc15

                mothdiv(1,nmagmax)=bpebc15
                mothdiv(3,nmagmax)=iydiv+1

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=bc9
                bpebc(10,nmagmax)=bc10

                bpebc(1,nmagmax)=x02(2)
                bpebc(2,nmagmax)=y02(2)
                bpebc(3,nmagmax)=z02(2)

                bpebc(4:7,nmagmax)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn2(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ibpeplan(nmagmax)=nplan
                ibpeplano(nmagmax)=nplan
                ibpecol(nmagmax)=ncol

                do iplan=1,nplan
                  ncorn=ncorn2(iplan)
                  ibpecorn(iplan,nmagmax)=ncorn+1
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,nmagmax)=
     &                corn2(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag(1:3,ncorn,iplan,nmagmax)=
     &              corn2(1:3,1,iplan) !debug 5
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                nplan=ibpeplan(nmagmax)
                do iplan=1,nplan
                  ncorn=ibpecorn(iplan,nmagmax)-1
                  do icorn=1,ncorn
                    i=i+1
                    x0=x0+bpemag(1,icorn,iplan,nmagmax)
                    y0=y0+bpemag(2,icorn,iplan,nmagmax)
                    z0=z0+bpemag(3,icorn,iplan,nmagmax)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(nmagmax)

                  p1(1)=bpemag(1,1,iplan,nmagmax)
                  p1(2)=bpemag(2,1,iplan,nmagmax)
                  p1(3)=bpemag(3,1,iplan,nmagmax)

                  p2(1)=bpemag(1,2,iplan,nmagmax)
                  p2(2)=bpemag(2,2,iplan,nmagmax)
                  p2(3)=bpemag(3,2,iplan,nmagmax)

                  p3(1)=bpemag(1,3,iplan,nmagmax)
                  p3(2)=bpemag(2,3,iplan,nmagmax)
                  p3(3)=bpemag(3,3,iplan,nmagmax)

                  call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 10 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                nmagmax,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag(1,1,iplan,nmagmax)-x0
                  vsy=bpemag(2,1,iplan,nmagmax)-y0
                  vsz=bpemag(3,1,iplan,nmagmax)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn2(iplan)
                    ibpecorn(iplan,nmagmax)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag(1:3,icorn,iplan,nmagmax)
                    enddo

                    do icorn=1,ncorn
                      bpemag(1:3,icorn,iplan,nmagmax)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ncorn1=0
                corn1=0.0d0
                ncorn1=ncorn2
                corn1=corn2

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                do iplan=1,nplan
                  do icorn=1,ncorn
                    if (corn1(2,icorn,iplan).lt.ydivmin)
     &                ydivmin=corn1(2,icorn,iplan)
                    if (corn1(2,icorn,iplan).gt.ydivmax)
     &                ydivmax=corn1(2,icorn,iplan)
                  enddo
                enddo

              endif !cut

              dydiv=dydiv/yfracdiv

            enddo !nydiv

          enddo !kdmag

          dzdiv=(zdivmax-zdivmin)/nzdiv

          do kdmag1=nmagmax-nxdiv*nydiv+1,nmagmax

            x02(2)=bpebc(1,kdmag1)
            y02(2)=bpebc(2,kdmag1)
            z02(2)=bpebc(3,kdmag1)

            ncorn1=0
            corn1=0.0d0
            ncorn2=0
            corn2=0.0d0

            nplan=ibpeplan(kdmag1)

            zdivmin=1.0d30
            zdivmax=-1.0d30

            do iplan=1,nplan
              ncorn=ibpecorn(iplan,kdmag1)
              ncorn1(iplan)=ncorn
              do icorn=1,ncorn
                corn1(1:3,icorn,iplan)=bpemag(1:3,icorn,iplan,kdmag1)
                if (corn1(3,icorn,iplan).lt.zdivmin)
     &            zdivmin=corn1(3,icorn,iplan)
                if (corn1(3,icorn,iplan).gt.zdivmax)
     &            zdivmax=corn1(3,icorn,iplan)
              enddo
            enddo

            zdiv=bpebc(3,kdmag1)+zdivmin

cdebug izdiv 3
            do izdiv=1,nzdiv-1

              if (izdiv.eq.1) then
                kdmag=kdmag1
              else
                kdmag=nmagmax
              endif

              zdiv=zdiv+dzdiv

              x02(1)=x02(2)
              y02(1)=y02(2)
              z02(1)=z02(2)

c              write(lun6,*)"Vorher:",kdmag1,kdmag,nmagmax,x02,y02,z02
              call undumag_cut_magnet(kdmag,x02,y02,z02, !debug 6
     &          2*nplanmax,2*ncornmax,
     &          ncorn1,corn1,ncorn2,corn2
     &          ,3,zdiv,hulltiny,ifail)
              if (ifail.ne.0) then
                write(lun6,*)"*** Error in undumag_ini_old: Bad return from undumag_cut_magnet, ifail, mag, izdiv, zdiv:",
     &            ifail,kdmag,izdiv,zdiv
              endif
c              write(lun6,*)"Nachher:",z02

              !kdmag is mother

c              ncutpiece=ncutpiece+1
              if (ncorn2(1).gt.0) then
                ! Magnet has been cut
                ncutpiece=ncutpiece+1

                ! First piece, replaces mother

                bpebc(8,nmagmax)=bc8
                bpebc(15,kdmag)=bpebc15
                mothdiv(1,kdmag)=bpebc15
                mothdiv(4,kdmag)=izdiv

                do ic=1,32
                  chmags(ic,kdmag)=chmag(ic:ic)
                  chmoths(ic,kdmag)=chmoth(ic:ic)
                enddo

                bpebc(9,kdmag)=bc9
                bpebc(10,kdmag)=bc10

                bpebc(1,kdmag)=x02(1)
                bpebc(2,kdmag)=y02(1)
                bpebc(3,kdmag)=z02(1)

                bpebc(4:7,kdmag)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ibpecol(kdmag)=ncol
                ibpeplan(kdmag)=nplan
                ibpeplano(kdmag)=nplan

                do iplan=1,nplan
                  ncorn=ncorn1(iplan)
                  ibpecorn(iplan,kdmag)=ncorn+1
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,kdmag)=
     &                corn1(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag(1:3,ncorn,iplan,kdmag)=
     &              corn1(1:3,1,iplan) !debug 6
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                nplan=ibpeplan(kdmag)
                do iplan=1,nplan
                  ncorn=ibpecorn(iplan,kdmag)-1
                  do icorn=1,ncorn
                    i=i+1
                    x0=x0+bpemag(1,icorn,iplan,kdmag)
                    y0=y0+bpemag(2,icorn,iplan,kdmag)
                    z0=z0+bpemag(3,icorn,iplan,kdmag)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(kdmag)

                  p1(1)=bpemag(1,1,iplan,kdmag)
                  p1(2)=bpemag(2,1,iplan,kdmag)
                  p1(3)=bpemag(3,1,iplan,kdmag)

                  p2(1)=bpemag(1,2,iplan,kdmag)
                  p2(2)=bpemag(2,2,iplan,kdmag)
                  p2(3)=bpemag(3,2,iplan,kdmag)

                  p3(1)=bpemag(1,3,iplan,kdmag)
                  p3(2)=bpemag(2,3,iplan,kdmag)
                  p3(3)=bpemag(3,3,iplan,kdmag)

                  call undumag_bpen(kdmag,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 11 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                kdmag,iplan
                    write(lun6,*)"icorn,x,y,z:"
                    do icorn=1,ibpecorn(iplan,kdmag)
                      write(lun6,*)icorn,bpemag(1:3,icorn,iplan,kdmag)
                    enddo
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag(1,1,iplan,kdmag)-x0
                  vsy=bpemag(2,1,iplan,kdmag)-y0
                  vsz=bpemag(3,1,iplan,kdmag)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn1(iplan)
                    ibpecorn(iplan,kdmag)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag(1:3,icorn,iplan,kdmag)
                    enddo

                    do icorn=1,ncorn
                      bpemag(1:3,icorn,iplan,kdmag)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ! Second piece

                nmagmax=nmagmax+1
+self,if=debug.
                write(lun6,*)"Second piece:",nmagmax
+self.

                bpebc(8,nmagmax)=bc8
                bpebc(15,nmagmax)=bpebc15

                mothdiv(1,nmagmax)=bpebc15
                mothdiv(4,nmagmax)=izdiv+1

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=bc9
                bpebc(10,nmagmax)=bc10

                bpebc(1,nmagmax)=x02(2)
                bpebc(2,nmagmax)=y02(2)
                bpebc(3,nmagmax)=z02(2)

                bpebc(4:7,nmagmax)=bc04

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn2(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                ibpeplan(nmagmax)=nplan
                ibpeplano(nmagmax)=nplan
                ibpecol(nmagmax)=ncol

                do iplan=1,nplan
                  ncorn=ncorn2(iplan)
                  ibpecorn(iplan,nmagmax)=ncorn+1
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,nmagmax)=
     &                corn2(1:3,icorn,iplan)
                  enddo
                  ncorn=ncorn+1
                  bpemag(1:3,ncorn,iplan,nmagmax)=
     &              corn2(1:3,1,iplan) !debug 6
                enddo

                !{ check orientation of planes

                x0=0.0d0
                y0=0.0d0
                z0=0.0d0

                i=0
                do iplan=1,ibpeplan(nmagmax)
                  do icorn=1,ibpecorn(iplan,nmagmax)-1
                    i=i+1
                    x0=x0+bpemag(1,icorn,iplan,nmagmax)
                    y0=y0+bpemag(2,icorn,iplan,nmagmax)
                    z0=z0+bpemag(3,icorn,iplan,nmagmax)
                  enddo ! icorn
                enddo !iplan

                x0=x0/i
                y0=y0/i
                z0=z0/i

                do iplan=1,ibpeplan(nmagmax)

                  p1(1)=bpemag(1,1,iplan,nmagmax)
                  p1(2)=bpemag(2,1,iplan,nmagmax)
                  p1(3)=bpemag(3,1,iplan,nmagmax)

                  p2(1)=bpemag(1,2,iplan,nmagmax)
                  p2(2)=bpemag(2,2,iplan,nmagmax)
                  p2(3)=bpemag(3,2,iplan,nmagmax)

                  p3(1)=bpemag(1,3,iplan,nmagmax)
                  p3(2)=bpemag(2,3,iplan,nmagmax)
                  p3(3)=bpemag(3,3,iplan,nmagmax)

                  call undumag_bpen(nmagmax,iplan,p1,p2,p3,vnormlab,ifail)
                  if (ifail.ne.0) then
                    write(lun6,*)"*** Error 12 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &                nmagmax,iplan
                    stop
                  endif

                  ! does normal vector point outside?

                  vsx=bpemag(1,1,iplan,nmagmax)-x0
                  vsy=bpemag(2,1,iplan,nmagmax)-y0
                  vsz=bpemag(3,1,iplan,nmagmax)-z0

                  if (vsx*vnormlab(1)+vsy*vnormlab(2)+vsz*vnormlab(3).lt.0.0d0) then

                    ncorn=ncorn2(iplan)
                    ibpecorn(iplan,nmagmax)=ncorn

                    do icorn=1,ncorn
                      corn1(1:3,icorn,iplan)=
     &                  bpemag(1:3,icorn,iplan,nmagmax)
                    enddo

                    do icorn=1,ncorn
                      bpemag(1:3,icorn,iplan,nmagmax)=
     &                  corn1(1:3,ncorn+1-icorn,iplan)
                    enddo

                  endif

                enddo !nplan
                !} check orientation of planes

                ncorn1=0
                corn1=0.0d0
                ncorn1=ncorn2
                corn1=corn2

                nplan=0
                do i=1,2*nplanmax
                  if (ncorn1(i).gt.0) then
                    nplan=nplan+1
                  endif
                enddo

                zdivmin=1.0d30
                zdivmax=-1.0d30
                do iplan=1,nplan
                  do icorn=1,ncorn
                    if (corn1(3,icorn,iplan).lt.zdivmin)
     &                zdivmin=corn1(3,icorn,iplan)
                    if (corn1(3,icorn,iplan).gt.zdivmax)
     &                zdivmax=corn1(3,icorn,iplan)
                  enddo
                enddo

              endif !cut

            enddo !nzdiv

          enddo !kdmag

        else if (nplan.eq.-11) then

          ncorn=4
          if (ncorn+1.gt.ncornmax) ncornmax=ncorn+1
          ncorn=ncorn+1

          nangmin=1+abs(angle)/(90.0d0+tiny)

          if (nang.lt.nangmin) nang=nangmin
          if (nr.lt.1) nr=1
          if (nh.lt.1) nh=1

          nmagdiv=nmagdiv+nr*nang*nh

! cyl magnet, i.e. nplan=-11{

          kcyl=kcyl+1
          magcyl(kcyl,1)=nmagmax

          if (radin.lt.tiny) radin=tiny

          x00=bpebc0(1,nmagmax)
          y00=bpebc0(2,nmagmax)
          z00=bpebc0(3,nmagmax)

          npmoth(nmoth)=8
          matmoth(nmoth)=imat
          ncolmoth(nmoth)=ibpecol(nmagmax)

          ip=0
          dphi=angle/nang*grarad1
          dr=(radout-radin)/nr
          dh=height/nh
          r=radin
          do ir=1,2
            h=-height/2.0d0
            do ih=1,2
              phi=-angle/2.0d0*grarad1
              do iphi=1,2
                ip=ip+1
                x1=r*sin(phi)
                y1=h
                z1=r*cos(phi)
                xmoth(ip,nmoth)=rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1+x00
                ymoth(ip,nmoth)=rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1+y00
                zmoth(ip,nmoth)=rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1+z00
                phi=angle/2.0d0*grarad1
              enddo
              h=height/2.0d0
            enddo
            r=radout
          enddo
cBau
          r=radin
          jplan=ibpeplano(nmagmax)

          if (ihullallo.eq.0) then
            maxpoints=8
            allocate(hull(3,maxpoints))
            allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
            allocate(khull(maxpoints))
            allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            ihullallo=1
          else
            if (maxpoints.lt.8) then
              deallocate(hull,xhull,yhull,zhull,khull,kedge,kface)
              maxpoints=8
              allocate(hull(3,maxpoints))
              allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
              allocate(khull(maxpoints))
              allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))
            endif
          endif

          do ir=1,nr
            h=-height/2.0d0+dh/2.0d0
            do ih=1,nh
              phi=-angle/2.0d0*grarad1+dphi/2.0d0
              do iphi=1,nang

                x0=r*sin(phi)
                y0=h
                z0=r*cos(phi)

                ri=radin
                ro=radout
                y1=y0-dh/2.0d0
                y2=y0+dh/2.0d0

                x1=ri*sin(phi-dphi/2.0d0)
                z1=ri*cos(phi-dphi/2.0d0)
                x2=ro*sin(phi-dphi/2.0d0)
                z2=ro*cos(phi-dphi/2.0d0)
                x3=ro*sin(phi+dphi/2.0d0)
                z3=ro*cos(phi+dphi/2.0d0)
                x4=ri*sin(phi+dphi/2.0d0)
                z4=ri*cos(phi+dphi/2.0d0)

                xhull(1)=rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1
                yhull(1)=rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1
                zhull(1)=rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1

                xhull(2)=rmat(1,1)*x2+rmat(1,2)*y1+rmat(1,3)*z2
                yhull(2)=rmat(2,1)*x2+rmat(2,2)*y1+rmat(2,3)*z2
                zhull(2)=rmat(3,1)*x2+rmat(3,2)*y1+rmat(3,3)*z2

                xhull(3)=rmat(1,1)*x3+rmat(1,2)*y1+rmat(1,3)*z3
                yhull(3)=rmat(2,1)*x3+rmat(2,2)*y1+rmat(2,3)*z3
                zhull(3)=rmat(3,1)*x3+rmat(3,2)*y1+rmat(3,3)*z3

                xhull(4)=rmat(1,1)*x4+rmat(1,2)*y1+rmat(1,3)*z4
                yhull(4)=rmat(2,1)*x4+rmat(2,2)*y1+rmat(2,3)*z4
                zhull(4)=rmat(3,1)*x4+rmat(3,2)*y1+rmat(3,3)*z4

                xhull(5)=rmat(1,1)*x1+rmat(1,2)*y2+rmat(1,3)*z1
                yhull(5)=rmat(2,1)*x1+rmat(2,2)*y2+rmat(2,3)*z1
                zhull(5)=rmat(3,1)*x1+rmat(3,2)*y2+rmat(3,3)*z1

                xhull(6)=rmat(1,1)*x2+rmat(1,2)*y2+rmat(1,3)*z2
                yhull(6)=rmat(2,1)*x2+rmat(2,2)*y2+rmat(2,3)*z2
                zhull(6)=rmat(3,1)*x2+rmat(3,2)*y2+rmat(3,3)*z2

                xhull(7)=rmat(1,1)*x3+rmat(1,2)*y2+rmat(1,3)*z3
                yhull(7)=rmat(2,1)*x3+rmat(2,2)*y2+rmat(2,3)*z3
                zhull(7)=rmat(3,1)*x3+rmat(3,2)*y2+rmat(3,3)*z3

                xhull(8)=rmat(1,1)*x4+rmat(1,2)*y2+rmat(1,3)*z4
                yhull(8)=rmat(2,1)*x4+rmat(2,2)*y2+rmat(2,3)*z4
                zhull(8)=rmat(3,1)*x4+rmat(3,2)*y2+rmat(3,3)*z4

                npoi=8
                call util_convex_hull_3d(npoi,xhull,yhull,zhull,
     &            khull,kedge,kface,
     &            nhull,nedge,nface,kfacelast,hulltiny,ifailhull)
                if (ifailhull.ne.0.or.nhull.lt.4) then
                  write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for ",
     &              trim(cline)
                  stop
                endif

                ibpeplano(nmagmax)=nface
                ibpeplan(nmagmax)=nface

                next=1

                gcen=0.0d0
                k=0
                do iplan=1,nface

                  ncorn=kface(next)

                  ncorn=ncorn+1
                  ibpecorn(iplan,nmagmax)=ncorn

                  do icorn=1,ncorn

                    if (icorn.lt.ncorn) then
                      ip=kface(next+icorn)
                      bpemag(1,icorn,iplan,nmagmax)=xhull(ip)+x00
                      bpemag(2,icorn,iplan,nmagmax)=yhull(ip)+y00
                      bpemag(3,icorn,iplan,nmagmax)=zhull(ip)+z00

                      k=k+1
                      gcen(1)=gcen(1)+xhull(ip)+x00
                      gcen(2)=gcen(2)+yhull(ip)+y00
                      gcen(3)=gcen(3)+zhull(ip)+z00

c                      write(99,*)nmagmax,iplan,icorn,bpemag0(1:3,icorn,iplan,nmagmax)
                    else ! icorn.lt.ncorn

                      bpemag(1,icorn,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                      bpemag(2,icorn,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                      bpemag(3,icorn,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)

                    endif ! icorn.lt.ncorn

                  enddo !icorn

                  next=next+ncorn ! here, ncorn is already increamented by 1

                enddo !nface

                gcen=gcen/k

               do iplan=1,nface
                 ncorn=ibpecorn(iplan,nmagmax)
                  do icorn=1,ncorn
                    bpemag(1:3,icorn,iplan,nmagmax)=
     &                bpemag(1:3,icorn,iplan,nmagmax)-gcen(1:3)
                  enddo !icorn
                enddo !nface

                bpebc(15,nmagmax)=bpebc15
                mothdiv(1,nmagmax)=bpebc15

                mothdiv(2,nmagmax)=ir
                mothdiv(3,nmagmax)=iy
                mothdiv(4,nmagmax)=iphi

                c32=chmag
                write(chmags(1:32,nmagmax),'(a)')c32a(1:32)
                c32=chmoth
                write(chmoths(1:32,nmagmax),'(a)')c32a(1:32)

                bpebc(9,nmagmax)=imat
                bpebc(10,nmagmax)=0

                ibpeplano(nmagmax)=jplan

                bpebc(1:3,nmagmax)=gcen(1:3)

                x1=xm*bdum
                y1=ym*bdum
                z1=zm*bdum

                bpebc(4,nmagmax)=
     &            rmat(1,1)*x1+rmat(1,2)*y1+rmat(1,3)*z1
                bpebc(5,nmagmax)=
     &            rmat(2,1)*x1+rmat(2,2)*y1+rmat(2,3)*z1
                bpebc(6,nmagmax)=
     &            rmat(3,1)*x1+rmat(3,2)*y1+rmat(3,3)*z1

                bpebc(7,nmagmax)=bc
                bpebc(8,nmagmax)=1
                ibpeplan(nmagmax)=6
                ibpecol(nmagmax)=ncol

                phi=phi+dphi

                nspecmag=nspecmag+1
                nmagmax=nmagmax+1
              enddo
              h=h+dh
            enddo !ih
            r=r+dr
          enddo !ir

          nspecmag=nspecmag-1
          nmagmax=nmagmax-1
          magcyl(kcyl,2)=nmagmax
          ncutpiece=ncutpiece+nr*nang*nh

! cyl magnet, i.e. nplan=-11}
        else ! nplan>0

! rectangular special magnet, i.e. nplan=-6{

          call util_skip_comment_end(lunbpe,ieof)

          read(lunbpe,*)xlen,ylen,zlen, nxdiv,nydiv,nzdiv

c          imag=nmagmax+nxdiv*nydiv*nzdiv-1

          dx=xlen/nxdiv

          fracsum=0.0d0
          ! yfracdiv**(nydiv-1)=yfacdiv
          ! ln(yfracdiv)*(nydiv-1)=ln(yfacdiv)
          if (nydiv.gt.1) then
            yfracdiv=exp(log(yfacdiv)/(nydiv-1))
          else
            yfracdiv=1.0d0
          endif
          do iydiv=0,nydiv-1
            fracsum=fracsum+yfracdiv**iydiv
          enddo

          dz=zlen/nzdiv

          x0=bpebc0(1,nmagmax)-xlen/2.0d0
          y0=bpebc0(2,nmagmax)-ylen/2.0d0
          z0=bpebc0(3,nmagmax)-zlen/2.0d0

          if (bc.ne.0.0d0.and.xmin.gt.x0) xmin=x0
          if (bc.ne.0.0d0.and.ymin.gt.y0) ymin=y0
          if (bc.ne.0.0d0.and.zmin.gt.z0) zmin=z0

          x0=x0+xlen
          y0=y0+ylen
          z0=z0+zlen

          if (bc.ne.0.0d0.and.xmax.lt.x0) xmax=x0
          if (bc.ne.0.0d0.and.ymax.lt.y0) ymax=y0
          if (bc.ne.0.0d0.and.zmax.lt.z0) zmax=z0

          x00=bpebc0(1,nmagmax)-xlen/2.0d0-dx/2.0d0
          y00=bpebc0(2,nmagmax)+ylen/2.0d0
          z00=bpebc0(3,nmagmax)-zlen/2.0d0-dz/2.0d0
cdebug
          npmoth(nmoth)=8
          matmoth(nmoth)=imat
          ncolmoth(nmoth)=ibpecol(nmagmax)

          x0=x0-xlen/2.0
          y0=y0-ylen/2.0
          z0=z0-zlen/2.0
          xmoth(1,nmoth)=x0-xlen/2.0d0
          ymoth(1,nmoth)=y0-ylen/2.0d0
          zmoth(1,nmoth)=z0-zlen/2.0d0

          xmoth(2,nmoth)=x0+xlen/2.0d0
          ymoth(2,nmoth)=y0-ylen/2.0d0
          zmoth(2,nmoth)=z0-zlen/2.0d0

          xmoth(3,nmoth)=x0+xlen/2.0d0
          ymoth(3,nmoth)=y0+ylen/2.0d0
          zmoth(3,nmoth)=z0-zlen/2.0d0

          xmoth(4,nmoth)=x0-xlen/2.0d0
          ymoth(4,nmoth)=y0+ylen/2.0d0
          zmoth(4,nmoth)=z0-zlen/2.0d0

          xmoth(5,nmoth)=x0-xlen/2.0d0
          ymoth(5,nmoth)=y0-ylen/2.0d0
          zmoth(5,nmoth)=z0+zlen/2.0d0

          xmoth(6,nmoth)=x0+xlen/2.0d0
          ymoth(6,nmoth)=y0-ylen/2.0d0
          zmoth(6,nmoth)=z0+zlen/2.0d0

          xmoth(7,nmoth)=x0+xlen/2.0d0
          ymoth(7,nmoth)=y0+ylen/2.0d0
          zmoth(7,nmoth)=z0+zlen/2.0d0

          xmoth(8,nmoth)=x0-xlen/2.0d0
          ymoth(8,nmoth)=y0+ylen/2.0d0
          zmoth(8,nmoth)=z0+zlen/2.0d0

          jplan=ibpeplano(nmagmax)

          imag=nmagmax
          bpebc(15,nmagmax)=nmagmax

          mothdiv(1,nmagmax)=nmagmax

          do ic=1,32
            chmag(ic:ic)=chmags(ic,nmagmax)
            chmoth(ic:ic)=chmoths(ic,nmagmax)
          enddo

          nmagmax=nmagmax-1

          ncutpiece=ncutpiece+1
cdebug ixdiv 4
          do ixdiv=1,nxdiv
            x0=x00+dx*ixdiv
            y0=y00
            dy=ylen/fracsum
cdebug iydiv 4
            do iydiv=1,nydiv
              y0=y0-dy/2.0d0
cdebug izdiv 4
              do izdiv=1,nzdiv

                z0=z00+dz*izdiv

                nmagmax=nmagmax+1

                bpebc(1,nmagmax)=x0
                bpebc(2,nmagmax)=y0
                bpebc(3,nmagmax)=z0

                bpebc(4,nmagmax)=bpebc0(4,imag)
                bpebc(5,nmagmax)=bpebc0(5,imag)
                bpebc(6,nmagmax)=bpebc0(6,imag)

                bc=sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)
                bpebc(7,nmagmax)=bc
c                write(lun6,*) nmagmax,bc

                bpebc(8,nmagmax)=bpebc0(7,imag)
                bpebc(15,nmagmax)=bpebc15

                mothdiv(1,nmagmax)=bpebc15
                mothdiv(2,nmagmax)=ixdiv
                mothdiv(3,nmagmax)=iydiv
                mothdiv(4,nmagmax)=izdiv

                do ic=1,32
                  chmags(ic,nmagmax)=chmag(ic:ic)
                  chmoths(ic,nmagmax)=chmoth(ic:ic)
                enddo

                bpebc(9,nmagmax)=imat

                ibpeplano(nmagmax)=jplan

                bpebc0(1,nmagmax)=x0
                bpebc0(2,nmagmax)=y0
                bpebc0(3,nmagmax)=z0

                bpebc0(4,nmagmax)=xm*bdum
                bpebc0(5,nmagmax)=ym*bdum
                bpebc0(6,nmagmax)=zm*bdum

                bpebc0(7,nmagmax)=-6
                ibpeplan(nmagmax)=6
                ibpecol(nmagmax)=ncol

                iplan=1
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=2
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=3
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=4
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=5
                ibpecorn(iplan,nmagmax)=5
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0-dz/2.0d0

                iplan=6
                ibpecorn(iplan,nmagmax)=5
                icorn=4
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=3
                bpemag(1,icorn,iplan,nmagmax)=x0-dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=2
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0+dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0
                icorn=1
                bpemag(1,icorn,iplan,nmagmax)=x0+dx/2.0d0
                bpemag(2,icorn,iplan,nmagmax)=y0-dy/2.0d0
                bpemag(3,icorn,iplan,nmagmax)=z0+dz/2.0d0

                do iplan=1,6
                  bpemag(1,5,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                  bpemag(2,5,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                  bpemag(3,5,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)
                enddo !iplan

                do iplan=1,6
                  bpemag(1,5,iplan,nmagmax)=bpemag(1,1,iplan,nmagmax)
                  bpemag(2,5,iplan,nmagmax)=bpemag(2,1,iplan,nmagmax)
                  bpemag(3,5,iplan,nmagmax)=bpemag(3,1,iplan,nmagmax)
                enddo !iplan

              enddo !nzdiv
              y0=y0-dy/2.0d0
              dy=dy*yfracdiv
            enddo !nydiv
          enddo !nxdiv
! rectangular magnet, i.e. nplan=-6}

        endif !nplan>0

      enddo !nspecmag

      do imag=kmag1,nmagmax
        if (bpebc(8,imag).eq.1.and.bpebc(7,imag).ne.0.0d0) then
          do iplan=1,ibpeplan(imag)
            do icorn=1,ibpecorn(iplan,imag)
              x0=bpemag(1,icorn,iplan,imag)+bpebc(1,imag)
              y0=bpemag(2,icorn,iplan,imag)+bpebc(2,imag)
              z0=bpemag(3,icorn,iplan,imag)+bpebc(3,imag)
              bpemag(1,icorn,iplan,imag)=x0
              bpemag(2,icorn,iplan,imag)=y0
              bpemag(3,icorn,iplan,imag)=z0
              if (x0.lt.xmin) xmin=x0
              if (x0.gt.xmax) xmax=x0
              if (y0.lt.ymin) ymin=y0
              if (y0.gt.ymax) ymax=y0
              if (z0.lt.zmin) zmin=z0
              if (z0.gt.zmax) zmax=z0
            enddo
          enddo
        endif
      enddo

      call util_skip_comment(lunbpe)
      read(lunbpe,*)x0,y0,z0

      nmag=nmagmax !includes now special magnets

      open(newunit=lunmag,file='undumag.run',status='old')
      read(lunmag,'(a)')cundutit
      close(lunmag)
      cundutit(1:1)='*'

cdebug material
      write(lun6,*)
      write(lun6,*) "Material files (material number, material type, mode, filename):"
      write(lun6,*)
      call util_skip_comment_end(lunbpe,ieof)
      read(lunbpe,*) imatfile
      do kmat=1,nmatfiles
        call util_skip_comment_end(lunbpe,ieof)
        read(lunbpe,*) imat ,lmat, mapmode, cfile
        nmatpoi=0
        bcmo=-1.0d30
        hmato=-1.0d30
        open(newunit=lunmat,file=trim(cfile),status='old')
        write(lun6,*)imat,lmat,mapmode,"      ",trim(cfile)
        nline=0

115     call util_skip_comment_end(lunmat,ieof)
        if (ieof.ne.0) goto 995
        perksi=0.0d0
        ! lmat = 1: Anisotropic magnet material with an easy axis
        !           mapmode=1: Linear material
        !           mapmode=2: Non-linear material

        if (lmat.eq.1) then

          if (mapmode.eq.1) then

            nline=nline+1

            if (nline.gt.1) then
              write(lun6,*)"*** Error in undumag_ini_old ***"
              write(lun6,*)"*** Material file for mapmode 1 must contain only one data line ***"
              write(lun6,*)"File: ,",trim(cfile)
              stop
            endif

            read(lunmat,*)bcmat(2:3,1,kmat) ! read mu=1.+parksi and perksi
            bcmat(2,1,kmat)=bcmat(2,1,kmat)-1.0d0

          else if (mapmode.eq.2) then
            read(lunmat,*)hmat,bcm,perksi
c              if (bcm.ne.bcmo.or.hmato.ne.hmat) then
c                nmatpoi=nmatpoi+1
c                bcmat(1,nmatpoi,kmat)=hmat
c                bcmat(2,nmatpoi,kmat)=bcm
c                bcmat(3,nmatpoi,kmat)=perksi
c              endif
            if (bcm.ne.bcmo) then
c                nmatpoi=nmatpoi+1
            endif
            bcmat(1,nmatpoi,kmat)=hmat
            bcmat(2,nmatpoi,kmat)=bcm
            bcmat(3,nmatpoi,kmat)=perksi
            bcmo=bcm
            hmato=hmat
          else
            write(lun6,*)"*** Bad material mode found in input file ***"
            stop
          endif
          goto 115
        else if (lmat.eq.2) then
            ! lmat = 2: Isotropic material
            if (mapmode.eq.0
     &          .or.mapmode.eq.2
     &          .or.mapmode.eq.3
     &          .or.mapmode.eq.4
     &          .or.mapmode.eq.5
     &          .or.mapmode.eq.6
     &          .or.mapmode.eq.7
     &          .or.mapmode.eq.8
     &          ) then
              read(lunmat,*)hmat,bcm
            else
              write(lun6,*)"*** Bad material mode found in input file ***"
              stop
            endif
c            if (bcm.ne.bcmo.or.hmato.ne.hmat) then
            if (bcm.ne.bcmo) then
              nmatpoi=nmatpoi+1
            endif
            bcmat(1,nmatpoi,kmat)=hmat
            bcmat(2,nmatpoi,kmat)=bcm
            bcmat(3,nmatpoi,kmat)=perksi
            if (
     &          mapmode.eq.2
     &          .or.mapmode.eq.3
     &          .or.mapmode.eq.4
     &          .or.mapmode.eq.5
     &          .or.mapmode.eq.6
     &          .or.mapmode.eq.7
     &          .or.mapmode.eq.8
     &          ) then
              if (mapmode.eq.3.and.hmat.eq.0.0d0) hmat=1.0d-30
              if (mapmode.eq.3.and.bcm.eq.0.0d0) bcm=1.0d-30
              feh1(nmatpoi)=hmat
              fem1(nmatpoi)=bcm
              bcmo=bcm
              hmato=hmat
            endif
c            endif
            goto 115
          else
            write(lun6,*)"*** Bad material type found in input file ***"
            write(lun6,*)"*** Must be 1 for anisotropic or 2 for isotropic material ***"
            stop
          endif !lmat

995     continue

        matmaps(1,kmat)=imat
        matmaps(2,kmat)=lmat
        matmaps(3,kmat)=mapmode
        matmaps(4,kmat)=nmatpoi

        close(lunmat)

        if (mapmode.gt.1.and.nmatpoi.lt.2) then
          write(lun6,*)"*** Error in undumag_ini_old ***"
          write(lun6,*)"*** Material file for mapmode > 1 must contain more then one data line ***"
          write(lun6,*)"File: ,",trim(cfile)
          stop
        endif
        if (lmat.eq.2.and.isplinefm.ne.0) call util_spline_coef(feh1,fem1,nmatpoi,
     &    0.0d0,0.0d0,fespl1,fewspl1,fewspl2,fewspl3,fewspl4)

      enddo !nmatfiles

      call util_skip_comment_end(lunbpe,ieof)
      if (ieof.ne.0) goto 9977

      read(lunbpe,'(a)')cline

      xcwmin=1.0e30
      xcwmax=-1.0e30

      if (cline.eq.'Coils') then

        nlines=0
777     read(lunbpe,'(a)')cline

        if (cline.ne.'EndCoils') then
          nlines=nlines+1
          goto 777
        endif

        if (nlines.gt.0) then

          do i=1,nlines+1
            backspace(lunbpe)
          enddo

          ncwires=0
          nrace=0
          nwind=0
          ncrace=0
          narc=0
          ncarc=0
          nrbar=0
          nthwir=0

          do i=1,nlines+1

            call util_skip_comment_end(lunbpe,ieof)
            read(lunbpe,'(a)')cline

            if (cline.eq.'EndCoils') then
              exit
            else if (cline.eq.'Filaments') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)ncfila
              if (ncfila.gt.0) then
                luncoi=lunbpe
              else
                ncfila=0
                open(newunit=luncoi,file=cline)
                call util_skip_comment_end(lunbpe,ieof)
                do while(ieof.eq.0)
                  read(luncoi,*)curr,x1,y1,z1,x2,y2,z2
                  ncfila=ncfila+1
                  call util_skip_comment_end(lunbpe,ieof)
                enddo
                rewind(luncoi)
              endif
              do k=1,ncfila
                call util_skip_comment_end(luncoi,ieof)
                read(luncoi,*)curr,x1,y1,z1,x2,y2,z2
                if (((x2-x1)**2+(y2-y1)**2+(z2-z1)**2)*curr.ne.0.0d0) then
                  ncwires=ncwires+1
                  if (x1.lt.xcwmin) xcwmin=x1
                  if (x2.lt.xcwmin) xcwmin=x2
                  if (x1.gt.xcwmax) xcwmax=x1
                  if (x2.gt.xcwmax) xcwmax=x2
                endif
                if (luncoi.ne.lunbpe) close(luncoi)
              enddo !ncfila
            else if (cline.eq.'RectWindings') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)wind19
              nwind=nwind+1
            else if (cline.eq.'Rectangular') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr,x,y,z,vx,vy,vz,phi,xlen
              nrace=nrace+1
            else if (cline.eq.'RectangCirc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              if (curr.ne.0.0d0) ncrace=ncrace+1
            else if (cline.eq.'RectArc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)dum
              if (curr.ne.0.0d0) narc=narc+1
            else if (cline.eq.'CircArc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)dum
              if (curr.ne.0.0d0) ncarc=ncarc+1
            else if (cline.eq.'RectBar') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              if (curr.ne.0.0d0) nrbar=nrbar+1
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)dum
            else if (cline.eq.'ThickWire') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)curr
              if (curr.ne.0.0d0) nthwir=nthwir+1
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)dum
            endif !key
          enddo !nlines

          if (ncwires.gt.0) then
            allocate(wire(nwitems,ncwires))
            wire=0.0d0
          endif

          if (nrace.gt.0) then
            allocate(race(17,nrace))
            race=0.0d0
          endif

          if (nwind.gt.0) then
            allocate(wind(19,nwind))
            wind=0.0d0
          endif

          if (ncrace.gt.0) then
            allocate(crace(17,ncrace))
            crace=0.0d0
          endif

          if (narc.gt.0) then
            allocate(arc(21,narc))
            arc=0.0d0
          endif

          if (ncarc.gt.0) then
            allocate(carc(20,ncarc))
            carc=0.0d0
          endif

          if (nrbar.gt.0) then
            allocate(rectbar(19,nrbar))
            rectbar=0.0d0
          endif

          if (nthwir.gt.0) then
            allocate(thickwire(18,nthwir))
            thickwire=0.0d0
          endif

          do i=1,nlines+1
            backspace(lunbpe)
          enddo

          ncwires=0
          nrace=0
          nwind=0
          ncrace=0
          narc=0
          ncarc=0
          nrbar=0
          nthwir=0
          ncoil=0

          do i=1,nlines+1

            call util_skip_comment_end(lunbpe,ieof)
            read(lunbpe,'(a)')cline

            if (cline.eq.'EndCoils') then
              exit
            else if (cline.eq.'Filaments') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)ncfila
              do k=1,ncfila
                call util_skip_comment_end(lunbpe,ieof)
                read(lunbpe,*)curr,x1,y1,z1,x2,y2,z2,kolor
                if (((x2-x1)**2+(y2-y1)**2+(z2-z1)**2)*curr.ne.0.0d0) then
                  ncwires=ncwires+1
                  wire(1,ncwires)=1
                  wire(2,ncwires)=curr
                  wire(3,ncwires)=x1
                  wire(4,ncwires)=y1
                  wire(5,ncwires)=z1
                  wire(6,ncwires)=x2
                  wire(7,ncwires)=y2
                  wire(8,ncwires)=z2
                  wire(9,ncwires)=kolor
                endif
              enddo
            else if (cline.eq.'RectWindings') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) wind19
              if (wind19(1).ne.0.0d0) then
                nwind=nwind+1
                wind(1,nwind)=wind19(1)
                wind(2:17,nwind)=wind19(4:19)
                wind(18:19,nwind)=wind19(2:3)
              endif
            else if (cline.eq.'Rectangular') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) race17
              if (race17(1).ne.0.0d0) then
                nrace=nrace+1
                race(1:17,nrace)=race17
              endif
            else if (cline.eq.'RectangCirc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) race17
              if (race17(1).ne.0.0d0) then
                ncrace=ncrace+1
                crace(:,ncrace)=race17
              endif
            else if (cline.eq.'RectArc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) arc21(1:12)
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) arc21(13:21)
              if (arc21(1).ne.0.0d0) then
                narc=narc+1
                arc(1:21,narc)=arc21
              endif
            else if (cline.eq.'CircArc') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) arc21(1:11)
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*) arc21(12:20)
              if (arc21(1).ne.0.0d0) then
                ncarc=ncarc+1
                carc(1:20,ncarc)=arc21(1:20)
              endif
            else if (cline.eq.'RectBar') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)arc21(1:10)
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)arc21(11:19)
              if (arc21(1).ne.0.0d0) then
                nrbar=nrbar+1
                rectbar(1:19,nrbar)=arc21(1:19)
              endif
            else if (cline.eq.'ThickWire') then
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)arc21(1:9)
              call util_skip_comment_end(lunbpe,ieof)
              read(lunbpe,*)arc21(10:18)
              if (arc21(1).ne.0.0d0) then
                nthwir=nthwir+1
                thickwire(1:18,nthwir)=arc21(1:18)
              endif
            endif
          enddo !nlines
        endif !nlines

        call undumag_bcoils(0.0d0,0.0d0,0.0d0,bx,by,bz,istat)

        if (ncoil.gt.0) then
          open(newunit=lunfil,file='undumag.fil',status='old')
          do while (.true.)
            call util_skip_comment_end(lunfil,ieof)
            if (ieof.ne.0) exit
            read(lunfil,*) itype,curr,x1,y1,z1,x2,y2,z2,icol,num
            if (x1.lt.xcwmin) xcwmin=x1
            if (x1.gt.xcwmax) xcwmax=x1
            if (x2.lt.xcwmin) xcwmin=x2
            if (x2.gt.xcwmax) xcwmax=x2
          enddo
          close(lunfil)
        endif

      endif !Coils

9977  write(lun6,*)

991   close(lunbpe)

      if (ixsymo.lt.0.or.iysymo.lt.0.or.izsymo.lt.0) then
        call undumag_duplicate_mags
        nmagmax=nmag
        if (ixsymo.lt.0) then
          ixsym=0
          nmoth=2*nmoth
        endif
        if (iysymo.lt.0) then
          iysym=0
          nmoth=2*nmoth
        endif
        if (izsymo.lt.0) then
          izsym=0
          nmoth=2*nmoth
        endif
      else
        bpebc(17,1:nmag)=-9999.0d0
      endif

      do imag=1,nmag
        write(chmoth,'(32a)')chmoths(1:32,imag)
        motho=nint(bpebc(15,imag))
        do kmag=imag+1,nmag
          write(chmoth1,'(32a)')chmoths(1:32,kmag)
          if (chmoth.eq.chmoth1) then
            bpebc(15,kmag)=motho
            mothdiv(1,kmag)=mothdiv(1,imag)
          endif
        enddo
      enddo
c      do imag=1,nmag
c        write(lun6,*)"0 Info:",imag,bpebc(15,imag),chmags(1:32,imag),chmoths(1:32,imag)
c      enddo
      write(lun6,*)"----------------------------------------------------"

      do imag=1,nmag
c center of magnet in lab

        rmag(1)=bpebc(1,imag)
        rmag(2)=bpebc(2,imag)
        rmag(3)=bpebc(3,imag)

c magnetization vector in lab

        vmaglab(1)=bpebc(4,imag)
        vmaglab(2)=bpebc(5,imag)
        vmaglab(3)=bpebc(6,imag)

        bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)

c        write(lun6,*)"imag,rmag:",imag,rmag

        nplan=ibpeplan(imag)
        do iplan=1,nplan

c three points defining plane (lab.-system)

          p1(1)=bpemag(1,1,iplan,imag)
          p1(2)=bpemag(2,1,iplan,imag)
          p1(3)=bpemag(3,1,iplan,imag)

          p2(1)=bpemag(1,2,iplan,imag)
          p2(2)=bpemag(2,2,iplan,imag)
          p2(3)=bpemag(3,2,iplan,imag)

          p3(1)=bpemag(1,3,iplan,imag)
          p3(2)=bpemag(2,3,iplan,imag)
          p3(3)=bpemag(3,3,iplan,imag)

c          write(lun6,*)"imag,iplan,p1:",imag,iplan,p1
c          write(lun6,*)"imag,iplan,p1:",imag,iplan,p2
c          write(lun6,*)"imag,iplan,p1:",imag,iplan,p3

          call undumag_bpen(imag,iplan,p1,p2,p3,vnormlab,ifail)
          if (ifail.ne.0) then
            write(lun6,*)"*** Error 13 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &        imag,iplan
            stop
          endif

c check if normal vector is perpendicular to magnetization vector
c if mag. vector is parallel, skip plane

          if (bc.ne.0.0d0) then
            dum=abs(
     &        (vnormlab(1)*vmaglab(1)+vnormlab(2)*vmaglab(2)+
     &        vnormlab(3)*vmaglab(3))
     &        /bc
     &        )
          else
            dum=0.0d0
          endif

c Removed, since magnetization can change during relaxation
c          if (dum.lt.1.0d-20.and.bpebc(8,imag).ne.-6) then
c            ibpecorn(iplan,imag)=-ibpecorn(iplan,imag)
c          endif

c            bpetm(1,8,iplan,imag)=vnormlab(1)
c            bpetm(2,8,iplan,imag)=vnormlab(2)
c            bpetm(3,8,iplan,imag)=vnormlab(3)
c
c          else

            bpetm(1,7,iplan,imag)=
     &        vmaglab(1)*vnormlab(1)+
     &        vmaglab(2)*vnormlab(2)+
     &        vmaglab(3)*vnormlab(3)
            bpetm(1,8,iplan,imag)=vnormlab(1)
            bpetm(2,8,iplan,imag)=vnormlab(2)
            bpetm(3,8,iplan,imag)=vnormlab(3)

c get matrices ts and tsinv. Ts transforms vnormlab to (0,0,1)

            call undumag_bpet(vnormlab,ts,tsinv)

            if (bpebc(8,imag).eq.-6) then

c for rectangular magnets, we rotate the plans such, that the edges coinside
c with the axis of the coord.-system.

c All planes are rotated to the system of the
c first plane

              if (iplan.eq.1) then
                ts1=ts
                ts1inv=tsinv
              else
                ts=ts1
                tsinv=ts1inv
              endif !(iplan.eq.1)

              do icorn=1,5

                r1lab(1)=bpemag(1,icorn,iplan,imag)
                r1lab(2)=bpemag(2,icorn,iplan,imag)
                r1lab(3)=bpemag(3,icorn,iplan,imag)

                r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
                r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
                r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

                bperot(1,icorn,iplan,imag)=r1(1)
                bperot(2,icorn,iplan,imag)=r1(2)
                bperot(3,icorn,iplan,imag)=r1(3)

              enddo !icorn=1,ncorn

              vx=bperot(1,2,iplan,imag)-bperot(1,1,iplan,imag)
              vy=bperot(2,2,iplan,imag)-bperot(2,1,iplan,imag)
              vn=sqrt(vx*vx+vy*vy)

              sa=vy/vn
              ca=vx/vn

              tz=ts

              ts(1,1)=ca
              ts(1,2)=sa
              ts(1,3)=0.0d0

              ts(2,1)=-sa
              ts(2,2)=ca
              ts(2,3)=0.0d0

              ts(3,1)=0.0d0
              ts(3,2)=0.0d0
              ts(3,3)=1.0d0

c              write(lun6,*)iplan,ca,sa

c              if (iplan.eq.1) then
c                do i=1,3
c                  write(lun6,*)"vorher:",tz(i,1:3)
c                enddo
c              endif
              call util_matrix_multiplication(3,3,3,ts,tz,ts,ws)

              do i=1,3
                do j=1,3
                  tsinv(i,j)=ts(j,i)
                enddo
              enddo

            endif ! if (bpebc(8,imag).eq.-6)

            do i=1,3
              do j=1,3
                bpetm(i,j,iplan,imag)=ts(i,j)
                bpetm(i,j+3,iplan,imag)=tsinv(i,j)
              enddo
c              if (iplan.eq.1) then
c                write(lun6,*)"nachher:",ts(i,1:3)
c              endif
            enddo

c          endif !check if normal vector is perpendicular to magnetization vector

c            write(lun6,*)imag,iplan,bpetm(1,7,iplan,imag)
c            write(lun6,*)imag,iplan,bpetm(1:3,8,iplan,imag)

        enddo !iplan

      enddo !imag

c      write(lun6,*)"Ende"
c      stop
!debug
+self,if=debug.
      do imag=1,nmag
        do iplan=1,ibpeplan(imag)
          do icorn=1,ibpecorn(iplan,imag)
            write(99,*)imag,iplan,icorn,
     &        bpemag(1:3,icorn,iplan,imag)
          enddo
        enddo
      enddo
      write(lun6,*) "fort.99!"
+self.,if=debug.
      do imag=1,nmag

c check, if all flanges appear twice, i.e. volume is closed

        iwarn=0
        nflange=0
        nplan=ibpeplan(imag)
        if (kudebug.eq.9) then
          if(imag.eq.1) then
            open(unit=99,file="debug_edges.dat")
          else
            open(unit=99,file="debug_edges.dat",access="append")
          endif
        endif

        do iplan=1,nplan
          ncorn=ibpecorn(iplan,imag)-1
          if (kudebug.eq.9) then
            write(lun6,*)"imag,nplan,ncorn",imag,nplan,ncorn
          endif
          do icorn=1,ncorn
            nflange=nflange+1
            ip1=icorn
            ip2=ip1+1
            bflange(1,nflange)=bpemag(1,ip1,iplan,imag)
            bflange(2,nflange)=bpemag(2,ip1,iplan,imag)
            bflange(3,nflange)=bpemag(3,ip1,iplan,imag)
            bflange(4,nflange)=bpemag(1,ip2,iplan,imag)
            bflange(5,nflange)=bpemag(2,ip2,iplan,imag)
            bflange(6,nflange)=bpemag(3,ip2,iplan,imag)
            if (kudebug.eq.9) then
              write(lun6,*)"iedge, i1, i2:",nflange,ip1,ip2
              write(lun6,*)"x1,y1,z1:",bflange(1:3,nflange)
              write(lun6,*)"x2,y2,z2:",bflange(4:6,nflange)
              write(99,*)imag,iplan,nflange,ip1,ip2,bflange(1:6,nflange)
            endif
          enddo ! icorn
        enddo !iplan
        if (kudebug.eq.9) then
          close(99)
        endif

        do iflange=1,nflange
          bflange(7,iflange)=1.0d0
        enddo

        rtiny=sqrt((xmax-xmin)**2+(ymax-ymin)**2+(zmax-zmin)**2)*1.0d-12

        do iflange=1,nflange

          do i=iflange+1,nflange

            if (
     &          abs(bflange(1,i)-bflange(1,iflange)).lt.rtiny .and.
     &          abs(bflange(2,i)-bflange(2,iflange)).lt.rtiny .and.
     &          abs(bflange(3,i)-bflange(3,iflange)).lt.rtiny .and.
     &          abs(bflange(4,i)-bflange(4,iflange)).lt.rtiny .and.
     &          abs(bflange(5,i)-bflange(5,iflange)).lt.rtiny .and.
     &          abs(bflange(6,i)-bflange(6,iflange)).lt.rtiny
     &          .or.
     &          abs(bflange(4,i)-bflange(1,iflange)).lt.rtiny .and.
     &          abs(bflange(5,i)-bflange(2,iflange)).lt.rtiny .and.
     &          abs(bflange(6,i)-bflange(3,iflange)).lt.rtiny .and.
     &          abs(bflange(1,i)-bflange(4,iflange)).lt.rtiny .and.
     &          abs(bflange(2,i)-bflange(5,iflange)).lt.rtiny .and.
     &          abs(bflange(3,i)-bflange(6,iflange)).lt.rtiny
     &          ) then

              bflange(7,iflange)=bflange(7,iflange)+1.0d0
              bflange(7,i)=bflange(7,i)+1.0d0

            endif !hit

          enddo !i

          if (bflange(7,iflange).ne.2.0d0.and.iwarn.eq.0
     &        .and.bpebc(7,imag).ne.0.0d0.and.bpebc(9,imag).ne.0) then
c            iwarn=1
            write(lun6,*)
     &        '*** Error in undumag_ini_old: Magnet ',chmoths(1:32,imag),' is not a closed volume'
            write(lun6,*)'magnet, edge, hits: ',imag,iflange,bflange(7,iflange)
            write(lun6,*)
            stop
          endif

        enddo !iflange

c center of gravity is a point inside the magnet since shape is convex

        x0=0.0d0
        y0=0.0d0
        z0=0.0d0

        i=0
        do iplan=1,ibpeplan(imag)
          do icorn=1,ibpecorn(iplan,imag)-1
            i=i+1
            x0=x0+bpemag(1,icorn,iplan,imag)
            y0=y0+bpemag(2,icorn,iplan,imag)
            z0=z0+bpemag(3,icorn,iplan,imag)
c            write(lun6,*)iplan,icorn,sngl(bpemag(1:3,icorn,iplan,imag))
          enddo ! icorn
        enddo !iplan

        x0=x0/i
        y0=y0/i
        z0=z0/i

c        write(lun6,*)"imag,x0,y0,z0",imag,x0,y0,z0

        do iplan=1,ibpeplan(imag)

          vnormlab(1)=bpetm(1,8,iplan,imag)
          vnormlab(2)=bpetm(2,8,iplan,imag)
          vnormlab(3)=bpetm(3,8,iplan,imag)

c does normal vector point outside?

          vsx=bpemag(1,1,iplan,imag)-x0
          vsy=bpemag(2,1,iplan,imag)-y0
          vsz=bpemag(3,1,iplan,imag)-z0

c          write(lun6,*)iplan
c          write(lun6,*)vnormlab
c          write(lun6,*)vsx,vsy,vsz

          if ( vsx*vnormlab(1) + vsy*vnormlab(2) + vsz*vnormlab(3)
     &        .lt. 0.0d0 ) then
            write(lun6,*)
            write(lun6,*)
     &        '*** Error in undumag_ini_old: Normal vector is not pointing outside'
            write(lun6,*)'magnet, plane: ',imag,iplan
            write(lun6,*)
c            stop
          endif

          do icorn=3,ibpecorn(iplan,imag)-1

            ip1=icorn-2
            ip2=icorn-1

            v1x=bpemag(1,ip2,iplan,imag)-bpemag(1,ip1,iplan,imag)
            v1y=bpemag(2,ip2,iplan,imag)-bpemag(2,ip1,iplan,imag)
            v1z=bpemag(3,ip2,iplan,imag)-bpemag(3,ip1,iplan,imag)

            v2x=bpemag(1,icorn,iplan,imag)-bpemag(1,ip2,iplan,imag)
            v2y=bpemag(2,icorn,iplan,imag)-bpemag(2,ip2,iplan,imag)
            v2z=bpemag(3,icorn,iplan,imag)-bpemag(3,ip2,iplan,imag)

            vsx=v1y*v2z-v1z*v2y
            vsy=v1z*v2x-v1x*v2z
            vsz=v1x*v2y-v1y*v2x

            if ( abs(v2x*vnormlab(1)+ v2y*vnormlab(2)+ v2z*vnormlab(3))
     &          .gt.tiny ) then
              write(lun6,*)
              write(lun6,*)'*** Error in undumag_ini_old: Points not in a plane'
              write(lun6,*)'magnet, plane, point: ',imag,iplan,icorn
              write(lun6,*)
              stop
            endif

            if ( vsx*vnormlab(1) + vsy*vnormlab(2) + vsz*vnormlab(3)
     &          .lt. 0.0d0 ) then
              write(lun6,*)
              write(lun6,*)'*** Error in undumag_ini_old: Direction of rotation not unique'
              write(lun6,*)'magnet, plane, point ',imag,iplan,icorn
              write(lun6,*)
              stop
            endif

          enddo !icorn=1,ncorn

        enddo ! iplan=1,nplan

      enddo ! imag=1,nmag

c transform everything to the nz=(0,0,1) system

      do imag=1,nmag

        qsign=0.0d0

        do iplan=1,ibpeplan(imag)

c          if (ibpecorn(iplan,imag).gt.0) then

            do i=1,3
              do j=1,3
                ts(i,j)=bpetm(i,j,iplan,imag)
              enddo
            enddo

            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

            do icorn=1,ibpecorn(iplan,imag)

              r1lab(1)=bpemag(1,icorn,iplan,imag)
              r1lab(2)=bpemag(2,icorn,iplan,imag)
              r1lab(3)=bpemag(3,icorn,iplan,imag)

              r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
              r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
              r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

              bperot(1,icorn,iplan,imag)=r1(1)
              bperot(2,icorn,iplan,imag)=r1(2)
              bperot(3,icorn,iplan,imag)=r1(3)

            enddo !icorn=1,ncorn

            do icorn=1,ibpecorn(iplan,imag)-1

              ip2=icorn+1

              r1(1)=bperot(1,icorn,iplan,imag)
              r1(2)=bperot(2,icorn,iplan,imag)
              r1(3)=bperot(3,icorn,iplan,imag)

              r2(1)=bperot(1,ip2,iplan,imag)
              r2(2)=bperot(2,ip2,iplan,imag)
              r2(3)=bperot(3,ip2,iplan,imag)

c              write(lun6,*)imag,iplan,icorn,r1(1)-r2(1)
c              if (abs(r1(1)-r2(1)).gt.tiny) then
              if (r1(1)-r2(1).ne.0.0d0) then

                a=(r2(2)-r1(2))/(r2(1)-r1(1))
                b=r1(2)-a*r1(1)

              else

                a=0.0d0
                b=r1(2)

              endif !(abs(r1(1)-r2(1)).gt.tiny)

              q=-((a*r1(1)+ a*r2(1) + 2*b)*(r1(1) - r2(1)))/2.d0

              qsign=qsign+q*(
     &           vnormlab(1)*bpebc(4,imag)
     &          +vnormlab(2)*bpebc(5,imag)
     &          +vnormlab(3)*bpebc(6,imag))

            enddo ! icorn

c          endif !(ibpecorn(iplan,imag).gt.0) then

        enddo ! iplan=1,nplan

        if (abs(qsign/bpebc(7,imag)).gt.1.d-9.and.bpebc(8,imag).ne.-6) then
c not checked for rectangular magnets since ibpecorn not negative for
c planes with normal vector parallel to surface. Then they are not skipped
c for while calculation qsign
          write(lun6,*)
          write(lun6,*)
     &      '*** Error in undumag_ini_old: Sum of magnetic charge not zero ***'
          write(lun6,*)'magnet: ',imag
          write(lun6,*)
          stop
        endif

      enddo ! imag=1,nmag

c Check if all magnets are zero

      nmag=0
      do imag=1,nmagmax
        if (bpebc(7,imag).ne.0.0d0) then
          nmag=nmagmax
          goto 109
        endif
      enddo

109   continue

      nmagmax=nmag

      if (nmatfiles.le.0.and.nmag.gt.0) then
        write(lun6,*)"*** Error in undumag_ini_old: No data files for materials found ***"
        stop
      endif

      allocate(bcrec(20,nmagmax))
      allocate(ibpeplanrec(nmagmax))
      allocate(ibpecolrec(nmagmax))
      allocate(ibpecornrec(nplanmax,nmagmax))
      allocate(bmagrec(3,ncornmax,nplanmax,nmagmax))
      allocate(brotrec(3,ncornmax,nplanmax,nmagmax))
      allocate(bpetmrec(3,8,nplanmax,nmagmax))

      allocate(bciron(20,nmagmax),bc0rec(7,nmagmax),bc0iron(7,nmagmax))
      allocate(ibpeplaniron(nmagmax))
      allocate(ibpecoliron(nmagmax))
      allocate(ibpecorniron(nplanmax,nmagmax))
      allocate(bmagiron(3,ncornmax,nplanmax,nmagmax))
      allocate(brotiron(3,ncornmax,nplanmax,nmagmax))
      allocate(bpetmiron(3,8,nplanmax,nmagmax))

      nrec=0
      niron=0

      if (irecrepl.eq.0) goto 666

      do imag=1,nmag

        if (bpebc(8,imag).ne.-6.and.ibpeplan(imag).eq.6) then

          ix1=0
          ix2=0
          iy1=0
          iy2=0
          iz1=0
          iz2=0

          do iplan=1,nplan

            ncorn=ibpecorn(iplan,imag)
            if (ncorn.ne.5) exit

c            write(lun6,*)imag,iplan,bpemag(3,1:5,iplan,imag)
            vnormlab(1)=bpetm(1,8,iplan,imag)
            vnormlab(2)=bpetm(2,8,iplan,imag)
            vnormlab(3)=bpetm(3,8,iplan,imag)

c            write(lun6,*)imag,vnormlab

            if (vnormlab(1).lt.-0.999999d0) then
              ix2=ix2+1
              xxmin=bpemag(1,1,iplan,imag)
            else if (vnormlab(1).gt.0.999999d0) then
              ix1=ix1+1
              xxmax=bpemag(1,1,iplan,imag)
            else if (vnormlab(2).lt.-0.999999d0) then
              iy2=iy2+1
              yymin=bpemag(2,1,iplan,imag)
            else if (vnormlab(2).gt.0.999999d0) then
              iy1=iy1+1
              yymax=bpemag(2,1,iplan,imag)
            else if (vnormlab(3).lt.-0.999999d0) then
              iz2=iz2+1
              zzmin=bpemag(3,1,iplan,imag)
            else if (vnormlab(3).gt.0.999999d0) then
              iz1=iz1+1
              zzmax=bpemag(3,1,iplan,imag)
            endif
          enddo

          if (
     &      ix1.ne.1.or.ix2.ne.1.or.
     &      iy1.ne.1.or.iy2.ne.1.or.
     &      iz1.ne.1.or.iz2.ne.1) cycle

          xcen=(xxmax+xxmin)/2.0d0
          ycen=(yymax+yymin)/2.0d0
          zcen=(zzmax+zzmin)/2.0d0

          bpebc(1,imag)=xcen
          bpebc(2,imag)=ycen
          bpebc(3,imag)=zcen

          bpebc(8,imag)=-6

          dx=xxmax-xxmin
          dy=yymax-yymin
          dz=zzmax-zzmin

          iplan=1
          ibpecorn(iplan,imag)=5
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=2
          ibpecorn(iplan,imag)=5
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=3
          ibpecorn(iplan,imag)=5
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=4
          ibpecorn(iplan,imag)=5
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=5
          ibpecorn(iplan,imag)=5
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen-dz/2.0d0

          iplan=6
          ibpecorn(iplan,imag)=5
          icorn=4
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=3
          bpemag(1,icorn,iplan,imag)=xcen-dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=2
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen+dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0
          icorn=1
          bpemag(1,icorn,iplan,imag)=xcen+dx/2.0d0
          bpemag(2,icorn,iplan,imag)=ycen-dy/2.0d0
          bpemag(3,icorn,iplan,imag)=zcen+dz/2.0d0

          do iplan=1,6
            bpemag(1,5,iplan,imag)=bpemag(1,1,iplan,imag)
            bpemag(2,5,iplan,imag)=bpemag(2,1,iplan,imag)
            bpemag(3,5,iplan,imag)=bpemag(3,1,iplan,imag)
          enddo !iplan

c center of magnet in lab

          rmag(1)=bpebc(1,imag)
          rmag(2)=bpebc(2,imag)
          rmag(3)=bpebc(3,imag)

c magnetization vector in lab

          vmaglab(1)=bpebc(4,imag)
          vmaglab(2)=bpebc(5,imag)
          vmaglab(3)=bpebc(6,imag)

          bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)

c        write(lun6,*)"imag,rmag:",imag,rmag

          do iplan=1,ibpeplan(imag)

c three points defining plane (lab.-system)

c          write(lun6,*)"imag,iplan,p1:",imag,iplan,p1

            p1(1)=bpemag(1,1,iplan,imag)
            p1(2)=bpemag(2,1,iplan,imag)
            p1(3)=bpemag(3,1,iplan,imag)

            p2(1)=bpemag(1,2,iplan,imag)
            p2(2)=bpemag(2,2,iplan,imag)
            p2(3)=bpemag(3,2,iplan,imag)

            p3(1)=bpemag(1,3,iplan,imag)
            p3(2)=bpemag(2,3,iplan,imag)
            p3(3)=bpemag(3,3,iplan,imag)

            call undumag_bpen(imag,iplan,p1,p2,p3,vnormlab,ifail)

            if (ifail.ne.0) then
              write(lun6,*)"*** Error 13 in undumag_ini_old: Failure in undumag_bpen, mag, plane:",
     &          imag,iplan
              stop
            endif

c check if normal vector is perpendicular to magnetization vector
c if mag. vector is parallel, skip plane

            if (bc.ne.0.0d0) then
              dum=abs(
     &          (vnormlab(1)*vmaglab(1)+vnormlab(2)*vmaglab(2)+
     &          vnormlab(3)*vmaglab(3))
     &          /bc
     &          )
            else
              dum=0.0d0
            endif

            bpetm(1,7,iplan,imag)=
     &        vmaglab(1)*vnormlab(1)+
     &        vmaglab(2)*vnormlab(2)+
     &        vmaglab(3)*vnormlab(3)

            bpetm(1,8,iplan,imag)=vnormlab(1)
            bpetm(2,8,iplan,imag)=vnormlab(2)
            bpetm(3,8,iplan,imag)=vnormlab(3)

c get matrices ts and tsinv

            call undumag_bpet(vnormlab,ts,tsinv)

c for rectangular magnets, we rotate plan such, that the flanges coinside with
c the axis of the coord.-system.

c All planes are rotated to the system of the
c first plane

            if (iplan.eq.1) then
              ts1=ts
              ts1inv=tsinv
            else
              ts=ts1
              tsinv=ts1inv
            endif !(iplan.eq.1)

            do icorn=1,5

              r1lab(1)=bpemag(1,icorn,iplan,imag)
              r1lab(2)=bpemag(2,icorn,iplan,imag)
              r1lab(3)=bpemag(3,icorn,iplan,imag)

              r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
              r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
              r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

              bperot(1,icorn,iplan,imag)=r1(1)
              bperot(2,icorn,iplan,imag)=r1(2)
              bperot(3,icorn,iplan,imag)=r1(3)

            enddo !icorn=1,ncorn

            vx=bperot(1,2,iplan,imag)-bperot(1,1,iplan,imag)
            vy=bperot(2,2,iplan,imag)-bperot(2,1,iplan,imag)
            vn=sqrt(vx*vx+vy*vy)

            sa=vy/vn
            ca=vx/vn

            tz=ts

            ts(1,1)=ca
            ts(1,2)=sa
            ts(1,3)=0.0d0

            ts(2,1)=-sa
            ts(2,2)=ca
            ts(2,3)=0.0d0

            ts(3,1)=0.0d0
            ts(3,2)=0.0d0
            ts(3,3)=1.0d0

            call util_matrix_multiplication(3,3,3,ts,tz,ts,ws)

            do i=1,3
              do j=1,3
                tsinv(i,j)=ts(j,i)
              enddo
            enddo

            do i=1,3
              do j=1,3
                bpetm(i,j,iplan,imag)=ts(i,j)
                bpetm(i,j+3,iplan,imag)=tsinv(i,j)
              enddo
            enddo

          enddo !iplan

        endif !(bpebc(8,imag).ne.-6.and.ibpeplan(imag).eq.6) then

      enddo !imag

chier
666   continue

      if (killbadmag.eq.-9999) then
        bpebc(16,1:nmag)=1.0d0
      else
        bpebc(16,1:nmag)=0.0d0
      endif

      if (killbadmag.gt.0.or.killbadmag.eq.-9999) then
        write(lun6,*)
        write(lun6,*)"Killing all voxel, but"
        open(newunit=lunkill,file="undumag.kll")
        do while (.true.)
          call util_read_line(lunkill,cline,last)
          if (last.le.0) exit
          read(cline,*)kmag,kill
          if (kmag.gt.nmag) then
            write(lun6,*)"*** Error in undumag_proc: Non existing magnet ",kmag," on undumag.kll ***"
            stop
          endif
          if (killbadmag.ne.-9999) then
            bpebc(16,kmag)=kill
            write(lun6,*)"Killing magnet ",kmag," due to flag killbadmag"
          else
            write(lun6,*)kmag
            bpebc(16,kmag)=0.0d0
          endif
        enddo
        close(lunkill)
        write(lun6,*)
      endif

      do imag=1,nmag

        mat=nint(bpebc(9,imag))

c        if (mat.lt.0) then
c          mat=nint(bcpre(2,1,-mat))
c        endif

        if (mat.eq.0) goto 9 !skip

        if (mat.gt.nmatfiles) then
          write(lun6,*)"*** Warning in undumag_proc: Material index out of range ***"
          write(lun6,*)"Skipping magnet",imag
          iwarnsum=1
          goto 9
        endif

        lmat=matmaps(2,mat)
        bn=sqrt(bpebc(4,imag)**2+bpebc(5,imag)**2+bpebc(6,imag)**2)

        if ((killbadmag.gt.0.or.killbadmag.eq.-9999).and.bpebc(16,imag).ne.0.0d0) then
          lmat=0
        endif

        if (lmat.eq.1) then
          if (bn.ne.0.0d0.and.bpebc(9,imag).ne.0.0d0) then
            if (bpebc(17,imag).ne.0.0d0.and.bpebc(17,imag).ne.-9999.0d0) cycle
            nrec=nrec+1
            bcrec(1:20,nrec)=bpebc(1:20,imag)
            bc0rec(1:3,nrec)=bpebc0(1:3,imag)
            chmagsm(1:32,nrec)=chmags(1:32,imag)
            chmothsm(1:32,nrec)=chmoths(1:32,imag)
            bmagrec(1:3,1:ncornmax,1:nplanmax,nrec)=
     &        bpemag(1:3,1:ncornmax,1:nplanmax,imag)
            brotrec(1:3,1:ncornmax,1:nplanmax,nrec)=
     &        bperot(1:3,1:ncornmax,1:nplanmax,imag)
            bpetmrec(1:3,1:8,1:nplanmax,nrec)=
     &        bpetm(1:3,1:8,1:nplanmax,imag)
            ibpeplanrec(nrec)=ibpeplan(imag)
            ibpecolrec(nrec)=ibpecol(imag)
            ibpecornrec(1:nplanmax,nrec)=ibpecorn(1:nplanmax,imag)
          endif !bn
        else if (lmat.eq.2) then
          if (bpebc(17,imag).ne.0.0d0.and.bpebc(17,imag).ne.-9999.0d0) cycle
          niron=niron+1
          bciron(1:20,niron)=bpebc(1:20,imag)
          bc0iron(1:7,niron)=bpebc0(1:7,imag)
          chmagsi(1:32,niron)=chmags(1:32,imag)
          chmothsi(1:32,niron)=chmoths(1:32,imag)
          bmagiron(1:3,1:ncornmax,1:nplanmax,niron)=
     &      bpemag(1:3,1:ncornmax,1:nplanmax,imag)
          brotiron(1:3,1:ncornmax,1:nplanmax,niron)=
     &      bperot(1:3,1:ncornmax,1:nplanmax,imag)
          bpetmiron(1:3,1:8,1:nplanmax,niron)=
     &      bpetm(1:3,1:8,1:nplanmax,imag)
          ibpeplaniron(niron)=ibpeplan(imag)
          ibpecoliron(niron)=ibpecol(imag)
          ibpecorniron(1:nplanmax,niron)=
     &      ibpecorn(1:nplanmax,imag)
        else if (lmat.ne.0) then
          write(lun6,*)
     &      "*** Error in undumag_ini_old: Unknown material index",lmat
          stop
        endif
 9    continue

      enddo !nmag

      if (nmag.gt.nspecmag) deallocate(bpemag0)
      deallocate(shuffle)

      deallocate(idamp8,bpebc,bpemag,bperot,bpetm,ibpeplan,ibpecorn,ibpecol)

      nmag=nrec+niron
      nsmag=nmag

      allocate(bpebc(20,nsmag),idamp8(nsmag))
      bpebc=0.0d0
      allocate(bpemag(3,ncornmax,nplanmax,nsmag))
      allocate(bperot(3,ncornmax,nplanmax,nsmag))
      allocate(bpetm(3,8,nplanmax,nsmag))
      allocate(ibpeplan(nsmag))
      allocate(ibpecol(nsmag))
      allocate(ibpecorn(nplanmax,nsmag))

      bpebc(1:20,1:nrec)=bcrec(1:20,1:nrec)
      bpebc0(1:3,1:nrec)=bc0rec(1:3,1:nrec)
      chmags(1:32,1:nrec)=chmagsm(1:32,1:nrec)
      chmoths(1:32,1:nrec)=chmothsm(1:32,1:nrec)
      bpemag(1:3,1:ncornmax,1:nplanmax,1:nrec)=
     &  bmagrec(1:3,1:ncornmax,1:nplanmax,1:nrec)
      bperot(1:3,1:ncornmax,1:nplanmax,1:nrec)=
     &  brotrec(1:3,1:ncornmax,1:nplanmax,1:nrec)
      bpetm(1:3,1:8,1:nplanmax,1:nrec)=
     &  bpetmrec(1:3,1:8,1:nplanmax,1:nrec)
      ibpeplan(1:nrec)=ibpeplanrec(1:nrec)
      ibpecol(1:nrec)=ibpecolrec(1:nrec)
      ibpecorn(1:nplanmax,1:nrec)=ibpecornrec(1:nplanmax,1:nrec)

      if (niron.gt.0) then

        iron1=nrec+1
        iron2=nrec+niron

        bpebc(1:20,iron1:iron2)=bciron(1:20,1:niron)

        bpebc0(1:3,iron1:iron2)=bc0iron(1:3,1:niron)
        chmags(1:32,iron1:iron2)=chmagsi(1:32,1:niron)
        chmoths(1:32,iron1:iron2)=chmothsi(1:32,1:niron)
        bpemag(1:3,1:ncornmax,1:nplanmax,iron1:iron2)=
     &    bmagiron(1:3,1:ncornmax,1:nplanmax,1:niron)
        bperot(1:3,1:ncornmax,1:nplanmax,iron1:iron2)=
     &    brotiron(1:3,1:ncornmax,1:nplanmax,1:niron)
        bpetm(1:3,1:8,1:nplanmax,iron1:iron2)=
     &    bpetmiron(1:3,1:8,1:nplanmax,1:niron)
        ibpeplan(iron1:iron2)=ibpeplaniron(1:niron)
        ibpecorn(1:nplanmax,iron1:iron2)=ibpecorniron(1:nplanmax,1:niron)

        bpebc(1:10,iron2+1:nmag)=0.0d0
        bpemag(1:3,1:ncornmax,1:nplanmax,iron2+1:nmag)=0.0d0
        bperot(1:3,1:ncornmax,1:nplanmax,iron2+1:nmag)=0.0d0
        bpetm(1:3,1:8,1:nplanmax,iron2+1:nmag)=0.0d0
        ibpeplan(iron2+1:nmag)=0
        ibpecorn(1:nplanmax,iron2+1:nmag)=0
        ibpecol(iron1:iron2)=ibpecoliron(1:niron)
        ibpecol(iron2+1:nmag)=0

      endif !iron

      kmag=0
      npol=0
      do imoth=1,nmoth
        if (matmoth(imoth).eq.1) then
          kmag=kmag+1
          xmothm(1:maxpoints,kmag)=xmoth(1:maxpoints,imoth)
          ymothm(1:maxpoints,kmag)=ymoth(1:maxpoints,imoth)
          zmothm(1:maxpoints,kmag)=zmoth(1:maxpoints,imoth)
          npmothm(kmag)=npmoth(imoth)
          matmothm(kmag)=matmoth(imoth)
          ncolmothm(kmag)=ncolmoth(imoth)
        else if (matmoth(imoth).eq.2) then
          npol=npol+1
          xmothi(1:maxpoints,npol)=xmoth(1:maxpoints,imoth)
          ymothi(1:maxpoints,npol)=ymoth(1:maxpoints,imoth)
          zmothi(1:maxpoints,npol)=zmoth(1:maxpoints,imoth)
          npmothi(npol)=npmoth(imoth)
          matmothi(npol)=matmoth(imoth)
          ncolmothi(npol)=ncolmoth(imoth)
        endif
      enddo

      xmoth(1:maxpoints,1:kmag)=xmothm(1:maxpoints,1:kmag)
      ymoth(1:maxpoints,1:kmag)=ymothm(1:maxpoints,1:kmag)
      zmoth(1:maxpoints,1:kmag)=zmothm(1:maxpoints,1:kmag)
      npmoth(1:kmag)=npmothm(1:kmag)
      matmoth(1:kmag)=matmothm(1:kmag)
      ncolmoth(1:kmag)=ncolmothm(1:kmag)

      xmoth(1:maxpoints,kmag+1:kmag+npol)=xmothi(1:maxpoints,1:npol)
      ymoth(1:maxpoints,kmag+1:kmag+npol)=ymothi(1:maxpoints,1:npol)
      zmoth(1:maxpoints,kmag+1:kmag+npol)=zmothi(1:maxpoints,1:npol)
      npmoth(kmag+1:kmag+npol)=npmothi(1:npol)
      matmoth(kmag+1:kmag+npol)=matmothi(1:npol)
      ncolmoth(kmag+1:kmag+npol)=ncolmothi(1:npol)

      dx0=dx

      xmaxinf = xmax

      xmin=1.0d30
      xmax=-1.0d30
      do imag=1,nmag
        if (bpebc(9,imag).ne.0) then
          do iplan=1,ibpeplan(imag)
            do icorn=1,ibpecorn(iplan,imag)
              vcorn(1)=bpemag(1,icorn,iplan,imag)
              if (vcorn(1).lt.xmin) xmin=vcorn(1)
              if (vcorn(1).gt.xmax) xmax=vcorn(1)
            enddo !icorn
          enddo !iplan
        endif

        if (kpreset.eq.0) then
          bpebc(11:14,imag)=bpebc(4:7,imag)
          bpebc(11:13,imag)=bpebc(11:13,imag)/bpebc(14,imag)
        endif

      enddo !imag

      xmin = min(xmin,xcwmin)
      xmax = max(xmax,xcwmax)

      if (kxcenter.ne.0) then

        if (ixsym.eq.0) then
          dx=xcenter-(xmax+xmin)/2.0d0
        else
          dx=xcenter-xsymmm
        endif

        xmin=xmin+dx
        xmax=xmax+dx

        dxfb=dx
        if (iforce.ne.9999) then
          ubfcenx=ubfcenx+dx
          bfcenxmm=ubfcenx
          utorqcenx=utorqcenx+dx
          if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
          bfcenx=ubfcenx/1000.0d0
          torqcenxmm=utorqcenx
          torqcenx=utorqcenx/1000.0d0
        endif

        forxpl=forxpl+dx

        xcentershift=dx

        write(lun6,*)
        write(lun6,*) "xcenter, shift:",xcenter,dx
        write(lun6,*)

        do moth=1,nmoth
          xmoth(1:npmoth(moth),moth)=xmoth(1:npmoth(moth),moth)+dx
        enddo

        do imag=1,nmag
          bpebc(1,imag)=bpebc(1,imag)+dx
          do iplan=1,ibpeplan(imag)

            do i=1,3
              do j=1,3
                ts(i,j)=bpetm(i,j,iplan,imag)
              enddo
            enddo

            do icorn=1,ibpecorn(iplan,imag)

              bpemag(1,icorn,iplan,imag)=bpemag(1,icorn,iplan,imag)+dx

              r1lab(1)=bpemag(1,icorn,iplan,imag)
              r1lab(2)=bpemag(2,icorn,iplan,imag)
              r1lab(3)=bpemag(3,icorn,iplan,imag)

              r1(1)=ts(1,1)*r1lab(1)+ts(1,2)*r1lab(2)+ts(1,3)*r1lab(3)
              r1(2)=ts(2,1)*r1lab(1)+ts(2,2)*r1lab(2)+ts(2,3)*r1lab(3)
              r1(3)=ts(3,1)*r1lab(1)+ts(3,2)*r1lab(2)+ts(3,3)*r1lab(3)

              bperot(1,icorn,iplan,imag)=r1(1)
              bperot(2,icorn,iplan,imag)=r1(2)
              bperot(3,icorn,iplan,imag)=r1(3)

            enddo !icorn
          enddo !iplan
        enddo !imag

      endif !kxcenter.ne.0

      g=0.0

      if (nmag.eq.0.or.(nxconv.eq.0.and.dxconv.eq.0.0d0)) then
        nxconv=1
        xconv(1)=0.0d0
        goto 1234
      endif

      nxconv=abs(nxconv)

      if (xconvmin.eq.9999.0d0) then
        xconvmin=xmin+mod(xmin,perlen)-1.0d0*perlen
        if (xconvmin.gt.xcwmin) xconvmin=xcwmin
      endif !(xconvmin.eq.9999.0d0) then

      if (xconvmax.eq.9999.0d0) then
        if (kxcenter.ne.0) then
          xconvmax=xcenter
        else
          xconvmax=xmax-mod(xmax,perlen)+2.0d0*perlen
        endif
        if (xconvmax.lt.xcwmax) xconvmax=xcwmax
      endif !(xconvmax.eq.9999.0d0) then

      if (xconvmax.le.xconvmin) xconvmin=xconvmax-perlen/2.0d0

      if (nxconv.eq.9999) then
        nxconv=(xconvmax-xconvmin)/perlen*2+1
      endif

      if (dxconv.eq.9999.0d0) dxconv=perlen/2.0d0

      if (abs(dxconv).gt.0.0d0) then
        nxconv=(xconvmax-xconvmin)/dxconv+1
        if (nxconv.gt.100) then
          write(lun6,*)"*** Warning in undmag_ini: dxconv changed to limit nxconv to 100 ***"
          nxconv=100
        endif
        dxconv=(xconvmax-xconvmin)/max(1,nxconv-1)
      else
        if (nxconv.gt.100) then
          write(lun6,*)"*** Warning in undmag_ini: nxconv limited to 100 ***"
          nxconv=100
        endif
        dxconv=(xconvmax-xconvmin)/max(1,nxconv-1)
      endif

      if (dxconv.lt.0.0d0) then
        dxcon(1)=0.0d0
        dx=1.0d0
        do i=2,nxconv
          dxcon(i)=dxcon(i-1) + dx
          dx=dx*abs(dxconv)
        enddo
        xlen=dxcon(nxconv)
        do i=2,nxconv
          xconv(i)=xconv(i-1) + (dxcon(i)-dxcon(i-1))*(xconvmax-xconvmin)/xlen
        enddo
      else
        do i=1,nxconv
          xconv(i)=xconvmin+dxconv*(i-1)
        enddo
      endif !(dxconv.lt.0.0d0) then

      do i=1,nxconv
        ! to avoid boundary effects:
        call util_random(2,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        xconv(i)=(xconv(i)+g(1)*randoxa)/1000.0d0
      enddo

      yconv=yconv/1000.0d0

      if (abs(g(2)).lt.randoz10) then
        if (g(2).gt.0.0d0) then
          g(2)=g(2)+randoz10
        else
          g(2)=g(2)-randoz10
        endif
      endif

      if (zconv.eq.0.0d0) then
        if (randoza.gt.0.0d0) then
          zconv=(zconv+g(2)*randoza)/1000.0d0
        else
          zconv=(zconv+randoza)/1000.0d0
        endif
      else
        zconv=zconv/1000.0d0
      endif

1234  continue

      nspecmag=0
      do imag=1,nmag
        if (bpebc(10,imag).ne.0) then
          nspecmag=nspecmag+1
        endif
      enddo

      if (nspecmag.gt.0) then
        allocate(kspecmag(nspecmag))
        nspecmag=0
        do imag=1,nmag
          if (bpebc(10,imag).ne.0) then
            nspecmag=nspecmag+1
            kspecmag(nspecmag)=imag
          endif
        enddo
      endif

c      xmin=xmin-dx0
c      xmax=xmax+dx0

      deallocate(ibpecornrec)
      deallocate(ibpeplanrec)
      deallocate(bpetmrec)
      deallocate(brotrec)
      deallocate(bmagrec)
      deallocate(bcrec)
      deallocate(ibpecolrec)

      deallocate(ibpecorniron)
      deallocate(ibpeplaniron)
      deallocate(bpetmiron)
      deallocate(brotiron)
      deallocate(bmagiron)
      deallocate(bciron,bc0rec,bc0iron)
      deallocate(ibpecoliron)

      if (ixsym.gt.0) then
        if (xmin.lt.xsymmm-tiny2.and.xmax.gt.xsymmm+tiny2) then
          write(lun6,*)"*** Error in input: Option ixsym is set, but not all x-values are on the same side of xsymm!"
          write(lun6,*)"*** Program undumag aborted ***"
          stop
        endif
        dx=xsymmm-xmin
        xmax=xsymmm+dx
        xsym=xsymmm/1000.0d0
      endif

      if (iysym.gt.0) then
        if (ymin.lt.-tiny2.and.ymax.gt.tiny2) then
          write(lun6,*)"*** Error in input: Option iysym is set, but not all y-values have the same sign!"
          if (iysymo.gt.0) then
            write(lun6,*)"*** Program undumag aborted ***"
            stop
          endif
        endif
        ymax=max(abs(ymax),abs(ymin))
        ymin=-ymax
      endif

      if (izsym.ne.0) then
        if (zmin.lt.-tiny2.and.zmax.gt.tiny2) then
          if (izsymo.gt.0) then
            write(lun6,*)"*** Error in input: Option izsym is set, but not all z-values have the same sign!"
            write(lun6,*)"*** Program undumag aborted ***"
            stop
          else if (izsymo.lt.0) then
            write(lun6,*)"*** Warning in input: Option izsym is set, but not all z-values have the same sign!"
          endif
        endif
        zmax=max(abs(zmax),abs(zmin))
        zmin=-zmax
      endif

      do imag=1,nmag

c        write(lun6,*)"1 Info:",imag,bpebc(15,imag),chmags(1:32,imag),chmoths(1:32,imag)
        write(chmoth,'(32a)')chmoths(1:32,imag)

        if (kdisplace.ne.0) then
          do idisp=1,ndisp
            if (chmoth.eq.chdisp(idisp)) then

              cosphi=cos(displace(6,idisp))
              sinphi=sin(displace(6,idisp))

              bpebc(1:3,imag)=bpebc(1:3,imag)+displace(1:3,idisp)

              y00=bpebc(2,imag)-displace(4,idisp)
              z00=bpebc(3,imag)-displace(5,idisp)
              bpebc(2,imag)= -sinphi*z00 + cosphi*y00
     &              +displace(4,idisp)
              bpebc(3,imag)=  cosphi*z00 + sinphi*y00
     &          +displace(5,idisp)

              bpebc(4:6,imag)=bpebc(4:6,imag)+displace(7:9,idisp)

              bcy=bpebc(5,imag)
              bcz=bpebc(6,imag)
              bpebc(5,imag)= -sinphi*bcz + cosphi*bcy
              bpebc(6,imag)=  cosphi*bcz + sinphi*bcy

              nplan=ibpeplan(imag)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,imag)
                do icorn=1,ncorn

                  x00=bpemag(1,icorn,iplan,imag)+displace(1,idisp)
                  bpemag(1,icorn,iplan,imag)= x00

                  y00=bpemag(2,icorn,iplan,imag)+displace(2,idisp)
     &              -displace(4,idisp)
                  z00=bpemag(3,icorn,iplan,imag)+displace(3,idisp)
     &              -displace(5,idisp)
                  bpemag(2,icorn,iplan,imag)= -sinphi*z00 + cosphi*y00
     &              +displace(4,idisp)
                  bpemag(3,icorn,iplan,imag)=  cosphi*z00 + sinphi*y00
     &              +displace(5,idisp)
                enddo
              enddo
            endif
          enddo
        endif

c        write(lun6,*)imag,moth,chmoth,chmoths(1:32,imag)
      enddo

      if (kdisplace.ne.0) then
        write(lun6,*)
        write(lun6,*)
        write(lun6,*)"Displacement and change of magnetization activated:"
        write(lun6,*)
        do idisp=1,ndisp
          write(lun6,*)idisp,trim(chdisp(idisp)),sngl(displace(1:9,idisp))
        enddo
        write(lun6,*)
        write(lun6,*)
        write(lun6,*)
      endif

      open(newunit=lunmag,file='undumag.mag',form='formatted',status='unknown')

      write(lunmag,'(a)')trim(cundutit)

      do imag=1,nmag

        do iplan=1,ibpeplan(imag)
          do icorn=1,ibpecorn(iplan,imag)

            htup(1)=bpebc(15,imag)
            htup(2)=imag
            htup(3)=ibpecol(imag)
            htup(4)=iplan
            htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
            htup(6)=bpemag(1,icorn,iplan,imag)
            htup(7)=bpemag(2,icorn,iplan,imag)
            htup(8)=bpemag(3,icorn,iplan,imag)
            htup(9)=bpebc(4,imag)
            htup(10)=bpebc(5,imag)
            htup(11)=bpebc(6,imag)
            htup(12)=bpebc(9,imag)

            vmaglab(1)=bpebc(4,imag)
            vmaglab(2)=bpebc(5,imag)
            vmaglab(3)=bpebc(6,imag)

            bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
            bpebc(7,imag)=bc

            if (bc.ne.0.0d0) then
              do i=5,10
                if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
              enddo
              write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
              chmoth1a=chmoths(1:32,imag)
              c32a=chmags(1:32,imag)
              cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
              write(lunmag,'(a)') trim(cline)
            endif !BC

          enddo !ncorn
        enddo !nplan
      enddo !nmag

      if (kplsym.eq.0) then
        if (ixsymo.ne.0) then
          dx=xmax-xmin
          xmax=xmax-dx/2.
        endif
        if (iysymo.ne.0) then
          dy=ymax-ymin
          ymax=ymax-dy/2.
        endif
        if (izsymo.ne.0) then
          dz=zmax-zmin
          zmax=zmax-dz/2.
        endif
        goto 19
      endif

      if (ixsym.eq.0) then
        if (iysym.ne.0.and.izsym.eq.0) then
          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (izsym.ne.0.and.iysym.eq.0) then

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (izsym.ne.0.and.iysym.ne.0) then

          do imag=1,nmag !izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+2*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym and izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+3*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        endif !(izsym.ne.) then

      else !:ixsym.eq.0

        if (iysym.eq.0.and.izsym.eq.0) then

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=xsymmm+(xsymmm-bpemag(1,icorn,iplan,imag))
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (iysym.ne.0.and.izsym.eq.0) then

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+2*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+3*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (izsym.ne.0.and.iysym.eq.0) then

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x1y1z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x2y1z1
                htup(1)=bpebc(15,imag)
                htup(2)=imag+2*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=xsymmm+(xsymmm-bpemag(1,icorn,iplan,imag))
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x2y1z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+3*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=xsymmm+(xsymmm-bpemag(1,icorn,iplan,imag))
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        else if (izsym.ne.0.and.iysym.ne.0) then

          do imag=1,nmag !izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x1y1z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x1y2z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+2*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym and izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x1y2z2
                htup(1)=bpebc(15,imag)
                htup(2)=imag+3*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                !x2y1z1
                htup(1)=bpebc(15,imag)
                htup(2)=imag+4*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+5*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !iysym and izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+6*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=-bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

          do imag=1,nmag !izsym
            do iplan=1,ibpeplan(imag)
              do icorn=1,ibpecorn(iplan,imag)

                htup(1)=bpebc(15,imag)
                htup(2)=imag+7*nmag
                htup(3)=ibpecol(imag)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,imag))
                htup(6)=2.0d0*xsymmm-bpemag(1,icorn,iplan,imag)
                htup(7)=bpemag(2,icorn,iplan,imag)
                htup(8)=-bpemag(3,icorn,iplan,imag)
                htup(9)=-bpebc(4,imag)
                htup(10)=bpebc(5,imag)
                htup(11)=-bpebc(6,imag)
                htup(12)=bpebc(9,imag)

                vmaglab(1)=bpebc(4,imag)
                vmaglab(2)=bpebc(5,imag)
                vmaglab(3)=bpebc(6,imag)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,imag)=bc

                if (bc.ne.0.0d0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  chmoth1a=chmoths(1:32,imag)
                  c32a=chmags(1:32,imag)
                  cline=trim(cline) // " " // trim(c32) // " " // trim(chmoth1)
                  write(lunmag,'(a)') trim(cline)
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nmag

        endif !(izsym.ne.) then

      endif !(ixsym.eq.0) then

19    close(lunmag)
      close(lun76)

      deallocate(corn1,corn2,ncorn1,ncorn2)

+self,if=chmagpols.
      if (nmag.gt.0) then
        nmagpols=1
        chmagpols(1:32,nmagpols)=chmoths(1:32,1)
      endif

      do imag=2,nmag
        do imp=1,nmagpols
          ifound=1
          do ic=1,32
            if (chmoths(ic,imag).ne.chmagpols(ic,imp)) then
              ifound=0
              exit
            endif
          enddo
          if (ifound.eq.0) then
            nmagpols=nmagpols+1
            chmagpols(1:32,nmagpols)=chmoths(1:32,imag)
            exit
          endif
        enddo
      enddo

      do imag=1,nmag
        do imp=1,nmagpols
          ifound=1
          do ic=1,32
            if (chmoths(ic,imag).ne.chmagpols(ic,imp)) then
              ifound=0
              exit
            endif
          enddo
          if (ifound.eq.1) then
            bpebc(15,imag)=imp
            exit
          endif
        enddo
      enddo
+self.,if=chmagpols.

      kforcemag=0

      if (iforce.eq.9999.or.iforcedip.ne.0) then

        if (chforcemag.eq.'') then
          write(lun6,*)"*** iforce=9999, but chforcemag is an empty string ***"
          write(lun6,*)
          stop
        endif

        write(lun6,*)""
        write(lun6,*)"      chforcemag: ",trim(chforcemag)
        do imag=1,nmag
          do ic=1,32
            chmoth(ic:ic)=chmoths(ic,imag)
          enddo
          if (chmoth.eq.chforcemag) then
            kforcemag=imag
            exit
          endif
        enddo

c        call undumag_magpol_index(chforcemag,kforcemag)
        if (kforcemag.eq.0) then
          write(lun6,*)"*** Magnet ",trim(chforcemag),"  for force calculations not found ***"
          write(lun6,*)"*** Check undumag_magnets.lis ***"
          stop
        endif

        if (chforcemag.eq.'') then
          chforcemag='None'
        endif

      endif !iforce, iforcedip

      if (iforce.eq.9999) then

        moth=nint(bpebc(15,kforcemag))

        xminfb=1.0d30
        xmaxfb=-1.0d30
        yminfb=1.0d30
        ymaxfb=-1.0d30
        zminfb=1.0d30
        zmaxfb=-1.0d30

        do imag=1,nmag
          gcen=bpebc(1:3,imag)
          bpebc15=bpebc(15,imag)
          if (nint(bpebc15).ne.moth) cycle
          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              x=bpemag(1,icorn,iplan,imag)
              y=bpemag(2,icorn,iplan,imag)
              z=bpemag(3,icorn,iplan,imag)
              if (x.lt.xminfb) xminfb=x
              if (x.gt.xmaxfb) xmaxfb=x
              if (y.lt.yminfb) yminfb=y
              if (y.gt.ymaxfb) ymaxfb=y
              if (z.lt.zminfb) zminfb=z
              if (z.gt.zmaxfb) zmaxfb=z
            enddo !icorn
          enddo !iplan
        enddo

        ubfcenx=(xmaxfb+xminfb)/2.0d0
        ubflenx=(xmaxfb-xminfb)
        if (ixsym.ne.0.and.(xmin.le.xsym.or.xmax.ge.xsym)) then
          ubfcenz=xsym
          ubflenz=2.0d0*ubflenz
        endif

        ubfceny=(ymaxfb+yminfb)/2.0d0
        ubfleny=(ymaxfb-yminfb)

        ubfcenz=(zmaxfb+zminfb)/2.0d0
        ubflenz=(zmaxfb-zminfb)
        if (izsym.ne.0) then
          ubfcenz=0.0d0
          ubflenz=2.0d0*ubflenz
        endif

        ubflenx=ubflenx+dedgefb
        ubfleny=ubfleny+dedgefb
        ubflenz=ubflenz+dedgefb

        if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
        if (utorqceny.eq.9999.0d0) utorqceny=ubfceny
        if (utorqcenz.eq.9999.0d0) utorqcenz=ubfcenz

        bfcenxmm=ubfcenx
        bfcenymm=ubfceny
        bfcenzmm=ubfcenz
        bflenxmm=ubflenx
        bflenymm=ubfleny
        bflenzmm=ubflenz
        torqcenxmm=utorqcenx
        torqcenymm=utorqceny
        torqcenzmm=utorqcenz
        bfcenx=ubfcenx/1000.0d0
        bfceny=ubfceny/1000.0d0
        bfcenz=ubfcenz/1000.0d0
        bflenx=ubflenx/1000.0d0
        bfleny=ubfleny/1000.0d0
        bflenz=ubflenz/1000.0d0
        torqcenx=utorqcenx/1000.0d0
        torqceny=utorqceny/1000.0d0
        torqcenz=utorqcenz/1000.0d0
        jplforce=iplforce
        if (iforce.eq.0) then
          mbforcex=0
          mbforcey=0
          mbforcez=0
        endif
        nbforcx=mbforcex
        nbforcy=mbforcey
        nbforcz=mbforcez
        iforcol=mfcolor
        forcol=iforcol
        forxpl(1)=bfcenxmm-bflenxmm/2.
        forxpl(2)=bfcenxmm+bflenxmm/2.
        forypl(1)=bfcenymm-bflenymm/2.
        forypl(2)=bfcenymm+bflenymm/2.
        forzpl(1)=bfcenzmm-bflenzmm/2.
        forzpl(2)=bfcenzmm+bflenzmm/2.

      endif !(iforce.eq.9999) then

      if (mbforcex*mbforcey*mbforcez.gt.0) then
        outbox(1,1)=ubfcenx-ubflenx/2.
        outbox(2,1)=ubfcenx+ubflenx/2.
        outbox(1,2)=ubfceny-ubfleny/2.
        outbox(2,2)=ubfceny+ubfleny/2.
        outbox(1,3)=ubfcenz-ubflenz/2.
        outbox(2,3)=ubfcenz+ubflenz/2.
      else
        outbox(1,1)=+1.0d30
        outbox(2,1)=-1.0d30
        outbox(1,2)=+1.0d30
        outbox(2,2)=-1.0d30
        outbox(1,3)=+1.0d30
        outbox(2,3)=-1.0d30
      endif

      do i=1,ncwires
        wire(3,i)=wire(3,i)+xcentershift
        wire(6,i)=wire(6,i)+xcentershift
      enddo

      if (nmag.eq.0) then
        xmin=1.0d30
        xmax=-1.0d30
        ymin=1.0d30
        ymax=-1.0d30
        zmin=1.0d30
        zmax=-1.0d30
      endif

      do i=1,ncwires
        if (wire(3,i).lt.xmin) xmin=wire(3,i)
        if (wire(3,i).gt.xmax) xmax=wire(3,i)
        if (wire(6,i).lt.xmin) xmin=wire(6,i)
        if (wire(6,i).gt.xmax) xmax=wire(6,i)
        if (wire(4,i).lt.ymin) ymin=wire(4,i)
        if (wire(4,i).gt.ymax) ymax=wire(4,i)
        if (wire(7,i).lt.ymin) ymin=wire(7,i)
        if (wire(7,i).gt.ymax) ymax=wire(7,i)
        if (wire(5,i).lt.zmin) zmin=wire(5,i)
        if (wire(5,i).gt.zmax) zmax=wire(5,i)
        if (wire(8,i).lt.zmin) zmin=wire(8,i)
        if (wire(8,i).gt.zmax) zmax=wire(8,i)
      enddo

      if (xmapmin.eq.9999.0d0) then
        xmapmin=xmin+mod(xmin,perlen)-9.0d0*perlen
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      else if (xmapmin.eq.9000.0d0) then
        xmapmin=xcenter-perlen/2.0d0
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      else if (xmapmin.eq.-9000.0d0) then
        xmapmin=xcenter-perlen/4.0d0
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      endif

      if (xmapmax.eq.9999.0d0) then
        xmapmax=xmax-mod(xmax,perlen)+10.0d0*perlen
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      else if (xmapmax.eq.9000.0d0) then
        xmapmax=xcenter+perlen/2.0d0
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      else if (xmapmax.eq.-9000.0d0) then
        xmapmax=xcenter+perlen/4.0d0
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      endif

      if (iplot.ne.0.and.nmag+ncwires.ne.0) then
        xplmin=xminpl
        xplmax=xmaxpl
        yplmin=yminpl
        yplmax=ymaxpl
        zplmin=zminpl
        zplmax=zmaxpl
        if (xminpl.eq.9999.0d0) xplmin=xmin-(xmax-xmin)*0.1
        if (xmaxpl.eq.9999.0d0) xplmax=xmax+(xmax-xmin)*0.1
        if (yminpl.eq.9999.0d0) yplmin=ymin-(ymax-ymin)*0.1
        if (ymaxpl.eq.9999.0d0) yplmax=ymax+(ymax-ymin)*0.1
        if (zminpl.eq.9999.0d0) zplmin=zmin-(zmax-zmin)*0.1
        if (zmaxpl.eq.9999.0d0) zplmax=zmax+(zmax-zmin)*0.1
        call undumag_bpolyplot_old(iplot,xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &    theta,pphi,nwitems,ncwires,wire)
      endif !iplot

      if (dxmap.eq.0.0d0.and.nxmap.eq.0.0d0) then
        nxmap=1
      endif

      if (dxmap.eq.9999.0d0) then
        if (nxbeff.gt.1) then
          dxmap=perlen/(nxbeff-1)
        else
          dxmap=perlen
        endif
      endif
      if (dxmap.ne.0.0d0) nxmap=nint((xmapmax-xmapmin)/dxmap)+1
      if (nxmap.le.0) then
        write(lun6,*)"*** Warning in undumag_ini_old: nxmap.le.0 ***"
      endif

      if (nymap.le.0) nymap=1
      if (nzmap.le.0) nzmap=1

cdebug
      if (nmag.le.0.and.ncwires.eq.0) goto 9999

      if (kpreset.ne.0) then

        maxplan=0

        open(newunit=lunpre,file='undumag.pre',status='old')
        npre=0
12      continue
        read(lunpre,*,end=92)nplan
        if (nplan.gt.maxplan) maxplan=nplan
        do iplan=1,nplan
          read(lunpre,*,end=92)xx
        enddo
        npre=npre+1
        goto 12
92      rewind(lunpre)

        allocate(bcpre(6,maxplan,npre),bpre16(16,npre))

        do ipre=1,npre
          read(lunpre,*)nplan,bpre16(1:15,ipre)
          bpre16(16,ipre)=nplan
          do iplan=1,nplan
            read(lunpre,*)bcpre(1:6,iplan,ipre)
c            write(33,*),ipre,iplan,bcpre(1:6,iplan,ipre)
          enddo
        enddo

        close(lunpre)

        do imag=1,nmag

          xx=bpebc(1,imag)
          yy=bpebc(2,imag)
          zz=bpebc(3,imag)

          ifound=0

          do ipre=1,npre

            nplan=nint(bpre16(16,ipre))

            do iplan=1,nplan

              dlab(1)=xx-bcpre(1,iplan,ipre)
              dlab(2)=yy-bcpre(2,iplan,ipre)
              dlab(3)=zz-bcpre(3,iplan,ipre)

              vnormlab(1)=bcpre(4,iplan,ipre)
              vnormlab(2)=bcpre(5,iplan,ipre)
              vnormlab(3)=bcpre(6,iplan,ipre)

              if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &            dlab(3)*vnormlab(3).gt.0.0d0) then
                goto 99
              endif

            enddo !iplan

            ifound=ipre

            lmat=matmaps(2,nint(bpebc(9,imag)))

            bpebc(1:15,imag)=bpre16(1:15,ipre)
            bpebc(16,imag)=0.0d0

            if (lmat.eq.2) then
              bpebc(14,imag)=bpre16(7,ipre)
              bpebc(11:13,imag)=bpre16(4:6,ipre)/bpre16(7,ipre)
            else if (lmat.eq.1.and.maxiterrec.gt.0) then
              bn=bpre16(14,ipre)
              bpebc(4:6,imag)=bpre16(11:13,ipre)*bn
              bpebc(7,imag)=bn
            endif

            goto 999
99          continue

          enddo !npre
999       continue

          if (ifound.eq.0) then
            write(lun6,*)"*** Warning in undumag_ini_old: No preset values found for magnet:",imag,xx,yy,zz
            bpebc(4:7,imag)=0.0d0
          endif

        enddo !imag

        deallocate(bcpre,bpre16)

      endif !kpreset

      if (iundugeo.ne.0) then

        write(lun6,*)
        write(lun6,*)'Writing geometry to undumag.geo'
        write(lun6,*)

        open(newunit=lunvox,file="undumag.geo")

        write(lunvox,'(a)')
     &    "* mag type xcen ycen zcen mother ixdiv iydiv izdiv mate color bcx bcy bcz bc plane corn x y z"

        if (nmag.gt.0) then
          moth=1
          do ic=1,32
            chmag(ic:ic)=chmags(ic,moth)
          enddo
        endif

        do imag=1,nmag

          gcen=bpebc(1:3,imag)
          nplan=ibpeplan(imag)
          moth=bpebc(15,imag)

          if(moth.ne.motho) then

            do ic=1,32
              chmag(ic:ic)=chmags(ic,imag)
            enddo

            write(cline,*)"* ",trim(chmag),moth
            write(lunvox,'(a)')cline(2:len_trim(cline))

            motho=moth

          endif

          imat=bpebc(9,imag)
          ispec=bpebc(10,imag)
          bx=bpebc(11,imag)
          by=bpebc(12,imag)
          bz=bpebc(13,imag)
          bc=bpebc(14,imag)
          ncol=ibpecol(imag)
          itype=bpebc(8,imag)
          mothdiv(1,imag)=moth
          motho=0

          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              x=bpemag(1,icorn,iplan,imag)
              y=bpemag(2,icorn,iplan,imag)
              z=bpemag(3,icorn,iplan,imag)
              write(lunvox,*)imag,itype,
     &          sngl(gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &          ,mothdiv(1:4,imag),imat,ncol
     &          ,sngl(bx),sngl(by),sngl(bz),sngl(bc)
     &          ,iplan,icorn
     &          ,sngl(x),sngl(y),sngl(z)
     &          ,chmags(:,imag),chmoths(:,imag)
              if (kplsym.ne.0) then
                if (ixsym.ne.0.and.iysym.ne.0.and.izsym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)2*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)3*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)4*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)5*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)6*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)7*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(-gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(-y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (ixsym.ne.0.and.iysym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)2*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)3*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (ixsym.ne.0.and.izsym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)2*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(bz),sngl(-bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)3*nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (iysym.ne.0.and.izsym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)2*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(bz),sngl(-bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                  write(lunvox,*)3*nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (ixsym.ne.0) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(-x),sngl(y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (iysym.ne.0.) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(-y),sngl(z)
     &              ,chmags(:,imag),chmoths(:,imag)
                else if (izsym.ne.0.) then
                  write(lunvox,*)nmag+imag,itype,
     &              sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &              ,mothdiv(1:4,imag),imat,ncol
     &              ,sngl(bx),sngl(by),sngl(-bz),sngl(bc)
     &              ,iplan,icorn
     &              ,sngl(x),sngl(y),sngl(-z)
     &              ,chmags(:,imag),chmoths(:,imag)
                endif !syms
              endif !(kplsym.ne.0) then
            enddo
          enddo
        enddo !nmag

        do i=1,ncwires
          mag=i
          itype=wire(1,i)
          moth=wire(10,i)
          icol=wire(9,i)
          x1=wire(3,i)
          y1=wire(4,i)
          z1=wire(5,i)
          ix=1
          iy=1
          iz=1
          mat=-1
          icol=wire(9,i)
          x2=wire(6,i)
          y2=wire(7,i)
          z2=wire(8,i)
          xc=(x2+x1)/2.0
          yc=(y2+y1)/2.0
          zc=(z2+z1)/2.0
          x21=(x2-x1)
          y21=(y2-y1)
          z21=(z2-z1)
          cw=wire(2,i)
          iplan=0
          icorn=0
          write(lunvox,*)mag,itype,xc,yc,zc,moth,ix,iy,iz,mat,icol,dx,dy,dz,cw,
     &      iplan,icorn,x1,y1,z1," wire", " wire"
        enddo !ncwires

        write(lun6,*)
        write(lun6,*)'Done'
        write(lun6,*)

        close(lunvox)

        if (iundugeo.lt.0) then
          open(newunit=lun,file="undumag.stat")
          write(lun,*)"0"
          flush(lun)
          close(lun)
          open(newunit=lun,file="undumag.sta")
          write(lun,*)'UNDUMAG finished due to iundugeo<0'
          flush(lun)
          close(lun)
          stop
        endif

      endif !(iundugeo.ne.0) then

      if (kseg.eq.1) then
+self,if=trace.
      print*,"-trace-: Leaving undumag_ini_old "
+self.
        return
      endif

      maxpoints=ncornmax*nplanmax

      if (ihullallo.ne.0) then
        deallocate(hull,khull,kface,kedge,xhull,yhull,zhull)
      endif

      allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints))
      allocate(khull(maxpoints))
      allocate(kedge(4,2*maxpoints-2),kface((maxpoints+1)*maxpoints))

cdebug
      if (ivrml.ne.0) then

        write(lun6,*)
        write(lun6,*)'Writing geometry to CAD file undumag.wrl'
        write(lun6,*)

        allocate(khullmoth(maxpoints,nmoth),
     &    kfacemoth(maxpoints,nmoth),nplanmoth(nmoth))

        open(newunit=lunvrml,file="undumag.wrl")

        write(lunvrml,'(a)')"#VRML V2.0 utf8"
        write(lunvrml,*)
        write(cline,*)"# UNDUMAG: ",kundurun,trim(usercom),' ',
     &    dttime(1:2),':',dttime(3:4),':',dttime(5:6),' '
     &    ,dtday(7:8),'.',dtday(5:6),'.',dtday(3:4)
        write(lunvrml,*)cline(2:len_trim(cline))
        write(lunvrml,*)" "

        if (ivrml.eq.1.or.ivrml.eq.2) then

          do moth=1,nmoth

            do ic=1,32
              chmag(ic:ic)=chmags(ic,moth)
            enddo

            write(lunvrml,*)" "
            write(lunvrml,*)"# --- ",chmag
            write(lunvrml,*)" "

            korn=npmoth(moth)
            xhull(1:korn)=xmoth(1:korn,moth)
            yhull(1:korn)=ymoth(1:korn,moth)
            zhull(1:korn)=zmoth(1:korn,moth)

            call util_weed_points(korn,xhull,yhull,zhull,tiny)

            call util_convex_hull_3d(korn,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for "
              write(lun6,*)"*** writing of VRML-File"
              stop
            endif

            khullmoth(1:nhull,moth)=khull(1:nhull)
            kfacemoth(1:kfacelast,moth)=kface(1:kfacelast)
            nplanmoth(moth)=nface

! Magnet is represented by faces

            write(lunvrml,*)"Shape{"
            write(lunvrml,*)" "
            write(lunvrml,*)"  appearance Appearance{"
            write(lunvrml,*)"    material Material{"
            color(1)=1
            color(2)=1
            color(3)=1
            if (ncolmoth(moth).eq.1) then !black
              color(1)=0
              color(2)=0
              color(3)=0
            else if (ncolmoth(moth).eq.2) then !red
              color(1)=1
              color(2)=0
              color(3)=0
            else if (ncolmoth(moth).eq.3) then !bright green
              color(1)=0
              color(2)=1
              color(3)=0
            else if (matmoth(moth).eq.4) then !blue
              color(1)=0
              color(2)=0
              color(3)=1
            else if (ncolmoth(moth).eq.5) then !gelb
              color(1)=1.
              color(2)=1.
              color(3)=0
            else if (ncolmoth(moth).eq.6) then !magenta
              color(1)=1
              color(2)=0
              color(3)=1
            else if (ncolmoth(moth).eq.7) then !light blau
              color(1)=0
              color(2)=1
              color(3)=1
            else if (ncolmoth(moth).eq.8) then ! green
              color(1)=0.35
              color(2)=0.83
              color(3)=0.33
            else if (ncolmoth(moth).eq.9) then !dark blue
              color(1)=0.35
              color(2)=0.33
              color(3)=0.85
            endif

            write(lunvrml,*)"      diffuseColor", color
            write(lunvrml,*)"    } # End of Material"
            write(lunvrml,*)"  } # End of Appearance"
            write(lunvrml,*)" "
            write(lunvrml,*)"  geometry IndexedFaceSet {"
            write(lunvrml,*)
            write(lunvrml,*)"      coord Coordinate{"

            write(lunvrml,*)"         point ["

            do korn=1,nhull
              x=xhull(korn)
              y=yhull(korn)
              z=zhull(korn)
              write(lunvrml,*)"          ",sngl(x),sngl(y),sngl(z),","
            enddo !nhull
            write(lunvrml,*)"         ] # End of point"

            write(lunvrml,*)"      } # End of Coordinate"
            write(lunvrml,*)
            write(lunvrml,*)"       coordIndex ["

cdebug
            korn=1
            do iplan=1,nface
              ncorn=kface(korn)
              do icorn=1,ncorn
                korn=korn+1
                ipoi=kface(korn)-1
                if (icorn.eq.1) i=ipoi
                write(lunvrml,*)"              ",ipoi,","
              enddo
              write(lunvrml,*)"                 ",i,"-1,"
              korn=korn+1
            enddo !nplan

            write(lunvrml,*)"       ] # End of coordIndex"
            write(lunvrml,*)"  } # End of Geometry"
            write(lunvrml,*)"} # End of Shape"
            write(lunvrml,*)" "

            if (kplsym.ne.0) then
              if (ixsym.ne.0.and.iysym.ne.0.and.izsym.ne.0) then
              else if (ixsym.ne.0.and.iysym.ne.0) then
              else if (ixsym.ne.0.and.izsym.ne.0) then
              else if (iysym.ne.0.and.izsym.ne.0) then
              else if (ixsym.ne.0) then
              else if (iysym.ne.0.) then
              else if (izsym.ne.0.) then
              endif !syms
            endif !(kplsym.ne.0) then

          enddo !nmoth

        endif !ivrml.eq.1

! Magnets is represented by lines to visualize the segmentation

        if (ivrml.eq.2) then

          do moth=1,nmoth

            do imag=1,nmag

              npoi=0
              nplan=ibpeplan(imag)
              do iplan=1,nplan
                ncorn=ibpecorn(iplan,imag)
                do icorn=1,ncorn
                  npoi=npoi+1
                  xhull(npoi)=bpemag(1,icorn,iplan,imag)
                  yhull(npoi)=bpemag(2,icorn,iplan,imag)
                  zhull(npoi)=bpemag(3,icorn,iplan,imag)
                enddo
              enddo

              call util_weed_points(npoi,xhull,yhull,zhull,tiny)

              call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &          nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

              if (ifailhull.ne.0.or.nhull.lt.4) then
                write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for "
                write(lun6,*)"*** writing of VRML-File"
                stop
              endif

              do ic=1,32
                chmag(ic:ic)=chmags(ic,imag)
              enddo

              write(lunvrml,*)" "
              write(lunvrml,*)"# ",chmag
              write(lunvrml,*)" "

              write(lunvrml,*)"Shape{"
              write(lunvrml,*)" "
              write(lunvrml,*)"  geometry IndexedLineSet {"
              write(lunvrml,*)
              write(lunvrml,*)"      coord Coordinate{"

              write(lunvrml,*)"         point ["

              do korn=1,npoi
                x=xhull(korn)
                y=yhull(korn)
                z=zhull(korn)
                write(lunvrml,*)"          ",sngl(x),sngl(y),sngl(z),","
              enddo !nhull

              write(lunvrml,*)"         ] # End of point"

              write(lunvrml,*)"      } # End of Coordinate"
              write(lunvrml,*)

              write(lunvrml,*)
              write(lunvrml,*)"       coordIndex ["

              korn=1
              do iplan=1,nface
                ncorn=kface(korn)
                gcen=0.0d0
                do icorn=1,ncorn
                  korn=korn+1
                  ipoi=kface(korn)
                  x=xhull(ipoi)
                  y=yhull(ipoi)
                  z=zhull(ipoi)
                  gcen(1)=gcen(1)+x
                  gcen(2)=gcen(2)+y
                  gcen(3)=gcen(3)+z
                enddo
                gcen=gcen/ncorn
                korn=korn+1
                kornmoth=1
                ifound=0
                do kplan=1,nplanmoth(moth)
                  npoimoth=kfacemoth(kornmoth,moth)
                  ipoimoth=kfacemoth(kornmoth+1,moth)
                  p1(1)=xmoth(ipoimoth,moth)
                  p1(2)=ymoth(ipoimoth,moth)
                  p1(3)=zmoth(ipoimoth,moth)
                  ipoimoth=kfacemoth(kornmoth+2,moth)
                  p2(1)=xmoth(ipoimoth,moth)
                  p2(2)=ymoth(ipoimoth,moth)
                  p2(3)=zmoth(ipoimoth,moth)
                  ipoimoth=kfacemoth(kornmoth+3,moth)
                  p3(1)=xmoth(ipoimoth,moth)
                  p3(2)=ymoth(ipoimoth,moth)
                  p3(3)=zmoth(ipoimoth,moth)
                  kornmoth=kornmoth+npoimoth+1
                  call util_plane(p1,p2,p3,gcen,vnor,dist,iover,istat)
                  if (abs(dist).lt.tiny) then
                    ifound=kplan
                    exit
                  endif
                enddo !kplan
                if (ifound.ne.0) then
                  korn=korn-ncorn-1
                  do icorn=1,ncorn
                    korn=korn+1
                    ipoi=kface(korn)-1
                    if (icorn.eq.1) i=ipoi
                    write(lunvrml,*)"              ",ipoi,","
                  enddo
                  korn=korn+1
                  write(lunvrml,*)"                 ",i,"-1,"
                endif
              enddo !nplan

              write(lunvrml,*)"       ] # End of coordIndex"

              write(lunvrml,*)"  } # End of Geometry"
              write(lunvrml,*)"} # End of Shape"
              write(lunvrml,*)" "

            enddo !nmag

          enddo !nmoth

        endif !vrml.eq.2

        if (ivrml.eq.-1) then

          do imag=1,nmag

            npoi=0
            nplan=ibpeplan(imag)
            ncol=ibpecol(imag)

            color(1)=1
            color(2)=1
            color(3)=1

            if (ncol.eq.1) then !black
              color(1)=0
              color(2)=0
              color(3)=0
            else if (ncol.eq.2) then !red
              color(1)=1
              color(2)=0
              color(3)=0
            else if (ncol.eq.3) then !bright green
              color(1)=0
              color(2)=1
              color(3)=0
            else if (ncol.eq.4) then !blue
              color(1)=0
              color(2)=0
              color(3)=1
            else if (ncol.eq.5) then !gelb
              color(1)=1.
              color(2)=1.
              color(3)=0
            else if (ncol.eq.6) then !magenta
              color(1)=1
              color(2)=0
              color(3)=1
            else if (ncol.eq.7) then !light blau
              color(1)=0
              color(2)=1
              color(3)=1
            else if (ncol.eq.8) then ! green
              color(1)=0.35
              color(2)=0.83
              color(3)=0.33
            else if (ncol.eq.9) then !dark blue
              color(1)=0.35
              color(2)=0.33
              color(3)=0.85
            endif

            do iplan=1,nplan
              ncorn=ibpecorn(iplan,imag)
              do icorn=1,ncorn
                npoi=npoi+1
                xhull(npoi)=bpemag(1,icorn,iplan,imag)
                yhull(npoi)=bpemag(2,icorn,iplan,imag)
                zhull(npoi)=bpemag(3,icorn,iplan,imag)
              enddo
            enddo

            call util_weed_points(npoi,xhull,yhull,zhull,tiny)

            call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

            if (ifailhull.ne.0.or.nhull.lt.4) then
              write(lun6,*)"*** Error in undumag_ini_old: Subroutine util_convex_hull_3d failed for "
              write(lun6,*)"*** writing of VRML-File"
              stop
            endif

            do ic=1,32
              chmag(ic:ic)=chmags(ic,imag)
            enddo

            write(lunvrml,*)" "
            write(lunvrml,*)"# ",chmag
            write(lunvrml,*)" "

            write(lunvrml,*)"Shape{"
            write(lunvrml,*)" "
            write(lunvrml,*)"  geometry IndexedLineSet {"
            write(lunvrml,*)
            write(lunvrml,*)"      coord Coordinate{"

            write(lunvrml,*)"         point ["

            do korn=1,npoi
              x=xhull(korn)
              y=yhull(korn)
              z=zhull(korn)
              write(lunvrml,*)"          ",sngl(x),sngl(y),sngl(z),","
            enddo !nhull

            write(lunvrml,*)"         ] # End of point"

            write(lunvrml,*)"      } # End of Coordinate"
            write(lunvrml,*)

            write(lunvrml,*)"       color Color {"
            write(lunvrml,*)"         color [", color," ] # End of color"
            write(lunvrml,*)"       } # End of color Color"
            write(lunvrml,*)
            write(lunvrml,*)"       coordIndex ["

            korn=1
            nedge=0
            do iplan=1,nface
              ncorn=kface(korn)
              do icorn=1,ncorn
                nedge=nedge+1
                korn=korn+1
                ipoi=kface(korn)-1
                if (icorn.eq.1) i=ipoi
                write(lunvrml,*)"              ",ipoi,","
              enddo
              korn=korn+1
              write(lunvrml,*)"                 ",i,"-1,"
            enddo !nplan

            write(lunvrml,*)"       ] # End of coordIndex"
            write(lunvrml,*)

            write(lunvrml,*)"       colorIndex ["
            do iedge=1,nedge
              write(lunvrml,*)"       0, 0,"
            enddo
            write(lunvrml,*)"       ] # End of colorIndex"
            write(lunvrml,*)
            write(lunvrml,*)"  } # End of Geometry"
            write(lunvrml,*)"} # End of Shape"
            write(lunvrml,*)" "

          enddo !nmag

        endif !vrml.eq.-1

        write(lunvrml,*)
        write(lunvrml,*)"# Coils"
        write(lunvrml,*)

        do i=1,ncwires
          xp1=wire(3,i)
          yp1=wire(4,i)
          zp1=wire(5,i)
          xp2=wire(6,i)
          yp2=wire(7,i)
          zp2=wire(8,i)
          if (((xp2-xp1)**2+(yp2-yp1)**2+(zp2-zp1)**2)*abs(wire(2,i)).lt.1.0d-12)
     &      cycle
          write(lunvrml,*)"Shape{"
          write(lunvrml,*)" "
          write(lunvrml,*)"  geometry IndexedLineSet {"
          write(lunvrml,*)
          write(lunvrml,*)"      coord Coordinate{"
          write(lunvrml,*)"         point ["
          write(lunvrml,*)"          ",xp1,yp1,zp1,","
          write(lunvrml,*)"          ",xp2,yp2,zp2,","
          write(lunvrml,*)"         ] # End of point"
          write(lunvrml,*)"      } # End of Coordinate"
          write(lunvrml,*)
          write(lunvrml,*)
          write(lunvrml,*)"       coordIndex ["
          write(lunvrml,*)"                 0,"
          write(lunvrml,*)"                 1, -1,"
          write(lunvrml,*)"       ] # End of coordIndex"

          write(lunvrml,*)"  } # End of Geometry"
          write(lunvrml,*)"} # End of Shape"
          write(lunvrml,*)" "

        enddo !ncwires

        write(lunvrml,*)
        write(lunvrml,*)"# End of Coils"
        write(lunvrml,*)

        close(lunvrml)

        write(lun6,*)
        write(lun6,*)'Done'
        write(lun6,*)

        deallocate(khullmoth,kfacemoth,nplanmoth)
      endif !ivrml.ne.0

      bpebc(17,1:nmag)=0.0d0
      if (intmaglis.ne.0) then
        ifound=0
        write(lun6,*)
        write(lun6,*)" --- Due to flag intmaglis, only magnets on file undumag_magmap.lis do contribute to field map ---"
        write(lun6,*)
        open(newunit=lunlis,file="undumag_magmap.lis")
        do while (.true.)
          call util_skip_comment_end(lunlis,ieof)
          if (ieof.ne.0) exit
          read(lunlis,*)chsel,bpe17
          do imag=1,nmag
            write(chmoth,'(32a)')chmoths(1:32,imag)
            if (chmoth.eq.chsel) then
              if (bpe17.gt.0.0d0) then
                bpebc(17,imag)=1.0d0
              else if (bpe17.lt.0.0d0) then
                bpebc(17,imag)=2.0d0
              endif
              ifound=1
            endif
          enddo
        enddo
        close(lunlis)
      endif !intmaglis

      open(newunit=lun,file='undumag_magnets.lis')
      do imag=1,nmag
c        write(lun6,*)imag,chmags(1:32,imag),nint(bpebc(15,imag)),
c     &    chmoths(1:32,imag)
        write(lun,*)imag,chmags(1:32,imag),chmoths(1:32,imag),
     &    sngl(bpebc(1,imag)),sngl(bpebc(2,imag)),sngl(bpebc(3,imag))
      enddo

      close(lun)

      open(newunit=lun,file='undumag_mother_magnets.lis')

      npoi=0
      ncount=0
      if (nmag.gt.0) motho=nint(bpebc(15,1))
      maxpoints=0

      do imag=1,nmag

        moth=nint(bpebc(15,imag))
c        write(lun6,*)"2 Info:",imag,moth,chmags(1:32,imag),chmoths(1:32,imag),npoi,maxpoints

        if (moth.eq.motho) then

          nplan=ibpeplan(imag)

          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              npoi=npoi+1
            enddo
          enddo

          if (npoi.gt.maxpoints) maxpoints=npoi

        else if (moth.ne.motho.or.imag.eq.nmag) then

          motho=moth
          if (npoi.gt.maxpoints) maxpoints=npoi
          npoi=0
          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              npoi=npoi+1
            enddo
          enddo

        endif !moth.eq.motho

      enddo !nmag

      deallocate(xhull,yhull,zhull,khull,kedge,kface)
      allocate(xhull(maxpoints),yhull(maxpoints),zhull(maxpoints),
     &  khull(maxpoints),kedge(4,2*maxpoints-2),
     &  kface((maxpoints+1)*maxpoints),stat=ierr)
      if (ierr.ne.0) then
        write(lun6,*)"*** Error while allocating xhull, yhull, zhull... Try less magnets...***"
        write(lun6,*)"*** Skipping writing undumag_mother_magnets.lis ***"
        goto 877
      endif

      npoi=0
      imag=1
      if (nmag.gt.0) motho=nint(bpebc(15,imag))

      do imag=1,nmag

        moth=nint(bpebc(15,imag))
        write(chmoth,'(32a)')chmoths(1:32,imag)
c        write(lun6,*)"3 Info:",imag,moth,chmags(1:32,imag),chmoths(1:32,imag)
c        write(lun6,*)imag,moth,chmoth

        if (moth.eq.motho) then
          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              npoi=npoi+1
              xhull(npoi)=bpemag(1,icorn,iplan,imag)
              yhull(npoi)=bpemag(2,icorn,iplan,imag)
              zhull(npoi)=bpemag(3,icorn,iplan,imag)
            enddo
          enddo

        else if (moth.ne.motho.or.imag.eq.nmag) then

          xmin=1.0d30
          xmax=-1.0d30
          ymin=1.0d30
          ymax=-1.0d30
          zmin=1.0d30
          zmax=-1.0d30
          do ipoi=1,npoi
            if (xhull(ipoi).lt.xmin) xmin=xhull(ipoi)
            if (xhull(ipoi).gt.xmax) xmax=xhull(ipoi)
            if (yhull(ipoi).lt.ymin) ymin=yhull(ipoi)
            if (yhull(ipoi).gt.ymax) ymax=yhull(ipoi)
            if (zhull(ipoi).lt.zmin) zmin=xhull(ipoi)
            if (zhull(ipoi).gt.zmax) zmax=xhull(ipoi)
          enddo

          dx=xmax-xmin
          dy=ymax-ymin
          dz=zmax-zmin

          if (dy.gt.dx) dx=dy
          if (dz.gt.dx) dx=dz

          call util_weed_points(npoi,xhull,yhull,zhull,tiny)
!hull
          call util_convex_hull_3d(npoi,xhull,yhull,zhull,khull,kedge,kface,
     &      nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

          if (ifailhull.ne.0.or.nhull.lt.4) then
            write(lun6,*)"*** Error ",ifailhull," in undumag_ini_old: Subroutine util_convex_hull_3d failed for "
            write(lun6,*)"*** writing of undumag_mother_magnets.lis"
            write(lun6,*)"*** Date written to util_convex_hull_3d.dat ***"
            open(newunit=lunf,file='util_convex_hull_3d.dat')
            do i=1,npoi
              write(lunf,*)xhull(i),yhull(i),zhull(i),i
            enddo
            close(lunf)
            nhull=npoi
            do icorn=1,nhull
              khull(icorn)=icorn
            enddo
c            stop
          endif

          gcen=0.0d0
          do icorn=1,nhull
            ipoi=khull(icorn)
            x=xhull(ipoi)
            y=yhull(ipoi)
            z=zhull(ipoi)
            gcen(1)=gcen(1)+x
            gcen(2)=gcen(2)+y
            gcen(3)=gcen(3)+z
c            write(lun6,*)chmoth1,motho,moth,imag,x,y,z
          enddo

          gcen=gcen/nhull
c          write(lun6,*)nhull,gcen

          ncount=ncount+1
c          write(lun6,*)"4 Info:",ncount,chmoth1,gcen
          write(lun,*) ncount,chmoth1,gcen

          motho=moth
          gcen=0.0d0
          npoi=0

          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              npoi=npoi+1
              xhull(npoi)=bpemag(1,icorn,iplan,imag)
              yhull(npoi)=bpemag(2,icorn,iplan,imag)
              zhull(npoi)=bpemag(3,icorn,iplan,imag)
            enddo
          enddo

        endif !moth.eq.motho

        chmoth1=chmoth

      enddo !nmag

877   flush(lun)
      close(lun)

      deallocate(xhull,yhull,zhull,khull,kedge,kface)

      call undumag_to_radia_old(kundurun,xsymmm,bpemag,ncornmax,nplanmax,nmag)

9999  deallocate(bpebc0,mothdiv,ncolmoth,
     &  xmoth,ymoth,zmoth,
     &  xmothm,ymothm,zmothm,
     &  xmothi,ymothi,zmothi,chmagsi,chmagsm,chmothsi,chmothsm,
     &  )

      if (nrec.eq.0) maxiterrec=1
      if (nrec.eq.0.and.ncwires.eq.0) then
        maxiteriron=1
        maxiter=1
      endif

      if (ncwires.ne.0.and.iforce.lt.0) then
        write(lun6,*)"*** Error in undumag_ini_old: Iforce<0 not yet implemented for coils and wires ***"
        write(lun6,*)"*** PROGRAM UNDUMAG ABORTED ***"
        stop
      endif

+self,if=randos.
      allocate(xyzsmear(3,nmag))
      do i=1,nmag
        call util_random(3,g)
        xyzsmear(1,i)=randos*g(1)
        xyzsmear(2,i)=randos*g(2)
        xyzsmear(3,i)=randos*g(3)
        bpebc(1:3,i)=bpebc(1:3,i)+xyzsmear(1:3,i)
      enddo
+self.

      zminprof=zplmin
      zmaxprof=zplmax

      if (iunduplot.lt.0) then
        open(newunit=lunst,file="undumag.stat")
        write(lunst,*)"0"
        flush(lunst)
        close(lunst)
        stop "--- Programm UNDUMAG terminated due to iunduplot < 0 ---"
      endif

+self,if=trace.
      print*,"-trace-: Leaving undumag_ini_old "
+self.
      end
+DECK,undumag_check_newclc.
*CMZ :  2.04/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 15/10/2021  08.31.14  by  Michael Scheer
*CMZ :  2.02/00 31/03/2021  20.30.51  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.27.23  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  16.04.15  by  Michael Scheer
*CMZ :  2.01/04 18/07/2019  13.56.54  by  Michael Scheer
*CMZ :  2.01/03 13/06/2019  15.03.29  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  14.56.07  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.15.25  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  14.30.21  by  Michael Scheer
*CMZ :  2.00/03 23/04/2018  17.47.12  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.39.07  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.09.03  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  16.25.38  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.30.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.59.20  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.35.49  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  19.08.03  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  13.53.24  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  11.50.12  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  18.37.06  by  Michael Scheer
*CMZ :  1.23/02 17/09/2017  11.21.15  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  16.23.00  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  14.53.35  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  08.50.03  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  11.30.39  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.56.28  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  12.48.09  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  13.11.48  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.31.54  by  Michael Scheer
*CMZ :  1.18/03 13/06/2017  15.30.31  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  14.09.42  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  09.19.34  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.04.28  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.55.08  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.22.37  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  12.23.38  by  Michael Scheer
*CMZ :  1.15/11 26/04/2017  11.23.30  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.22.06  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  14.32.29  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.29.10  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.46.33  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.15.21  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  19.50.52  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  11.26.05  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  09.16.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  10.00.53  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.14.36  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  15.40.55  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  16.37.53  by  Michael Scheer
*CMZ :  1.12/00 24/02/2017  08.47.15  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.24.23  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.18.36  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.27.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  10.13.44  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.40  by  Michael Scheer
*CMZ :  1.11/01 06/01/2017  13.46.07  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  15.56.40  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  15.36.58  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.12.02  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.10/00 01/11/2016  09.47.47  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.08.03  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  09.12.28  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  18.54.27  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.39.27  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.51.14  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.43.31  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.17  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.32.16  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.35.03  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.29.44  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.28  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  13.31.19  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.37.12  by  Michael Scheer
*CMZ :  1.02/02 12/09/2016  10.20.23  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.27.52  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  14.10.42  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  17.52.14  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.06.57  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.47  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.13.39  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  15.05.25  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  17.54.03  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  13.38.55  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.51.40  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.27.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.43  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  15.56.38  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.48.03  by  Michael Scheer
*CMZ :  1.17/15 19/04/2016  15.54.31  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  12.32.55  by  Michael Scheer
*CMZ :  1.17/13 08/04/2016  11.47.10  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.29.22  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  12.46.06  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.46.34  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.41.39  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.58.50  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.42.21  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine undumag_check_newclc

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

      integer :: istat=0,lunclc,lunst
      character c1

      konv=-9

      open(newunit=lunst,file="undumag.sta")
      write(lunst,*)"-9999",konv
      write(lunst,*)"started"
      close(lunst)

      newclc=0
      open(newunit=lunclc,file=trim(Fclc),status="old", iostat=istat)
      if (istat.ne.0) then
        stop "*** File " // trim(Fclc) // " not found ***"
      endif

      do while (.true.)
        read(lunclc,'(a)',end=91) c1
        if (c1.eq.'&') then
          newclc=1
          exit
        endif
      enddo
91    close(lunclc)

      return
      end
+DECK,undumag_ini_magnets.
*CMZ :  2.04/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/00 25/02/2023  14.36.37  by  Michael Scheer
*CMZ :  2.02/02 02/03/2022  13.26.45  by  Michael Scheer
*CMZ :  2.02/01 11/02/2022  09.49.54  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine undumag_ini_magnets(kseg)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      integer kseg
+self,if=debcm.
      integer i,l,imag,n,ipoi,iplan
+self.

c      print*," "
c      print*," "
c      print*,"Baustellen:"
c      print*,"bpebc(18:20),corrtiny, dedgefb, simpson-file, chicut und andere Variablen aus undumag_ini_old.Randommechnismus, spez. mit Blick auf 1. Integral"
      print*," "

      ! Evaluate buffer of coils
      call clccoil_to_coils

      if (kseg.eq.2) return

      call undumag_read_modules

      ! Evaluate buffer of magnets and poles
      call clcbuff_to_magnets

+self,if=debcm.
      do imag=1,nmag_t+nspecmag_t
        l=0
        do iplan=1,t_magnets(imag)%nface
          l=l+1
          n=t_magnets(imag)%kface(l)
          do i=1,n
            l=l+1
            ipoi=t_magnets(imag)%kface(l)
            write(902,*)imag,iplan,i,l,ipoi,
     &        t_magnets(imag)%xhull0(ipoi),
     &        t_magnets(imag)%yhull0(ipoi),
     &        t_magnets(imag)%zhull0(ipoi)
          enddo
        enddo
      enddo
+self.
      ! Apply translations, rotations, and copying of magnets and poles
      if (ntransrotcop.ne.0) call clctransrotcop

      ! Drop zero magnets , after the call, xhull, yhull, zhull refer to gcen
      call clcmag_drop_zero_magnets

      ! Coating of magnets
      call clcmag_shrink_magnets

      ! Mothers
      call clcmag_mothers

      ! inhomogenities of magnets
      call clcmag_inhom

      ! Evaluate modules
      call clcmag_copy_magnets

      ! Apply longitudinal symmetry and center set-up
      call clcmag_sym

      ! segmentation of magnets
      call clcmag_cut

      ! convert to internal arrays for undumag_proc and undumag_end
      call clcmag_to_bpe
      call undumag_ini_bpetm

      ! write set-up to lists
      call clcmag_magnets_list

      if (kseg.ne.0) return

      call clcmag_ini_force

      return
      end
+DECK,undumag_read_modules.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*-- Author :    Michael Scheer   15/10/2021
      subroutine undumag_read_modules

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision undumag_variable_getval,space

      integer ib,ipos(2,10),istat,nwords,i,j,imodul

      character(512) cword

+seq,grarad.

+self,if=trace.
      print*,"-trace-: undumag_read_modules entered"
+self.

      allocate(t_modules(nmodule_t))

      ib=0
      nmodule_t=0
      do while (ib.lt.nclcmod)
        ib=ib+1
        if (clcmod(ib)(1:8).eq.'& Module') cycle
        nmodule_t=nmodule_t+1
        call util_string_split(clcmod(ib),10,nwords,ipos,istat)
        do i=1,3
          cword=clcmod(ib)(ipos(1,i):ipos(2,i))
          if (cword(1:1).eq.'$') then
            t_modules(nmodule_t)%offset(i)=undumag_variable_getval(cword)
          else
            read(cword,*)t_modules(nmodule_t)%offset(i)
          endif
        enddo
        ib=ib+1
        call util_string_split(clcmod(ib),10,nwords,ipos,istat)
        cword=clcmod(ib)(ipos(1,1):ipos(2,1))
        if (cword(1:1).eq.'$') then
          t_modules(nmodule_t)%ncopy=nint(undumag_variable_getval(cword))
        else
          read(cword,*)t_modules(nmodule_t)%ncopy
        endif
        ib=ib+1
        call util_string_split(clcmod(ib),10,nwords,ipos,istat)
        cword=clcmod(ib)(ipos(1,1):ipos(2,1))
        if (cword(1:1).eq.'$') then
          space=undumag_variable_getval(cword)
        else
          read(cword,*)space
        endif
        do i=2,4
          cword=clcmod(ib)(ipos(1,i):ipos(2,i))
          if (cword(1:1).eq.'$') then
            t_modules(nmodule_t)%vspace(i-1)=undumag_variable_getval(cword)
          else
            read(cword,*)t_modules(nmodule_t)%vspace(i-1)
          endif
        enddo
        t_modules(nmodule_t)%vspace=space*t_modules(nmodule_t)%vspace/
     &    norm2(t_modules(nmodule_t)%vspace)
        cword=clcmod(ib)(ipos(1,5):ipos(2,5))
        if (cword(1:1).eq.'$') then
          t_modules(nmodule_t)%phi=undumag_variable_getval(cword)
        else
          read(cword,*)t_modules(nmodule_t)%phi
        endif
        ib=ib+1
        call util_string_split(clcmod(ib),10,nwords,ipos,istat)
        do i=1,3
          cword=clcmod(ib)(ipos(1,i):ipos(2,i))
          if (cword(1:1).eq.'$') then
            t_modules(nmodule_t)%scalmag(i)=undumag_variable_getval(cword)
          else
            read(cword,*)t_modules(nmodule_t)%scalmag(i)
          endif
        enddo
        ib=ib+1
      enddo

      do i=1,nmodule_t
        call util_rotmat(t_modules(i)%vspace,t_modules(i)%phi*grarad1,
     &    t_modules(i)%rotmat,istat)
      enddo

      return
      end
+DECK,clcmag_copy_voxels.
*CMZ :  2.04/07 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/06 04/08/2023  11.26.53  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/00 24/12/2022  13.07.12  by  Michael Scheer
*CMZ :  2.02/01 19/01/2022  10.54.41  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2021
      subroutine clcmag_copy_voxels

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      integer i_tvoxel_is_block
      integer imag,ivox,icopy,imodul,kmag

      type (T_Magnet) tmag
      type (T_Voxel) tv
      type (T_Voxel_Copy) tvc

+self,if=trace.
      print*,"-trace-: Entered clcmag_copy_voxels"
+self.
      nvoxcopy_t=0
      do imag=1,nmagtot_t
        nvoxcopy_t=nvoxcopy_t+t_magnets(t_magcopy(imag)%kproto)%nvoxels
      enddo !imag

      allocate(t_voxcopy(nvoxcopy_t))

      nrec=0
      niron=0
      nvoxcopy_t=0

      do imag=1,nmagtot_t
        kmag=t_magcopy(imag)%kproto
        imodul=t_magcopy(imag)%kmodule
        icopy=t_magcopy(imag)%kcopy
        do ivox=1,t_magnets(kmag)%nvoxels
          nvoxcopy_t=nvoxcopy_t+1
          t_voxcopy(nvoxcopy_t)%kmodule=imodul
          t_voxcopy(nvoxcopy_t)%kmagnet=imag
          t_voxcopy(nvoxcopy_t)%kproto=kmag
          t_voxcopy(nvoxcopy_t)%kvoxel=ivox
          t_voxcopy(nvoxcopy_t)%kcopy=icopy
          t_voxcopy(nvoxcopy_t)%gcen=t_magnets(kmag)%t_voxels(ivox)%gcen
     &      +t_magcopy(imag)%gcen-t_magnets(kmag)%gcen
          t_voxcopy(nvoxcopy_t)%br=t_magnets(kmag)%t_voxels(ivox)%br
          t_voxcopy(nvoxcopy_t)%Ispole=t_magnets(kmag)%Ispole
          if (t_magnets(kmag)%Ispole.eq.0) then
            nrec=nrec+1
          else
            niron=niron+1
          endif
        enddo !ivox
      enddo !imag

      do ivox=1,nvoxcopy_t
        tvc=t_voxcopy(ivox)
        imag=tvc%kproto
        tmag=t_magnets(imag)
        tv=t_magnets(imag)%t_voxels(tvc%kvoxel)
        t_magnets(imag)%t_voxels(tvc%kvoxel)%IsBlock=tmag%IsBlock
        if (tmag%ctype.ne.'Cylinder'
     &      .and.tv%nhull.eq.8.and.tv%nedge.eq.12.and.tv%nface.eq.6
     &      .and.tmag%IsBlock.eq.0) then
          if (irecrepl.eq.0) then
            t_magnets(imag)%t_voxels(tvc%kvoxel)%IsBlock=-i_tvoxel_is_block(tv)
          else
            t_magnets(imag)%t_voxels(tvc%kvoxel)%IsBlock=i_tvoxel_is_block(tv)
          endif
        endif
      enddo !ivox

+self,if=trace.
      print*,"-trace-: Leaving clcmag_copy_voxels"
+self.
      return
      end
+DECK,undumag_ini_displacement.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*-- Author :    Michael Scheer   19/10/2021
      subroutine undumag_ini_displacement

      use undumagf90m
      use commandlinef90m
      use displacement

      implicit none

      real g(100)
      integer lun,ieof,k,i

      character(2048) cline

      if (kdisplace.ne.0) then
        kdisplace=0
        if (ixsym.gt.0.or.iysym.gt.0.or.izsym.gt.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_ini_old: kdisplace is set, but set-up is mirrored due to ixsym, iysym, or izsym ***"
          write(lun6,*)
        endif
        open(newunit=lun,file="undumag.dis",status="old")
        do while (.true.)
          call util_skip_comment_end(lun,ieof)
          read(lun,'(a)')cline
          kdisplace=kdisplace+1
        enddo
        rewind(lun)
        allocate(chdisp(kdisplace))
        allocate(displace(18,kdisplace))
        do i=1,kdisplace
          ! displace(1:3,i) displacement of magnet
          ! displace(4:6,i) yrot, zrot, dphi of rotation around x-axis
          ! displace(7:9,i) change of magnetization
          ! displace(10:18,i)
          !mode: 0, apply changes as they are
          !mode: 1, apply changes with randomization
          call util_skip_comment(lun)
          read(lun,*)chdisp(i),displace(1:18,i)
          call util_random(9,g)
          do k=1,9
            if (displace(k+9,i).ne.0.0d0) displace(k,i)=displace(k,i)*g(k)
          enddo
        enddo
        close(lun)
      endif

      return
      end
+DECK,undumag_ini_random.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*-- Author :    Michael Scheer   19/10/2021
      subroutine undumag_ini_random

      use undumagf90m
      use commandlinef90m
      use bpolyederf90m

      implicit none

+seq,random.

      integer lunio,i,k

      if (irnmode.eq.1.or.irnmode.eq.2) then
        kundurun=0
        open(newunit=lunio,file="undumag.run",form='formatted',recl=512)
        read(lunio,*,end=9)kundurun
 9      kundurun=kundurun+1
        close(lunio)
        if (irnmode.eq.2) irnseed(12)=irnseed(12)+kundurun
        call util_random_set_seed(irnsize,irnseed)
      else if (irnmode<0) then
        open(newunit=lunio,file='undumag.seeds',status='old')
        read(lunio,*) k
        do i=1,irnsize
          read(lunio,*)k,irnseed(k)
        enddo
        close(lunio)
        call util_random_set_seed(irnsize,irnseed)
      else
        call util_random_init(irnsize,irnseed)
      endif

      randoxa=abs(randox)
      randoya=abs(randoy)
      randoza=abs(randoz)
      randox10=randoxa/10.0d0
      randoy10=randoya/10.0d0
      randoz10=randoza/10.0d0

      return
      end
+DECK,undumag_ini_namelists.
*CMZ :  2.04/03 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/02 25/02/2022  09.54.41  by  Michael Scheer
*CMZ :  2.02/01 09/02/2022  18.49.27  by  Michael Scheer
*-- Author :    Michael Scheer   19/10/2021
      subroutine undumag_ini_namelists

      use commandlinef90m
      use undumagf90m
      use bpolyederf90m
      use magnets_structure

      implicit none

+seq,random.

      integer lunnam,istat
      logical lexist

      character(128) c128

      inquire(file=trim(Fnam),exist=lexist)
      if (lexist.eqv..false.) then
        write(lun6,*)""
        write(lun6,*)"*** Error in undumag_ini_namelists: File " // trim(Fnam) // " not found ***"
        write(lun6,*)"*** Program UNDUMAG aborted ***"
        stop
      endif

      open(newunit=lunnam,file=trim(Fnam),form='formatted',status='old')
      read(lunnam,undumagn)
      read(lunnam,randomn)
      close(lunnam)

      kcalcvars=1 !to avoid problems with undumag.in if coating is used

      if (kbextern.eq.0) then
        bxex=0.0d0
        byex=0.0d0
        bzex=0.0d0
      endif

      rcvthron=abs(rcvthron)
      if (rcvthron.eq.0.0d0) rcvthron=1.0d30

      if (cuttiny.eq.0.0d0) cuttiny=0.1
      if (hulltiny.eq.0.0d0) hulltiny=1.0d-6

      if (nchiiron.le.0) nchiiron=1

      nchimax=0

      if (chicut.eq.-9999.0d0) chicut=max(abs(hconv),1.0d-10)
      corrtiny=corrtiny/1000.0d0 ! mm->meter

      open(unit=99,file='.util_spline_or_simpson_integral.dat')
      write(99,*)isimpson
      if (isimpson.gt.0) then
        write(lun6,*)
        write(lun6,*)"*** Simpson integrations applied ***"
        write(lun6,*)
      endif
      flush(99)
      close(99)

      hconva=abs(hconv)
      if (hconv.le.-1000.0d0) hconva=0.0d0

      if (dampiron.eq.0.0d0.or.dampiron.gt.1.0d0) then
        dampiron=1.0d0
      endif

      if (maxiteriron.eq.-9999.and.dampiron.lt.1.0d0) then
        maxiteriron=nint(log(0.001)/log(1.0d0-dampiron)+1)
      endif

      dampi=dampiron

      if (maxiteriron.eq.-9999) maxiteriron=1

      if(kdumpconv.ne.0) open(newunit=lunconv,file="undumag.cnv")

      if (perlen.eq.9999.0d0.and.newclc.eq.0) then
        c128="perlen"
        call undumag_parameter(c128,perlen,istat)
        if (istat.ne.0) then
          c128="Perlen"
          call undumag_parameter(c128,perlen,istat)
          if (istat.ne.0) then
            c128="PerLen"
            call undumag_parameter(c128,perlen,istat)
          endif
        endif
        if (istat.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Error in undumag_ini_namelists: Bad return from undumag_parameter for PerLen ***"
          write(lun6,*)"Make sure, that " // trim(Fclc) // " contains parameter or variable PerLen!"
          write(lun6,*)
          stop
        else
          write(lun6,*)
          write(lun6,*)"Period length read from " // trim(Fclc) // ":",sngl(perlen)
          write(lun6,*)
          if (perlen.le.0.0d0) then
            perlen=100.0d0
            write(lun6,*)
            write(lun6,*)"*** Warning in undumag_ini_namelists:Zero or negative period-length found ***"
            write(lun6,*)"*** Set to 100 ***"
            write(lun6,*)
          endif
        endif
      endif

      jrunnum=krunnum
      jcomment=kcomment
      jrunnum=krunnum
      jdate=kdate
      nthreads=nuthreads

      if (dedgefb.eq.0.0d0) dedgefb=0.02d0

      if (iforcedip.ne.0) idipoles=1

      return
      end
+DECK,undumag_greeter.
*CMZ :  2.02/01 23/08/2023  16.15.38  by  Michael Scheer
*-- Author :    Michael Scheer   19/10/2021
      subroutine undumag_greeter
      use undumagf90m
      use commandlinef90m
      implicit none
+seq,unduver.
      return
      end
+DECK,undumag_ini_materials.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/02 20/02/2022  16.26.00  by  Michael Scheer
*CMZ :  2.02/01 08/01/2022  16.53.06  by  Michael Scheer
*-- Author :    Michael Scheer   19/10/2021
      subroutine undumag_ini_materials

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision bcm,bcmo,hmat,hmato

      integer :: ib,nmat,imat,lmat,mapmode,nmatpoi,nmatpoimax=0,ieof,lunmat,
     &  kmat,nline

      character(1024) cfile

      if (nclcmat.le.0) return

      read(clcmat(1),*) nmat

      bcmo=-1.0d30
      hmato=-1.0d30

      do ib=1,nmat
        read(clcmat(ib+1),*) imat,lmat,mapmode,cfile
        nmatpoi=0
        open(newunit=lunmat,file=trim(cfile),status='old')
        do while (.true.)
          call util_skip_comment_end(lunmat,ieof)
          if (ieof.ne.0) exit
          read(lunmat,*)hmat,bcm
          if (bcm.ne.bcmo) then
            nmatpoi=nmatpoi+1
          endif
          hmato=hmat
          bcmo=bcm
        enddo
        close(lunmat)
        nmatpoimax=max(nmatpoimax,nmatpoi)
      enddo

      allocate(bcmat(3,nmatpoimax,nmat))
      bcmat=0.0d0

      allocate(feh1(nmatpoimax))
      allocate(fem1(nmatpoimax))

      if (isplinefm.ne.0) then
        allocate(fespl1(nmatpoimax))
        allocate(ufespl1(nmatpoimax))
        allocate(fewspl1(nmatpoimax))
        allocate(fewspl2(nmatpoimax))
        allocate(fewspl3(nmatpoimax))
        allocate(fewspl4(nmatpoimax))
      endif

      write(lun6,*)
      write(lun6,*) "Material files (material number, material type, mode, filename):"
      write(lun6,*)

      do kmat=1,nmat

        read(clcmat(kmat+1),*) imat,lmat,mapmode,cfile

        nmatpoi=0
        bcmo=-1.0d30
        hmato=-1.0d30

        open(newunit=lunmat,file=trim(cfile),status='old')

        write(lun6,*)imat,lmat,mapmode,"      ",trim(cfile)
        nline=0

115     call util_skip_comment_end(lunmat,ieof)

        if (ieof.ne.0) goto 995

        perksi=0.0d0
        ! lmat = 1: Anisotropic magnet material with an easy axis
        !           mapmode=1: Linear material
        !           mapmode=2: Non-linear material

        if (lmat.eq.1) then

          if (mapmode.eq.1) then

            nline=nline+1

            if (nline.gt.1) then
              write(lun6,*)"*** Error in undumag_ini_materials ***"
              write(lun6,*)"*** Material file for mapmode 1 must contain only one data line ***"
              write(lun6,*)"File: ,",trim(cfile)
              stop
            endif

            read(lunmat,*)bcmat(2:3,1,kmat) ! read mu=1.+parksi and perksi
            bcmat(2,1,kmat)=bcmat(2,1,kmat)-1.0d0

          else if (mapmode.eq.2) then
            read(lunmat,*)hmat,bcm,perksi
            bcmat(1,nmatpoi,kmat)=hmat
            bcmat(2,nmatpoi,kmat)=bcm
            bcmat(3,nmatpoi,kmat)=perksi
            bcmo=bcm
            hmato=hmat
          else
            write(lun6,*)"*** Bad material mode found in input file ***"
            stop
          endif
          goto 115
        else if (lmat.eq.2) then
            ! lmat = 2: Isotropic material
            if (mapmode.eq.0
     &          .or.mapmode.eq.2
     &          .or.mapmode.eq.3
     &          .or.mapmode.eq.4
     &          .or.mapmode.eq.5
     &          .or.mapmode.eq.6
     &          .or.mapmode.eq.7
     &          .or.mapmode.eq.8
     &          ) then
              read(lunmat,*)hmat,bcm
            else
              write(lun6,*)"*** Bad material mode found in input file ***"
              stop
            endif
c            if (bcm.ne.bcmo.or.hmato.ne.hmat) then
            if (bcm.ne.bcmo) then
              nmatpoi=nmatpoi+1
            endif
            bcmat(1,nmatpoi,kmat)=hmat
            bcmat(2,nmatpoi,kmat)=bcm
            bcmat(3,nmatpoi,kmat)=perksi
            if (
     &          mapmode.eq.2
     &          .or.mapmode.eq.3
     &          .or.mapmode.eq.4
     &          .or.mapmode.eq.5
     &          .or.mapmode.eq.6
     &          .or.mapmode.eq.7
     &          .or.mapmode.eq.8
     &          ) then
              if (mapmode.eq.3.and.hmat.eq.0.0d0) hmat=1.0d-30
              if (mapmode.eq.3.and.bcm.eq.0.0d0) bcm=1.0d-30
              feh1(nmatpoi)=hmat
              fem1(nmatpoi)=bcm
              bcmo=bcm
              hmato=hmat
            endif
c            endif
            goto 115
          else
            write(lun6,*)"*** Bad material type found in input file ***"
            write(lun6,*)"*** Must be 1 for anisotropic or 2 for isotropic material ***"
            stop
          endif !lmat

995     continue

        matmaps(1,kmat)=imat
        matmaps(2,kmat)=lmat
        matmaps(3,kmat)=mapmode
        matmaps(4,kmat)=nmatpoi

        close(lunmat)

        if (mapmode.gt.1.and.nmatpoi.lt.2) then
          write(lun6,*)"*** Error in undumag_ini_materials ***"
          write(lun6,*)"*** Material file for mapmode > 1 must contain more then one data line ***"
          write(lun6,*)"File: ,",trim(cfile)
          stop
        endif
        if (lmat.eq.2.and.isplinefm.ne.0) call util_spline_coef(feh1,fem1,nmatpoi,
     &    0.0d0,0.0d0,fespl1,fewspl1,fewspl2,fewspl3,fewspl4)

      enddo !nmat

      nmat_t=nmat
      nmatfiles=nmat_t

      return
      end
+DECK,clcmag_sym.
*CMZ :  2.04/07 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/06 02/05/2023  10.37.14  by  Michael Scheer
*CMZ :  2.04/04 06/03/2023  16.27.00  by  Michael Scheer
*CMZ :  2.03/00 31/08/2022  08.24.49  by  Michael Scheer
*CMZ :  2.02/02 17/02/2022  11.05.25  by  Michael Scheer
*CMZ :  2.02/01 10/02/2022  21.54.35  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2021
      subroutine clcmag_sym

      use undumagf90m
      use bpolyederf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision xsymmm,xlen,dx,dxcon(100),
     &  xmin,xmax,ymin,ymax,zmin,zmax,tiny2

      real g(3)

      integer i

      if (ixsym.lt.0.or.iysym.lt.0.or.izsym.lt.0) then
        print*,"*** Error in clcmag_sym: Hard symmetry operations, i.e. duplication of magnets not allowed ***"
        stop
      endif

      xcentershift=0.0d0

      xcwmin= 1.0d30
      xcwmax=-1.0d30
      ycwmin= 1.0d30
      ycwmax=-1.0d30
      zcwmin= 1.0d30
      zcwmax=-1.0d30

      if (ncwires.gt.0) then
        do i=1,ncwires
          if (wire(3,i).lt.xcwmin) xcwmin=wire(3,i)
          if (wire(6,i).lt.xcwmin) xcwmin=wire(6,i)
          if (wire(3,i).gt.xcwmax) xcwmax=wire(3,i)
          if (wire(6,i).gt.xcwmax) xcwmax=wire(6,i)
          if (wire(4,i).lt.ycwmin) ycwmin=wire(4,i)
          if (wire(7,i).lt.ycwmin) ycwmin=wire(7,i)
          if (wire(4,i).gt.ycwmax) ycwmax=wire(4,i)
          if (wire(7,i).gt.ycwmax) ycwmax=wire(7,i)
          if (wire(5,i).lt.zcwmin) zcwmin=wire(5,i)
          if (wire(8,i).lt.zcwmin) zcwmin=wire(8,i)
          if (wire(5,i).gt.zcwmax) zcwmax=wire(5,i)
          if (wire(8,i).gt.zcwmax) zcwmax=wire(8,i)
        enddo
      endif

      xmin_t=min(xmin_t,xcwmin)
      xmax_t=max(xmax_t,xcwmax)
      ymin_t=min(ymin_t,ycwmin)
      ymax_t=max(ymax_t,ycwmax)
      zmin_t=min(zmin_t,zcwmin)
      zmax_t=max(zmax_t,zcwmax)

      xmin=xmin_t
      ymin=ymin_t
      zmin=zmin_t

      xmax=xmax_t
      ymax=ymax_t
      zmax=zmax_t

      xsymmm=xsym

      if (xsymmm.eq.9999.0d0) xsymmm=xcenter
      if (xsym.ne.9999.0d0) xsym=xsym/1000.0d0

      xsymmm_t=xsymmm

      if (kxcenter.ne.0) then

        if (ixsym.eq.0) then
          xcentershift=xcenter-(xmax_t+xmin_t)/2.0d0
        else
          xcentershift=xcenter-xsymmm
        endif

        xmin_t=xmin_t+xcentershift
        xmax_t=xmax_t+xcentershift

        do i=1,ncwires
          wire(3,i)=wire(3,i)+xcentershift
          wire(6,i)=wire(6,i)+xcentershift
        enddo

        write(lun6,*)
        write(lun6,*) "xcenter, shift:",xcenter,xcentershift
        write(lun6,*)

      endif !kxcenter

      if (nmag_t+nspecmag_t.eq.0.or.(nxconv.eq.0.and.dxconv.eq.0.0d0)) then
        nxconv=1
        xconv(1)=0.0d0
        goto 1234
      endif

      nxconv=abs(nxconv)

      if (xconvmin.eq.9999.0d0) then
        xconvmin=xmin_t+mod(xmin_t,perlen)-1.0d0*perlen
        if (xconvmin.gt.xcwmin) xconvmin=xcwmin
      endif !(xconvmin.eq.9999.0d0) then

      if (xconvmax.eq.9999.0d0) then
        if (kxcenter.ne.0) then
          xconvmax=xcenter
        else
          xconvmax=xmax_t-mod(xmax_t,perlen)+2.0d0*perlen
        endif
        if (xconvmax.lt.xcwmax) xconvmax=xcwmax
      endif !(xconvmax.eq.9999.0d0) then

      if (xconvmax.le.xconvmin) xconvmin=xconvmax-perlen/2.0d0

      if (nxconv.eq.9999) then
        nxconv=min(100,nint((xconvmax-xconvmin)/perlen*2)+1)
      else if (nxconv.gt.100) then
        write(lun6,*)"*** Warning in clcmag_sym: nxconv changed to limit of 100 ***"
        nxconv=100
      endif

      if (dxconv.eq.0.0d0) then
        dxconv=(xconvmax-xconvmin)/max(1,nxconv-1)

      else if (dxconv.eq.9999.0d0) then
        dxconv=perlen/2.0d0
        if (perlen.le.0.0d0) then
          stop "*** Error in clcmag_sym: Negative period-length ***"
        endif
        nxconv=nint((xconvmax-xconvmin)/dxconv)+1
        if (nxconv.gt.100) then
          write(lun6,*)"*** Warning in clcmag_sym: dxconv changed to limit nxconv to 100 ***"
          nxconv=100
        endif
        dxconv=(xconvmax-xconvmin)/max(1,nxconv-1)

      else if (dxconv.lt.0.0d0) then
        dxcon(1)=0.0d0
        dx=1.0d0
        do i=2,nxconv
          dxcon(i)=dxcon(i-1) + dx
          dx=dx*abs(dxconv)
        enddo
        xlen=dxcon(nxconv)
        do i=2,nxconv
          xconv(i)=xconv(i-1) + (dxcon(i)-dxcon(i-1))*(xconvmax-xconvmin)/xlen
        enddo
      else
        do i=1,nxconv
          xconv(i)=xconvmin+dxconv*(i-1)
        enddo
      endif !(dxconv.lt.0.0d0) then

      do i=1,nxconv
        ! to avoid boundary effects:
        call util_random(2,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        xconv(i)=(xconv(i)+g(1)*randoxa)/1000.0d0
      enddo

      yconv=yconv/1000.0d0

      if (abs(g(2)).lt.randoz10) then
        if (g(2).gt.0.0d0) then
          g(2)=g(2)+randoz10
        else
          g(2)=g(2)-randoz10
        endif
      endif

      if (zconv.eq.0.0d0) then
        if (randoza.gt.0.0d0) then
          zconv=(zconv+g(2)*randoza)/1000.0d0
        else
          zconv=(zconv+randoza)/1000.0d0
        endif
      else
        zconv=zconv/1000.0d0
      endif

1234  continue

      window=uwindow
      kdebug=kudebug

      tiny=1.1d-6
      tiny=corrtiny

      if (nmag_t+nspecmag_t.eq.0.and.ncwires+nrace.eq.0.and.kbextern.eq.0) then
        xmapmin=0.1
        xmapmax=0.1
      endif

      if (xmapmin.eq.9999.0d0) then
        xmapmin=xmin_t+mod(xmin_t,perlen)-9.0d0*perlen
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      else if (xmapmin.eq.9000.0d0) then
        xmapmin=xcenter-perlen/2.0d0
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      else if (xmapmin.eq.-9000.0d0) then
        xmapmin=xcenter-perlen/4.0d0
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      endif

      if (xmapmax.eq.9999.0d0) then
        xmapmax=xmax_t-mod(xmax_t,perlen)+10.0d0*perlen
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      else if (xmapmax.eq.9000.0d0) then
        xmapmax=xcenter+perlen/2.0d0
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      else if (xmapmax.eq.-9000.0d0) then
        xmapmax=xcenter+perlen/4.0d0
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      endif

      if (dxmap.eq.0.0d0.and.nxmap.eq.0.0d0) then
        nxmap=1
      endif

      if (dxmap.eq.9999.0d0) then
        if (nxbeff.gt.1) then
          dxmap=perlen/(nxbeff-1)
        else
          dxmap=perlen
        endif
      endif

      if (dxmap.ne.0.0d0) nxmap=nint((xmapmax-xmapmin)/dxmap)+1

      if (nxmap.le.0) then
        write(lun6,*)"*** Warning in clcmag_sym: nxmap.le.0 ***"
      endif

      if (nymap.le.0) nymap=1
      if (nzmap.le.0) nzmap=1

      if (ixsym.gt.0) then
        if (xmin.lt.xsymmm-tiny2.and.xmax.gt.xsymmm+tiny2) then
          write(lun6,*)"*** Error in input: Option ixsym is set, but not all x-values are on the same side of xsymm!"
          write(lun6,*)"*** Program undumag aborted ***"
          stop
        endif
        dx=xsymmm-xmin
        xmax=xsymmm+dx
        xsym=xsymmm/1000.0d0
        xmapmax=-xmapmin
      else
        xmin=xmin_t
        xmax=xmax_t
      endif

      if (iysym.ne.0) then
        if (ymin.lt.-tiny2.and.ymax.gt.tiny2) then
          write(lun6,*)"*** Error in input: Option iysym is set, but not all y-values have the same sign!"
          if (iysym.gt.0) then
            write(lun6,*)"*** Program undumag aborted ***"
            stop
          endif
        endif
        ymax=max(abs(ymax),abs(ymin))
        ymin=-ymax
      else
        ymin=ymin_t
        ymax=ymax_t
      endif

      if (izsym.ne.0) then
        if (zmin.lt.-tiny2.and.zmax.gt.tiny2) then
          if (izsym.gt.0) then
            write(lun6,*)"*** Error in input: Option izsym is set, but not all z-values have the same sign!"
            write(lun6,*)"*** Program undumag aborted ***"
            stop
          else if (izsym.lt.0) then
            write(lun6,*)"*** Warning in input: Option izsym is set, but not all z-values have the same sign!"
          endif
        endif
        zmax=max(abs(zmax),abs(zmin))
        zmin=-zmax
      else
        zmin=zmin_t
        zmax=zmax_t
      endif

      nxmap=nint((xmapmax-xmapmin)/dxmap)+1

      xmin_t=xmin
      ymin_t=ymin
      zmin_t=zmin

      xmax_t=xmax
      ymax_t=ymax
      zmax_t=zmax

      return
      end
+DECK,clcmag_voxels_sym.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2021
      subroutine clcmag_voxels_sym

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      integer imag,ix,iy,iz,nvox,npol,nmag,imodul

      type(T_Voxel) tvox

      stop "Baustelle clcmag_voxels_sym"

      return
      end
+DECK,undumag_magfile.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*-- Author :    Michael Scheer   20/10/2021
      subroutine undumag_magfile

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure

      implicit none

      integer, parameter :: ntupp=12

      double precision vmaglab(3),htup(ntupp),dx,dy,dz,bc
      integer luno,iplan,icorn,imag,kmag,i,ivox

      character(2048) cline

      type (T_Magnet_Copy) tmc
      type (T_Voxel_Copy) tvc

      open(newunit=luno,file='undumag.mag',form='formatted',status='unknown')

      write(luno,'(a)')trim(cundutit)

      do ivox=1,nvoxcopy_t

        tvc=t_voxcopy(ivox)
        kmag=tvc%kproto
        imag=tvc%kmagnet
        kvox=tvc%kvoxel
        tmc=t_magcopy(imag)

        do iplan=1,ibpeplan(ivox)
          do icorn=1,ibpecorn(iplan,ivox)

            htup(1)=bpebc(15,ivox)
            htup(2)=ivox
            htup(3)=ibpecol(ivox)
            htup(4)=iplan
            htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
            htup(6)=bpemag(1,icorn,iplan,ivox)
            htup(7)=bpemag(2,icorn,iplan,ivox)
            htup(8)=bpemag(3,icorn,iplan,ivox)
            htup(9)=bpebc(4,ivox)
            htup(10)=bpebc(5,ivox)
            htup(11)=bpebc(6,ivox)
            htup(12)=bpebc(9,ivox)

            vmaglab(1)=bpebc(4,ivox)
            vmaglab(2)=bpebc(5,ivox)
            vmaglab(3)=bpebc(6,ivox)

            bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
            bpebc(7,ivox)=bc

            if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
              do i=5,10
                if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
              enddo
              write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
              cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &          trim(tmc%cmoth)
              if (t_magnets(kmag)%IsPole.ne.0) then
                write(luno,'(a)') trim(cline) // " 1"
              else
                write(luno,'(a)') trim(cline) // " 0"
              endif
            endif !BC

          enddo !ncorn
        enddo !nplan
      enddo !nvoxcopy_t

      if (kplsym.eq.0) then
        if (ixsymo.ne.0) then
          dx=xmax_t-xmin_t
          xmax_t=xmax_t-dx/2.
        endif
        if (iysymo.ne.0) then
          dy=ymax_t-ymin_t
          ymax_t=ymax_t-dy/2.
        endif
        if (izsymo.ne.0) then
          dz=zmax_t-zmin_t
          zmax_t=zmax_t-dz/2.
        endif
        goto 19
      endif

      if (ixsym.eq.0) then
        if (iysym.ne.0.and.izsym.eq.0) then
          do ivox=1,nvoxcopy_t

            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)

            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=-bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

        else if (izsym.ne.0.and.iysym.eq.0) then

          do ivox=1,nvoxcopy_t
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=-bpemag(3,icorn,iplan,ivox)
                htup(9)=bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

        else if (izsym.ne.0.and.iysym.ne.0) then

          do ivox=1,nvoxcopy_t !izsym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=-bpemag(3,icorn,iplan,ivox)
                htup(9)=bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t !iysym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+2*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=-bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t !iysym and izsym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+3*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=-bpemag(2,icorn,iplan,ivox)
                htup(8)=-bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

        endif !(izsym.ne.) then

      else !:ixsym.eq.0

        if (iysym.eq.0.and.izsym.eq.0) then

          do ivox=1,nvoxcopy_t
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=xsymmm_t+(xsymmm_t-bpemag(1,icorn,iplan,ivox))
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

        else if (iysym.ne.0.and.izsym.eq.0) then

          do ivox=1,nvoxcopy_t
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=2.0d0*xsymmm_t-bpemag(1,icorn,iplan,ivox)
                htup(7)=-bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+2*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=-bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+3*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=2.0d0*xsymmm_t-bpemag(1,icorn,iplan,ivox)
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

        else if (izsym.ne.0.and.iysym.eq.0) then

          do ivox=1,nvoxcopy_t
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                !x1y1z2
                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=-bpemag(3,icorn,iplan,ivox)
                htup(9)=bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                !x2y1z1
                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+2*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=xsymmm_t+(xsymmm_t-bpemag(1,icorn,iplan,ivox))
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                !x2y1z2
                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+3*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=xsymmm_t+(xsymmm_t-bpemag(1,icorn,iplan,ivox))
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=-bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

        else if (izsym.ne.0.and.iysym.ne.0) then

          do ivox=1,nvoxcopy_t !izsym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                !x1y1z2
                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=-bpemag(3,icorn,iplan,ivox)
                htup(9)=bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t !iysym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                !x1y2z2
                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+2*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=-bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t !iysym and izsym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                !x1y2z2
                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+3*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=bpemag(1,icorn,iplan,ivox)
                htup(7)=-bpemag(2,icorn,iplan,ivox)
                htup(8)=-bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t !izsym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                !x2y1z1
                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+4*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=2.0d0*xsymmm_t-bpemag(1,icorn,iplan,ivox)
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t !iysym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+5*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=2.0d0*xsymmm_t-bpemag(1,icorn,iplan,ivox)
                htup(7)=-bpemag(2,icorn,iplan,ivox)
                htup(8)=bpemag(3,icorn,iplan,ivox)
                htup(9)=bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t !iysym and izsym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+6*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=2.0d0*xsymmm_t-bpemag(1,icorn,iplan,ivox)
                htup(7)=-bpemag(2,icorn,iplan,ivox)
                htup(8)=-bpemag(3,icorn,iplan,ivox)
                htup(9)=bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

          do ivox=1,nvoxcopy_t !izsym
            tvc=t_voxcopy(ivox)
            kvox=tvc%kproto
            kmag=tvc%kproto
            imag=tvc%kmagnet
            tmc=t_magcopy(imag)
            do iplan=1,ibpeplan(ivox)
              do icorn=1,ibpecorn(iplan,ivox)

                htup(1)=bpebc(15,ivox)
                htup(2)=ivox+7*nvoxcopy_t
                htup(3)=ibpecol(ivox)
                htup(4)=iplan
                htup(5)=icorn*sign(1,ibpecorn(iplan,ivox))
                htup(6)=2.0d0*xsymmm_t-bpemag(1,icorn,iplan,ivox)
                htup(7)=bpemag(2,icorn,iplan,ivox)
                htup(8)=-bpemag(3,icorn,iplan,ivox)
                htup(9)=-bpebc(4,ivox)
                htup(10)=bpebc(5,ivox)
                htup(11)=-bpebc(6,ivox)
                htup(12)=bpebc(9,ivox)

                vmaglab(1)=bpebc(4,ivox)
                vmaglab(2)=bpebc(5,ivox)
                vmaglab(3)=bpebc(6,ivox)

                bc=sqrt(vmaglab(1)**2+vmaglab(2)**2+vmaglab(3)**2)
                bpebc(7,ivox)=bc

                if (bc.ne.0.0d0.or.t_magnets(kmag)%IsPole.ne.0) then
                  do i=5,10
                    if (abs(htup(i)).lt.1.0d-15) htup(i)=1.0d-15
                  enddo
                  write(cline,'(5f9.0,6e15.5e3,f7.0)')htup
                  cline=trim(cline) // " " // trim(tmc%cnam) // " " //
     &              trim(tmc%cmoth)
                  if (t_magnets(kmag)%IsPole.ne.0) then
                    write(luno,'(a)') trim(cline) // " 1"
                  else
                    write(luno,'(a)') trim(cline) // " 0"
                  endif
                endif !BC

              enddo !ncorn
            enddo !nplan
          enddo !nvoxcopy_t

        endif !(izsym.ne.) then

      endif !(ixsym.eq.0) then

19    close(luno)

      return
      end
+DECK,clcmag_bpolyplot.
*CMZ :  2.04/10 23/08/2023  16.06.46  by  Michael Scheer
*CMZ :  2.04/09 16/08/2023  09.50.47  by  Michael Scheer
*CMZ :  2.04/07 07/08/2023  12.29.11  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  17.12.50  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  14.10.28  by  Michael Scheer
*CMZ :  2.03/00 23/07/2022  08.30.04  by  Michael Scheer
*CMZ :  2.02/02 18/02/2022  10.24.23  by  Michael Scheer
*CMZ :  2.02/01 30/01/2022  08.39.29  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  13.07.52  by  Michael Scheer
*CMZ :  2.01/02 25/04/2018  11.48.35  by  Michael Scheer
*CMZ :  1.25/01 19/03/2018  16.23.08  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.02.34  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.20.09  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  12.45.15  by  Michael Scheer
*CMZ :  1.17/08 27/05/2017  10.32.42  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  14.33.44  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.09.14  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.50  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.39.32  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.47.10  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.49.25  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.46.16  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.01.00  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  13.31.06  by  Michael Scheer
*CMZ :  1.02/01 08/09/2016  15.25.02  by  Michael Scheer
*CMZ :  1.02/00 23/08/2016  12.01.08  by  Michael Scheer
*CMZ :  0.00/13 31/07/2016  16.05.11  by  Michael Scheer
*CMZ :  0.00/01 25/04/2016  15.07.20  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.27.40  by  Michael Scheer
*CMZ :  1.17/02 09/10/2014  14.52.20  by  Michael Scheer
*CMZ :  1.17/01 03/10/2014  11.25.46  by  Michael Scheer
*CMZ :  1.17/00 25/08/2014  15.14.09  by  Michael Scheer
*CMZ :  1.16/04 16/04/2014  15.34.26  by  Michael Scheer
*CMZ :  1.16/01 14/03/2014  12.26.15  by  Michael Scheer
*CMZ :  1.12/16 01/06/2007  11.17.50  by  Michael Scheer
*CMZ :  1.12/08 02/08/2006  17.03.41  by  Michael Scheer
*CMZ :  1.11/03 21/06/2005  12.56.55  by  Michael Scheer
*CMZ :  1.11/01 01/03/2005  09.45.36  by  Michael Scheer
*CMZ :  1.10/04 25/02/2005  11.55.05  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  08.54.30  by  Michael Scheer
*CMZ :  1.01/01 11/08/2004  13.30.53  by  Michael Scheer
*CMZ :  1.01/00 02/03/2004  17.00.13  by  Michael Scheer
*CMZ :  1.00/01 27/02/2004  14.29.35  by  Michael Scheer
*CMZ :  1.00/00 26/02/2004  17.21.29  by  Michael Scheer
*CMZ :  0.99/13 26/02/2004  16.14.57  by  Michael Scheer
*CMZ :  0.99/12 26/02/2004  12.02.34  by  Michael Scheer
*CMZ :  0.99/11 25/02/2004  15.21.06  by  Michael Scheer
*CMZ :  0.99/10 25/02/2004  13.42.35  by  Michael Scheer
*CMZ :  0.99/09 20/02/2004  17.26.48  by  Michael Scheer
*CMZ :  0.99/08 20/02/2004  16.32.55  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  15.21.29  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  13.55.05  by  Michael Scheer
*CMZ :  0.99/00 26/01/2004  17.03.49  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  12.52.23  by  Michael Scheer
*CMZ :  0.00/07 16/01/2004  11.05.44  by  Michael Scheer
*CMZ :  0.00/06 09/01/2004  15.55.17  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  14.52.54  by  Michael Scheer
*CMZ :  0.00/04 23/12/2003  10.15.07  by  Michael Scheer
*CMZ :  0.00/02 15/12/2003  12.43.34  by  Michael Scheer
*CMZ :  0.00/01 10/12/2003  17.56.52  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine clcmag_bpolyplot(iplot,xmin,xmax,ymin,ymax,zmin,zmax,
     &  theta,phi,nwitems,ncwires,wire)

+seq,bpolyederf90u.

      use commandlinef90m
      use magnets_structure

      implicit none

+seq,mshplt.
+seq,bpolyeder,if=static.

      integer npawp
      parameter (npawp=10000)

      integer nwitems,ncwires
      double precision wire(nwitems,ncwires)

      real, dimension (:), allocatable :: rmothb,rmagb,rcolb,rplanb,rcornb,
     &  xb,yb,zb,bxb,byb,bzb,rmatb

      real, dimension (:), allocatable :: xpl,ypl,zpl,zplm,xmpl,ympl,zmpl
      integer, dimension (:), allocatable :: ispole

      real
     &  xplb(2),yplb(2),zplb(2),xt(1),yt(1),zt(1),
     &  xplbo(2),yplbo(2),zplbo(2),rmtyp31,rmtyp24,rmtyp20,rlwidth,rlwidtho

      real xyzmin,xyzmax,xmin,xmax,ymin,ymax,zmin,zmax,theta,phi,
     &  x,y,z,bx,by,bz,dx,dy,dz,bxo,byo,bzo,bo,eps,
     &  xmn,xmx,ymn,ymx,zmn,zmx,
     &  xmmn,xmmx,ymmn,ymmx,zmmn,zmmx,
     &  xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &  rmoth,rmag,rcol,rplan,rcorn,rmat,
     &  xc,yc,zc,xmc(1),ymc(1),zmc(1),dot0,circ0,pscal,vn,vnx,vnz

      integer i,iplot,iplot1,iplot10,iplot100,idev,
     &  imag,icol,iplan,icorn,kpole,
     &  iplano,ncorno,iline,iw,nline,iallo,
     &  ncorn,ncornmax,igird,imago,impl,izero,nfirst,nlast

      integer luncnf,lunmag

      character(64) ctitle,cline
      character(32), dimension(:), allocatable ::  cnam,cmoth

      data dot0/25./
      data circ0/5./
      data rmtyp20/20./
      data rmtyp24/-9999./
      data rmtyp31/31./

      data eps/0.01/

      iallo=0

      write(lun6,*)
      if (kunduplot_mode.eq.0) then
        write(lun6,*) "Reading file undumag.mag and writing geometry to plotfile undumag.eps"
      else
        write(lun6,*) "Reading file undumag.mag and writing geometry to plotfile undumag_3d.eps"
      endif
      write(lun6,*)

      open(newunit=luncnf,file='.mshplt.cnf')

      write(luncnf,'(a)')"0 !idev, 0: viewer is not used"
      write(luncnf,'(a)')"-20. -20. !plot size in cm, negative values indicate HIGZ compatible mode"
      write(luncnf,'(a)')"0.8 !rescaling factor; if not one, plot files are copied and rescaled"
      write(luncnf,'(a)')"0 0 800 800 !bounding box"
      if (kunduplot_mode.ne.0) then
        write(luncnf,'(a)')"undumag_3d.eps !base name of plotfiles"
      else
        write(luncnf,'(a)')"undumag.eps !base name of plotfiles"
      endif
      write(luncnf,'(a)')"$UNDUMAG/shell/undumag_viewer.sh"
      write(luncnf,'(a)')"$UNDUMAG/shell/undumag_kill_viewer.sh"

      close(luncnf)

      iplano=0
      nline=0

      xmn=sngl(xmin_t)
      xmx=sngl(xmax_t)
      ymn=sngl(ymin_t)
      ymx=sngl(ymax_t)
      zmn=sngl(zmin_t)
      zmx=sngl(zmax_t)

      if (jrunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      ncornmax=ncornmax_t
      if (ncwires.gt.0) then
        ncornmax=max(2,ncornmax_t)
      endif

      open(newunit=lunmag,file='undumag.mag',status='old')
      read(lunmag,'(a)')cline
1     read(lunmag,*,end=9) rmoth,rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz,rmat
      if (bx**2+by**2+bz**2.eq.0.0d0) goto 1
      nline=nline+1
      goto 1
9     rewind(lunmag)

      allocate(
     &  rmothb(nline),rmagb(nline),rcolb(nline),rplanb(nline),rcornb(nline),
     &  xb(nline),yb(nline),zb(nline),bxb(nline),byb(nline),bzb(nline),
     &  rmatb(nline),cnam(nline),cmoth(nline),ispole(nline))

      read(lunmag,'(a)')cline

      do i=1,nline
        read(lunmag,*)
     &  rmothb(i),rmagb(i),rcolb(i),rplanb(i),rcornb(i),
     &  xb(i),yb(i),zb(i),bxb(i),byb(i),bzb(i),
     &    rmatb(i),cnam(i),cmoth(i),ispole(i)
        if (rmatb(i).eq.0) then
          bxb(i)=0.0
          byb(i)=0.0
          bzb(i)=0.0
        endif
        imag=nint(rmagb(i))
        ispole(imag)=ispole(i)
      enddo

      close(lunmag)

      if (ncornmax.eq.0.and.ncwires.le.0) then
        write(lun6,*)"*** Warning in clcmag_bpolyplot: Nothing to plot!?"
        goto 9999
      endif

      allocate(xpl(ncornmax))
      allocate(ypl(ncornmax))
      allocate(zpl(ncornmax))
      allocate(zplm(ncornmax))

      allocate(xmpl(ncornmax*nplanmax_t))
      allocate(ympl(ncornmax*nplanmax_t))
      allocate(zmpl(ncornmax*nplanmax_t))

      iallo=1

      call mlimit(npawp)

      if (jdate.ne.0) then
        call mplopt('DATE',1)
      else
        call mplopt('NDAT',1)
      endif

      call mplint(idev)

      if (jdate.ne.0) then
        call mplopt('DATE',1)
      else
        call mplopt('NDAT',1)
      endif

      call mplset('YGTI',0.)
      call mplset('GSIZ',0.3)
      call mgset('TXCI',1.)

      iplot100=abs(iplot)/100
      iplot10=(abs(iplot)-iplot100*100)/10
      iplot1=abs(iplot)-iplot100*100-iplot10*10

      call mshplt_get_line_width(rlwidtho)
      rlwidth=rlwidtho
      call mshplt_set_line_width(rlwidtho/2.)

c--- Open plotfiles {

      if (iplot.gt.0) then

        if (idev.ne.0) then
          call mgmeta(98,-111)    !seite 22
        else
          call mgmeta(-98,-111)    !seite 22
        endif

      else if (iplot.lt.0) then

        if (idev.ne.0) then
          call mgmeta(98,-113)    !seite 22
        else
          call mgmeta(-98,-113)    !seite 22
        endif

      endif !iplot

c--- Open plotfiles }

      iplano=1

      if (xmin.eq.9999.) then
        xplmin=xmn
      else
        xplmin=xmin
      endif

      if (xmax.eq.9999.) then
        xplmax=xmx
      else
        xplmax=xmax
      endif

      if (ymin.eq.9999.) then
        yplmin=ymn
      else
        yplmin=ymin
      endif

      if (ymax.eq.9999.) then
        yplmax=ymx
      else
        yplmax=ymax
      endif

      if (zmin.eq.9999.) then
        zplmin=zmn
      else
        zplmin=zmin
      endif

      if (zmax.eq.9999.) then
        zplmax=zmx
      else
        zplmax=zmax
      endif

      if (nbforcx*nbforcy*nbforcy.ne.0) then
        dx=(sngl(outbox(2,1))-sngl(outbox(1,1)))*0.1
        if (xplmin.ge.sngl(outbox(1,1))) xplmin=sngl(outbox(1,1))-dx
        if (xplmax.le.sngl(outbox(2,1))) xplmax=sngl(outbox(2,1))+dx
        dy=(sngl(outbox(2,2))-sngl(outbox(1,2)))*0.1
        if (yplmin.ge.sngl(outbox(1,2))) yplmin=sngl(outbox(1,2))-dy
        if (yplmax.le.sngl(outbox(2,2))) yplmax=sngl(outbox(2,2))+dy
        dz=(sngl(outbox(2,3))-sngl(outbox(1,3)))*0.1
        if (zplmin.ge.sngl(outbox(1,3))) zplmin=sngl(outbox(1,3))-dz
        if (zplmax.le.sngl(outbox(2,3))) zplmax=sngl(outbox(2,3))+dz
      endif

      dx=(xplmax-xplmin)*0.05
      if (xmin.eq.9999.) then
        xplmin=xplmin-dx
      endif

      if (xmax.eq.9999.) then
        xplmax=xplmax+dx
      endif

      dy=(yplmax-yplmin)*0.05
      if (ymin.eq.9999.) then
        yplmin=yplmin-dy
      endif

      if (ymax.eq.9999.) then
        yplmax=yplmax+dy
      endif

      dz=(zplmax-zplmin)*0.05
      if (zmin.eq.9999.) then
        zplmin=zplmin-dz
      endif

      if (zmax.eq.9999.) then
        zplmax=zplmax+dz
      endif

      if (dx.eq.0.0d0) then
        dx=1.05
        xplmin=xplmin-dx
        xplmax=xplmax+dx
      endif

      if (dy.eq.0.0d0) then
        dy=1.05
        yplmin=yplmin-dy
        yplmax=yplmax+dy
      endif

      if (dz.eq.0.0d0) then
        dz=1.05
        zplmin=zplmin-dz
        zplmax=zplmax+dz
      endif

      if (xplmax.le.xplmin.or.zplmax.le.zplmin.or.zplmax.le.zplmin) then
        write(lun6,*)'*** Warning in clcmag_bpolyplot: Bad coordinate system for plotting '
        goto 9999
      endif

      pscal=min(3.,sqrt(10000./((xplmax-xplmin)*(zplmax-zplmin))))

c--- 3D, top and side views {

      if (jcomment.ne.0) call mtitle(trim(ctitle))

      if (kunduplot_mode.eq.0) then
        call mplset('YMGL',0.5)
        call mplzon(1,1,1,' ')
        call mplfra(0.,10.,0.,10.,'AB')

        call mgset('CHHE',0.4)
        xpl(1)=0.2
        ypl(1)=6.

        xpl(2)=xpl(1)+cosd(phi)*cosd(theta)*0.8
        ypl(2)=ypl(1)+sind(phi)*cosd(theta)*0.8
        call mpl(2,xpl,ypl)
        dx=xpl(2)-xpl(1)
        dy=ypl(2)-ypl(1)
        call mtx(xpl(1)+dx*1.2,ypl(1)+dy*1.2,'x')

        xpl(2)=xpl(1)
        ypl(2)=ypl(1)+cosd(theta)*0.8
        call mpl(2,xpl,ypl)
        dx=xpl(2)-xpl(1)
        dy=ypl(2)-ypl(1)
        call mtx(xpl(1)+dx*1.2,ypl(1)+dy*1.2,'y')

        xpl(2)=xpl(1)+sind(phi)*cosd(theta)*0.8
        ypl(2)=ypl(1)-cosd(phi)*cosd(theta)*0.8
        call mpl(2,xpl,ypl)
        dx=xpl(2)-xpl(1)
        dy=ypl(2)-ypl(1)
        call mtx(xpl(1)+dx*1.2,ypl(1)+dy*1.2,'z')

        call mgset('CHHE',0.5)
        call mtx(4.1,4.7,'upper magnets')
        call mtx(4.1,1.8,'lower magnets')
        call mgset('CHHE',0.4)
        call mtx(4.6,-0.75,'x[mm]')
        call mshplt_set_text_angle(90.)
        call mtx(-1.,2.4,'z[mm]')
        call mshplt_set_text_angle(0.)
        call mplset('YMGL',2.)
        call mplset('YMGL',0.5)
        call mgset('CHHE',0.4)
        call muwk(0,0)
        call mplzon(2,2,1,'S')
      else
        call mplset('YMGL',0.5)
        call mplzon(1,1,1,' ')
        call mgset('CHHE',0.4)
        if (theta.ne.0.0.or.phi.ne.0.0) then

          call mplfr3(0.,1.,0.,1.,0.,1.,theta,phi,'W')
          call mplfra(0.,1.,0.,1.,'AB')

          xpl(1)=0.2
          xpl(2)=0.3
          ypl(1)=0.0
          ypl(2)=0.0
          zpl(1)=0.0
          zpl(2)=0.0
          xt(1)=xpl(1)+(xpl(2)-xpl(1))*1.3
          yt(1)=ypl(1)+(ypl(2)-ypl(1))*1.3
          zt(1)=zpl(1)+(zpl(2)-zpl(1))*1.3
          call mshplt_3dto2d(1,xt,-zt,yt,xt,zt)
          call mtx(xt(1),zt(1),'x')
          call mshplt_3dto2d(2,xpl,-zpl,ypl,xpl,ypl)
          call mpl(2,xpl,ypl)

          xpl(1)=0.2
          xpl(2)=0.2
          ypl(1)=0.0
          ypl(2)=0.1
          zpl(1)=0.0
          zpl(2)=0.0
          xt(1)=xpl(1)+(xpl(2)-xpl(1))*1.3
          yt(1)=ypl(1)+(ypl(2)-ypl(1))*1.3
          zt(1)=zpl(1)+(zpl(2)-zpl(1))*1.3
          call mshplt_3dto2d(1,xt,-zt,yt,xt,zt)
          call mtx(xt(1),zt(1),'y')
          call mshplt_3dto2d(2,xpl,-zpl,ypl,xpl,ypl)
          call mpl(2,xpl,ypl)

          xpl(1)=0.2
          xpl(2)=0.2
          ypl(1)=0.0
          ypl(2)=0.0
          zpl(1)=0.0
          zpl(2)=0.1
          xt(1)=xpl(1)+(xpl(2)-xpl(1))*1.3
          yt(1)=ypl(1)+(ypl(2)-ypl(1))*1.3
          zt(1)=zpl(1)+(zpl(2)-zpl(1))*1.3
          call mshplt_3dto2d(1,xt,-zt,yt,xt,zt)
          call mtx(xt(1),zt(1),'z')
          call mshplt_3dto2d(2,xpl,-zpl,ypl,xpl,ypl)
          call mpl(2,xpl,ypl)
          call muwk(0,0)

        endif
        call mplzon(1,1,1,'S')
      endif

      iplano=1

c y is vertical (WAVE-system)
      if (theta.eq.0.0.and.phi.eq.0.0) then

        !call mplfra(xplmin,xplmax,yplmin,yplmax,' ')
        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'x[mm]','y[mm]',' ')
        !call mplax('x (mm)', 'y (mm)')
        !call muwk(0,0)

        if (nbforcx*nbforcy*nbforcz.ne.0)
     &    call undumag_bpolypl2(forxpl,forypl,forcol,12)

        do iline=1,nline

          x=xb(iline)
          y=yb(iline)
          z=zb(iline)
          bx=bxb(iline)
          by=byb(iline)
          bz=bzb(iline)

          if (bx**2+by**2+bz**2.eq.0.0d0) cycle

          imag=nint(rmagb(iline))
          icol=nint(rcolb(iline))
          iplan=nint(rplanb(iline))
          icorn=nint(rcornb(iline))

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &          xpl(i).lt.xplmin.or.
     &          xpl(i).gt.xplmax.or.
     &          ypl(i).lt.yplmin.or.
     &          ypl(i).gt.yplmax.or.
     &          zpl(i).lt.zplmin.or.
     &          zpl(i).gt.zplmax
     &          ) cycle
            enddo

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mshplt_set_line_width(rlwidth/5.)
            call mgset('PLCI',1.)
            call mpl(ncorno,xpl,ypl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*5.0*rlwidth
              ypl(i)=ypl(i)+(yc-ypl(i))*5.0*rlwidth
              zpl(i)=zpl(i)+(zc-zpl(i))*5.0*rlwidth
              zplm(i)=-zpl(i)
            enddo

            call mshplt_set_line_width(rlwidth/2.)
            call mgset('PLCI',rcol)
            call mpl(ncorno,xpl,ypl)

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)

        enddo !nline

        call mshplt_set_line_width(rlwidth*2.)
        do iw=1,ncwires
          rcol=sngl(wire(9,iw))
          call mgset('PLCI',rcol)
          xpl(1)=sngl(wire(3,iw))
          xpl(2)=sngl(wire(6,iw))
          ypl(1)=sngl(wire(4,iw))
          ypl(2)=sngl(wire(7,iw))
          call mpl(2,xpl,ypl)
        enddo
        call mshplt_set_line_width(rlwidth/2.)

      else !:if (theta.eq.0.0.and.phi.eq.0.0) then

        xyzmin=min(xplmin,yplmin,zplmin)*0.8
        xyzmax=max(xplmax,yplmax,zplmax)*0.8

        !dx=(xyzmax-xyzmin)*0.1*0.0
c        call mplfr3(xyzmin,xyzmax,
c     &    -xyzmax,-xyzmin,
c     &    xyzmin,xyzmax,theta,phi,'W')

        !call mplfr3(xplmin,xplmax,zplmin,zplmax,yplmin,yplmax,theta,phi,'W')
        call mplfr3(xyzmin,xyzmax,xyzmin,xyzmax,xyzmin,xyzmax,theta,phi,'W')
        !goto 9999

        do iline=1,nline

          x=xb(iline)
          y=yb(iline)
          z=zb(iline)
          bx=bxb(iline)
          by=byb(iline)
          bz=bzb(iline)

          if (bx**2+by**2+bz**2.eq.0.0d0) cycle

          imag=nint(rmagb(iline))
          icol=nint(rcolb(iline))
          iplan=nint(rplanb(iline))
          icorn=nint(rcornb(iline))

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &          xpl(i).lt.xplmin.or.
     &          xpl(i).gt.xplmax.or.
     &          ypl(i).lt.yplmin.or.
     &          ypl(i).gt.yplmax.or.
     &          zpl(i).lt.zplmin.or.
     &          zpl(i).gt.zplmax
     &          ) cycle
            enddo

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',1.)
            call mpl3(ncorno,xpl,zplm,ypl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*0.015*rcol
              ypl(i)=ypl(i)+(yc-ypl(i))*0.015*rcol
              zpl(i)=zpl(i)+(zc-zpl(i))*0.015*rcol
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',rcol)
            call mpl3(ncorno,xpl,zplm,ypl)

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)

        enddo !nline

        call mshplt_set_line_width(rlwidth*2.)
        do iw=1,ncwires
          rcol=sngl(wire(9,iw))
          call mgset('PLCI',rcol)
          xpl(1)=sngl(wire(3,iw))
          xpl(2)=sngl(wire(6,iw))
          ypl(1)=sngl(wire(4,iw))
          ypl(2)=sngl(wire(7,iw))
          zpl(1)=-sngl(wire(5,iw))
          zpl(2)=-sngl(wire(8,iw))
          call mpl3(2,xpl,zpl,ypl)
        enddo
        call mshplt_set_line_width(rlwidth/2.)

      endif !(theta.eq.0.0.and.phi.eq.0.0) then

      call muwk(0,0)

      if (kunduplot_mode.ne.0) goto 9999

c--- 3D }

c--- y vs z or z vs y {

      !call mplfra(zplmin,zplmax,yplmin,yplmax,' ')
      !call mplax('z (mm)', 'y (mm)')
      call mshplt_frame(zplmin,zplmax,yplmin,yplmax,'z[mm]','y[mm]',' ')
      if (nbforcx*nbforcy*nbforcz.ne.0)
     &  call undumag_bpolypl2(forzpl,forypl,forcol,23)

      iplano=1

      do iline=1,nline

        x=xb(iline)
        y=yb(iline)
        z=zb(iline)
        bx=bxb(iline)
        by=byb(iline)
        bz=bzb(iline)

        if (bx**2+by**2+bz**2.eq.0.0d0) cycle

        imag=nint(rmagb(iline))
        icol=nint(rcolb(iline))
        iplan=nint(rplanb(iline))
        icorn=nint(rcornb(iline))

        ncorn=abs(icorn)

        if (iline.eq.nline) then

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)

        endif !(iline.eq.nline

        if(iplan.ne.iplano.or.iline.eq.nline) then

          do i=1,ncorno
            zplm(i)=-zpl(i)
          enddo

          call mshplt_set_line_width(rlwidth/5.)
          call mgset('PLCI',1.)
          call mpl(ncorno,zpl,ypl)

          xc=0.
          yc=0.
          zc=0.

          do i=1,ncorno-1
            xc=xc+xpl(i)
            yc=yc+ypl(i)
            zc=zc+zpl(i)
          enddo

          xc=xc/(ncorno-1)
          yc=yc/(ncorno-1)
          zc=zc/(ncorno-1)

          izero=0
          do i=1,ncorno
            if (
     &        abs(yc-ypl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &        ) izero=1
            xpl(i)=xpl(i)+(xc-xpl(i))*2.0*rlwidth
            ypl(i)=ypl(i)+(yc-ypl(i))*2.0*rlwidth
            zpl(i)=zpl(i)+(zc-zpl(i))*2.0*rlwidth
            zplm(i)=-zpl(i)
          enddo

          call mgset('PLCI',rcol)

          if (izero.ne.0) call mpl(ncorno,zpl,ypl)

        endif !iplano

        xpl(ncorn)=x
        ypl(ncorn)=y
        zpl(ncorn)=z

        iplano=iplan
        ncorno=ncorn
        rcol=rcolb(iline)

      enddo !nline

      call mshplt_set_line_width(rlwidth*2.)
      do iw=1,ncwires
        rcol=sngl(wire(9,iw))
        call mgset('PLCI',rcol)
        xpl(1)=sngl(wire(3,iw))
        xpl(2)=sngl(wire(6,iw))
        ypl(1)=sngl(wire(4,iw))
        ypl(2)=sngl(wire(7,iw))
        zpl(1)=sngl(wire(5,iw))
        zpl(2)=sngl(wire(8,iw))
        call mpl(2,zpl,ypl)
      enddo
      call mshplt_set_line_width(rlwidth/2.)

      call mshplt_set_line_width(rlwidtho)

      if (nbforcx*nbforcy*nbforcz.ne.0)
     &  call undumag_bpolypl2(forzpl,forypl,forcol,23)

c--- y vs z or z vs y }

c--- top views of girder {

      call muwk(0,0)
      call mplzon(1,4,3,'S')

      do igird=1,2

c--- z vs x, y is vertical coordinate {
        !hier
        call mplfra(xplmin,xplmax,zplmin,zplmax,' ')
        !call mplax('x (mm)', 'z (mm)')
        !call mshplt_frame(xplmin,xplmax,zplmin,zplmax,'x[mm]','z[mm]',' ')

        if (nbforcx*nbforcy*nbforcz.ne.0)
     &    call undumag_bpolypl2(forxpl,forzpl,forcol,13)

        if (nline.gt.0) then
          imago=int(rmagb(nline))
          kpole=ispole(imago)
          iplano=1
          impl=0
        endif

        do iline=1,nline

          x=xb(iline)
          y=yb(iline)
          z=zb(iline)
          bx=bxb(iline)
          by=byb(iline)
          bz=bzb(iline)

          if (bx**2+by**2+bz**2.eq.0.0d0) cycle

          imag=nint(rmagb(iline))
          icol=nint(rcolb(iline))
          iplan=nint(rplanb(iline))
          icorn=nint(rcornb(iline))

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if (imag.ne.imago.or.iline.eq.nline) then

            xmc(1)=0.
            ymc(1)=0.
            zmc(1)=0.

            xmmx=-1.0e30
            xmmn= 1.0e30
            ymmx=-1.0e30
            ymmn= 1.0e30
            zmmx=-1.0e30
            zmmn= 1.0e30

            do i=1,impl-1
              xmc(1)=xmc(1)+xmpl(i)
              ymc(1)=ymc(1)+ympl(i)
              zmc(1)=zmc(1)+zmpl(i)
              if (xmpl(i).gt.xmmx) xmmx=xmpl(i)
              if (xmpl(i).lt.xmmn) xmmn=xmpl(i)
              if (ympl(i).gt.ymmx) ymmx=ympl(i)
              if (ympl(i).lt.ymmn) ymmn=ympl(i)
              if (zmpl(i).gt.zmmx) zmmx=zmpl(i)
              if (zmpl(i).lt.zmmn) zmmn=zmpl(i)
            enddo

            xmc(1)=xmc(1)/(impl-1)
            ymc(1)=ymc(1)/(impl-1)
            zmc(1)=zmc(1)/(impl-1)

            dx=xmmx-xmmn
            dy=ymmx-ymmn
            dz=zmmx-zmmn

            impl=0

          endif !imag.ne.imago

          impl=impl+1

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            xmpl(impl)=x
            ympl(impl)=y
            zmpl(impl)=z

            bxo=bx
            byo=by
            bzo=bz

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            if (igird.eq.1.and.yc.ge.0.0) then

              do i=1,ncorno
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',1.)
              call mpl(ncorno,xpl,zpl)

              izero=0
              do i=1,ncorno
                if (
     &            abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &            ) izero=1
                xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcol
                ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcol
                zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcol
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcol)
              if (izero.ne.0) call mpl(ncorno,xpl,zpl)

              if (imag.ne.imago.or.iline.eq.nline) then

                bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                if (abs(bxo).lt.bo*eps) bxo=0.0
                if (abs(byo).lt.bo*eps) byo=0.0
                if (abs(bzo).lt.bo*eps) bzo=0.0

                xplb(1)=xmc(1)-2.*bxo/bo*dx/6.
                xplb(2)=xmc(1)+2.*bxo/bo*dx/6.
                yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                zplb(1)=zmc(1)-2.*bzo/bo*dz/5.
                zplb(2)=zmc(1)+2.*bzo/bo*dz/5.

                xplbo(1)=xplb(1)
                xplbo(2)=xplb(2)
                yplbo(1)=yplb(1)
                yplbo(2)=yplb(2)
                zplbo(1)=zplb(1)
                zplbo(2)=zplb(2)

                if (kpole.eq.0) call mpl(2,xplbo,zplbo)

                vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                if (vn.ne.0.0d0) then

                  vnx=(xplbo(2)-xplbo(1))/vn
                  vnz=(zplbo(2)-zplbo(1))/vn

                  xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                  xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                endif !vn

                if (byo.gt.1.e-9) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp20)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                else if (byo.lt.0.0) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp31)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                endif

              endif !imago

            else if (igird.eq.2.and.yc.le.0.0) then

              do i=1,ncorno
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',1.)
              call mpl(ncorno,xpl,zpl)

              izero=0
              do i=1,ncorno
                if (
     &            abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &            ) izero=1
                xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcol
                ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcol
                zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcol
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcol)
              if (izero.ne.0) call mpl(ncorno,xpl,zpl)

              if (imag.ne.imago.or.iline.eq.nline) then

                bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)
                if (abs(bxo).lt.bo*eps) bxo=0.0
                if (abs(byo).lt.bo*eps) byo=0.0
                if (abs(bzo).lt.bo*eps) bzo=0.0

                xplb(1)=xmc(1)-2.*bxo/bo*dx/6.
                xplb(2)=xmc(1)+2.*bxo/bo*dx/6.
                yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                zplb(1)=zmc(1)-2.*bzo/bo*dz/5.
                zplb(2)=zmc(1)+2.*bzo/bo*dz/5.

                xplbo(1)=xplb(1)
                xplbo(2)=xplb(2)
                yplbo(1)=yplb(1)
                yplbo(2)=yplb(2)
                zplbo(1)=zplb(1)
                zplbo(2)=zplb(2)

                if (kpole.eq.0) call mpl(2,xplbo,zplbo)

                vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                if (vn.ne.0.0d0) then

                  vnx=(xplbo(2)-xplbo(1))/vn
                  vnz=(zplbo(2)-zplbo(1))/vn

                  xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                  xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                endif !vn

                if (byo.gt.1.e-9) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp20)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                else if (byo.lt.0.0) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp31)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                endif

              endif !imago

            endif !yc

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          xmpl(impl)=x
          ympl(impl)=y
          zmpl(impl)=z

          bxo=bx
          byo=by
          bzo=bz

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)
          imago=imag
          kpole=ispole(imago)

        enddo !nline

        if (nbforcx*nbforcy*nbforcz.ne.0) call undumag_bpolypl2(forxpl,forzpl,forcol,13)

        if (igird.eq.1) then
          call mshplt_set_line_width(rlwidth*2.)
          do iw=1,ncwires
            rcol=sngl(wire(9,iw))
            call mgset('PLCI',rcol)
            xpl(1)=sngl(wire(3,iw))
            xpl(2)=sngl(wire(6,iw))
            ypl(1)=sngl(wire(4,iw))
            ypl(2)=sngl(wire(7,iw))
            zpl(1)=sngl(wire(5,iw))
            zpl(2)=sngl(wire(8,iw))
            if (ypl(1).gt.0.0.or.ypl(2).gt.0.0) call mpl(2,xpl,zpl)
          enddo
          call mshplt_set_line_width(rlwidth/2.)
        else
          call mshplt_set_line_width(rlwidth*2.)
          do iw=1,ncwires
            rcol=sngl(wire(9,iw))
            call mgset('PLCI',rcol)
            xpl(1)=sngl(wire(3,iw))
            xpl(2)=sngl(wire(6,iw))
            ypl(1)=sngl(wire(4,iw))
            ypl(2)=sngl(wire(7,iw))
            zpl(1)=sngl(wire(5,iw))
            zpl(2)=sngl(wire(8,iw))
            if (ypl(1).lt.0.0.or.ypl(2).lt.0.0) call mpl(2,xpl,zpl)
          enddo
          call mshplt_set_line_width(rlwidth/2.)
        endif

      enddo !igird

      call muwk(0,0)

c--- y vs x }

c--- top views of girder}

c--- 3D, top and side views }

9999  continue

      if (iallo.eq.1) then
        deallocate(xpl)
        deallocate(ypl)
        deallocate(zpl)
        deallocate(zplm)
        deallocate(xmpl)
        deallocate(ympl)
        deallocate(zmpl)
      endif

c      call mgmeta(0,0)
c      call mplend

      call mshplt_end

      write(lun6,*)"Done"
      write(lun6,*)

      deallocate(rmothb,rmagb,rcolb,rplanb,rcornb,
     &  xb,yb,zb,bxb,byb,bzb,rmatb)

      return
      end
+DECK,clcmag_drop_zero_magnets.
*CMZ :  2.04/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.03/00 23/07/2022  09.34.17  by  Michael Scheer
*CMZ :  2.02/01 26/01/2022  20.00.07  by  Michael Scheer
*-- Author :    Michael Scheer   25/10/2021
      subroutine clcmag_drop_zero_magnets

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure

      implicit none

      ! Drop zero magnets
      ! At entrance xhull,yhull,zhull refer to lab-system.
      ! At exit to gcen of the magnet or pole

      type (T_Magnet) tmag

      integer nmagl,nspecl,mmag,imag,ipoi

+self,if=trace.
      print*,"-trace-: Entered clcmag_drop_zero_magnets"
+self.

      nmagl=0
      nspecl=0
      nmagtot_t=nmag_t+nspecmag_t

      mmag=0
      do imag=1,nmagtot_t

        tmag=t_magnets(imag)
+self,if=trace.
        print*,"-trace-:: imag:",imag
        print*,tmag%brn
        print*,""
+self.

        if (tmag%IsPole.eq.0.and.tmag%Brn.eq.0.0d0.or.tmag%imat.eq.0) cycle

        if (tmag%Isspecial.eq.0) then
          nmagl=nmagl+1
        else
          nspecl=nspecl+1
        endif

        mmag=mmag+1

        do ipoi=1,tmag%nhull
          tmag%xhull(ipoi)=tmag%xhull(ipoi)-tmag%gcen(1)
          tmag%yhull(ipoi)=tmag%yhull(ipoi)-tmag%gcen(2)
          tmag%zhull(ipoi)=tmag%zhull(ipoi)-tmag%gcen(3)
        enddo

        t_magnets(mmag)=tmag

      enddo !imag

      nmag_t=nmagl
      nspecmag_t=nspecl
      nmagtot_t=mmag

+self,if=trace.
      print*,"-trace-: Leaving clcmag_drop_zero_magnets"
+self.

      return
      end
+DECK,clcmag_cut_cyl.
*CMZ :  2.04/08 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/02 25/02/2023  17.21.35  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  18.33.07  by  Michael Scheer
*CMZ :  2.02/01 05/01/2022  11.09.38  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_cut_cyl(imag)

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      character(2048) cline

      double precision
     &  xp(8),yp(8),zp(8),phi,sp,cp,
     &  z1,z2,z3,z4,y1,y2,x1,x2,x3,x4,x0,y0,z0,ro,ri,r,h,
     &  radin,radout,height,angle,xyz(3),dphi,dr,dh

      integer khull(8),kedge(4,2*8-2),kface(5*8),ir,iphi,ih,npoi,i,ivox,
     &  nhull,nedge,nface,kfacelast,ifailhull,imag,nr,nang,nh

+seq,phyconparam.

      if (nmagcyl.le.0) return

      radin=t_magnets(imag)%size(1)
      radout=t_magnets(imag)%size(2)
      height=t_magnets(imag)%size(3)
      angle=t_magnets(imag)%cylphi

      if (coating.ne.0.0d0) then
        radin=radin+coating
        radout=radout-coating
        height=height-2.0d0*coating
        t_magnets(imag)%size(1)=radin
        t_magnets(imag)%size(2)=radout
        t_magnets(imag)%size(3)=height
      endif

      if (radin.lt.tiny) radin=tiny
      t_magnets(imag)%size(1)=radin

      xyz=t_magnets(imag)%xyz

      nr=t_magnets(imag)%nxdiv
      nang=t_magnets(imag)%nydiv
      nh=t_magnets(imag)%nzdiv

      allocate(t_magnets(imag)%t_voxels(nr*nang*nh))
      t_magnets(imag)%nvoxels=nr*nang*nh

      dphi=angle/nang*grarad1
      dr=(radout-radin)/nr
      dh=height/nh

      r=radin

      ivox=0
      r=radin+dr/2.0d0
      do ir=1,nr
        h=-height/2.0d0+dh/2.0d0
        do ih=1,nh
          phi=-angle/2.0d0*grarad1+dphi/2.0d0
          do iphi=1,nang

            ivox=ivox+1

            x0=r*sin(phi)
            y0=h
            z0=r*cos(phi)

            ri=r-dr/2.0d0
            ro=r+dr/2.0d0

            y1=y0-dh/2.0d0
            y2=y0+dh/2.0d0

            sp=sin(phi-dphi/2.0d0)
            cp=cos(phi-dphi/2.0d0)
            x1=ri*sp+coating*cp
            z1=ri*cp+coating*sp
            x2=ro*sp+coating*cp
            z2=ro*cp+coating*sp
            sp=sin(phi+dphi/2.0d0)
            cp=cos(phi+dphi/2.0d0)
            x3=ro*sp-coating*cp
            z3=ro*cp-coating*sp
            x4=ri*sp-coating*cp
            z4=ri*cp-coating*sp

            xp(1)=x1
            yp(1)=y1
            zp(1)=z1

            xp(2)=x2
            yp(2)=y1
            zp(2)=z2

            xp(3)=x3
            yp(3)=y1
            zp(3)=z3

            xp(4)=x4
            yp(4)=y1
            zp(4)=z4

            xp(5)=x1
            yp(5)=y2
            zp(5)=z1

            xp(6)=x2
            yp(6)=y2
            zp(6)=z2

            xp(7)=x3
            yp(7)=y2
            zp(7)=z3

            xp(8)=x4
            yp(8)=y2
            zp(8)=z4

            npoi=8

            call util_convex_hull_3d_overwrite(npoi,xp,yp,zp,
     &        khull,kedge,kface,
     &        nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

            if (ifailhull.ne.0.or.nhull.lt.6) then
              write(lun6,*)"*** Error in clcmag_cut_cyl: Subroutine util_convex_hull_3d failed for ",
     &          trim(cline)
              stop
            endif

            allocate(t_magnets(imag)%t_voxels(ivox)%xhull(nhull))
            allocate(t_magnets(imag)%t_voxels(ivox)%yhull(nhull))
            allocate(t_magnets(imag)%t_voxels(ivox)%zhull(nhull))
            allocate(t_magnets(imag)%t_voxels(ivox)%khull(nhull))
            allocate(t_magnets(imag)%t_voxels(ivox)%kface(5*4))
            allocate(t_magnets(imag)%t_voxels(ivox)%kedge(4,2*8-2))

            t_magnets(imag)%t_voxels(ivox)%nhull=nhull
            t_magnets(imag)%t_voxels(ivox)%khull=khull
            t_magnets(imag)%t_voxels(ivox)%nface=nface
            t_magnets(imag)%t_voxels(ivox)%kface=kface
            t_magnets(imag)%t_voxels(ivox)%kfacelast=kfacelast
            t_magnets(imag)%t_voxels(ivox)%nedge=nedge

            t_magnets(imag)%t_voxels(ivox)%IsBlock=t_magnets(imag)%IsBlock

            do i=1,nhull
              t_magnets(imag)%t_voxels(ivox)%xhull(i)=xp(i)+xyz(1)
              t_magnets(imag)%t_voxels(ivox)%yhull(i)=yp(i)+xyz(2)
              t_magnets(imag)%t_voxels(ivox)%zhull(i)=zp(i)+xyz(3)
            enddo

            phi=phi+dphi

          enddo !iphi

          h=h+dh

        enddo !ih

        r=r+dr

      enddo !ir

      return
      end
+DECK,clcmag_ini_force.
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 14/01/2022  12.54.16  by  Michael Scheer
*CMZ :  2.02/00 31/03/2021  20.30.51  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.27.23  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  16.04.15  by  Michael Scheer
*CMZ :  2.01/04 18/07/2019  13.56.54  by  Michael Scheer
*CMZ :  2.01/03 13/06/2019  15.03.29  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  14.56.07  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.15.25  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  14.30.21  by  Michael Scheer
*CMZ :  2.00/03 23/04/2018  17.47.12  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.39.07  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.09.03  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  16.25.38  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.30.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.59.20  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.35.49  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  19.08.03  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  13.53.24  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  11.50.12  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  18.37.06  by  Michael Scheer
*CMZ :  1.23/02 17/09/2017  11.21.15  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  16.23.00  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  14.53.35  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  08.50.03  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  11.30.39  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.56.28  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  12.48.09  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  13.11.48  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.31.54  by  Michael Scheer
*CMZ :  1.18/03 13/06/2017  15.30.31  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  14.09.42  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  09.19.34  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.04.28  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.55.08  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.22.37  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  12.23.38  by  Michael Scheer
*CMZ :  1.15/11 26/04/2017  11.23.30  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.22.06  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  14.32.29  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.29.10  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.46.33  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.15.21  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  19.50.52  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  11.26.05  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  09.16.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  10.00.53  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.14.36  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  15.40.55  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  16.37.53  by  Michael Scheer
*CMZ :  1.12/00 24/02/2017  08.47.15  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.24.23  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.18.36  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.27.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  10.13.44  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.40  by  Michael Scheer
*CMZ :  1.11/01 06/01/2017  13.46.07  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  15.56.40  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  15.36.58  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.12.02  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.10/00 01/11/2016  09.47.47  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.08.03  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  09.12.28  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  18.54.27  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.39.27  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.51.14  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.43.31  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.17  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.32.16  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.35.03  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.29.44  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.28  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  13.31.19  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.37.12  by  Michael Scheer
*CMZ :  1.02/02 12/09/2016  10.20.23  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.27.52  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  14.10.42  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  17.52.14  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.06.57  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.47  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.13.39  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  15.05.25  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  17.54.03  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  13.38.55  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.51.40  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.27.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.43  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  15.56.38  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.48.03  by  Michael Scheer
*CMZ :  1.17/15 19/04/2016  15.54.31  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  12.32.55  by  Michael Scheer
*CMZ :  1.17/13 08/04/2016  11.47.10  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.29.22  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  12.46.06  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.46.34  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.41.39  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.58.50  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.42.21  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine clcmag_ini_force

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      !use displacement

      implicit none

+seq,phyconparam.
+seq,seqdebug.
+seq,random.

      double precision undumag_variable_getval,val
      double precision xminfb,xmaxfb,yminfb,ymaxfb,zminfb,zmaxfb,
     &  x,y,z,gcen(3),bpebc15

      integer moth,nplan,ncorn,iplan,icorn,imag

      nowarnugv=1

      val=undumag_variable_getval('iplforce')
      if (val.ne.-9999.0d29) iplforce=nint(val)

      val=undumag_variable_getval('ubflenx')
      if (val.ne.-9999.0d29) ubflenx=val
      val=undumag_variable_getval('ubfleny')
      if (val.ne.-9999.0d29) ubfleny=val
      val=undumag_variable_getval('ubflenz')
      if (val.ne.-9999.0d29) ubflenz=val

      val=undumag_variable_getval('ubfcenx')
      if (val.ne.-9999.0d29) ubfcenx=val
      val=undumag_variable_getval('ubfceny')
      if (val.ne.-9999.0d29) ubfceny=val
      val=undumag_variable_getval('ubfcenz')
      if (val.ne.-9999.0d29) ubfcenz=val

      val=undumag_variable_getval('utorqcenx')
      if (val.ne.-9999.0d29) utorqcenx=val
      val=undumag_variable_getval('utorqceny')
      if (val.ne.-9999.0d29) utorqceny=val
      val=undumag_variable_getval('utorqcenz')
      if (val.ne.-9999.0d29) utorqcenz=val

      val=undumag_variable_getval('mbforcex')
      if (val.ne.-9999.0d29) mbforcex=nint(val)
      val=undumag_variable_getval('mbforcey')
      if (val.ne.-9999.0d29) mbforcey=nint(val)
      val=undumag_variable_getval('mbforcez')
      if (val.ne.-9999.0d29) mbforcez=nint(val)

      val=undumag_variable_getval('mfcolor')
      if (val.ne.-9999.0d29) mfcolor=nint(val)

      nowarnugv=0

      ndivfby=max(ndivfboxy,1)

      if (iforce.ne.9999) then

        if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
        if (utorqceny.eq.9999.0d0) utorqceny=ubfceny
        if (utorqcenz.eq.9999.0d0) utorqcenz=ubfcenz

        bfcenxmm=ubfcenx
        bfcenymm=ubfceny
        bfcenzmm=ubfcenz
        bflenxmm=ubflenx
        bflenymm=ubfleny
        bflenzmm=ubflenz
        torqcenxmm=utorqcenx
        torqcenymm=utorqceny
        torqcenzmm=utorqcenz
        bfcenx=ubfcenx/1000.0d0
        bfceny=ubfceny/1000.0d0
        bfcenz=ubfcenz/1000.0d0
        bflenx=ubflenx/1000.0d0
        bfleny=ubfleny/1000.0d0
        bflenz=ubflenz/1000.0d0
        torqcenx=utorqcenx/1000.0d0
        torqceny=utorqceny/1000.0d0
        torqcenz=utorqcenz/1000.0d0
        jplforce=iplforce
        if (iforce.eq.0) then
          mbforcex=0
          mbforcey=0
          mbforcez=0
        endif
        nbforcx=mbforcex
        nbforcy=mbforcey
        nbforcz=mbforcez
        iforcol=mfcolor
        forcol=iforcol
        forxpl(1)=sngl(bfcenxmm-bflenxmm/2.)
        forxpl(2)=sngl(bfcenxmm+bflenxmm/2.)
        forypl(1)=sngl(bfcenymm-bflenymm/2.)
        forypl(2)=sngl(bfcenymm+bflenymm/2.)
        forzpl(1)=sngl(bfcenzmm-bflenzmm/2.)
        forzpl(2)=sngl(bfcenzmm+bflenzmm/2.)

      endif !(iforce.ne.9999) then

c      if (iforce.ne.9999)  then
c        ubfcenx=ubfcenx+xcentershift
c        bfcenxmm=ubfcenx
c        utorqcenx=utorqcenx+xcentershift
c        if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
c        bfcenx=ubfcenx/1000.0d0
c        torqcenxmm=utorqcenx
c        torqcenx=utorqcenx/1000.0d0
c      endif

      forxpl=forxpl+sngl(xcentershift)

      kforcemag=0

      if (iforce.eq.9999.or.iforcedip.ne.0) then

        if (chforcemag.eq.'') then
          write(lun6,*)"*** iforce=9999, but chforcemag is an empty string ***"
          write(lun6,*)
          stop
        endif

        write(lun6,*)""
        write(lun6,*)"      chforcemag: ",trim(adjustl(chforcemag))
        do imag=1,nmagtot_t
          if (t_magnets(imag)%cmoth.eq.chforcemag) then
            kforcemag=imag
            exit
          endif
        enddo

        if (kforcemag.eq.0) then
          write(lun6,*)"*** Magnet ",trim(chforcemag),"  for force calculations not found ***"
          write(lun6,*)"*** Check undumag_magnets.lis ***"
          stop
        endif

        if (chforcemag.eq.'') then
          chforcemag='None'
        endif

      endif !iforce, iforcedip

      if (iforce.eq.9999) then

        moth=nint(bpebc(15,kforcemag))

        xminfb=1.0d30
        xmaxfb=-1.0d30
        yminfb=1.0d30
        ymaxfb=-1.0d30
        zminfb=1.0d30
        zmaxfb=-1.0d30

        do imag=1,nmagtot_t
          gcen=bpebc(1:3,imag)
          bpebc15=bpebc(15,imag)
          if (nint(bpebc15).ne.moth) cycle
          nplan=ibpeplan(imag)
          do iplan=1,nplan
            ncorn=ibpecorn(iplan,imag)
            do icorn=1,ncorn
              x=bpemag(1,icorn,iplan,imag)
              y=bpemag(2,icorn,iplan,imag)
              z=bpemag(3,icorn,iplan,imag)
              if (x.lt.xminfb) xminfb=x
              if (x.gt.xmaxfb) xmaxfb=x
              if (y.lt.yminfb) yminfb=y
              if (y.gt.ymaxfb) ymaxfb=y
              if (z.lt.zminfb) zminfb=z
              if (z.gt.zmaxfb) zmaxfb=z
            enddo !icorn
          enddo !iplan
        enddo

        ubfcenx=(xmaxfb+xminfb)/2.0d0
        ubflenx=(xmaxfb-xminfb)
        if (ixsym.ne.0.and.(xmin_t.le.xsym.or.xmax_t.ge.xsym)) then
          ubfcenz=xsym
          ubflenz=2.0d0*ubflenz
        endif

        ubfceny=(ymaxfb+yminfb)/2.0d0
        ubfleny=(ymaxfb-yminfb)

        ubfcenz=(zmaxfb+zminfb)/2.0d0
        ubflenz=(zmaxfb-zminfb)
        if (izsym.ne.0) then
          ubfcenz=0.0d0
          ubflenz=2.0d0*ubflenz
        endif

        ubflenx=ubflenx+2.0*dedgefb
        ubfleny=ubfleny+2.0*dedgefb
        ubflenz=ubflenz+2.0*dedgefb

        if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
        if (utorqceny.eq.9999.0d0) utorqceny=ubfceny
        if (utorqcenz.eq.9999.0d0) utorqcenz=ubfcenz

        bfcenxmm=ubfcenx
        bfcenymm=ubfceny
        bfcenzmm=ubfcenz
        bflenxmm=ubflenx
        bflenymm=ubfleny
        bflenzmm=ubflenz
        torqcenxmm=utorqcenx
        torqcenymm=utorqceny
        torqcenzmm=utorqcenz
        bfcenx=ubfcenx/1000.0d0
        bfceny=ubfceny/1000.0d0
        bfcenz=ubfcenz/1000.0d0
        bflenx=ubflenx/1000.0d0
        bfleny=ubfleny/1000.0d0
        bflenz=ubflenz/1000.0d0
        torqcenx=utorqcenx/1000.0d0
        torqceny=utorqceny/1000.0d0
        torqcenz=utorqcenz/1000.0d0
        jplforce=iplforce
        if (iforce.eq.0) then
          mbforcex=0
          mbforcey=0
          mbforcez=0
        endif
        nbforcx=mbforcex
        nbforcy=mbforcey
        nbforcz=mbforcez
        iforcol=mfcolor
        forcol=iforcol
        forxpl(1)=sngl(bfcenxmm-bflenxmm/2.)
        forxpl(2)=sngl(bfcenxmm+bflenxmm/2.)
        forypl(1)=sngl(bfcenymm-bflenymm/2.)
        forypl(2)=sngl(bfcenymm+bflenymm/2.)
        forzpl(1)=sngl(bfcenzmm-bflenzmm/2.)
        forzpl(2)=sngl(bfcenzmm+bflenzmm/2.)

      endif !(iforce.eq.9999) then

      if (mbforcex*mbforcey*mbforcez.gt.0) then
        outbox(1,1)=ubfcenx-ubflenx/2.
        outbox(2,1)=ubfcenx+ubflenx/2.
        outbox(1,2)=ubfceny-ubfleny/2.
        outbox(2,2)=ubfceny+ubfleny/2.
        outbox(1,3)=ubfcenz-ubflenz/2.
        outbox(2,3)=ubfcenz+ubflenz/2.
      else
        outbox(1,1)=+1.0d30
        outbox(2,1)=-1.0d30
        outbox(1,2)=+1.0d30
        outbox(2,2)=-1.0d30
        outbox(1,3)=+1.0d30
        outbox(2,3)=-1.0d30
      endif

      end
+DECK,clcmag_magnets_list.
*CMZ :  2.04/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 31/01/2022  08.57.51  by  Michael Scheer
*CMZ :  2.02/00 31/03/2021  20.30.51  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.27.23  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  16.04.15  by  Michael Scheer
*CMZ :  2.01/04 18/07/2019  13.56.54  by  Michael Scheer
*CMZ :  2.01/03 13/06/2019  15.03.29  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  14.56.07  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.15.25  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  14.30.21  by  Michael Scheer
*CMZ :  2.00/03 23/04/2018  17.47.12  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.39.07  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.09.03  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  16.25.38  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.30.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.59.20  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.35.49  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  19.08.03  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  13.53.24  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  11.50.12  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  18.37.06  by  Michael Scheer
*CMZ :  1.23/02 17/09/2017  11.21.15  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  16.23.00  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  14.53.35  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  08.50.03  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  11.30.39  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.56.28  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  12.48.09  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  13.11.48  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.31.54  by  Michael Scheer
*CMZ :  1.18/03 13/06/2017  15.30.31  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  14.09.42  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  09.19.34  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.04.28  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.55.08  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.22.37  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  12.23.38  by  Michael Scheer
*CMZ :  1.15/11 26/04/2017  11.23.30  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.22.06  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  14.32.29  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.29.10  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.46.33  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.15.21  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  19.50.52  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  11.26.05  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  09.16.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  10.00.53  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.14.36  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  15.40.55  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  16.37.53  by  Michael Scheer
*CMZ :  1.12/00 24/02/2017  08.47.15  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.24.23  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.18.36  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.27.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  10.13.44  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.40  by  Michael Scheer
*CMZ :  1.11/01 06/01/2017  13.46.07  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  15.56.40  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  15.36.58  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.12.02  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.10/00 01/11/2016  09.47.47  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.08.03  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  09.12.28  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  18.54.27  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.39.27  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.51.14  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.43.31  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.17  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.32.16  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.35.03  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.29.44  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.28  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  13.31.19  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.37.12  by  Michael Scheer
*CMZ :  1.02/02 12/09/2016  10.20.23  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.27.52  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  14.10.42  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  17.52.14  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.06.57  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.47  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.13.39  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  15.05.25  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  17.54.03  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  13.38.55  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.51.40  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.27.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.43  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  15.56.38  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.48.03  by  Michael Scheer
*CMZ :  1.17/15 19/04/2016  15.54.31  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  12.32.55  by  Michael Scheer
*CMZ :  1.17/13 08/04/2016  11.47.10  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.29.22  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  12.46.06  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.46.34  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.41.39  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.58.50  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.42.21  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine clcmag_magnets_list

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      !use displacement

      implicit none

      Type(T_Magnet) tmag
      Type(T_Magnet_Copy) tmc

      integer lun,imoth,imag,i,ifound

      character(32) chmutt
      character c32(32)
      equivalence(chmutt,c32)

      allocate(chmutts(nmagtot_t),chmoths(32,nmagtot_t))

      nmoth_t=0
      do imag=1,nmagtot_t
        chmutt=t_magcopy(imag)%cmoth(1:32)
        ifound=0
        do i=1,nmoth_t
          if (chmutt.eq.chmutts(i)) then
            ifound=1
            exit
          endif
        enddo
        if (ifound.eq.0) then
          nmoth_t=nmoth_t+1
          chmutts(nmoth_t)=chmutt
          chmoths(:,nmoth_t)=c32
        endif
      enddo

      open(newunit=lun,file='undumag_magnets.lis')
      do imag=1,nmagtot_t
        write(lun,*)imag,t_magcopy(imag)%cnam,t_magcopy(imag)%cmoth,
     &    sngl(t_magcopy(imag)%gcen(1)),sngl(t_magcopy(imag)%gcen(2)),
     &    sngl(t_magcopy(imag)%gcen(3))
      enddo
      flush(lun)
      close(lun)

      call clcmag_voxels_list(0)

      open(newunit=lun,file='undumag_mother_magnets.lis')

      do imoth=1,nmoth_t
        tmc=t_magcopy(1)
        tmag=t_magnets(tmc%kproto)
        chmutt=tmc%cmoth
        do imag=1,nmagtot_t
          tmc=t_magcopy(imag)
          tmag=t_magnets(tmc%kproto)
          if (tmc%cmoth.ne.chmutt) cycle
          write(lun,*) imoth,chmutt,imag,tmc%cmoth
        enddo !nmagtot_t
      enddo !nmoth_t

      flush(lun)
      close(lun)

      end
+DECK,clcmag_to_radia.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 09/02/2022  19.36.16  by  Michael Scheer
*CMZ :  2.02/00 09/01/2021  12.08.32  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  12.47.44  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  15.45.12  by  Michael Scheer
*CMZ :  1.25/04 04/04/2018  11.40.25  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.27.59  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.25.43  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  09.00.40  by  Michael Scheer
*CMZ :  1.23/02 11/09/2017  15.35.11  by  Michael Scheer
*CMZ :  1.18/01 08/06/2017  14.20.17  by  Michael Scheer
*CMZ :  1.15/10 11/04/2017  11.14.47  by  Michael Scheer
*CMZ :  1.15/00 24/03/2017  10.28.46  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  17.33.35  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  10.15.10  by  Michael Scheer
*CMZ :  1.11/03 13/01/2017  15.10.38  by  Michael Scheer
*CMZ :  1.11/00 03/01/2017  16.16.45  by  Michael Scheer
*-- Author :    Michael Scheer   12/12/2016
      subroutine clcmag_to_radia

      use undumagf90m
      use bpolyederf90m
      use commandlinef90m
      use magnets_structure

! Interface to radia notebook. It writes the geometry to snipplets for RADIA
! Restriction:
! Isotropic materials must have a magnetization less then 0.01
!
! RADIA coordinate system: y is longitudinal, z is vertical
! UNDUMAG: x is longitudinal, y is vertical

      implicit none

+seq,phyconparam.

      double precision, dimension (:), allocatable :: x,y,z,brrec

      integer, dimension (:), allocatable :: khull,imatrec,imatiron,
     &  imatmagpol

      double precision :: gcen(3)

      real :: hfe,bfe

      integer ::
     &  nsymx,nsymy,nsymz,npoi,nmatfe,nlast,nfirst,nface,ncyl,ncolor,mater
     &  ,lunrad,lunfe,lmat,kproto,kpoi,k,ironmode,iron,imp,ipoi,imag,imat
     &  ,ifound,i,iface,ieof,nbr,nUnduMag,nUnduPol,nMagPolTot,lenout,lunproc,
     &  istat=0

      character(2048) cline,cbuff(10),cout
      character(64) chmat
      character(32) c32,c32x,c32y,c32z

      ncyl=0

      maxpoints=max(maxpoints,ncornmax*nplanmax)

      allocate(x(maxpoints),y(maxpoints),z(maxpoints),khull(maxpoints))
      allocate(brrec(nmagtot_t),imatrec(nmagtot_t),
     &  imatiron(nmagtot_t),imatmagpol(nmagtot_t))

      nbr=0
      nmatfe=0
      brrec=0.0d0
      imatrec=0

      do imag=1,nmagtot_t
        kproto=t_magcopy(imag)%kproto
        ifound=0
        if (t_magnets(kproto)%ispole.ne.0) then
          do i=1,nmatfe
            if (t_magnets(kproto)%imat.eq.imatiron(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) then
            cycle
          endif
          nmatfe=nmatfe+1
          imatiron(nmatfe)=t_magnets(kproto)%imat
          imatmagpol(imag)=nmatfe
        else
          do i=1,nbr
            if (brrec(i).eq.t_magcopy(imag)%brn.and.
     &          t_magnets(kproto)%imat.eq.imatrec(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) cycle
          nbr=nbr+1
          brrec(nbr)=t_magcopy(imag)%brn
          imatrec(nbr)=t_magnets(kproto)%imat
          imatmagpol(imag)=nbr
        endif
      enddo

      nsymx=1
      nsymy=1
      nsymz=1

      if (ixsymo.lt.0) nsymx=nsymx*2
      if (iysymo.lt.0) nsymy=nsymy*2
      if (izsymo.lt.0) nsymz=nsymz*2

      open(newunit=lunrad,file='undumag.nb')

      write(lunrad,*)' '
      write(lunrad,*)'(*-- Begin of lines generated by UNDUMAG --*)'
      write(lunrad,*)'(*-- Version ',trim(chuvers),' --*)'
      write(lunrad,*)' '
      write(lunrad,*)'<<Radia`; Off[General::"spell1"];'
      write(lunrad,*)' '
      write(cline,*)kundurun
      call util_string_trim(cline,nfirst,nlast)
      write(lunrad,*)'(*'
      call util_zeit_kommentar(lunrad,"Run: "//cline(nfirst:nlast))
      write(lunrad,*)'*)'

      write(lunrad,*)"(*"
      write(lunrad,*)"Comment: "//trim(unducomment)
      write(lunrad,*)"*)"
      write(lunrad,*)' '
      write(lunrad,*)'run = ',kundurun,";"
      write(lunrad,*)'comment = "'//trim(unducomment)//'";'
      write(lunrad,*)' '
      write(lunrad,*)'(* --- Variables of undumag.nam ---*)'
      write(lunrad,*)' '
      write(lunrad,*)'iUnduXsym = ',ixsymo,";"
      write(lunrad,*)'iUnduYsym = ',iysymo,";"
      write(lunrad,*)'iUnduZsym = ',izsymo,";"
      write(lunrad,*)' '
      write(lunrad,*)'UnduSymX = ',xsym,";"
      write(lunrad,*)' '
      write(lunrad,*)"kDraw = ",iunduplot,";"
      write(lunrad,*)"unduplot_theta = ",unduplot_theta,";"
      write(lunrad,*)"unduplot_phi = ",unduplot_phi,";"
      write(lunrad,*)' '

      write(c32x,*)xcenter
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXCenter = ",c32x," ;"
      write(c32x,*)xcentershift
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXCenterShift = ",c32x," ;"
      write(lunrad,*)' '
      write(c32x,*)utorqcenx
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenX = ",c32x," ;"
      write(c32x,*)utorqceny
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenY = ",c32x," ;"
      write(c32x,*)utorqcenz
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenZ = ",c32x," ;"
      write(lunrad,*)' '
      write(c32x,*)xmapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXMapMin = ",c32x," ;"
      write(c32x,*)xmapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduXMap = ",nxmap," ;"
      write(lunrad,*)' '
      write(c32x,*)ymapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduYMapMin = ",c32x," ;"
      write(c32x,*)ymapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduYMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduYMap = ",nymap," ;"
      write(lunrad,*)' '
      write(c32x,*)zmapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduZMapMin = ",c32x," ;"
      write(c32x,*)zmapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduZMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduZMap = ",nzmap," ;"
      write(lunrad,*)' '
      write(lunrad,*)' '
      write(lunrad,*)"nUnduNoPolMap = ",knopolmap," ;"
      write(lunrad,*)"nUnduNoMagMap = ",knomagmap," ;"
      write(lunrad,*)' '
+self,if=uvarrad.

      write(lunrad,*)' '
      write(lunrad,*)'(* --- Variables of undumag.clc ---*)'
      write(lunrad,*)' '

      do i=1,nvar_t
        write(lunrad,*) trim(t_variables(i)%cname),' = ',t_variables(i)%val,';'
      enddo !nvar_t
+self.,if=uvarrad.

      write(lunrad,*)' '
      write(lunrad,*)'(* --- Materials of undumag.clc ---*)'
      write(lunrad,*)' '

      do i=1,nbr
        imat=imatrec(i)
        if (imat.eq.0) cycle
        write(c32,*)i
        if (matmaps(1,imat).eq.1) then
          if (matmaps(2,imat).eq.1) then
            write(c32x,'(f6.4)')bcmat(2,1,imat) !-1.0d0
            write(c32y,'(f6.4)')bcmat(3,1,imat) !-1.0d0
            write(c32z,'(g12.5)')brrec(i)
            write(lunrad,*)
     &        "UmatREC[" // trim(adjustl(c32)) // "] = radMatLin[{" //
     &        trim(adjustl(c32x)) // "," //
     &        trim(adjustl(c32y)) //
     &        "}," // trim(adjustl(c32z)) // "];"
          else
            print*,"*** Error in clcmag_to_radia: mode",
     &        matmaps(2,imat), " not yet implemented for REC material ",imat
            print*,""
            !stop "--- UNDUMAG aborted ---"
          endif
        else
          print*,"*** Error in clcmag_to_radia: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          !stop "--- UNDUMAG aborted ---"
        endif
      enddo

      do i=1,nmatfe
        imat=imatiron(i)
        if (imat.eq.0) cycle
        write(c32,*)i
        if (matmaps(1,imat).eq.2) then
          write(lunrad,*)
     &      "UmatIron[" // trim(adjustl(c32)) // "] = radMatSatIso[{"
          do k=2,nclcmat
            read(clcmat(k),*)iron,lmat,ironmode,cbuff(1)
            if (iron.eq.imat) then
              open(newunit=lunfe,file=trim(cbuff(1)),status='old')
              ieof=0
              do while (ieof.eq.0)
                call util_skip_comment_end(lunfe,ieof)
                if (ieof.ne.0) exit
                read(lunfe,*) hfe,bfe
                write(lunrad,*)"{",hfe,",",bfe,"},"
              enddo
              backspace(lunrad)
              write(lunrad,*)"{",hfe,",",bfe,"}"
              close(lunfe)
            endif
          enddo
          write(lunrad,*)"}];"
        else
          print*,"*** Error in clcmag_to_radia: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          !stop "--- UNDUMAG aborted ---"
        endif
      enddo

      write(lunrad,*)' '
      write(lunrad,*)'(* --- Poles and magnets of undumag.clc ---*)'
      write(lunrad,*)' '

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        ! radObjPolyhdr[
        ! {
        !   {x1,y1,z1}, ..., {xn,yn,zn} Corners
        ! },
        ! {
        !   {f1n1,f1n2,...}, ...., {f2n1,f2n2,...} Faces
        ! },
        ! {mx,my,mz}:{0,0,0}]

        nface=t_magnets(kproto)%nface
        ncolor=t_magnets(kproto)%icol

        write(lunrad,*)"   ",trim(t_magcopy(imp)%cnam)//" = radObjPolyhdr["
        write(lunrad,*)"        { (* List of points *)"

        gcen=t_magcopy(imp)%gcen

        do kpoi=1,t_magnets(kproto)%nhull
          write(c32x,*)sngl(t_magnets(kproto)%xhull(kpoi)+gcen(1))
          call undumag_double_to_radia(c32x)
          write(c32y,*)sngl(t_magnets(kproto)%yhull(kpoi)+gcen(2))
          call undumag_double_to_radia(c32y)
          write(c32z,*)sngl(t_magnets(kproto)%zhull(kpoi)+gcen(3))
          call undumag_double_to_radia(c32z)
          if (kpoi.lt.t_magnets(kproto)%nhull) then
            write(lunrad,*)
     &        "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"
          else
            write(lunrad,*)
     &        "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
          endif
        enddo !kpoi

        write(lunrad,*)"        }, (* End of list of points *)"

        write(lunrad,*)"        { (* List of faces *)"

        kpoi=1
        do iface=1,nface
          npoi=t_magnets(kproto)%kface(kpoi)
          cline="         {"
          do ipoi=kpoi+1,kpoi+npoi
            call util_string_append_num(cline,t_magnets(kproto)%kface(ipoi),
     &        nfirst,nlast)
            if (ipoi.lt.kpoi+npoi) then
              call util_string_append(cline,',',nfirst,nlast)
            else
              call util_string_append(cline,'},',nfirst,nlast)
            endif
          enddo !ipoi
          if (iface.lt.nface) then
            write(lunrad,*)cline(1:nlast)
            call util_string_append(cline,'},',nfirst,nlast)
          else
            write(lunrad,*)cline(1:nlast-1)
          endif
          kpoi=kpoi+npoi+1
        enddo !nface

        write(lunrad,*)"        }, (* End of list of faces *)"

        if (t_magnets(kproto)%IsPole.eq.0) then
          write(c32x,*)t_magnets(kproto)%br(1)
          call undumag_double_to_radia(c32x)
          write(c32y,*)t_magnets(kproto)%br(2)
          call undumag_double_to_radia(c32y)
          write(c32z,*)t_magnets(kproto)%br(3)
          call undumag_double_to_radia(c32z)
          write(lunrad,*)"         {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
          mater = imatmagpol(imp)
          write(chmat,*)mater
          call util_string_trim(chmat,nfirst,nlast)
          chmat="UmatREC["//chmat(nfirst:nlast)//"]"
        else
          write(lunrad,*)"         {0,0,0}"
          write(lunrad,*)"       ];"
          mater = imatmagpol(imp)
          write(chmat,*)mater
          call util_string_trim(chmat,nfirst,nlast)
          chmat="UmatIron["//chmat(nfirst:nlast)//"]"
        endif !Pole/Mag

        if (t_magnets(kproto)%nzdiv*t_magnets(kproto)%nydiv*t_magnets(kproto)%nxdiv.gt.1) then
          write(lunrad,*)' '
          write(cline,*)
     &      "      radObjDivMag["//trim(adjustl(t_magcopy(imp)%cnam))//", {{",
     &      t_magnets(kproto)%nzdiv,",",
     &      sngl(t_magnets(kproto)%zfracdiv),"},",t_magnets(kproto)%nxdiv,
     &      ",{",t_magnets(kproto)%nydiv,",",
     &      sngl(t_magnets(kproto)%yfracdiv),"}},kxkykz->Numb];"
          call util_remove_double_blanks(cline,cout,lenout)
          write(lunrad,*)'       ',cout(1:lenout)
          write(lunrad,*)' '
        endif

        write(lunrad,*)" "
        write(lunrad,*)"       radMatApl["//trim(adjustl(t_magcopy(imp)%cnam))//","//
     &    trim(chmat)//"];"

        if (ncolor.eq.2) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{1,0,0},0.0001];"
        else if (ncolor.eq.3) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{0,1,0},0.0001];"
        else if (ncolor.eq.4) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{0,0,1},0.0001];"
        else if (ncolor.eq.5) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{1,1,0},0.0001];"
        else if (ncolor.eq.6) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{1,0,1},0.0001];"
        else if (ncolor.eq.7) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{0,1,1},0.0001];"
        endif

        write(lunrad,*)" "

      enddo !imp=1,nmagtot_t

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        if (t_magnets(kproto)%IsPole.eq.0) then

          nUnduMag=nUnduMag+1

          write(c32,*)nUnduMag
          write(lunrad,*)"       nUnduMag = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       UnduMag[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"

          nMagPolTot=nMagPolTot+1

          write(c32,*)nMagPolTot
          write(lunrad,*)"       nMagPolTot = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       AllMagPols[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"
          write(lunrad,*)" "

          if (t_magcopy(imp)%cnam.eq.chforcemag) then
            write(lunrad,*)' '
            write(lunrad,*)"       iForceTyp = 1;"
            write(c32,*)nUnduMag
            write(lunrad,*)"      nForce = " // trim(adjustl(c32)) //";"
            write(lunrad,*)' '
            write(lunrad,*)" "
          endif

        else

          nUnduPol=nUnduPol+1
          write(c32,*)nUnduPol
          write(lunrad,*)"       nUnduPol = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       UnduPol[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"

          nMagPolTot=nMagPolTot+1

          write(c32,*)nMagPolTot
          write(lunrad,*)"       nMagPolTot = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       AllMagPols[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"
          write(lunrad,*)" "

          if (t_magcopy(imp)%cnam.eq.chforcemag) then
            write(lunrad,*)' '
            write(lunrad,*)"       iForceTyp = 1;"
            write(c32,*)nUnduPol
            write(lunrad,*)"      nForce = " // trim(adjustl(c32)) //";"
            write(lunrad,*)' '
            write(lunrad,*)" "
          endif

        endif !Pole/Mag

      enddo !imp=1,nmagtot_t

      deallocate(brrec)

      write(lunrad,*)' '
      write(lunrad,*)'(*-- End of lines generated by UNDUMAG --*)'
      write(lunrad,*)' '

      write(lunrad,*)' '
      write(lunrad,*)'(*-- Reading undumag_proc.nb and appending to undumag.nb --*)'
      write(lunrad,*)' '

      open(newunit=lunproc,file='undumag_proc.nb',status='old', iostat=istat)

      if (istat.ne.0) then
        write(lun6,*)"*** Error in clcmag_to_radia: File undumag_proc.nb not found ***"
      else

        ieof=0
        cline=''

        do while (ieof.eq.0)
          read(lunproc,'(a)',iostat=ieof) cline
          if (ieof.eq.0) write(lunrad,'(a)') trim(cline)
        enddo
        close(lunproc)

      endif

      flush(lunrad)
      close(lunrad)

      return
      end
+DECK,clcmag_copy_magnets.
*CMZ :  2.04/08 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/07 09/08/2023  15.35.36  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/01 22/01/2023  13.28.01  by  Michael Scheer
*CMZ :  2.02/01 10/02/2022  22.24.03  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2021
      subroutine clcmag_copy_magnets

! Rotates primary magnets according to module rotation
! The rotated primary magnets are copied and shiftet according to
! module definitions.

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      double precision, dimension (:), allocatable :: xsort
      double precision gcen(3),xyz(3),vspace(3),off(3),phi,shift(3),rot(3,3),
     &  scalmag(3),brn,xmin,xmax,ymin,ymax,zmin,zmax

      integer imag,imodul,ic,i,ispole,k,kmag,nesti,kproto,istat

      character(32) cmod,ccop

+seq,grarad.

      type (T_Module) tmod
      type (T_Magnet_Copy), dimension (:), allocatable :: tmc

      nmagtot_t=0

      if (nmodule_t.gt.0) then
        do imodul=1,nmodule_t
          tmod=t_modules(imodul)
          do imag=1,nmag_t
            nmagtot_t=nmagtot_t+tmod%ncopy
            t_magnets(imag)%ncopy=t_magnets(imag)%ncopy+tmod%ncopy
          enddo !imag
        enddo
      else
        nmagtot_t=nmag_t
      endif

      do imag=1,nmag_t+nspecmag_t
        allocate(t_magnets(imag)%kcopy(t_magnets(imag)%ncopy))
      enddo !imag

      nmagtot_t=nmagtot_t+nspecmag_t

      allocate(ksort_t(nmagtot_t),t_magcopy(nmagtot_t))

      allocate(xsort(nmagtot_t))
      nmagtot_t=0

      do imodul=1,nmodule_t

        write(cmod,*)imodul

        tmod=t_modules(imodul)
        vspace=tmod%vspace
        off=tmod%offset
        phi=tmod%phi*grarad1
        rot=tmod%rotmat
        scalmag=tmod%scalmag

        do imag=1,nmag_t

          if (t_magnets(imag)%kmodule.ne.imodul) cycle

          gcen=t_magnets(imag)%gcen
          ispole=t_magnets(imag)%ispole

          xmin=1.0d30
          xmax=-1.0d30
          ymin=1.0d30
          ymax=-1.0d30
          zmin=1.0d30
          zmax=-1.0d30

          do i=1,t_magnets(imag)%nhull
            xyz=[t_magnets(imag)%xhull(i),t_magnets(imag)%yhull(i),t_magnets(imag)%zhull(i)]
            call util_mat_mul_vec_3x3(rot,xyz,xyz)
            t_magnets(imag)%xhull(i)=xyz(1)
            t_magnets(imag)%yhull(i)=xyz(2)
            t_magnets(imag)%zhull(i)=xyz(3)
            !if (t_magnets(imag)%ctype.ne.'Cylinder') then
               if (t_magnets(imag)%xhull(i).lt.xmin) xmin=t_magnets(imag)%xhull(i)
              if (t_magnets(imag)%xhull(i).gt.xmax) xmax=t_magnets(imag)%xhull(i)
              if (t_magnets(imag)%yhull(i).lt.ymin) ymin=t_magnets(imag)%yhull(i)
              if (t_magnets(imag)%yhull(i).gt.ymax) ymax=t_magnets(imag)%yhull(i)
              if (t_magnets(imag)%zhull(i).lt.zmin) zmin=t_magnets(imag)%zhull(i)
              if (t_magnets(imag)%zhull(i).gt.zmax) zmax=t_magnets(imag)%zhull(i)
            !else
            !  size=t_magnets(imag)%size
+self,if=p.
              xmin=min(xmin-xyz(1)-size(2),xmin)
              xmax=max(xmin+xyz(1)+size(2),xmax)
              ymin=min(ymin-xyz(2)-size(3),xmin)
              ymax=max(ymin+xyz(2)+size(3),xmax)
              zmin=min(zmin-xyz(3)-size(2),xmin)
              zmax=max(zmin+xyz(3)+size(2),xmax)
+self.
            !endif
          enddo

          t_magnets(imag)%xmin=xmin
          t_magnets(imag)%xmax=xmax
          t_magnets(imag)%ymin=ymin
          t_magnets(imag)%ymax=ymax
          t_magnets(imag)%zmin=zmin
          t_magnets(imag)%zmax=zmax

          if (t_magnets(imag)%ctype.ne.'Cylinder') then
            t_magnets(imag)%size(1)=xmax-xmin
            t_magnets(imag)%size(2)=ymax-ymin
            t_magnets(imag)%size(3)=zmax-zmin
          endif

          call util_mat_mul_vec_3x3(rot,t_magnets(imag)%gcen,t_magnets(imag)%gcen)
          call util_mat_mul_vec_3x3(rot,t_magnets(imag)%xyz,t_magnets(imag)%xyz)

          do ic=1,tmod%ncopy
            write(ccop,*)ic
            nmagtot_t=nmagtot_t+1
            t_magnets(imag)%kcopy(ic)=nmagtot_t
            ksort_t(nmagtot_t)=nmagtot_t
            shift=off+(ic-1)*vspace
            t_magcopy(nmagtot_t)%gcen=t_magnets(imag)%gcen+shift
            t_magcopy(nmagtot_t)%xmin=t_magnets(imag)%xmin
            t_magcopy(nmagtot_t)%xmax=t_magnets(imag)%xmax
            t_magcopy(nmagtot_t)%ymin=t_magnets(imag)%ymin
            t_magcopy(nmagtot_t)%ymax=t_magnets(imag)%ymax
            t_magcopy(nmagtot_t)%zmin=t_magnets(imag)%zmin
            t_magcopy(nmagtot_t)%zmax=t_magnets(imag)%zmax
            t_magcopy(nmagtot_t)%size=t_magnets(imag)%size
            ksort_t(nmagtot_t)=nmagtot_t
            xsort(nmagtot_t)=t_magcopy(nmagtot_t)%gcen(1)
            t_magcopy(nmagtot_t)%ispole=ispole
            t_magcopy(nmagtot_t)%isspecial=0
            t_magcopy(nmagtot_t)%kproto=imag
            t_magcopy(nmagtot_t)%kmodule=imodul
            t_magcopy(nmagtot_t)%kcopy=ic
            t_magcopy(nmagtot_t)%br=t_magnets(imag)%br*scalmag
            brn=norm2(t_magcopy(nmagtot_t)%br)
            t_magcopy(nmagtot_t)%brn=brn
            if (brn.ne.0.0d0)
     &        t_magcopy(nmagtot_t)%br=t_magcopy(nmagtot_t)%br/brn
            if (imodul.ne.1.or.ic.ne.1) then
              t_magcopy(nmagtot_t)%cnam=trim(adjustl(t_magnets(imag)%cnam)) // "_"
     &          // trim(adjustl(cmod)) // "_" // trim(adjustl(ccop))
              t_magcopy(nmagtot_t)%cmoth=trim(adjustl(t_magnets(imag)%cmoth)) // "_"
     &          // trim(adjustl(cmod)) // "_" // trim(adjustl(ccop))
            else
              t_magcopy(nmagtot_t)%cnam=t_magnets(imag)%cnam
              t_magcopy(nmagtot_t)%cmoth=t_magnets(imag)%cmoth
            endif
          enddo
        enddo !imag
      enddo

      do i=1,nspecmag_t

        imag=nmag_t+i

        ispole=t_magnets(imag)%ispole
        gcen=t_magnets(imag)%gcen

        xmin=1.0d30
        xmax=-1.0d30
        ymin=1.0d30
        ymax=-1.0d30
        zmin=1.0d30
        zmax=-1.0d30

        do k=1,t_magnets(imag)%nhull
          if (t_magnets(imag)%xhull(k).lt.xmin) xmin=t_magnets(imag)%xhull(k)
          if (t_magnets(imag)%xhull(k).gt.xmax) xmax=t_magnets(imag)%xhull(k)
          if (t_magnets(imag)%yhull(k).lt.ymin) ymin=t_magnets(imag)%yhull(k)
          if (t_magnets(imag)%yhull(k).gt.ymax) ymax=t_magnets(imag)%yhull(k)
          if (t_magnets(imag)%zhull(k).lt.zmin) zmin=t_magnets(imag)%zhull(k)
          if (t_magnets(imag)%zhull(k).gt.zmax) zmax=t_magnets(imag)%zhull(k)
        enddo

        t_magnets(imag)%xmin=xmin
        t_magnets(imag)%xmax=xmax
        t_magnets(imag)%ymin=ymin
        t_magnets(imag)%ymax=ymax
        t_magnets(imag)%zmin=zmin
        t_magnets(imag)%zmax=zmax

        if (t_magnets(imag)%ctype.ne.'Cylinder') then
          t_magnets(imag)%size(1)=xmax-xmin
          t_magnets(imag)%size(2)=ymax-ymin
          t_magnets(imag)%size(3)=zmax-zmin
        endif

        nmagtot_t=nmagtot_t+1
        ksort_t(nmagtot_t)=nmagtot_t
        xsort(nmagtot_t)=t_magnets(imag)%gcen(1)

        t_magcopy(nmagtot_t)%ispole=ispole
        t_magcopy(nmagtot_t)%isspecial=1
        t_magcopy(nmagtot_t)%kproto=imag
        t_magcopy(nmagtot_t)%kmodule=0
        t_magcopy(nmagtot_t)%kcopy=0
        t_magcopy(nmagtot_t)%cnam=t_magnets(imag)%cnam
        t_magcopy(nmagtot_t)%cmoth=t_magnets(imag)%cmoth
        t_magcopy(nmagtot_t)%gcen=t_magnets(imag)%gcen
        t_magcopy(nmagtot_t)%br=t_magnets(imag)%br
        t_magcopy(nmagtot_t)%brn=t_magnets(imag)%brn

        t_magcopy(nmagtot_t)%xmin=t_magnets(imag)%xmin
        t_magcopy(nmagtot_t)%xmax=t_magnets(imag)%xmax
        t_magcopy(nmagtot_t)%ymin=t_magnets(imag)%ymin
        t_magcopy(nmagtot_t)%ymax=t_magnets(imag)%ymax
        t_magcopy(nmagtot_t)%zmin=t_magnets(imag)%zmin
        t_magcopy(nmagtot_t)%zmax=t_magnets(imag)%zmax

      enddo !imag

      call util_sort_index(nmagtot_t,xsort,ksort_t)
      deallocate(xsort)

      allocate(tmc(nmagtot_t))
      tmc=t_magcopy

      xmin_t=1.0d30
      xmax_t=-1.0d30
      ymin_t=1.0d30
      ymax_t=-1.0d30
      zmin_t=1.0d30
      zmax_t=-1.0d30

      do imag=1,nmagtot_t
        t_magcopy(imag)=tmc(ksort_t(imag))
        gcen=t_magcopy(imag)%gcen
        if (t_magcopy(imag)%xmin+gcen(1).lt.xmin_t) xmin_t=gcen(1)+t_magcopy(imag)%xmin
        if (t_magcopy(imag)%xmax+gcen(1).gt.xmax_t) xmax_t=gcen(1)+t_magcopy(imag)%xmax
        if (t_magcopy(imag)%ymin+gcen(2).lt.ymin_t) ymin_t=gcen(2)+t_magcopy(imag)%ymin
        if (t_magcopy(imag)%ymax+gcen(2).gt.ymax_t) ymax_t=gcen(2)+t_magcopy(imag)%ymax
        if (t_magcopy(imag)%zmin+gcen(3).lt.zmin_t) zmin_t=gcen(3)+t_magcopy(imag)%zmin
        if (t_magcopy(imag)%zmax+gcen(3).gt.zmax_t) zmax_t=gcen(3)+t_magcopy(imag)%zmax
      enddo

      tmc=t_magcopy
      kmag=0
      nesti=0

      do imag=1,nmagtot_t
        if (tmc(imag)%IsPole.ne.0) cycle
        kproto=tmc(imag)%kproto
        nesti=nesti+
     &    t_magnets(kproto)%nxdiv*t_magnets(kproto)%nydiv*t_magnets(kproto)%nzdiv
        kmag=kmag+1
        t_magcopy(kmag)=tmc(imag)
      enddo

      do imag=1,nmagtot_t
        if (tmc(imag)%IsPole.eq.0) cycle
        kproto=tmc(imag)%kproto
        nesti=nesti+
     &    t_magnets(kproto)%nxdiv*t_magnets(kproto)%nydiv*t_magnets(kproto)%nzdiv
        kmag=kmag+1
        t_magcopy(kmag)=tmc(imag)
      enddo

      deallocate(tmc)

      if (matrix.ne.0) then
        allocate(wwmatrix4(3,3,nesti,nesti),stat=istat)
        if (istat.ne.0) then
          write(lun6,*)'*** Warning in clcmag_copy_magnets: Not enough memory for interaction matrix of size 3 x 3 x',nesti,' x ',nesti
          write(lun6,*) '** UNDUMAG will fail in undumag_proc ***'
        else
          deallocate(wwmatrix4)
          write(lun6,*)
          write(lun6,*)'--- Expected size of interaction matrix of size 3x3x',nesti,' x ',nesti
        endif
      endif

      return
      end
+DECK,clcmag_shrink_xyz.
*CMZ :  2.04/03 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/01 20/01/2023  17.31.48  by  Michael Scheer
*CMZ :  2.04/00 14/01/2023  16.20.31  by  Michael Scheer
*CMZ :  2.02/01 24/01/2022  16.24.16  by  Michael Scheer
*-- Author :    Michael Scheer   25/10/2021
      subroutine clcmag_shrink_xyz(imag)

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure

      implicit none

      Type(T_Magnet) tmi,tmo

      double precision, dimension(:), allocatable :: x,y,z

      integer, dimension(:), allocatable :: khull,kface
      integer, dimension(:,:), allocatable :: kedge

      ! Shrinking of the magnet to the effective size
      ! xhull etc. refer to center of mass system

      double precision gcen(3)
      integer imag,i,istat,nin

      tmi=t_magnets(imag)
      tmo=t_magnets(imag)

      if (tmi%IsPole.ne.0) then
        write(lun6,*)"*** Warning clcmag_shrink_xyz is called for a pole ***"
      endif

      gcen=0.0d0
      call util_shrink_xyz(tmi%nhull,
     &  tmi%xhull0,tmi%yhull0,tmi%zhull0,gcen,coating,hulltiny,
     &  tmo%nhull,tmo%xhull,tmo%yhull,tmo%zhull,istat)

      nin=tmo%nhull

+self,if=debugshrink.
      do i=1,nin
        write(77,*)i,tmo%xhull(i),tmo%yhull(i),tmo%zhull(i),tmo%gcen
      enddo
      flush(77)
+self.
      allocate(x(nin),y(nin),z(nin),
     &  khull(nin),kedge(4,2*nin),kface((nin+1)*nin))

      call clcmag_update_magnet(tmo)

      t_magnets(imag)=tmo

+self,if=debugshrink.
      do i=1,nin
        write(78,*)i,t_magnets(imag)%xhull(i),t_magnets(imag)%yhull(i),t_magnets(imag)%zhull(i),t_magnets(imag)%gcen
      enddo
      flush(78)
+self.
      deallocate(x,y,z,khull,kedge,kface)

      return
      end
+DECK,CLCMAG_SHRINK_magnets.
*CMZ :  2.04/08 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/03 03/03/2023  14.14.57  by  Michael Scheer
*CMZ :  2.04/01 20/01/2023  12.55.16  by  Michael Scheer
*CMZ :  2.04/00 14/01/2023  11.51.31  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  13.37.13  by  Michael Scheer
*CMZ :  2.02/01 24/01/2022  17.35.48  by  Michael Scheer
*-- Author :    Michael Scheer   25/10/2021
      subroutine clcmag_shrink_magnets

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure

      implicit none

      ! Apply coating to permanent magnets,
      ! i.e. shrinking of the magnet to the effective size

      ! xhull etc. refer to lab-system

      double precision vol

      integer imag,k,l,i,kfail,npoi
      type (T_Magnet) tmag

      if (coating.eq.0.0d0) return

      do k=1,nmagtot_t
        t_magnets(k)%IsPart=0
        do l=1,nmagtot_t
          if (k.ne.l.and.t_magnets(k)%cmoth.eq.t_magnets(l)%cmoth) t_magnets(k)%IsPart=1
        enddo
      enddo

      do imag=1,nmagtot_t

        tmag=t_magnets(imag)
        if (tmag%IsPole.ne.0.or.tmag%ctype.eq.'Cylinder') cycle

        if (tmag%IsPart.ne.0) then
          write(lun6,*)""
          write(lun6,*)"*** Warning in clcmag_shrink_magnets: Shrinking magnet, which is part of the compound mother magnet ***"
          write(lun6,*)"*** Mother, magnet:  ",trim(tmag%cmoth),"  ",trim(tmag%cnam)
          write(lun6,*)""
        endif

        if (tmag%ctype.eq.'Corners'.or.tmag%ctype.eq.'File') then
          call clcmag_shrink_xyz(imag)
        endif

      enddo !imag

      do imag=1,nmagtot_t
        if (t_magnets(imag)%ctype.eq.'Cylinder') cycle
        npoi=t_magnets(imag)%nhull
        do i=1,npoi
          k=t_magnets(imag)%khull(i)
          xpuffer1(i)=t_magnets(imag)%xhull(k)
          ypuffer1(i)=t_magnets(imag)%yhull(k)
          zpuffer1(i)=t_magnets(imag)%zhull(k)
        enddo
        call util_volume(npoi,xpuffer1,ypuffer1,zpuffer1,hulltiny,vol,kfail)
        if (kfail.ne.0) then
          print*,"*** Warning in clcmag_shrink_magnets: Bad return from util_volume ***"
          print*,"*** Magnet: ",t_magnets(imag)%cnam
        else
          t_magnets(imag)%volume=vol
        endif
      enddo

      return
      end
+DECK,clcbuff_to_magnets.
*CMZ :  2.04/10 23/08/2023  08.02.18  by  Michael Scheer
*CMZ :  2.04/07 09/08/2023  16.11.22  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  12.23.20  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  16.43.57  by  Michael Scheer
*CMZ :  2.04/01 22/01/2023  13.04.45  by  Michael Scheer
*CMZ :  2.04/00 17/01/2023  09.24.20  by  Michael Scheer
*CMZ :  2.03/00 22/08/2022  12.31.51  by  Michael Scheer
*CMZ :  2.02/01 29/01/2022  15.17.16  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcbuff_to_magnets

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

+seq,grarad.

      character(2048) cline,cbuff(5),cfile,cline1
      character(128) cword,ckey

      double precision, dimension (:), allocatable :: xp,yp,zp,xpc,ypc,zpc

      double precision undumag_variable_getval,size(3),dphi

      double precision x,dx,dy,dz,Br(5),xc,yc,zc,gcen(3),chamf,
     &  r,h,phi,radin,radout,height,angle,xyz(3),vol

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface

      integer i,k,l,m,kb,ib,ip,npoi,ir,ih,iphi,limit,
     &  nxdiv,nydiv,nzdiv,nhull,nface,nedge,kfacelast,kblockch

+self,if=debcm.
      integer n,ipoi,iplan
+self.
      integer ipos(2,1000),jpos(2,1000),nwords,istat,ibrn,ifound

      integer ifailhull,lun,ieof,kfail
      logical lexist

      !xhull,yhull,zhull are absolute at the end of this routine

      !call util_break
      nmag=nmag_t+nspecmag_t+nclccop_t

      allocate(t_magnets(nmag),t_magnets_copy(nmag))
      allocate(brnmat(2,nmag_t+nspecmag_t))

      nbrnmat=0

      nmag=0
      niron=0
      ncornmax=12
      nplanmax=8

      allocate(
     &  xpuffer1(ncornmax),ypuffer1(ncornmax),zpuffer1(ncornmax),
     &  xpuffer2(ncornmax),ypuffer2(ncornmax),zpuffer2(ncornmax),
     &  xpuffer3(ncornmax),ypuffer3(ncornmax),zpuffer3(ncornmax),
     &  xp(ncornmax),yp(ncornmax),zp(ncornmax),
     &  xpc(ncornmax),ypc(ncornmax),zpc(ncornmax),
     &  kface((ncornmax+1)*ncornmax),kedge(4,2*ncornmax-2),khull(ncornmax))

      ib=0
      kb=0

      limit=nclcmag+nclcspec

      do while (ib.lt.limit)

        if (kb.eq.0.and.ib.ge.nclcmag) then
          ib=0
          kb=1
          limit=nclcspec
        endif

        ib=ib+1

        if (kb.eq.0) then
          cline = clcmag(ib)
        else
          cline = clcspec(ib)
        endif

        call util_string_split(cline,1000,nwords,ipos,istat)

        if (cline(ipos(1,1):ipos(2,1)).eq.'Magnet'.or.
     &      cline(ipos(1,1):ipos(2,1)).eq.'Pole') then
          nmag=nmag+1
          t_magnets(nmag)%kmodule=magmodule(nmag)
          t_magnets(nmag)%IsSpecial=0
          cycle
        else if (cline(ipos(1,1):ipos(2,1)).eq.'Special_Magnet'.or.
     &      cline(ipos(1,1):ipos(2,1)).eq.'Special_Pole') then
          nspecmag=nspecmag+1
          nmag=nmag+1
          t_magnets(nmag)%kmodule=0
          t_magnets(nmag)%IsSpecial=1
          cycle
        endif

        ckey=cline(ipos(1,1):ipos(2,1))

        if (kb.eq.0) then
          cbuff=clcmag(ib:ib+4)
        else
          cbuff=clcspec(ib:ib+4)
        endif

        ib=ib+4

        t_magnets(nmag)%cnam=cline(ipos(1,2):ipos(2,2))
        t_magnets(nmag)%cmoth=cline(ipos(1,3):ipos(2,3))

        do m=1,nmag-1
          if (t_magnets(m)%cnam.eq.t_magnets(nmag)%cnam) then
            print*,""
            print*,"*** Error in clcbuff_to_magnets: Duplicate magnet ",
     &        t_magnets(m)%cnam
            print*,""
            stop "*** Program UNDUMAG aborted ***"
          endif
        enddo

        t_magnets(nmag)%cfile=''

        cword=cline(ipos(1,4):ipos(2,4))

        if (cword(1:1).eq.'$') then
          t_magnets(nmag)%icol=nint(undumag_variable_getval(cword))
        else
          read(cword,*)t_magnets(nmag)%icol
        endif

        cline=cbuff(2)
        call util_string_split(cline,1000,nwords,ipos,istat)

        do i=1,3
          cword=cline(ipos(1,i):ipos(2,i))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%xyz(i)=undumag_variable_getval(cword)
          else
            read(cword,*)t_magnets(nmag)%xyz(i)
          endif
        enddo

        xc=t_magnets(nmag)%xyz(1)
        yc=t_magnets(nmag)%xyz(2)
        zc=t_magnets(nmag)%xyz(3)

        cline=cbuff(3)
        call util_string_split(cline,1000,nwords,ipos,istat)

        if (kb.eq.0) then
          cline1=clcmag(ib-5)
        else
          cline1=clcspec(ib-5)
        endif

        if (cline1.eq.'Pole'.or.cline1.eq. 'Special_Pole') then
          niron=niron+1
          cword = cline(ipos(1,1):ipos(2,1))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%imat=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%imat
          endif
          t_magnets(nmag)%IsPole=1
        else
          do i=1,5
            cword=cline(ipos(1,i):ipos(2,i))
            if (cword(1:1).eq.'$') then
              cword=cline(ipos(1,i):ipos(2,i))
              Br(i)=undumag_variable_getval(cword)
            else
              read(cword,*)br(i)
            endif
          enddo
          t_magnets(nmag)%IsPole=0
          if (norm2(br(2:4)).ne.0.0d0) br(2:4)=br(2:4)/norm2(br(2:4))
          if (br(5).eq.0.0d0) br=0.0d0

          t_magnets(nmag)%brn=br(1)
+self,if=trace
          print*,"--trace: CLCBUFF_TO_MAGNETS:",nmag,t_magnets(nmag)%brn
+self.
          t_magnets(nmag)%br=br(2:4)*br(1)
          t_magnets(nmag)%imat=nint(br(5))

          ifound=0
          do ibrn=1,nbrnmat
            if (br(1).eq.brnmat(2,ibrn).and.br(5).eq.brnmat(1,ibrn)) then
              ifound=1
              exit
            endif
          enddo
          if (ifound.eq.0) then
            nbrnmat=nbrnmat+1
            brnmat(1,nbrnmat)=br(5) !material index
            brnmat(2,nbrnmat)=br(1) !Br
          endif
        endif  !Pole

        t_magnets(nmag)%ctype=ckey(1:32)
        t_magnets(nmag)%IsBlock=0
        t_magnets(nmag)%IsRotated=0

        if (ckey.eq.'Block') then

          if (irecrepl.ne.0) then
            t_magnets(nmag)%IsBlock=1
          else
            t_magnets(nmag)%IsBlock=-1
          endif

          cline=cbuff(4)
          call util_string_split(cline,1000,nwords,jpos,istat)

          do i=1,3
            cword=cline(jpos(1,i):jpos(2,i))
            if (cword(1:1).eq.'$') then
              t_magnets(nmag)%size(i)=undumag_variable_getval(cword)
            else
              read(cword,*)t_magnets(nmag)%size(i)
            endif
            if (t_magnets(nmag)%IsPole.eq.0.and.coating.ne.0.0d0) then
              t_magnets(nmag)%size(i)=t_magnets(nmag)%size(i)-2.0d0*coating
            endif
            if (t_magnets(nmag)%size(i).le.0.0d0) then
              t_magnets(nmag)%brn=0.0d0
              t_magnets(nmag)%br=0.0d0
            endif
          enddo

          cline=cbuff(5)
          call util_string_split(cline,1000,nwords,jpos,istat)

          cword=cline(jpos(1,1):jpos(2,1))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nxdiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nxdiv
          endif

          cword=cline(jpos(1,2):jpos(2,2))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nydiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nydiv
          endif

          cword=cline(jpos(1,3):jpos(2,3))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nzdiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nzdiv
          endif

          cword=cline(jpos(1,4):jpos(2,4))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%yfracdiv=undumag_variable_getval(cword)
          else
            read(cword,*)t_magnets(nmag)%yfracdiv
          endif

          cword=cline(jpos(1,5):jpos(2,5))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%zfracdiv=undumag_variable_getval(cword)
          else
            read(cword,*)t_magnets(nmag)%zfracdiv
          endif

          xc=t_magnets(nmag)%xyz(1)
          yc=t_magnets(nmag)%xyz(2)
          zc=t_magnets(nmag)%xyz(3)

          npoi=8

          xp(1)=xc-t_magnets(nmag)%size(1)/2.0d0
          xp(2)=xc+t_magnets(nmag)%size(1)/2.0d0
          xp(3)=xp(2)
          xp(4)=xp(1)
          xp(5:8)=xp(1:4)

          yp(1:4)=yc-t_magnets(nmag)%size(2)/2.0d0
          yp(5:8)=yc+t_magnets(nmag)%size(2)/2.0d0

          zp(1:2)=zc-t_magnets(nmag)%size(3)/2.0d0
          zp(3:4)=zc+t_magnets(nmag)%size(3)/2.0d0
          zp(5:8)=zp(1:4)

          else if (
     &        ckey.eq.'BlockChamf'.or.
     &        ckey.eq.'BlockUsChamf'.or.
     &        ckey.eq.'BlockDsChamf'
     &        ) then

          cline=cbuff(4)
          call util_string_split(cline,1000,nwords,jpos,istat)

          do i=1,3
            cword=cline(jpos(1,i):jpos(2,i))
            if (cword(1:1).eq.'$') then
              t_magnets(nmag)%size(i)=undumag_variable_getval(cword)
            else
              read(cword,*)t_magnets(nmag)%size(i)
            endif
            if (t_magnets(nmag)%size(i).le.0.0d0) then
              t_magnets(nmag)%brn=0.0d0
              t_magnets(nmag)%br=0.0d0
            endif
          enddo

          cword=cline(jpos(1,4):jpos(2,4))
          if (cword(1:1).eq.'$') then
            chamf=undumag_variable_getval(cword)
          else
            read(cword,*) chamf
          endif

          kblockch=0
          t_magnets(nmag)%UsChamf=chamf
          t_magnets(nmag)%DsChamf=chamf

          if (ckey.eq.'BlockUsChamf') then
            kblockch=-1
            t_magnets(nmag)%DsChamf=0.0d0
          else if (ckey.eq.'BlockDsChamf') then
            kblockch=1
            t_magnets(nmag)%UsChamf=0.0d0
          endif

          npoi=12

          dx=t_magnets(nmag)%size(1)
          dy=t_magnets(nmag)%size(2)
          dz=t_magnets(nmag)%size(3)

          if (dx.le.0.0d0.or.dy.le.0.0d0.or.dz.le.0.0d0) then
            t_magnets(nmag)%brn=0.0d0
            t_magnets(nmag)%br=0.0d0
          endif

          if (t_magnets(nmag)%IsPole.ne.0.) then
            call util_shrink_blockchamf(dx,dy,dz,chamf,kblockch,
     &        coating*0.0d0,npoi,xp,yp,zp)
          else
            call util_shrink_blockchamf(dx,dy,dz,chamf,kblockch,
     &        coating,npoi,xp,yp,zp)
          endif

          xp=xp+xc
          yp=yp+yc
          zp=zp+zc

          cline=cbuff(5)
          call util_string_split(cline,1000,nwords,jpos,istat)

          cword=cline(jpos(1,1):jpos(2,1))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nxdiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nxdiv
          endif

          cword=cline(jpos(1,2):jpos(2,2))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nydiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nydiv
          endif

          cword=cline(jpos(1,3):jpos(2,3))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nzdiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nzdiv
          endif

          cword=cline(jpos(1,4):jpos(2,4))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%yfracdiv=undumag_variable_getval(cword)
          else
            read(cword,*)t_magnets(nmag)%yfracdiv
          endif

          cword=cline(jpos(1,5):jpos(2,5))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%zfracdiv=undumag_variable_getval(cword)
          else
            read(cword,*)t_magnets(nmag)%zfracdiv
          endif

        else if (ckey.eq.'Cylinder') then

          cline=cbuff(4)
          call util_string_split(cline,1000,nwords,jpos,istat)

          do i=1,3
            cword=cline(jpos(1,i):jpos(2,i))
            if (cword(1:1).eq.'$') then
              t_magnets(nmag)%size(i)=undumag_variable_getval(cword)
            else
              read(cword,*)t_magnets(nmag)%size(i)
            endif
            if (t_magnets(nmag)%size(i).le.0.0d0) then
              t_magnets(nmag)%brn=0.0d0
              t_magnets(nmag)%br=0.0d0
            endif
          enddo

          cword=cline(jpos(1,4):jpos(2,4))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%size(i)=undumag_variable_getval(cword)
          else
            read(cword,*)t_magnets(nmag)%cylphi
          endif

          cline=cbuff(5)
          call util_string_split(cline,1000,nwords,jpos,istat)

          cword=cline(jpos(1,1):jpos(2,1))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nxdiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nxdiv
          endif

          cword=cline(jpos(1,2):jpos(2,2))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nydiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)nydiv
            phi=t_magnets(nmag)%cylphi
            nydiv=max(nydiv,int(phi/45.0))+2
            t_magnets(nmag)%nydiv=nydiv
          endif

          cword=cline(jpos(1,3):jpos(2,3))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nzdiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nzdiv
          endif

          radin=t_magnets(nmag)%size(1)
          radout=t_magnets(nmag)%size(2)
          height=t_magnets(nmag)%size(3)
          angle=t_magnets(nmag)%cylphi

          xyz=t_magnets(nmag)%xyz

          if (radin.lt.tiny) radin=tiny

          npoi=4*(nydiv+1)

          if(npoi.gt.ncornmax) then
            ncornmax=npoi
            deallocate(xp,yp,zp,xpc,ypc,zpc,kface,kedge,khull,
     &        xpuffer1,ypuffer1,zpuffer1,
     &        xpuffer2,ypuffer2,zpuffer2,
     &        xpuffer3,ypuffer3,zpuffer3
     &        )
            allocate(
     &        xpuffer1(ncornmax),ypuffer1(ncornmax),zpuffer1(ncornmax),
     &        xpuffer2(ncornmax),ypuffer2(ncornmax),zpuffer2(ncornmax),
     &        xpuffer3(ncornmax),ypuffer3(ncornmax),zpuffer3(ncornmax),
     &        xp(ncornmax),yp(ncornmax),zp(ncornmax),
     &        xpc(ncornmax),ypc(ncornmax),zpc(ncornmax),
     &        kface((npoi+1)*npoi),kedge(4,2*npoi-2),khull(ncornmax))
          endif

          ip=0
          r=radin
          npoi=0
          dphi=angle/dble(nydiv)*grarad1
          do ir=1,2
            h=-height/2.0d0
            do ih=1,2
              phi=-angle/2.0d0*grarad1
              do iphi=1,nydiv+1
                ip=ip+1
                xp(ip)=r*sin(phi)+xc
                yp(ip)=h+yc
                zp(ip)=r*cos(phi)+zc
                phi=phi+dphi
              enddo
              h=height/2.0d0
            enddo
            r=radout
          enddo

          npoi=ip

          call clcmag_cut_cyl(nmag)

        else if (ckey.eq.'Corners'.or.ckey.eq.'File') then

          cline=cbuff(4)
          call util_string_split(cline,1000,nwords,jpos,istat)

          cword=cline(jpos(1,1):jpos(2,1))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nxdiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nxdiv
          endif

          cword=cline(jpos(1,2):jpos(2,2))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nydiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nydiv
          endif

          cword=cline(jpos(1,3):jpos(2,3))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%nzdiv=nint(undumag_variable_getval(cword))
          else
            read(cword,*)t_magnets(nmag)%nzdiv
          endif

          cword=cline(jpos(1,4):jpos(2,4))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%yfracdiv=undumag_variable_getval(cword)
          else
            read(cword,*)t_magnets(nmag)%yfracdiv
          endif

          cword=cline(jpos(1,5):jpos(2,5))
          if (cword(1:1).eq.'$') then
            t_magnets(nmag)%zfracdiv=undumag_variable_getval(cword)
          else
            read(cword,*)t_magnets(nmag)%zfracdiv
          endif

          if (ckey.eq.'Corners') then

            read(cbuff(5),*) npoi

            if(npoi.gt.ncornmax) then
              ncornmax=npoi
              deallocate(xp,yp,zp,xpc,ypc,zpc,kface,kedge,khull,
     &          xpuffer1,ypuffer1,zpuffer1,
     &          xpuffer2,ypuffer2,zpuffer2,
     &          xpuffer3,ypuffer3,zpuffer3
     &          )
              allocate(
     &          xpuffer1(ncornmax),ypuffer1(ncornmax),zpuffer1(ncornmax),
     &          xpuffer2(ncornmax),ypuffer2(ncornmax),zpuffer2(ncornmax),
     &          xpuffer3(ncornmax),ypuffer3(ncornmax),zpuffer3(ncornmax),
     &          xp(ncornmax),yp(ncornmax),zp(ncornmax),
     &          xpc(ncornmax),ypc(ncornmax),zpc(ncornmax),
     &          kface((npoi+1)*npoi),kedge(4,2*npoi-2),khull(ncornmax))
            endif

            do i=1,npoi

              ib=ib+1
              if (kb.eq.0) then
                cline=clcmag(ib)
              else
                cline=clcspec(ib)
              endif

              call util_string_split(cline,1000,nwords,ipos,istat)

              do k=1,3
                cword=cline(ipos(1,k):ipos(2,k))
                if (cword(1:1).eq.'$') then
                  x=undumag_variable_getval(cword)
                else
                  read(cword,*)x
                endif
                if (k.eq.1) then
                  xp(i)=x+xc
                else if (k.eq.2) then
                  yp(i)=x+yc
                else if (k.eq.3) then
                  zp(i)=x+zc
                endif
              enddo !k

            enddo !npoi

          else !ckey

            cfile=cbuff(5)
            cline=trim(cfile)
            l=len_trim(cfile)
            if (cfile(1:1).eq."'") then
              cline=cfile(2:l-1)
            endif
            cfile=cline
            t_magnets(nmag)%cfile=trim(cfile)

            inquire(file=trim(cfile),exist=lexist)
            if (lexist.eqv..false.) then
              write(lun6,*)"*** Error in clcbuff_to_magnets: File"
              write(lun6,*)trim(cfile)
              write(lun6,*)"not found ***"
              stop
            endif

            open(newunit=lun,file=trim(cfile),status='old')
            npoi=0
            do while(.true.)
              call util_skip_comment_empty_end(lun,ieof)
              if (ieof.ne.0) exit
              read(lun,'(a)')cline
              npoi=npoi+1
            enddo
            rewind(lun)

            if(npoi.gt.ncornmax) then
              ncornmax=npoi
              deallocate(xp,yp,zp,kface,kedge,khull,
     &          xpuffer1,ypuffer1,zpuffer1,
     &          xpuffer2,ypuffer2,zpuffer2,
     &          xpuffer3,ypuffer3,zpuffer3)
              allocate(xp(ncornmax),yp(ncornmax),zp(ncornmax),
     &          kface((npoi+1)*npoi),kedge(4,2*npoi-2),khull(npoi),
     &          xpuffer1(ncornmax),ypuffer1(ncornmax),zpuffer1(ncornmax),
     &          xpuffer2(ncornmax),ypuffer2(ncornmax),zpuffer2(ncornmax),
     &          xpuffer3(ncornmax),ypuffer3(ncornmax),zpuffer3(ncornmax)
     &          )
            endif

            do i=1,npoi
              call util_skip_comment_empty_end(lun,ieof)
              read(lun,'(a)')cline
              call util_string_split(cline,1000,nwords,ipos,istat)
              do k=1,3
                cword=cline(ipos(1,k):ipos(2,k))
                if (cword(1:1).eq.'$') then
                  x=undumag_variable_getval(cword)
                else
                  read(cword,*)x
                endif
                if (k.eq.1) then
                  xp(i)=x+xc
                else if (k.eq.2) then
                  yp(i)=x+yc
                else if (k.eq.3) then
                  zp(i)=x+zc
                endif
              enddo !k
            enddo !npoi

          endif !Corners and File

        else

          write(lun6,*)"*** Error in clcbuff_to_magnets: Unknown magnet type:"
          write(lun6,*)trim(ckey)
          stop

        endif

+self,if=debcm.
        do i=1,npoi
          write(887,*)xp(i),yp(i),zp(i),i
        enddo
        flush(887)
        close(887)
+self.

        if (t_magnets(nmag)%IsPole.eq.0.and.t_magnets(nmag)%brn.eq.0.0d0) then
          !print*,"Test:",nmag,t_magnets(nmag)%brn
          nmag=nmag-1
          cycle
        endif

        call util_convex_hull_3d_overwrite(npoi,xp,yp,zp,khull,kedge,kface,
     &    nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

+self,if=debcm.
        l=0
        do iplan=1,nface
          l=l+1
          n=kface(l)
          do i=1,n
            l=l+1
            ipoi=kface(l)
            write(900,*)iplan,i,l,ipoi,xp(ipoi),yp(ipoi),zp(ipoi)
          enddo
        enddo
+self.
        if (ifailhull.ne.0.or.nhull.lt.4) then
          write(lun6,*)"*** Error in clcbuff_to_magnets: Subroutine util_convex_hull_3d failed for ",
     &      trim(t_magnets(nmag)%cnam)
          stop
        endif

        if (ifailhull.ne.0.or.nhull.lt.4) then
          write(lun6,*)"*** Error in clcbuff_to_magnets: Subroutine util_convex_hull_3d failed for ",
     &      trim(t_magnets(nmag)%cnam)
          stop
        endif

        npoi=nhull

        allocate(t_magnets(nmag)%xhull0(npoi))
        allocate(t_magnets(nmag)%yhull0(npoi))
        allocate(t_magnets(nmag)%zhull0(npoi))
        allocate(t_magnets(nmag)%xhull(npoi))
        allocate(t_magnets(nmag)%yhull(npoi))
        allocate(t_magnets(nmag)%zhull(npoi))
        allocate(t_magnets(nmag)%khull(npoi))
        allocate(t_magnets(nmag)%kface(kfacelast))
        allocate(t_magnets(nmag)%kedge(4,nedge))

        t_magnets(nmag)%nhull=npoi
        t_magnets(nmag)%khull(1:npoi)=khull(1:npoi)

        gcen=0.0d0
        do i=1,npoi
          t_magnets(nmag)%xhull0(i)=xp(i)
          t_magnets(nmag)%yhull0(i)=yp(i)
          t_magnets(nmag)%zhull0(i)=zp(i)
          t_magnets(nmag)%xhull(i)=xp(i)
          t_magnets(nmag)%yhull(i)=yp(i)
          t_magnets(nmag)%zhull(i)=zp(i)
          gcen=gcen+[xp(i),yp(i),zp(i)]
        enddo

        if (t_magnets(nmag)%ctype.eq.'Cylinder') then
          size=t_magnets(nmag)%size
          vol=(size(2)**2-size(1)**2)*size(3)*t_magnets(nmag)%cylphi/360.0d0*pi1
        else
          call util_volume(npoi,xp,yp,zp,hulltiny,vol,kfail)
          if (kfail.ne.0) then
            write(lun6,*)"*** Error in clcbuff_to_magnets: Subroutine util_volume failed for ",
     &        trim(t_magnets(nmag)%cnam)
            stop
          endif
        endif

        t_magnets(nmag)%volume=vol

        gcen=gcen/npoi
        t_magnets(nmag)%gcen=gcen

        t_magnets(nmag)%kedge(:,1:nedge)=kedge(:,1:nedge)
        t_magnets(nmag)%nedge=nedge
        t_magnets(nmag)%kedge(:,1:nedge)=kedge(:,1:nedge)
        t_magnets(nmag)%nface=nface
        t_magnets(nmag)%kfacelast=kfacelast
        t_magnets(nmag)%kface(1:kfacelast)=kface(1:kfacelast)

        nplanmax=max(nplanmax,nface)

        nxdiv=t_magnets(nmag)%nxdiv
        nydiv=t_magnets(nmag)%nydiv
        nzdiv=t_magnets(nmag)%nzdiv

        t_magnets(nmag)%nvoxels=0

        allocate(t_magnets(nmag)%kvoxels(nxdiv,nydiv,nzdiv))
        t_magnets(nmag)%kvoxels=0
        allocate(t_magnets(nmag)%t_xyzcuts(nxdiv,nydiv,nzdiv))
        allocate(t_magnets(nmag)%t_xycuts(nxdiv,nydiv))
        allocate(t_magnets(nmag)%t_xcuts(nxdiv))

      enddo !nclcmag

      deallocate(xp,yp,zp,xpc,ypc,zpc,kface,kedge,khull)

      !call util_break


      nmag_t=0
      nspecmag_t=0
      do i=1,nmag
        if (t_magnets(i)%IsSpecial.eq.1) then
          nspecmag_t=nspecmag_t+1
        else
          nmag_t=nmag_t+1
        endif
      enddo

      nplanmax_t=nplanmax
      ncornmax_t=ncornmax

      nmagtot_t=nmag_t+nspecmag_t

      deallocate(magmodule)

      return
      end
+DECK,clcmag_to_bpe.
*CMZ :  2.04/07 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.55.09  by  Michael Scheer
*CMZ :  2.02/01 11/02/2022  09.47.13  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine clcmag_to_bpe

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision xyz(3),br(3),bn,dx,dy,dz,bpe17,gcen(3)

      integer :: idebug=0

      integer kmod,kmag,kcopy,npoi,n,k,iv,ipoi,i,im,lunlis,ieof,lunkill,
     &  last,kill,kv

      character(128) cline
      character(32) chsel

+seq,random.
+seq,phyconparam.

      type (T_Magnet) :: tmag
      type (T_Voxel) :: tv

      allocate(bpebc(20,nvoxcopy_t))
      bpebc=0.0d0

      ! bpebc(1:3,... position x,y,z
      ! bpebc(4:6,... M vector, might be changed during relaxation
      ! bpebc(7,... length of M vector, might be changed during relaxation
      ! bpebc(8,... type
      ! bpebc(9,imag)=imat
      ! bpebc(10,imag) special magnet flag
      ! bpebc(11:13,imag) normalized M vector at the beginning, will survive
      ! bpebc(14,imag) length M vector at the beginning, will survive
      ! bpebc(15,imag) Mother volume
      ! bpebc(16,imag) kill flag
      ! bpebc(17,imag) select flag
      ! bpebc(18:20,imag) B of coils in voxel

      ! ibpeplan(imag)=nplan
      ! ibpecorn(iplan,imag)=ncorn
      ! ibpecol(imag) color index

      allocate(ibpeplan(nvoxcopy_t))
      allocate(ibpecol(nvoxcopy_t))
      allocate(ibpecorn(nplanmax,nvoxcopy_t))

      allocate(bpetm(3,8,nplanmax,nvoxcopy_t))
      allocate(bpemag(3,ncornmax,nplanmax,nvoxcopy_t))
      allocate(bperot(3,ncornmax,nplanmax,nvoxcopy_t))

      kv=0

      do iv=1,nvoxcopy_t

        if (idebug.ne.0) then
          print*,iv
        endif

        kmod=t_voxcopy(iv)%kmodule
        kmag=t_voxcopy(iv)%kproto

        tmag=t_magnets(kmag)
        if (tmag%IsPole.ne.0) cycle

        kv=kv+1

        im=t_voxcopy(iv)%kmagnet
        kvox=t_voxcopy(iv)%kvoxel
        kcopy=t_voxcopy(iv)%kcopy

        tv=tmag%t_voxels(kvox)

        gcen=t_voxcopy(iv)%gcen
        br=t_voxcopy(iv)%br

        bpebc(1,kv)=gcen(1)+xcentershift
        bpebc(2:3,kv)=gcen(2:3)

        bpebc(4:6,kv)=br
        bpebc(7,kv)=norm2(br)

        if ((irecrepl.ne.0.and.tv%isblock.ne.0).or.tmag%isblock.gt.0) then
          bpebc(8,kv)=-6.0
          dx=tv%xmax-tv%xmin
          dy=tv%ymax-tv%ymin
          dz=tv%zmax-tv%zmin
          call clcmag_bpemag(dx,dy,dz,bpemag(1:3,1:5,1:6,kv),bpebc(1:3,kv))
          ibpecorn(:,kv)=5
        else !Is Block}
          bpebc(8,kv)=1.0
        endif

        bpebc(9,kv)=tmag%imat
        bpebc(10,kv)=tmag%isspecial
        bn=norm2(br)

        if (bn.ne.0.0d0) bpebc(11:13,kv)=br/bn

        bpebc(14,kv)=bn
        bpebc(15,kv)=im
        bpebc(16,kv)=0.0
        bpebc(17,kv)=0.0

        ibpecol(kv)=tmag%icol
        ibpeplan(kv)=tv%nface

        if (tv%IsBlock.gt.0) cycle

        k=1
        do n=1,tv%nface
          npoi=tv%kface(k)
          ibpecorn(n,kv)=npoi+1
          do i=1,npoi
            k=k+1
            ipoi=tv%kface(k)
            xyz=[tv%xhull(ipoi),tv%yhull(ipoi),tv%zhull(ipoi)]
            bpemag(1:3,i,n,kv)=xyz+bpebc(1:3,kv)
          enddo
          bpemag(1:3,npoi+1,n,kv)=bpemag(1:3,1,n,kv)
          k=k+1
        enddo

      enddo !voxel

      do iv=1,nvoxcopy_t

        kmod=t_voxcopy(iv)%kmodule
        kmag=t_voxcopy(iv)%kproto

        tmag=t_magnets(kmag)
        if (tmag%IsPole.eq.0) cycle

        kv=kv+1

        im=t_voxcopy(iv)%kmagnet
        kvox=t_voxcopy(iv)%kvoxel
        kcopy=t_voxcopy(iv)%kcopy

        tv=tmag%t_voxels(kvox)

        gcen=t_voxcopy(iv)%gcen
        br=t_voxcopy(iv)%br

        bpebc(1,kv)=gcen(1)+xcentershift
        bpebc(2:3,kv)=gcen(2:3)

        bpebc(4:6,kv)=br
        bpebc(7,kv)=norm2(br)

        if ((irecrepl.ne.0.and.tv%isblock.ne.0).or.tmag%isblock.gt.0) then
          bpebc(8,kv)=-6.0
          dx=tv%xmax-tv%xmin
          dy=tv%ymax-tv%ymin
          dz=tv%zmax-tv%zmin
          call clcmag_bpemag(dx,dy,dz,bpemag(1:3,1:5,1:6,kv),bpebc(1:3,kv))
          ibpecorn(:,kv)=5
        else !Is Block}
          bpebc(8,kv)=1.0
        endif

        bpebc(9,kv)=tmag%imat
        bpebc(10,kv)=tmag%isspecial
        bn=norm2(br)

        if (bn.ne.0.0d0) bpebc(11:13,kv)=br/bn

        bpebc(14,kv)=bn
        bpebc(15,kv)=im
        bpebc(16,kv)=0.0
        bpebc(17,kv)=0.0

        ibpecol(kv)=tmag%icol
        ibpeplan(kv)=tv%nface

        if (tv%IsBlock.gt.0) cycle

        k=1
        do n=1,tv%nface
          npoi=tv%kface(k)
          ibpecorn(n,kv)=npoi+1
          do i=1,npoi
            k=k+1
            ipoi=tv%kface(k)
            xyz=[tv%xhull(ipoi),tv%yhull(ipoi),tv%zhull(ipoi)]
            bpemag(1:3,i,n,kv)=xyz+bpebc(1:3,kv)
          enddo
          bpemag(1:3,npoi+1,n,kv)=bpemag(1:3,1,n,kv)
          k=k+1
        enddo

      enddo !voxel

      if (killbadmag.eq.-9999) then
        bpebc(16,:)=1.0d0
      else
        bpebc(16,:)=0.0d0
      endif

      if (killbadmag.gt.0.or.killbadmag.eq.-9999) then
        write(lun6,*)
        write(lun6,*)"Killing all voxels, but"
        open(newunit=lunkill,file="undumag.kll")
        do while (.true.)
          call util_read_line(lunkill,cline,last)
          if (last.le.0) exit
          read(cline,*)kmag,kill
          if (kmag.gt.nmag) then
            write(lun6,*)"*** Error in undumag_ini_magnets: Non existing voxel ",kmag," on undumag.kll ***"
            stop
          endif
          if (killbadmag.ne.-9999) then
            bpebc(16,kmag)=kill
            write(lun6,*)"Killing voxel ",kmag," due to flag killbadmag"
          else
            write(lun6,*)kmag
            bpebc(16,kmag)=0.0d0
          endif
        enddo
        close(lunkill)
        write(lun6,*)
      endif

      if (intmaglis.ne.0) then
        write(lun6,*)
        write(lun6,*)" --- Due to flag intmaglis, only magnets on file undumag_magmap.lis do contribute to field map ---"
        write(lun6,*)
        open(newunit=lunlis,file="undumag_magmap.lis")
        do while (.true.)
          call util_skip_comment_end(lunlis,ieof)
          if (ieof.ne.0) exit
          read(lunlis,*)chsel,bpe17
          do iv=1,nvoxcopy_t
            kmag=t_voxcopy(iv)%kproto
            if (t_magnets(kmag)%cmoth.eq.chsel) then
              if (bpe17.gt.0.0d0) then
                bpebc(17,iv)=1.0d0
              else if (bpe17.lt.0.0d0) then
                bpebc(17,iv)=2.0d0
              endif
            endif
          enddo
        enddo
        close(lunlis)
      endif !intmaglis

      return
      end
+DECK,clcmag_copy.
*CMZ :  2.04/05 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 26/01/2022  11.19.15  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_copy(kcopy)

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      integer i,k,ifound,kcopy
      integer ipos(2,1000),nwords,istat

      character(32) cnam,cnamnew,cmoth

      i=kcopy

      call util_string_split(clccop(i),1000,nwords,ipos,istat)

      cnam=clccop(i)(ipos(1,1):ipos(2,1))
      cnamnew=clccop(i)(ipos(1,2):ipos(2,2))
      cmoth=clccop(i)(ipos(1,3):ipos(2,3))

      do k=1,nmagtot_t
        if (t_magnets(k)%cmoth.eq.cnam) then
          print*,"*** Error in clcmag_copy: Can copy magnets only, not mother volumes, check " // cnam // " ***"
          return
        endif
      enddo

      do k=1,nmagtot_t
        ifound=0
        if (t_magnets(k)%cnam.eq.cnam) then
          ifound=k
          if (t_magnets(k)%IsSpecial.ne.0) then
            nmagtot_t=nmagtot_t+1
            nspecmag_t=nspecmag_t+1
            t_magnets(nmagtot_t)=t_magnets(k)
            t_magnets(nmagtot_t)%cnam=cnamnew
            t_magnets(nmagtot_t)%cmoth=cmoth
          else if (nspecmag_t.eq.0) then
            nmagtot_t=nmagtot_t+1
            nmag_t=nmag_t+1
            t_magnets(nmag_t)=t_magnets(k)
            t_magnets(nmag_t)%cnam=cnamnew
            t_magnets(nmag_t)%cmoth=cmoth
          else
            nmagtot_t=nmagtot_t+1
            nmag_t=nmag_t+1
            t_magnets(nmagtot_t)=t_magnets(nmag_t)
            t_magnets(nmag_t)=t_magnets(k)
            t_magnets(nmag_t)%cnam=cnamnew
            t_magnets(nmag_t)%cmoth=cmoth
          endif
          exit
        endif
      enddo

      if (ifound.eq.0) then
        print*,"*** Error in clcmag_copy: Cannot copy " // cnam // ", not found ***"
        return
      endif

      return
      end
+DECK,clctransrotcop.
*CMZ :  2.04/10 23/08/2023  08.05.44  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.49.50  by  Michael Scheer
*CMZ :  2.04/07 09/08/2023  09.15.04  by  Michael Scheer
*CMZ :  2.04/06 01/08/2023  15.05.17  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/01 20/01/2023  08.02.02  by  Michael Scheer
*CMZ :  2.04/00 16/01/2023  15.35.00  by  Michael Scheer
*CMZ :  2.02/01 26/01/2022  11.22.41  by  Michael Scheer
*-- Author :    Michael Scheer   29/12/2021
      subroutine clctransrotcop

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none
+seq,grarad.

      type(T_magnet) tmag
      double precision rm(3,3),t8(8),r(3),xmin,xmax,ymin,ymax,zmin,zmax
      integer imag,itr,ipoi,istat,ifound,iold,i,key,ipos(2,100),nwords,iv
      integer :: ndim=100,j,nvar
      character(2048) cline
      character(128) ctrans,cvar

      double precision undumag_variable_getval

+self,if=trace.
      print*,"-trace-: Entered clctransrotcop "
+self.

      do itr=1,ntransrotcop

        t8=transrotcop(:,itr)
        key=int(t8(8))
        i=int(t8(1))

        if (i.le.0) cycle

        nvar=3
        if (key.eq.3) nvar=6

        cline=clcbuff(i)
        call util_string_split(cline,ndim,nwords,ipos,istat)

        do j=1,nvar
          cvar=cline(ipos(1,j):ipos(2,j))
          if (cvar(1:1).eq.'$') then
            transrotcop(j,itr)=undumag_variable_getval(trim(cvar))
          else
            read(cvar,*) transrotcop(j,itr)
          endif
        enddo !nvar

        if (key.eq.2) then
          ! Rotation
          cline=clcbuff(i+1)
          call util_string_split(cline,ndim,nwords,ipos,istat)
          do j=1,4
            cvar=cline(ipos(1,j):ipos(2,j))
            if (cvar(1:1).eq.'$') then
              transrotcop(3+j,itr)=undumag_variable_getval(trim(cvar))
            else
              read(cvar,*) transrotcop(3+j,itr)
            endif
          enddo
        endif !key

      enddo !ntransrotcop

      iold=0
      ctrans=''
      do itr=1,ntransrotcop
        ifound=0
        do imag=1,nmagtot_t
          tmag=t_magnets(imag)
          if (tmag%ctype.eq.'Cylinder') cycle
          t8=transrotcop(:,itr)
          if(
     &        tmag%cmoth.eq.ctransrotcop(itr).or.
     &        tmag%cnam.eq.ctransrotcop(itr)
     &        ) then
            ifound=itr
            if (t8(8).eq.0.0d0) then
              t_magnets(imag)%xmin=t_magnets(imag)%xmin+t8(1)
              t_magnets(imag)%xmax=t_magnets(imag)%xmax+t8(1)
              t_magnets(imag)%ymin=t_magnets(imag)%ymin+t8(2)
              t_magnets(imag)%ymax=t_magnets(imag)%ymax+t8(2)
              t_magnets(imag)%zmin=t_magnets(imag)%zmin+t8(3)
              t_magnets(imag)%zmax=t_magnets(imag)%zmax+t8(3)
              t_magnets(imag)%xyz=t_magnets(imag)%xyz+t8(1:3)
              t_magnets(imag)%gcen=t_magnets(imag)%gcen+t8(1:3)
              do ipoi=1,tmag%nhull
                t_magnets(imag)%xhull(ipoi)=t_magnets(imag)%xhull(ipoi)+t8(1)
                t_magnets(imag)%yhull(ipoi)=t_magnets(imag)%yhull(ipoi)+t8(2)
                t_magnets(imag)%zhull(ipoi)=t_magnets(imag)%zhull(ipoi)+t8(3)
              enddo
              do iv=1,t_magnets(imag)%nvoxels
                t_magnets(imag)%t_voxels(iv)%xmin=t_magnets(imag)%t_voxels(iv)%xmin+t8(1)
                t_magnets(imag)%t_voxels(iv)%xmax=t_magnets(imag)%t_voxels(iv)%xmax+t8(1)
                t_magnets(imag)%t_voxels(iv)%ymin=t_magnets(imag)%t_voxels(iv)%ymin+t8(2)
                t_magnets(imag)%t_voxels(iv)%ymax=t_magnets(imag)%t_voxels(iv)%ymax+t8(2)
                t_magnets(imag)%t_voxels(iv)%zmin=t_magnets(imag)%t_voxels(iv)%zmin+t8(3)
                t_magnets(imag)%t_voxels(iv)%zmax=t_magnets(imag)%t_voxels(iv)%zmax+t8(3)
                t_magnets(imag)%t_voxels(iv)%xyz=t_magnets(imag)%t_voxels(iv)%xyz+t8(1:3)
                t_magnets(imag)%t_voxels(iv)%gcen=t_magnets(imag)%t_voxels(iv)%gcen+t8(1:3)
                do ipoi=1,t_magnets(imag)%t_voxels(iv)%nhull
                  t_magnets(imag)%t_voxels(iv)%xhull(ipoi)=t_magnets(imag)%t_voxels(iv)%xhull(ipoi)+t8(1)
                  t_magnets(imag)%t_voxels(iv)%yhull(ipoi)=t_magnets(imag)%t_voxels(iv)%yhull(ipoi)+t8(2)
                  t_magnets(imag)%t_voxels(iv)%zhull(ipoi)=t_magnets(imag)%t_voxels(iv)%zhull(ipoi)+t8(3)
                enddo
              enddo
            else if (t8(8).eq.3.0d0) then
              if (tmag%IsPole.ne.0) then
                write(lun6,*)"*** Warning in clctransrotcop: Setting remanence not allowed for iron ***"
                write(lun6,*)"*** Pole:",tmag%cnam
                cycle
              endif
              t_magnets(imag)%Brn=t8(1)
              t_magnets(imag)%Br=0.0d0
              if(norm2(t8(2:4)).ne.0.0d0)
     &          t_magnets(imag)%Br=t8(1)*t8(2:4)/norm2(t8(2:4))
              t_magnets(imag)%imat=int(t8(5))
              t_magnets(imag)%icol=int(t8(6))
            else if (t8(8).eq.1.0d0.or.t8(8).eq.2.0d0) then
              if (t8(8).eq.2.0d0) t_magnets(imag)%IsRotated=1
              call util_rotmat(t8(4:6),t8(7)*grarad1,rm,istat)
              if (t8(8).eq.2) then
                call util_mat_mul_vec_3x3(rm,tmag%br,t_magnets(imag)%br)
              endif
              r=tmag%xyz-t8(1:3)
              call util_mat_mul_vec_3x3(rm,r,r)
              t_magnets(imag)%xyz=r+t8(1:3)
              r=tmag%gcen-t8(1:3)
              call util_mat_mul_vec_3x3(rm,r,r)
              t_magnets(imag)%gcen=r+t8(1:3)
              !xmin=1.0d30
              !xmax=-1.0d30
              !ymin=1.0d30
              !ymax=-1.0d30
              !zmin=1.0d30
              !zmax=-1.0d30
              do ipoi=1,tmag%nhull
                r=[tmag%xhull(ipoi)-t8(1),tmag%yhull(ipoi)-t8(2),tmag%zhull(ipoi)-t8(3)]
                call util_mat_mul_vec_3x3(rm,r,r)
                t_magnets(imag)%xhull(ipoi)=r(1)+t8(1)
                t_magnets(imag)%yhull(ipoi)=r(2)+t8(2)
                t_magnets(imag)%zhull(ipoi)=r(3)+t8(3)
                !if (r(1)+t8(1).lt.xmin) xmin=r(1)+t8(1)
                !if (r(1)+t8(1).gt.xmax) xmax=r(1)+t8(1)
                !if (r(2)+t8(2).lt.ymin) ymin=r(2)+t8(2)
                !if (r(2)+t8(2).gt.ymax) ymax=r(2)+t8(2)
                !if (r(3)+t8(3).lt.zmin) zmin=r(3)+t8(3)
                !if (r(3)+t8(3).gt.zmax) zmax=r(3)+t8(3)
              enddo
              do iv=1,t_magnets(imag)%nvoxels
                if (t8(8).eq.2) then
                  call util_mat_mul_vec_3x3(rm,tmag%br,t_magnets(imag)%t_voxels(iv)%br)
                endif
                r=t_magnets(imag)%t_voxels(iv)%xyz-t8(1:3)
                call util_mat_mul_vec_3x3(rm,r,r)
                t_magnets(imag)%t_voxels(iv)%xyz=r+t8(1:3)
                r=t_magnets(imag)%t_voxels(iv)%gcen-t8(1:3)
                call util_mat_mul_vec_3x3(rm,r,r)
                t_magnets(imag)%t_voxels(iv)%gcen=r+t8(1:3)
                !xmin=1.0d30
                !xmax=-1.0d30
                !ymin=1.0d30
                !ymax=-1.0d30
                !zmin=1.0d30
                !zmax=-1.0d30
                do ipoi=1,t_magnets(imag)%t_voxels(iv)%nhull
                  r=[t_magnets(imag)%t_voxels(iv)%xhull(ipoi)-t8(1),
     &              t_magnets(imag)%t_voxels(iv)%yhull(ipoi)-t8(2),
     &              t_magnets(imag)%t_voxels(iv)%zhull(ipoi)-t8(3)]
                  call util_mat_mul_vec_3x3(rm,r,r)
                  t_magnets(imag)%t_voxels(iv)%xhull(ipoi)=r(1)+t8(1)
                  t_magnets(imag)%t_voxels(iv)%yhull(ipoi)=r(2)+t8(2)
                  t_magnets(imag)%t_voxels(iv)%zhull(ipoi)=r(3)+t8(3)
                  !if (r(1)+t8(1).lt.xmin) xmin=r(1)+t8(1)
                  !if (r(1)+t8(1).gt.xmax) xmax=r(1)+t8(1)
                  !if (r(2)+t8(2).lt.ymin) ymin=r(2)+t8(2)
                  !if (r(2)+t8(2).gt.ymax) ymax=r(2)+t8(2)
                  !if (r(3)+t8(3).lt.zmin) zmin=r(3)+t8(3)
                  !if (r(3)+t8(3).gt.zmax) zmax=r(3)+t8(3)
                enddo
              enddo
            else if (t8(8).lt.0.0d0) then
              call clcmag_copy(-int(t8(8)))
            else
              ifound=0
            endif
          endif
        enddo !imag
c        if (ifound.eq.0.and.itr.ne.iold.and.ctrans.ne.ctransrotcop(itr)) then
        if (ifound.eq.0) then
          write(lun6,*)"*** Warning in clctransrotcop: No magnet found or undefined action ***"
          write(lun6,*)"Action, Magnet:",itr,ctransrotcop(itr)
          write(lun6,*)
          iold=itr
          ctrans=ctransrotcop(itr)
        endif
      enddo !ntransrotcop

+self,if=trace.
      print*,"-trace-: Leaving clctransrotcop "
+self.

      call transrotcopcyl

      return
      end
+DECK,undumag_bpolyplot_old.
*CMZ :  2.04/10 22/08/2023  09.42.44  by  Michael Scheer
*CMZ :  2.04/01 18/01/2023  17.45.21  by  Michael Scheer
*CMZ :  2.02/01 07/02/2022  13.13.34  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  13.07.52  by  Michael Scheer
*CMZ :  2.01/02 25/04/2018  11.48.35  by  Michael Scheer
*CMZ :  1.25/01 19/03/2018  16.23.08  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.02.34  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.20.09  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  12.45.15  by  Michael Scheer
*CMZ :  1.17/08 27/05/2017  10.32.42  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  14.33.44  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.09.14  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.50  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.39.32  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.47.10  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.49.25  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.46.16  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.01.00  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  13.31.06  by  Michael Scheer
*CMZ :  1.02/01 08/09/2016  15.25.02  by  Michael Scheer
*CMZ :  1.02/00 23/08/2016  12.01.08  by  Michael Scheer
*CMZ :  0.00/13 31/07/2016  16.05.11  by  Michael Scheer
*CMZ :  0.00/01 25/04/2016  15.07.20  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.27.40  by  Michael Scheer
*CMZ :  1.17/02 09/10/2014  14.52.20  by  Michael Scheer
*CMZ :  1.17/01 03/10/2014  11.25.46  by  Michael Scheer
*CMZ :  1.17/00 25/08/2014  15.14.09  by  Michael Scheer
*CMZ :  1.16/04 16/04/2014  15.34.26  by  Michael Scheer
*CMZ :  1.16/01 14/03/2014  12.26.15  by  Michael Scheer
*CMZ :  1.12/16 01/06/2007  11.17.50  by  Michael Scheer
*CMZ :  1.12/08 02/08/2006  17.03.41  by  Michael Scheer
*CMZ :  1.11/03 21/06/2005  12.56.55  by  Michael Scheer
*CMZ :  1.11/01 01/03/2005  09.45.36  by  Michael Scheer
*CMZ :  1.10/04 25/02/2005  11.55.05  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  08.54.30  by  Michael Scheer
*CMZ :  1.01/01 11/08/2004  13.30.53  by  Michael Scheer
*CMZ :  1.01/00 02/03/2004  17.00.13  by  Michael Scheer
*CMZ :  1.00/01 27/02/2004  14.29.35  by  Michael Scheer
*CMZ :  1.00/00 26/02/2004  17.21.29  by  Michael Scheer
*CMZ :  0.99/13 26/02/2004  16.14.57  by  Michael Scheer
*CMZ :  0.99/12 26/02/2004  12.02.34  by  Michael Scheer
*CMZ :  0.99/11 25/02/2004  15.21.06  by  Michael Scheer
*CMZ :  0.99/10 25/02/2004  13.42.35  by  Michael Scheer
*CMZ :  0.99/09 20/02/2004  17.26.48  by  Michael Scheer
*CMZ :  0.99/08 20/02/2004  16.32.55  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  15.21.29  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  13.55.05  by  Michael Scheer
*CMZ :  0.99/00 26/01/2004  17.03.49  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  12.52.23  by  Michael Scheer
*CMZ :  0.00/07 16/01/2004  11.05.44  by  Michael Scheer
*CMZ :  0.00/06 09/01/2004  15.55.17  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  14.52.54  by  Michael Scheer
*CMZ :  0.00/04 23/12/2003  10.15.07  by  Michael Scheer
*CMZ :  0.00/02 15/12/2003  12.43.34  by  Michael Scheer
*CMZ :  0.00/01 10/12/2003  17.56.52  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bpolyplot_old(iplot,xmin,xmax,ymin,ymax,zmin,zmax,
     &  theta,phi,nwitems,ncwires,wire)

+seq,bpolyederf90u.

      use commandlinef90m

      implicit none

+seq,mshplt.
+seq,bpolyeder,if=static.

      integer npawp
      parameter (npawp=10000)

      integer nwitems,ncwires
      double precision wire(nwitems,ncwires)

      real, dimension (:), allocatable :: xpl,ypl,zpl,zplm,xmpl,ympl,zmpl

      real hpaw(npawp),
     &  xplb(2),yplb(2),zplb(2),
     &  xplbo(2),yplbo(2),zplbo(2),rmtyp31,rmtyp24,rmtyp20,rlwidth,rlwidtho

      real xmin,xmax,ymin,ymax,zmin,zmax,theta,phi,
     &  x,y,z,bx,by,bz,dx,dy,dz,bxo,byo,bzo,bo,eps,
     &  xmn,xmx,ymn,ymx,zmn,zmx,
     &  xmmn,xmmx,ymmn,ymmx,zmmn,zmmx,
     &  xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &  rmoth,rmag,rcol,rcolo,rplan,rcorn,rmat,rmato,
     &  xc,yc,zc,xmc(1),ymc(1),zmc(1),dot0,circ0,pscal,vn,vnx,vny,vnz

c      integer ibatch
      integer i,iplot,iplot1,iplot10,iplot100,idev,
     &  imoth,imag,icol,iplan,icorn,
     &  iplano,ncorno,iline,nline,iallo,
     &  ncorn,nplanmax,ncornmax,idx,igird,imago,impl,izero,nfirst,nlast

      integer icolor,ired,igreen,iblue,luncnf,lunmag

      character(20) cdx
      character(23) cdxmm
      character(64) ctitle,cline

      common/pawc/hpaw

      data dot0/25./
      data circ0/5./
      data rmtyp20/20./
      data rmtyp24/-9999./
      data rmtyp31/31./

      data eps/0.01/

      iallo=0

      write(lun6,*)
      write(lun6,*) "Reading file undumag.mag and writing geometry to plot file undumag.eps"
      write(lun6,*)

      open(newunit=luncnf,file='.mshplt.cnf')

      write(luncnf,'(a)')"0 !idev, 0: viewer is not used"
      write(luncnf,'(a)')"-20. -20. !plot size in cm, negative values indicate HIGZ compatible mode"
      write(luncnf,'(a)')"0.8 !rescaling factor; if not one, plot files are copied and rescaled"
      write(luncnf,'(a)')"0 0 800 800 !bounding box"
      write(luncnf,'(a)')"undumag.eps !base name of plotfiles"
      write(luncnf,'(a)')"$UNDUMAG/shell/undumag_viewer.sh"
      write(luncnf,'(a)')"$UNDUMAG/shell/undumag_kill_viewer.sh"

      close(luncnf)

      nplanmax=0
      ncornmax=0

      iplano=0
      nline=0

      xmn=1.e10
      xmx=-1.e10
      ymn=1.e10
      ymx=-1.e10
      zmn=1.e10
      zmx=-1.e10

      if (jrunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      if (ncwires.gt.0) then
        do i=1,ncwires
          x=wire(3,i)
          y=wire(4,i)
          z=wire(5,i)
          if (x.lt.xmn) xmn=x
          if (x.gt.xmx) xmx=x
          if (y.lt.ymn) ymn=y
          if (y.gt.ymx) ymx=y
          if (z.lt.zmn) zmn=z
          if (z.gt.zmx) zmx=z
          x=wire(6,i)
          y=wire(7,i)
          z=wire(8,i)
          if (x.lt.xmn) xmn=x
          if (x.gt.xmx) xmx=x
          if (y.lt.ymn) ymn=y
          if (y.gt.ymx) ymx=y
          if (z.lt.zmn) zmn=z
          if (z.gt.zmx) zmx=z
        enddo
        ncornmax=2
      endif

      open(newunit=lunmag,file='undumag.mag',status='old')

      read(lunmag,'(a)')cline

1     read(lunmag,*,end=9) rmoth,rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz,rmat

      if (bx**2+by**2+bz**2.eq.0.0d0) goto 1

      nline=nline+1

      imag=nint(rmag)
      icol=nint(rcol)
      iplan=nint(rplan)
      icorn=nint(rcorn)

      if (iplan.gt.nplanmax) nplanmax=iplan
      if (abs(icorn).gt.ncornmax) ncornmax=abs(icorn)

      if (x.lt.xmn) xmn=x
      if (x.gt.xmx) xmx=x
      if (y.lt.ymn) ymn=y
      if (y.gt.ymx) ymx=y
      if (z.lt.zmn) zmn=z
      if (z.gt.zmx) zmx=z

      goto 1

9     rewind (lunmag)

      if (ncornmax.eq.0) then
        write(lun6,*)"*** Warning in undumag_bpolyplot_old: Nothing to plot!?"
        goto 9999
      endif

      allocate(xpl(ncornmax))
      allocate(ypl(ncornmax))
      allocate(zpl(ncornmax))
      allocate(zplm(ncornmax))

      allocate(xmpl(ncornmax*nplanmax))
      allocate(ympl(ncornmax*nplanmax))
      allocate(zmpl(ncornmax*nplanmax))

      iallo=1

      call mlimit(npawp)
      if (jdate.ne.0) then
        call mplopt('DATE',1)
      else
        call mplopt('NDAT',1)
      endif
      call mplint(idev)
      if (jdate.ne.0) then
        call mplopt('DATE',1)
      else
        call mplopt('NDAT',1)
      endif
      call mplset('YGTI',0.)
      call mplset('GSIZ',0.3)
      call mgset('TXCI',1.)

      iplot100=abs(iplot)/100
      iplot10=(abs(iplot)-iplot100*100)/10
      iplot1=abs(iplot)-iplot100*100-iplot10*10

      call mshplt_get_line_width(rlwidtho)
      rlwidth=rlwidtho
      call mshplt_set_line_width(rlwidtho/2.)

c--- Open plotfiles {

      if (iplot.gt.0) then

        if (idev.ne.0) then
          call mgmeta(98,-111)    !seite 22
        else
          call mgmeta(-98,-111)    !seite 22
        endif

      else if (iplot.lt.0) then

        if (idev.ne.0) then
          call mgmeta(98,-113)    !seite 22
        else
          call mgmeta(-98,-113)    !seite 22
        endif

      endif !iplot

c--- Open plotfiles }

      iplano=1

      if (xmin.eq.9999.) then
        xplmin=xmn
      else
        xplmin=xmin
      endif

      if (xmax.eq.9999.) then
        xplmax=xmx
      else
        xplmax=xmax
      endif

      if (ymin.eq.9999.) then
        yplmin=ymn
      else
        yplmin=ymin
      endif

      if (ymax.eq.9999.) then
        yplmax=ymx
      else
        yplmax=ymax
      endif

      if (zmin.eq.9999.) then
        zplmin=zmn
      else
        zplmin=zmin
      endif

      if (zmax.eq.9999.) then
        zplmax=zmx
      else
        zplmax=zmax
      endif

      if (nbforcx*nbforcy*nbforcy.ne.0) then
        dx=(outbox(2,1)-outbox(1,1))*0.1
        if (xplmin.ge.outbox(1,1)) xplmin=outbox(1,1)-dx
        if (xplmax.le.outbox(2,1)) xplmax=outbox(2,1)+dx
        dy=(outbox(2,2)-outbox(1,2))*0.1
        if (yplmin.ge.outbox(1,2)) yplmin=outbox(1,2)-dy
        if (yplmax.le.outbox(2,2)) yplmax=outbox(2,2)+dy
        dz=(outbox(2,3)-outbox(1,3))*0.1
        if (zplmin.ge.outbox(1,3)) zplmin=outbox(1,3)-dz
        if (zplmax.le.outbox(2,3)) zplmax=outbox(2,3)+dz
      endif

      dx=(xplmax-xplmin)*0.05
      if (xmin.eq.9999.) then
        xplmin=xplmin-dx
      endif

      if (xmax.eq.9999.) then
        xplmax=xplmax+dx
      endif

      dy=(yplmax-yplmin)*0.05
      if (ymin.eq.9999.) then
        yplmin=yplmin-dy
      endif

      if (ymax.eq.9999.) then
        yplmax=yplmax+dy
      endif

      dz=(zplmax-zplmin)*0.05
      if (zmin.eq.9999.) then
        zplmin=zplmin-dz
      endif

      if (zmax.eq.9999.) then
        zplmax=zplmax+dz
      endif

      if (dx.eq.0.0d0) then
        dx=1.05d0
        xplmin=xplmin-dx
        xplmax=xplmax+dx
      endif

      if (dy.eq.0.0d0) then
        dy=1.05d0
        yplmin=yplmin-dy
        yplmax=yplmax+dy
      endif

      if (dz.eq.0.0d0) then
        dz=1.05d0
        zplmin=zplmin-dz
        zplmax=zplmax+dz
      endif

      if (xplmax.le.xplmin.or.zplmax.le.zplmin.or.zplmax.le.zplmin) then
        write(lun6,*)'*** Warning in undumag_bpolyplot_old: Bad coordinate system for plotting '
        goto 9999
      endif

      pscal=min(3.,sqrt(10000./((xplmax-xplmin)*(zplmax-zplmin))))

c--- 3D, top and side views {

      if (jcomment.ne.0) call mtitle(trim(ctitle))

      call mplset('YMGL',0.5)
      call mplzon(1,1,1,' ')
      call mplfra(0.,10.,0.,10.,'AB')
      call mgset('CHHE',0.4)
      call mtx(3.4,2.6,'upper magnets')
      call mtx(3.5,0.15,'lower magnets')
      call mgset('CHHE',0.3)
      call mplset('YMGL',2.)
      call muwk(0,0)

      call mplzon(2,2,1,'S')
      rewind(lunmag)
      read(lunmag,'(a)')cline
      iplano=1

c y is vertical (WAVE-system)

      if (theta.eq.0.0.and.phi.eq.0.0) then

        call mplfra(xplmin,xplmax,yplmin,yplmax,' ')
        call mplax('x (mm)', 'y (mm)')
        if (nbforcx*nbforcy*nbforcz.ne.0) call undumag_bpolypl2(forxpl,forypl,forcol,12)

        do iline=1,nline

311       read(lunmag,*) rmoth,rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz,rmat
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 311

          imag=nint(rmag)
          icol=nint(rcol)
          iplan=nint(rplan)
          icorn=nint(rcorn)

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &          xpl(i).lt.xplmin.or.
     &          xpl(i).gt.xplmax.or.
     &          ypl(i).lt.yplmin.or.
     &          ypl(i).gt.yplmax.or.
     &          zpl(i).lt.zplmin.or.
     &          zpl(i).gt.zplmax
     &          ) goto 81
            enddo

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mshplt_set_line_width(rlwidth/5.)
            call mgset('PLCI',1.)
            call mpl(ncorno,xpl,ypl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*5.0*rlwidth
              ypl(i)=ypl(i)+(yc-ypl(i))*5.0*rlwidth
              zpl(i)=zpl(i)+(zc-zpl(i))*5.0*rlwidth
              zplm(i)=-zpl(i)
            enddo

            call mshplt_set_line_width(rlwidth/2.)
            call mgset('PLCI',rcolo)
            call mpl(ncorno,xpl,ypl)

81          continue

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcolo=rcol

        enddo !nline

        call mshplt_set_line_width(rlwidth*2.)
        do iline=1,ncwires
          rcolo=wire(9,iline)
          call mgset('PLCI',rcolo)
          xpl(1)=wire(3,iline)
          xpl(2)=wire(6,iline)
          ypl(1)=wire(4,iline)
          ypl(2)=wire(7,iline)
          call mpl(2,xpl,ypl)
        enddo
        call mshplt_set_line_width(rlwidth/2.)

      else !:if (theta.eq.0.0.and.phi.eq.0.0) then

        call mplfr3(xplmin,xplmax,-zplmax,-zplmin,yplmin,yplmax,theta,phi,'W')

        do iline=1,nline

31        read(lunmag,*) rmoth,rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz,rmat
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 31

          imag=nint(rmag)
          icol=nint(rcol)
          iplan=nint(rplan)
          icorn=nint(rcorn)

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &          xpl(i).lt.xplmin.or.
     &          xpl(i).gt.xplmax.or.
     &          ypl(i).lt.yplmin.or.
     &          ypl(i).gt.yplmax.or.
     &          zpl(i).lt.zplmin.or.
     &          zpl(i).gt.zplmax
     &          ) goto 8
            enddo

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',1.)
            call mpl3(ncorno,xpl,zplm,ypl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*0.015*rcolo
              ypl(i)=ypl(i)+(yc-ypl(i))*0.015*rcolo
              zpl(i)=zpl(i)+(zc-zpl(i))*0.015*rcolo
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',rcolo)
            call mpl3(ncorno,xpl,zplm,ypl)

8           continue

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcolo=rcol

        enddo !nline

        call mshplt_set_line_width(rlwidth*2.)
        do iline=1,ncwires
          rcolo=wire(9,iline)
          call mgset('PLCI',rcolo)
          xpl(1)=wire(3,iline)
          xpl(2)=wire(6,iline)
          ypl(1)=wire(4,iline)
          ypl(2)=wire(7,iline)
          zpl(1)=-wire(5,iline)
          zpl(2)=-wire(8,iline)
          call mpl3(2,xpl,zpl,ypl)
        enddo
        call mshplt_set_line_width(rlwidth/2.)

      endif !(theta.eq.0.0.and.phi.eq.0.0) then

c--- 3D }

c--- y vs z or z vs y {

      call mplfra(zplmin,zplmax,yplmin,yplmax,' ')
      call mplax('z (mm)', 'y (mm)')
      if (nbforcx*nbforcy*nbforcz.ne.0) call undumag_bpolypl2(forzpl,forypl,forcol,23)

      rewind(lunmag)
      read(lunmag,'(a)')cline
      iplano=1

      do iline=1,nline

51      read(lunmag,*) rmoth,rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz,rmat
        if (bx**2+by**2+bz**2.eq.0.0d0) goto 51

        imag=nint(rmag)
        icol=nint(rcol)
        iplan=nint(rplan)
        icorn=nint(rcorn)

        ncorn=abs(icorn)

        if (iline.eq.nline) then

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcolo=rcol

        endif !(iline.eq.nline

        if(iplan.ne.iplano.or.iline.eq.nline) then

          do i=1,ncorno
            zplm(i)=-zpl(i)
          enddo

          call mshplt_set_line_width(rlwidth/5.)
          call mgset('PLCI',1.)
          call mpl(ncorno,zpl,ypl)

          xc=0.
          yc=0.
          zc=0.

          do i=1,ncorno-1
            xc=xc+xpl(i)
            yc=yc+ypl(i)
            zc=zc+zpl(i)
          enddo

          xc=xc/(ncorno-1)
          yc=yc/(ncorno-1)
          zc=zc/(ncorno-1)

          izero=0
          do i=1,ncorno
            if (
     &        abs(yc-ypl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &        ) izero=1
            xpl(i)=xpl(i)+(xc-xpl(i))*2.0*rlwidth
            ypl(i)=ypl(i)+(yc-ypl(i))*2.0*rlwidth
            zpl(i)=zpl(i)+(zc-zpl(i))*2.0*rlwidth
            zplm(i)=-zpl(i)
          enddo

          call mgset('PLCI',rcolo)

          if (izero.ne.0) call mpl(ncorno,zpl,ypl)

        endif !iplano

        xpl(ncorn)=x
        ypl(ncorn)=y
        zpl(ncorn)=z

        iplano=iplan
        ncorno=ncorn
        rcolo=rcol

      enddo !nline

      call mshplt_set_line_width(rlwidth*2.)
      do iline=1,ncwires
        rcolo=wire(9,iline)
        call mgset('PLCI',rcolo)
        xpl(1)=wire(3,iline)
        xpl(2)=wire(6,iline)
        ypl(1)=wire(4,iline)
        ypl(2)=wire(7,iline)
        zpl(1)=wire(5,iline)
        zpl(2)=wire(8,iline)
        call mpl(2,zpl,ypl)
      enddo
      call mshplt_set_line_width(rlwidth/2.)

      call mshplt_set_line_width(rlwidtho)

      if (nbforcx*nbforcy*nbforcz.ne.0) call undumag_bpolypl2(forzpl,forypl,forcol,23)

c--- y vs z or z vs y }

c--- top views of girder {
      call muwk(0,0)
      call mplzon(1,4,3,'S')

      do igird=1,2

c--- z vs x, y is vertical coordinate {
        call mplfra(xplmin,xplmax,zplmin,zplmax,' ')
        call mplax('x (mm)', 'z (mm)')

        if (nbforcx*nbforcy*nbforcz.ne.0)
     &    call undumag_bpolypl2(forxpl,forzpl,forcol,13)

        rewind(lunmag)
        read(lunmag,'(a)')cline
        if (nline.gt.0) then
61        read(lunmag,*) rmoth,rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz,rmat
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 61
          backspace(lunmag)
        endif
        imago=int(rmag)
        rmato=rmat
        iplano=1
        impl=0

        do iline=1,nline

71        read(lunmag,*) rmoth,rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz,rmat
          if (bx**2+by**2+bz**2.eq.0.0d0) goto 71

          imag=nint(rmag)
          icol=nint(rcol)
          iplan=nint(rplan)
          icorn=nint(rcorn)

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol

          endif !(iline.eq.nline

          if (imag.ne.imago.or.iline.eq.nline) then

            xmc(1)=0.
            ymc(1)=0.
            zmc(1)=0.

            xmmx=-1.0e30
            xmmn= 1.0e30
            ymmx=-1.0e30
            ymmn= 1.0e30
            zmmx=-1.0e30
            zmmn= 1.0e30

            do i=1,impl-1
              xmc(1)=xmc(1)+xmpl(i)
              ymc(1)=ymc(1)+ympl(i)
              zmc(1)=zmc(1)+zmpl(i)
              if (xmpl(i).gt.xmmx) xmmx=xmpl(i)
              if (xmpl(i).lt.xmmn) xmmn=xmpl(i)
              if (ympl(i).gt.ymmx) ymmx=ympl(i)
              if (ympl(i).lt.ymmn) ymmn=ympl(i)
              if (zmpl(i).gt.zmmx) zmmx=zmpl(i)
              if (zmpl(i).lt.zmmn) zmmn=zmpl(i)
            enddo

            xmc(1)=xmc(1)/(impl-1)
            ymc(1)=ymc(1)/(impl-1)
            zmc(1)=zmc(1)/(impl-1)

            dx=xmmx-xmmn
            dy=ymmx-ymmn
            dz=zmmx-zmmn

            impl=0

          endif !imag.ne.imago

          impl=impl+1

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            xmpl(impl)=x
            ympl(impl)=y
            zmpl(impl)=z

            bxo=bx
            byo=by
            bzo=bz

            iplano=iplan
            ncorno=ncorn
            rcolo=rcol

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            if (igird.eq.1.and.yc.ge.0.0) then

              do i=1,ncorno
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',1.)
              call mpl(ncorno,xpl,zpl)

              izero=0
              do i=1,ncorno
                if (
     &            abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &            ) izero=1
                xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcolo)
              if (izero.ne.0) call mpl(ncorno,xpl,zpl)

              if (imag.ne.imago.or.iline.eq.nline) then

                bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                if (abs(bxo).lt.bo*eps) bxo=0.0
                if (abs(byo).lt.bo*eps) byo=0.0
                if (abs(bzo).lt.bo*eps) bzo=0.0

                xplb(1)=xmc(1)-2.*bxo/bo*dx/6.
                xplb(2)=xmc(1)+2.*bxo/bo*dx/6.
                yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                zplb(1)=zmc(1)-2.*bzo/bo*dz/5.
                zplb(2)=zmc(1)+2.*bzo/bo*dz/5.

                xplbo(1)=xplb(1)
                xplbo(2)=xplb(2)
                yplbo(1)=yplb(1)
                yplbo(2)=yplb(2)
                zplbo(1)=zplb(1)
                zplbo(2)=zplb(2)

                if (rmato.eq.1) call mpl(2,xplbo,zplbo)

                vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                if (vn.ne.0.0d0) then

                  vnx=(xplbo(2)-xplbo(1))/vn
                  vnz=(zplbo(2)-zplbo(1))/vn

                  xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                  !call mpl(2,xplb,zplb)

                  xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                  if (rmato.eq.1) call mpl(2,xplb,zplb)

                endif !vn

                if (byo.gt.1.e-9) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp20)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                else if (byo.lt.0.0) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp31)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                endif

              endif !imago

            else if (igird.eq.2.and.yc.le.0.0) then

              do i=1,ncorno
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',1.)
              call mpl(ncorno,xpl,zpl)

              izero=0
              do i=1,ncorno
                if (
     &            abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &            ) izero=1
                xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcolo
                ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcolo
                zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcolo
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcolo)
              if (izero.ne.0) call mpl(ncorno,xpl,zpl)

              if (imag.ne.imago.or.iline.eq.nline) then

                bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)
                if (abs(bxo).lt.bo*eps) bxo=0.0
                if (abs(byo).lt.bo*eps) byo=0.0
                if (abs(bzo).lt.bo*eps) bzo=0.0

                xplb(1)=xmc(1)-2.*bxo/bo*dx/6.
                xplb(2)=xmc(1)+2.*bxo/bo*dx/6.
                yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                zplb(1)=zmc(1)-2.*bzo/bo*dz/5.
                zplb(2)=zmc(1)+2.*bzo/bo*dz/5.

                xplbo(1)=xplb(1)
                xplbo(2)=xplb(2)
                yplbo(1)=yplb(1)
                yplbo(2)=yplb(2)
                zplbo(1)=zplb(1)
                zplbo(2)=zplb(2)

                if (rmato.eq.1) call mpl(2,xplbo,zplbo)

                vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                if (vn.ne.0.0d0) then

                  vnx=(xplbo(2)-xplbo(1))/vn
                  vnz=(zplbo(2)-zplbo(1))/vn

                  xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                  if (rmato.eq.1) call mpl(2,xplb,zplb)

                  xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                  if (rmato.eq.1)call mpl(2,xplb,zplb)

                endif !vn

                if (byo.gt.1.e-9) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp20)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                else if (byo.lt.0.0) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp31)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                endif

              endif !imago

            endif !yc

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          xmpl(impl)=x
          ympl(impl)=y
          zmpl(impl)=z

          bxo=bx
          byo=by
          bzo=bz

          iplano=iplan
          ncorno=ncorn
          rcolo=rcol
          imago=imag
          rmato=rmat

        enddo !nline

        if (nbforcx*nbforcy*nbforcz.ne.0) call undumag_bpolypl2(forxpl,forzpl,forcol,13)

        if (igird.eq.1) then
          call mshplt_set_line_width(rlwidth*2.)
          do iline=1,ncwires
            rcolo=wire(9,iline)
            call mgset('PLCI',rcolo)
            xpl(1)=wire(3,iline)
            xpl(2)=wire(6,iline)
            ypl(1)=wire(4,iline)
            ypl(2)=wire(7,iline)
            zpl(1)=wire(5,iline)
            zpl(2)=wire(8,iline)
            if (ypl(1).gt.0.0.or.ypl(2).gt.0.0) call mpl(2,xpl,zpl)
          enddo
          call mshplt_set_line_width(rlwidth/2.)
        else
          call mshplt_set_line_width(rlwidth*2.)
          do iline=1,ncwires
            rcolo=wire(9,iline)
            call mgset('PLCI',rcolo)
            xpl(1)=wire(3,iline)
            xpl(2)=wire(6,iline)
            ypl(1)=wire(4,iline)
            ypl(2)=wire(7,iline)
            zpl(1)=wire(5,iline)
            zpl(2)=wire(8,iline)
            if (ypl(1).lt.0.0.or.ypl(2).lt.0.0) call mpl(2,xpl,zpl)
          enddo
          call mshplt_set_line_width(rlwidth/2.)
        endif

      enddo !igird

      call muwk(0,0)

c--- y vs x }

c--- top views of girder}

c--- 3D, top and side views }

9999  close (lunmag)

      if (iallo.eq.1) then
        deallocate(xpl)
        deallocate(ypl)
        deallocate(zpl)
        deallocate(zplm)
        deallocate(xmpl)
        deallocate(ympl)
        deallocate(zmpl)
      endif

c      call mgmeta(0,0)
c      call mplend

      call mshplt_end

      write(lun6,*)"Done"
      write(lun6,*)

      return
      end
+DECK,undumag_geo.
*CMZ :  2.04/09 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/03 28/02/2023  12.18.17  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  10.01.47  by  Michael Scheer
*CMZ :  2.02/02 17/02/2022  12.11.11  by  Michael Scheer
*CMZ :  2.02/01 30/01/2022  08.30.33  by  Michael Scheer
*-- Author :    Michael Scheer   01/11/2021
      subroutine undumag_geo

      ! Writes voxels to undumag.geo

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      double precision gcen(3),xc,yc,zc,x1,x2,y1,y2,z1,z2,x21,y21,z21,
     &  x,y,z,bx,by,bz,dx,dy,dz,bc,cw

      integer :: lunvox,imag,nplan,icorn,ncorn,moth,motho,ispec,iplan,
     &  kmod,kmag,im,kcopy,mothdiv(4),ncol,mag,mat,ix,iy,iz,itype,imat,icol,
     &  i

      character(2048) cline

      type (T_Magnet) tmag
      type (T_Magnet_Copy) tmagc

      write(lun6,*)
      write(lun6,*)'Writing geometry to undumag.geo'
      write(lun6,*)

      open(newunit=lunvox,file="undumag.geo")

      write(lunvox,'(a)')
     &  "* mag ityp xc yc zc moth ix iy iz mat icol mx my mz bc iplan icorn x y z cmag cmoth"

      nmag=nvoxcopy_t
      motho=0

      do imag=1,nmag

        kmod=t_voxcopy(imag)%kmodule
        kmag=t_voxcopy(imag)%kproto
        im=t_voxcopy(imag)%kmagnet
        kvox=t_voxcopy(imag)%kvoxel
        kcopy=t_voxcopy(imag)%kcopy

        tmag=t_magnets(kmag)
        tmagc=t_magcopy(im)

        gcen=bpebc(1:3,imag)
        nplan=ibpeplan(imag)
        moth=nint(bpebc(15,imag))

        if(moth.ne.motho) then
          chmag=tmagc%cnam
          write(cline,*)"* ",trim(chmag),moth
          write(lunvox,'(a)')cline(2:len_trim(cline))
          motho=moth
        endif

        imat=nint(bpebc(9,imag))
        ispec=nint(bpebc(10,imag))
        bx=bpebc(11,imag)
        by=bpebc(12,imag)
        bz=bpebc(13,imag)
        bc=bpebc(14,imag)
        ncol=ibpecol(imag)
        itype=nint(bpebc(8,imag))

        mothdiv(1)=moth

        mothdiv(2)=t_magnets(kmag)%t_voxels(kvox)%ixdiv
        mothdiv(3)=t_magnets(kmag)%t_voxels(kvox)%iydiv
        mothdiv(4)=t_magnets(kmag)%t_voxels(kvox)%izdiv
        motho=0

        do iplan=1,nplan
          ncorn=ibpecorn(iplan,imag)
          do icorn=1,ncorn
            x=bpemag(1,icorn,iplan,imag)
            y=bpemag(2,icorn,iplan,imag)
            z=bpemag(3,icorn,iplan,imag)
            write(lunvox,*)imag,itype,
     &        sngl(gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &        ,mothdiv(1:4),imat,ncol
     &        ,sngl(bx),sngl(by),sngl(bz),sngl(bc)
     &        ,iplan,icorn
     &        ,sngl(x),sngl(y),sngl(z)
     &        ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
            if (kplsym.ne.0) then
              if (ixsym.ne.0.and.iysym.ne.0.and.izsym.ne.0) then
                write(lunvox,*)nmag+imag,itype,
     &            sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(-x),sngl(y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)2*nmag+imag,itype,
     &            sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(-y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)3*nmag+imag,itype,
     &            sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(bx),sngl(by),sngl(-bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(y),sngl(-z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)4*nmag+imag,itype,
     &            sngl(-gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(-x),sngl(-y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)5*nmag+imag,itype,
     &            sngl(-gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(-x),sngl(y),sngl(-z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)6*nmag+imag,itype,
     &            sngl(gcen(1)),sngl(-gcen(2)),sngl(-gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(-y),sngl(-z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)7*nmag+imag,itype,
     &            sngl(-gcen(1)),sngl(-gcen(2)),sngl(-gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(bx),sngl(by),sngl(-bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(-x),sngl(-y),sngl(-z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
              else if (ixsym.ne.0.and.iysym.ne.0) then
                write(lunvox,*)nmag+imag,itype,
     &            sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(-x),sngl(y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)2*nmag+imag,itype,
     &            sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(-y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)3*nmag+imag,itype,
     &            sngl(-gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(-x),sngl(-y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
              else if (ixsym.ne.0.and.izsym.ne.0) then
                write(lunvox,*)nmag+imag,itype,
     &            sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(-x),sngl(y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)2*nmag+imag,itype,
     &            sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(bx),sngl(by),sngl(bz),sngl(-bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(y),sngl(-z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)3*nmag+imag,itype,
     &            sngl(-gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(-x),sngl(y),sngl(-z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
              else if (iysym.ne.0.and.izsym.ne.0) then
                write(lunvox,*)nmag+imag,itype,
     &            sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(-y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)2*nmag+imag,itype,
     &            sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(bx),sngl(by),sngl(bz),sngl(-bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(y),sngl(-z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
                write(lunvox,*)3*nmag+imag,itype,
     &            sngl(gcen(1)),sngl(-gcen(2)),sngl(-gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(-bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(-y),sngl(-z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
              else if (ixsym.ne.0) then
                write(lunvox,*)nmag+imag,itype,
     &            sngl(-gcen(1)),sngl(gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(-x),sngl(y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
              else if (iysym.ne.0.) then
                write(lunvox,*)nmag+imag,itype,
     &            sngl(gcen(1)),sngl(-gcen(2)),sngl(gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(-bx),sngl(by),sngl(bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(-y),sngl(z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
              else if (izsym.ne.0.) then
                write(lunvox,*)nmag+imag,itype,
     &            sngl(gcen(1)),sngl(gcen(2)),sngl(-gcen(3))
     &            ,mothdiv(1:4),imat,ncol
     &            ,sngl(bx),sngl(by),sngl(-bz),sngl(bc)
     &            ,iplan,icorn
     &            ,sngl(x),sngl(y),sngl(-z)
     &            ,trim(tmagc%cnam)," ",trim(tmagc%cmoth)
              endif !syms
            endif !(kplsym.ne.0) then
          enddo
        enddo
      enddo !nmag

      dx=xmax_t-xmin_t
      dy=ymax_t-ymin_t
      dz=zmax_t-zmin_t

      do i=1,ncwires
        mag=i
        itype=nint(wire(1,i))
        moth=nint(wire(10,i))
        icol=nint(wire(9,i))
        x1=wire(3,i)
        y1=wire(4,i)
        z1=wire(5,i)
        ix=1
        iy=1
        iz=1
        mat=-1
        x2=wire(6,i)
        y2=wire(7,i)
        z2=wire(8,i)
        xc=(x2+x1)/2.0
        yc=(y2+y1)/2.0
        zc=(z2+z1)/2.0
        x21=(x2-x1)
        y21=(y2-y1)
        z21=(z2-z1)
        cw=wire(2,i)
        iplan=0
        icorn=0
        write(lunvox,*)mag,itype,xc,yc,zc,moth,ix,iy,iz,mat,icol,dx,dy,dz,cw,
     &    iplan,icorn,x1,y1,z1," wire ", adjustl(trim(t_coils(moth)%cnam))
      enddo !ncwires

      write(lun6,*)
      write(lun6,*)'Done'
      write(lun6,*)

      close(lunvox)

      return
      end
+DECK,undumag_to_radia_old.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/02 04/07/2022  11.26.34  by  Michael Scheer
*CMZ :  2.02/01 30/01/2022  08.43.28  by  Michael Scheer
*CMZ :  2.02/00 09/01/2021  12.08.32  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  12.47.44  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  15.45.12  by  Michael Scheer
*CMZ :  1.25/04 04/04/2018  11.40.25  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.27.59  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.25.43  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  09.00.40  by  Michael Scheer
*CMZ :  1.23/02 11/09/2017  15.35.11  by  Michael Scheer
*CMZ :  1.18/01 08/06/2017  14.20.17  by  Michael Scheer
*CMZ :  1.15/10 11/04/2017  11.14.47  by  Michael Scheer
*CMZ :  1.15/00 24/03/2017  10.28.46  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  17.33.35  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  10.15.10  by  Michael Scheer
*CMZ :  1.11/03 13/01/2017  15.10.38  by  Michael Scheer
*CMZ :  1.11/00 03/01/2017  16.16.45  by  Michael Scheer
*-- Author :    Michael Scheer   12/12/2016
      subroutine undumag_to_radia_old(krun,xsymmm,bpemag,mcornmax,mplanmax,mmag)

      use undumagf90m

! Interface to radia notebook. It writes the geometry to snipplets for RADIA
! Restriction:
! Isotropic materials must have a magnetization less then 0.01
!
! RADIA coordinate system: y is longitudinal, z is vertical
! UNDUMAG: x is longitudinal, y is vertical

      use commandlinef90m

      implicit none

+seq,phyconparam.

      integer, parameter :: ncontp=1000

      double precision, dimension (:), allocatable :: x,y,z

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface

      double precision bc,bcx,bcy,bcz,bn,
     &  vnor(3),dist,p1(3),p2(3),p3(3),
     &  x02(2),y02(2),z02(2),ydiv,ymin,ymax,space,ex,ey,ez,en,smx,smy,smz,
     &  br,bcxs,bcys,bczs,xsymmm,xx,yy,zz,
     &  w,h,xo,xi,zo,zi,ri,curr,currden,vx,vy,vz,alpha,vn
     &  ,radin,radout,height,angle,rmat(3,3),offx,offy,offz

      double precision bpemag(3,mcornmax,mplanmax,mmag)

      double precision :: tiny=1.0d-6

      real x0,y0,z0,xlen,ylen,zlen,yfrac

      integer lunrad,lunin,lunfi,kread,ipos(2,10),krun,
     &  istat,nxdiv,nydiv,nzdiv,nwords,ispecial,
     &  mi,me,nfirst,nlast,ncolor,mater,nmodules,narrays,imodule,iarray,
     &  nhull,nface,nedge,kfacelast,kfail,ipoi,npoi,luncorn,ieof,
     &  iface,kpoi,lface,npoimax,
     &  ifound,iplan,nplan,i,l,imag,
     &  nsymx,nsymy,nsymz,lsymx,lsymy,lsymz,ncont,icont,kcont,newcont,
     &  kradia,kforceradia,kolor,nz,ny,nphi,nr,ncyl,mcyl1,mcyl2,icorn,
     &  mcornmax,mplanmax,mmag,k,itranrot

      integer nUnduMag,nUnduPol,nMagPolTot,nUnduSpecMag,nUnduSpecPol

      character(2048) cline,cbuff(10)
      character(64) chmat
      character(32) c32x,c32y,c32z,c32t,chcont,chconts(ncontp),chmago

      ncyl=0

      maxpoints=max(maxpoints,ncornmax*nplanmax)

      allocate(x(maxpoints))
      allocate(y(maxpoints))
      allocate(z(maxpoints))

      allocate(khull(maxpoints))
      allocate(kedge(4,2*maxpoints-2))
      allocate(kface(5*maxpoints))

      nsymx=1
      nsymy=1
      nsymz=1
      if (ixsymo.lt.0) nsymx=nsymx*2
      if (iysymo.lt.0) nsymy=nsymy*2
      if (izsymo.lt.0) nsymz=nsymz*2
      ncont=0

      open(newunit=lunin,file='undumag.in',status='old')
      open(newunit=lunrad,file='undumag.nb')

      write(lunrad,*)' '
      write(lunrad,*)'(*-- Begin of lines generated by UNDUMAG --*)'
      write(lunrad,*)'(*-- Version ',trim(chuvers),' --*)'
      write(lunrad,*)' '
      write(lunrad,*)'<<Radia`; Off[General::"spell1"];'
      write(lunrad,*)' '
      write(cline,*)krun
      call util_string_trim(cline,nfirst,nlast)
      write(lunrad,*)'(*'
      call util_zeit_kommentar(lunrad,"Run: "//cline(nfirst:nlast))
      write(lunrad,*)'*)'

      kread=0
      br=-9999.0d0
      do while (kread.eq.0)
        read(lunin,'(a)')cline
        if (br.eq.-9999.0d0.and.cline(1:4).eq.'*Br:') then
          backspace(lunin)
          read(lunin,*)c32x,br
        endif
        if (cline(1:8).eq."*EndCalc") kread=1
      enddo

      call util_skip_comment(lunin)
      read(lunin,'(a)')cline ! comment line of undumag.in

      write(lunrad,*)"(*"
      write(lunrad,*)"Comment: "//trim(unducomment)
      write(lunrad,*)"*)"
      write(lunrad,*)' '
      write(lunrad,*)'run = ',krun,";"
      write(lunrad,*)'comment = "'//trim(unducomment)//'";'
      write(lunrad,*)' '
      write(lunrad,*)'iUnduXsym = ',ixsymo,";"
      write(lunrad,*)'iUnduYsym = ',iysymo,";"
      write(lunrad,*)'iUnduZsym = ',izsymo,";"
      write(lunrad,*)' '
      write(lunrad,*)'UnduSymX = ',xsym,";"
      write(lunrad,*)' '
      write(lunrad,*)"kDraw = ",iunduplot,";"
      write(lunrad,*)"unduplot_theta = ",unduplot_theta,";"
      write(lunrad,*)"unduplot_phi = ",unduplot_phi,";"
      write(lunrad,*)' '
      nUnduMag=0
      nUnduPol=0
      nUnduSpecMag=0
      nUnduSpecPol=0
      write(lunrad,*)"nUnduMag=0;"
      write(lunrad,*)"nUnduPol=0;"
      write(lunrad,*)"nUnduSpecMag=0;"
      write(lunrad,*)"nUnduSpecPol=0;"
      write(lunrad,*)' '
      write(c32x,*)br
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduBr = ",c32x," ;"
      write(lunrad,*)' '
      write(c32x,*)xcenter
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXCenter = ",c32x," ;"
      write(c32x,*)xcentershift
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXCenterShift = ",c32x," ;"
      write(lunrad,*)' '
      write(c32x,*)utorqcenx
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenX = ",c32x," ;"
      write(c32x,*)utorqceny
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenY = ",c32x," ;"
      write(c32x,*)utorqcenz
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenZ = ",c32x," ;"
      write(lunrad,*)' '
      write(c32x,*)xmapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXMapMin = ",c32x," ;"
      write(c32x,*)xmapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduXMap = ",nxmap," ;"
      write(lunrad,*)' '
      write(c32x,*)ymapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduYMapMin = ",c32x," ;"
      write(c32x,*)ymapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduYMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduYMap = ",nymap," ;"
      write(lunrad,*)' '
      write(c32x,*)zmapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduZMapMin = ",c32x," ;"
      write(c32x,*)zmapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduZMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduZMap = ",nzmap," ;"
      write(lunrad,*)' '
      write(lunrad,*)' '
      write(lunrad,*)"nUnduNoPolMap = ",knopolmap," ;"
      write(lunrad,*)"nUnduNoMagMap = ",knomagmap," ;"
      write(lunrad,*)' '

      kread=0
      ispecial=0

      do while (kread.eq.0)

        call util_read_line(lunin,cbuff(1),nlast)

        itranrot=1
        do while (itranrot.eq.1)
          if (cbuff(1).eq.'Translate') then
            print*,"--- Warning in undumag_to_radia_old: Translate is not yet implemented..."
            write(lunrad,*)'(*'
            do i=1,3
              call util_read_line(lunin,cbuff(1),nlast)
            enddo
            write(lunrad,*)'*)'
            itranrot=1
          else if (cbuff(1).eq.'Rotate') then
            print*,"--- Warning in undumag_to_radia_old: Translate is not yet implemented..."
            write(lunrad,*)'(*'
            do i=1,5
              call util_read_line(lunin,cbuff(1),nlast)
            enddo
            write(lunrad,*)'*)'
            itranrot=1
          else
            itranrot=0
          endif
        enddo

        read(cbuff(1),*)x0,y0,z0

        if (x0.eq.-9999.0.and.y0.eq.-9999.0.and.z0.eq.-9999.0) then
          if (ispecial.eq.0) then

            ispecial=1

            write(lunrad,*)' '
            write(lunrad,*)'(*- End of regular magnets -*)'
            write(lunrad,*)' '

            call util_skip_comment(lunin)
            read(lunin,*)nmodules

            write(lunrad,*)" "
            write(lunrad,*)"nUnduModules = ",nmodules,";"
            write(lunrad,*)" "

            do imodule=1,nmodules

              call util_skip_comment(lunin)
              read(lunin,*)offx,offy,offz

              write(lunrad,*)"UnduOffx[",imodule,"] = ",offx,";"
              write(lunrad,*)"UnduOffy[",imodule,"] = ",offy,";"
              write(lunrad,*)"UnduOffz[",imodule,"] = ",offz,";"
              write(lunrad,*)" "

              call util_skip_comment(lunin)
              read(lunin,*)smx,smy,smz
              if (smx.ne.1.0d0.or.smy.ne.0.0d0.or.smz.ne.0.0d0) then
                write(lun6,*)
                write(lun6,*)"*** Warning in undumag_to_radia_old:  Rotation matrix not unit matrix ***"
                write(lun6,*)"module:",imodule
                write(lun6,*)"*** NOT YET IMPLEMENTED ***"
                write(lun6,*)
              endif

              call util_skip_comment(lunin)
              read(lunin,*)smx,smy,smz
              if (smx.ne.0.0d0.or.smy.ne.1.0d0.or.smz.ne.0.0d0) then
                write(lun6,*)
                write(lun6,*)"*** Warning in undumag_to_radia_old:  Rotation matrix not unit matrix ***"
                write(lun6,*)"module:",imodule
                write(lun6,*)"*** NOT YET IMPLEMENTED ***"
                write(lun6,*)
              endif

              call util_skip_comment(lunin)
              read(lunin,*)smx,smy,smz
              if (smx.ne.0.0d0.or.smy.ne.0.0d0.or.smz.ne.1.0d0) then
                write(lun6,*)
                write(lun6,*)"*** Warning in undumag_to_radia_old:  Rotation matrix not unit matrix ***"
                write(lun6,*)"module:",imodule
                write(lun6,*)"*** NOT YET IMPLEMENTED ***"
                write(lun6,*)
              endif

              call util_skip_comment(lunin)
              read(lunin,*)narrays
              write(lunrad,*)"nUnduArrays[",imodule,"] = ",narrays,";"
              write(lunrad,*)" "
              call util_skip_comment(lunin)
              read(lunin,*)space,ex,ey,ez
              en=sqrt(ex**2+ey**2+ez**2)
              ex=ex/en
              ey=ey/en
              ez=ez/en
              write(lunrad,*)"UnduArraySpace[",imodule,"] = ",space,";"
              write(lunrad,*)"UnduArrayEx[",imodule,"] = ",ex,";"
              write(lunrad,*)"UnduArrayEy[",imodule,"] = ",ey,";"
              write(lunrad,*)"UnduArrayEz[",imodule,"] = ",ez,";"
              call util_skip_comment(lunin)
              read(lunin,*)smx,smy,smz
              write(lunrad,*)"UnduArraySMx[",imodule,"] = ",smx,";"
              write(lunrad,*)"UnduArraySMy[",imodule,"] = ",smy,";"
              write(lunrad,*)"UnduArraySMz[",imodule,"] = ",smz,";"
              if (smx.ne.1.0d0.or.smy.ne.1.0d0.or.smz.ne.1.0d0) then
                write(lun6,*)
                write(lun6,*)"*** Warning in undumag_to_radia_old: Scaling of magnetic field of module array not 1. 1. 1. ***"
                write(lun6,*)"module:",imodule
                write(lun6,*)"*** NOT YET IMPLEMENTED ***"
                write(lun6,*)
              endif
            enddo !nmodules

            write(lunrad,*)" "

            cycle

          else !ispecial
            kread=1
            exit
          endif !ispecial

        endif !(x0.eq.-9999.0.and.y0.eq.-9999.0.and.z0.eq.-9999.0) then

        call util_read_line(lunin,cbuff(2),nlast)
        call util_read_line(lunin,cbuff(3),nlast)
        call util_read_line(lunin,cbuff(4),nlast)

        read(cbuff(2),*)bc,bcx,bcy,bcz,mater

        bcx=bcx*bc
        bcy=bcy*bc
        bcz=bcz*bc
        bc=abs(bc)
        bn=sqrt(bcx**2+bcy**2+bcz**2)

        bcx=bcx/bn
        bcy=bcy/bn
        bcz=bcz/bn

        kradia=0
        call util_string_split(cbuff(1),6,nwords,ipos,istat)

        if (nwords.eq.5) then
          kradia=1
          chmag=cbuff(1)(ipos(1,4):ipos(2,4))
          chcont=cbuff(1)(ipos(1,5):ipos(2,5))
          newcont=1
          do icont=1,ncont
            if (chconts(icont).eq.chcont) then
              newcont=0
              kcont=icont
              exit
            endif
          enddo
          if (newcont.eq.1) then
            ncont=ncont+1
            if (ncont.gt.ncontp) then
              write(lun6,*)"*** Error in undumag_to_radia_old: Dimension ncontp exceeded ***"
              write(lun6,*)'*** returning from undumag_to_radia ***'
              goto 9999
            endif
            kcont=ncont
            chconts(kcont)=trim(chcont)//'xyz'
            write(lunrad,*)" "
            write(lunrad,*)trim(chconts(ncont))//" =  radObjCnt[{}];"
            if (ispecial.eq.0) then
              if (abs(bc).gt.0.01) then
                nUnduMag=nUnduMag+1
                write(lunrad,*)"nUnduMag=",nUnduMag," ;"
                write(lunrad,*)"UnduMag[",nUnduMag," ] = ",
     &            trim(chconts(kcont)),";"
                write(lunrad,*)" "
                nMagPolTot=nMagPolTot+1
                write(lunrad,*)"nMagPolTot=",nMagPolTot,";"
                write(lunrad,*)"AllMagPols[",nMagPolTot," ] = ",
     &            trim(chconts(kcont)),";"
                if (chcont.eq.chforcemag) then
                  write(lunrad,*)' '
                  write(lunrad,*)"iForceTyp = 1;"
                  write(lunrad,*)"nForce = ",nUnduMag,";"
                  write(lunrad,*)' '
                endif
              else if (abs(bc).gt.0.0) then
                write(lunrad,*)" "
                nUnduPol=nUnduPol+1
                write(lunrad,*)"nUnduPol=",nUnduPol,";"
                write(lunrad,*)"UnduPol[",nUnduPol,"] = ",
     &            trim(chconts(kcont)),";"
                if (chcont.eq.chforcemag) then
                  write(lunrad,*)' '
                  write(lunrad,*)"iForceTyp = 2;"
                  write(lunrad,*)"nForce = ",nUnduPol,";"
                  write(lunrad,*)' '
                endif
              endif
            else !ispecial
              if (abs(bc).gt.0.01) then
                nUnduSpecMag=nUnduSpecMag+1
                write(lunrad,*)"nUnduSpecMag=",nUnduSpecMag,";"
                write(lunrad,*)"UnduSpecMag[",nUnduSpecMag,"] = ",
     &            trim(chconts(kcont)),";"
                write(lunrad,*)" "
                nMagPolTot=nMagPolTot+1
                write(lunrad,*)"nMagPolTot=",nMagPolTot,";"
                write(lunrad,*)"AllMagPols[",nMagPolTot,"] = ",
     &            trim(chconts(kcont)),";"
                if (chcont.eq.chforcemag) then
                  write(lunrad,*)' '
                  write(lunrad,*)"iForceTyp = 3;"
                  write(lunrad,*)"nForce = ",nUnduSpecMag,";"
                  write(lunrad,*)' '
                endif
              else if (abs(bc).gt.0.0) then
                write(lunrad,*)" "
                nUnduSpecPol=nUnduSpecPol+1
                write(lunrad,*)"nUnduSpecPol=",nUnduSpecPol,";"
                write(lunrad,*)"UnduSpecPol[",nUnduSpecPol,"] = ",
     &            trim(chconts(kcont)),";"
                if (chcont.eq.chforcemag) then
                  write(lunrad,*)' '
                  write(lunrad,*)"iForceTyp = 4;"
                  write(lunrad,*)"nForce = ",nUnduSpecPol,";"
                  write(lunrad,*)' '
                endif
              endif
            endif !ispecial
            write(lunrad,*)" "
          endif !newcont
        endif !nwords

        call util_string_split(cbuff(3),7,nwords,ipos,istat)

        if (
     &      cbuff(3)(ipos(1,1):ipos(2,1)).eq.'Block'.or.
     &      cbuff(3)(ipos(1,1):ipos(2,1)).eq.'-6'
     &      ) then

          if (kradia.eq.0) cycle

          read(cbuff(3)(ipos(1,2):ipos(2,2)),*) ncolor

          cline=cbuff(1)
          call util_string_split(cline,6,nwords,ipos,istat)

          yfrac=1.0
          read(cbuff(4),*,iostat=istat)xlen,ylen,zlen,nxdiv,nydiv,nzdiv,yfrac

          if (abs(bc).gt.0.0) then

            do lsymx=1,nsymx
              do lsymy=1,nsymy
                do lsymz=1,nsymz

                  if (abs(bc).lt.0.01) then
                    bcx=0.0d0
                    bcy=0.0d0
                    bcz=0.0d0
                  endif

                  if (lsymx.eq.1) then
                    write(c32x,*)x0
                    call util_string_append(chmag,'x',mi,me)
                  else if (lsymx.eq.2) then
                    write(c32x,*)xsymmm+(xsymmm-x0)
                    call util_string_append(chmag,'X',mi,me)
                  endif
                  call undumag_double_to_radia(c32x)

                  if (lsymy.eq.1) then
                    write(c32y,*) y0
                    call util_string_append(chmag,'y',mi,me)
                  else if (lsymy.eq.2) then
                    write(c32y,*) -y0
                    call util_string_append(chmag,'Y',mi,me)
                  endif
                  call undumag_double_to_radia(c32y)

                  if (lsymz.eq.1) then
                    write(c32z,*) z0
                    call util_string_append(chmag,'z',mi,me)
                  else if (lsymz.eq.2) then
                    write(c32z,*) -z0
                    call util_string_append(chmag,'Z',mi,me)
                  endif
                  call undumag_double_to_radia(c32z)

                  write(lunrad,*)chmag(mi:me)//" = radObjRecMag["
                  write(lunrad,*)"           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"
                  write(c32x,*)xlen
                  call undumag_double_to_radia(c32x)
                  write(c32y,*)ylen
                  call undumag_double_to_radia(c32y)
                  write(c32z,*)zlen
                  call undumag_double_to_radia(c32z)
                  write(lunrad,*)"           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"

                  bcxs=bcx
                  bcys=bcy
                  bczs=bcz
                  if (lsymx.eq.2) then
                    bcxs=-bcx
                  endif
                  if (lsymy.eq.2) then
                    bcxs=-bcx
                    bczs=-bcz
                  endif
                  if (lsymz.eq.2) then
                    bczs=-bcz
                  endif

                  call util_string_trim(chmag,mi,me)

                  write(lunrad,*)"               {",
     &              sngl(bczs),",",sngl(bcxs),",",sngl(bcys),"}"
                  write(lunrad,*)"       ];"

                  if (nzdiv*nydiv*nxdiv.gt.1) then
                    write(lunrad,*)' '
                    if (yfrac.eq.1.0) then
                      write(lunrad,*)' '
                      write(lunrad,*)
     &                  " radObjDivMag["//chmag(mi:me)//", {",
     &                  nzdiv,",",nxdiv,",",nydiv,"},kxkykz->Numb];"
                    else
                      write(lunrad,*)' '
                      write(lunrad,*)
     &                  " radObjDivMag["//chmag(mi:me)//", {",
     &                  nzdiv,",",nxdiv,",{",nydiv,",",yfrac,"}},kxkykz->Numb];"
                    endif
                    write(lunrad,*)' '
                  endif

                  write(chmat,*)mater
                  call util_string_trim(chmat,nfirst,nlast)
                  chmat="MatRec"//chmat(nfirst:nlast)

                  call util_string_trim(chmag,mi,me)

                  write(lunrad,*)" "
                  write(lunrad,*)"(***       radMatApl["//chmag(mi:me)//","//
     &              trim(chmat)//"]; ***)"
                  write(lunrad,*)" "

                  if (ncolor.eq.2) then
                    write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                ",{1,0,0},0.0001];"
                  else if (ncolor.eq.3) then
                    write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                ",{0,1,0},0.0001];"
                  else if (ncolor.eq.4) then
                    write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                ",{0,0,1},0.0001];"
                  else if (ncolor.eq.5) then
                    write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                ",{1,1,0},0.0001];"
                  else if (ncolor.eq.6) then
                    write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                ",{1,0,1},0.0001];"
                  else if (ncolor.eq.7) then
                    write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                ",{0,1,1},0.0001];"
                  endif

                  write(lunrad,*)" "
                  write(lunrad,*)"radObjAddToCnt["//chconts(kcont)//",{"//
     &              chmag(mi:me)//"}];"

                enddo !nsymz
              enddo !nsymz
            enddo !nsymz

          endif !(abs(bc).gt.0.0) then

        else if (kradia.ne.0.and.cbuff(3)(ipos(1,1):ipos(2,1)).eq.'Cyl') then

          if (kradia.eq.0) cycle

          ncyl=ncyl+1

          read(cbuff(3)(ipos(1,2):ipos(2,2)),*) ncolor
          read(cbuff(4),*)radin,radout,height,angle,nr,nphi,nzdiv
          call util_skip_comment(lunin)
          read(lunin,*)rmat(1,1:3)
          call util_skip_comment(lunin)
          read(lunin,*)rmat(2,1:3)
          call util_skip_comment(lunin)
          read(lunin,*)rmat(3,1:3)

          if (bc.ne.0.0) then

            mcyl1=magcyl(ncyl,1)
            mcyl2=magcyl(ncyl,2)

            chmago=chmag

            do imag=mcyl1,mcyl2

              iplan=2
              do icorn=1,4
                x(icorn)=bpemag(1,icorn,iplan,imag)
                y(icorn)=bpemag(2,icorn,iplan,imag)
                z(icorn)=bpemag(3,icorn,iplan,imag)
              enddo

              iplan=4
              do icorn=1,4
                x(4+icorn)=bpemag(1,icorn,iplan,imag)
                y(4+icorn)=bpemag(2,icorn,iplan,imag)
                z(4+icorn)=bpemag(3,icorn,iplan,imag)
              enddo

              npoi=8

              call util_convex_hull_3d(npoi,x,y,z,khull,kedge,kface,
     &          nhull,nedge,nface,kfacelast,tiny,istat)

              if (istat.ne.0) then
                write(lun6,*)"*** Error in undumag_to_radia_old: Subroutine util_convex_hull_3d failed for ",
     &            trim(chmag)
                write(lun6,*)'*** returning from undumag_to_radia ***'
                goto 9999
              endif

              bcxs=bcx
              bcys=bcy
              bczs=bcz

              write(c32x,*)imag
              call util_string_trim(c32x,nfirst,nlast)
              chmag=trim(chmag(ipos(1,1):ipos(1,2)))//c32x(nfirst:nlast)

              do lsymx=1,nsymx
                do lsymy=1,nsymy
                  do lsymz=1,nsymz

                    if (lsymx.eq.1) then
                      write(c32x,*)x0
                      call util_string_append(chmag,'x',mi,me)
                    else if (lsymx.eq.2) then
                      bcxs=-bcx
                      write(c32x,*)xsymmm+(xsymmm-x0)
                      call util_string_append(chmag,'X',mi,me)
                    endif
                    call undumag_double_to_radia(c32x)

                    if (lsymy.eq.1) then
                      write(c32y,*) y0
                      call util_string_append(chmag,'y',mi,me)
                    else if (lsymy.eq.2) then
                      bcxs=-bcx
                      bczs=-bcz
                      write(c32y,*) -y0
                      call util_string_append(chmag,'Y',mi,me)
                    endif
                    call undumag_double_to_radia(c32y)

                    if (lsymz.eq.1) then
                      write(c32z,*) z0
                      call util_string_append(chmag,'z',mi,me)
                    else if (lsymz.eq.2) then
                      bczs=-bcz
                      write(c32z,*) -z0
                      call util_string_append(chmag,'Z',mi,me)
                    endif
                    call undumag_double_to_radia(c32z)

                    ! radObjPolyhdr[
                    ! {
                    !   {x1,y1,z1}, ..., {xn,yn,zn} Corners
                    ! },
                    ! {
                    !   {f1n1,f1n2,...}, ...., {f2n1,f2n2,...} Faces
                    ! },
                    ! {mx,my,mz}:{0,0,0}]

                    write(lunrad,*)chmag(mi:me)//" = radObjPolyhdr["
                    write(lunrad,*)"        { (* List of points *)"

                    do kpoi=1,npoi
                      write(c32x,*)sngl(x0+x(kpoi))
                      call undumag_double_to_radia(c32x)
                      write(c32y,*)sngl(y0+y(kpoi))
                      call undumag_double_to_radia(c32y)
                      write(c32z,*)sngl(z0+z(kpoi))
                      call undumag_double_to_radia(c32z)
                      if (kpoi.lt.npoi) then
                        write(lunrad,*)
     &                    "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"
                      else
                        write(lunrad,*)
     &                    "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
                      endif
                    enddo !kpoi

                    write(lunrad,*)"        }, (* End of list of points *)"

                    write(lunrad,*)"        { (* List of faces *)"

                    kpoi=1
                    do iface=1,nface
                      npoi=kface(kpoi)
                      cline="         {"
                      do ipoi=kpoi+1,kpoi+npoi
                        call util_string_append_num(cline,kface(ipoi),nfirst,nlast)
                        if (ipoi.lt.kpoi+npoi) then
                          call util_string_append(cline,',',nfirst,nlast)
                        else
                          call util_string_append(cline,'},',nfirst,nlast)
                        endif
                      enddo !ipoi
                      if (iface.lt.nface) then
                        write(lunrad,*)cline(1:nlast)
                        call util_string_append(cline,'},',nfirst,nlast)
                      else
                        write(lunrad,*)cline(1:nlast-1)
                      endif
                      kpoi=kpoi+npoi+1
                    enddo !nface

                    write(lunrad,*)"        }, (* End of list of faces *)"

                    write(c32x,*)bcx
                    call undumag_double_to_radia(c32x)
                    write(c32y,*)bcy
                    call undumag_double_to_radia(c32y)
                    write(c32z,*)bcz
                    call undumag_double_to_radia(c32z)

                    if (abs(bc).ge.0.01) then
                      write(lunrad,*)"         {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
                    else
                      write(lunrad,*)"         {0,0,0}"
                    endif
                    write(lunrad,*)"       ];"

                    write(chmat,*)mater
                    call util_string_trim(chmat,nfirst,nlast)
                    chmat="MatRec"//chmat(nfirst:nlast)

                    call util_string_trim(chmag,mi,me)

                    write(lunrad,*)" "
                    write(lunrad,*)"(***       radMatApl["//chmag(mi:me)//","//
     &                trim(chmat)//"]; ***)"
                    write(lunrad,*)" "

                    if (ncolor.eq.2) then
                      write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                  ",{1,0,0},0.0001];"
                    else if (ncolor.eq.3) then
                      write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                  ",{0,1,0},0.0001];"
                    else if (ncolor.eq.4) then
                      write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                  ",{0,0,1},0.0001];"
                    else if (ncolor.eq.5) then
                      write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                  ",{1,1,0},0.0001];"
                    else if (ncolor.eq.6) then
                      write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                  ",{1,0,1},0.0001];"
                    else if (ncolor.eq.7) then
                      write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &                  ",{0,1,1},0.0001];"
                    endif

                    write(lunrad,*)" "
                    write(lunrad,*)"radObjAddToCnt["//chconts(kcont)//",{"//
     &                chmag(mi:me)//"}];"
                    write(lunrad,*)" "
                    write(lunrad,*)" "

                  enddo !izsym
                enddo !iysym
              enddo !ixsym

              chmag=chmago

            enddo !imag=mcyl1,mcyl2

          endif !bc.ne.0.0

        else !} Block

          read(cbuff(3)(ipos(1,2):ipos(2,2)),*) ncolor
          read(cbuff(3)(ipos(1,3):ipos(2,3)),*) nxdiv
          read(cbuff(3)(ipos(1,4):ipos(2,4)),*) nydiv
          read(cbuff(3)(ipos(1,5):ipos(2,5)),*) nzdiv
          yfrac=1.9
          if(nwords.gt.5) read(cbuff(3)(ipos(1,6):ipos(2,6)),*) yfrac

          if (kradia.ne.0.and.cbuff(3)(ipos(1,1):ipos(2,1)).eq.'File') then

            open(newunit=lunfi,file=trim(cbuff(4)),status='old')

            npoi=0

            do while (.true.)
              call util_read_line(lunfi,cline,nlast)
              if (nlast.gt.0) then
                npoi=npoi+1
                read(cline,*)x(npoi),y(npoi),z(npoi)
              else
                exit
              endif
            enddo

            close(lunfi)

          else if (kradia.ne.0.and.cbuff(3)(ipos(1,1):ipos(2,1)).eq.'Corners') then

            read(cbuff(4),*) npoi

            do ipoi=1,npoi
              call util_skip_comment(lunin)
              read(lunin,*)x(ipoi),y(ipoi),z(ipoi)
            enddo

          else ! polyhedron

            read(cbuff(3),*) nplan
            backspace(lunin)
            npoi=0

            do iplan=1,nplan

              call util_skip_comment(lunin)
              read(lunin,*)kpoi

              if (kpoi.lt.3) then
                write(lun6,*)"*** Error in undumag_to_radia_old: Plane has less then three points  ***"
                write(lun6,*)"Magnet and plane:", trim(chmag)," ",nplan
                write(lun6,*)'*** returning from undumag_to_radia ***'
                goto 9999
              endif

              do ipoi=1,kpoi
                npoi=npoi+1
                call util_skip_comment(lunin)
                read(lunin,*)x(npoi),y(npoi),z(npoi)
              enddo

            enddo !nplan

          endif ! File, Corners, Polyhedron

+self,if=debradia.
          do i=1,npoi
            write(77,*)x(i),y(i),z(i),i
          enddo
+self.
          call util_convex_hull_3d(npoi,x,y,z,khull,kedge,kface,
     &      nhull,nedge,nface,kfacelast,tiny,istat)

+self,if=debradia.
          do i=1,nhull
            k=khull(i)
            write(78,*)x(k),y(k),z(k),i,k
          enddo

          kpoi=1
          do iface=1,nface
            npoi=kface(kpoi)
            do ipoi=kpoi+1,kpoi+npoi
              k = kface(ipoi)
              write(79,*)x(k),y(k),z(k),iface,ipoi,k
            enddo !ipoi
            kpoi=kpoi+npoi+1
          enddo !nface

+self.
          if (istat.ne.0) then
            write(lun6,*)"*** Error in undumag_to_radia_old: Subroutine util_convex_hull_3d failed for ",
     &        trim(chmag)
            write(lun6,*)'*** returning from undumag_to_radia ***'
            goto 9999
          endif

          bcxs=bcx
          bcys=bcy
          bczs=bcz

          do lsymx=1,nsymx
            do lsymy=1,nsymy
              do lsymz=1,nsymz

                if (lsymx.eq.1) then
                  write(c32x,*)x0
                  call util_string_append(chmag,'x',mi,me)
                else if (lsymx.eq.2) then
                  bcxs=-bcx
                  write(c32x,*)xsymmm+(xsymmm-x0)
                  call util_string_append(chmag,'X',mi,me)
                endif
                call undumag_double_to_radia(c32x)

                if (lsymy.eq.1) then
                  write(c32y,*) y0
                  call util_string_append(chmag,'y',mi,me)
                else if (lsymy.eq.2) then
                  bcxs=-bcx
                  bczs=-bcz
                  write(c32y,*) -y0
                  call util_string_append(chmag,'Y',mi,me)
                endif
                call undumag_double_to_radia(c32y)

                if (lsymz.eq.1) then
                  write(c32z,*) z0
                  call util_string_append(chmag,'z',mi,me)
                else if (lsymz.eq.2) then
                  bczs=-bcz
                  write(c32z,*) -z0
                  call util_string_append(chmag,'Z',mi,me)
                endif
                call undumag_double_to_radia(c32z)

                ! radObjPolyhdr[
                ! {
                !   {x1,y1,z1}, ..., {xn,yn,zn} Corners
                ! },
                ! {
                !   {f1n1,f1n2,...}, ...., {f2n1,f2n2,...} Faces
                ! },
                ! {mx,my,mz}:{0,0,0}]

                write(lunrad,*)chmag(mi:me)//" = radObjPolyhdr["
                write(lunrad,*)"        { (* List of points *)"

                do kpoi=1,npoi
                  write(c32x,*)sngl(x0+x(kpoi))
                  call undumag_double_to_radia(c32x)
                  write(c32y,*)sngl(y0+y(kpoi))
                  call undumag_double_to_radia(c32y)
                  write(c32z,*)sngl(z0+z(kpoi))
                  call undumag_double_to_radia(c32z)
                  if (kpoi.lt.npoi) then
                    write(lunrad,*)
     & "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"
                  else
                    write(lunrad,*)
     & "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
                  endif
                enddo !kpoi

                write(lunrad,*)"        }, (* End of list of points *)"
                write(lunrad,*)"        { (* List of faces *)"

                kpoi=1
                do iface=1,nface
                  npoi=kface(kpoi)
                  cline="         {"
                  do ipoi=kpoi+1,kpoi+npoi
                    call util_string_append_num(cline,kface(ipoi),nfirst,nlast)
                    if (ipoi.lt.kpoi+npoi) then
                      call util_string_append(cline,',',nfirst,nlast)
                    else
                      call util_string_append(cline,'},',nfirst,nlast)
                    endif
                  enddo !ipoi
                  if (iface.lt.nface) then
                    write(lunrad,*)cline(1:nlast)
                    call util_string_append(cline,'},',nfirst,nlast)
                  else
                    write(lunrad,*)cline(1:nlast-1)
                  endif
                  kpoi=kpoi+npoi+1
                enddo !nface

                write(lunrad,*)"        }, (* End of list of faces *)"

                write(c32x,*)bcx
                call undumag_double_to_radia(c32x)
                write(c32y,*)bcy
                call undumag_double_to_radia(c32y)
                write(c32z,*)bcz
                call undumag_double_to_radia(c32z)

                if (abs(bc).ge.0.01) then
                  write(lunrad,*)"         {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
                else
                  write(lunrad,*)"         {0,0,0}"
                endif
                write(lunrad,*)"       ];"

                if (nzdiv*nydiv*nxdiv.gt.1) then
                  write(lunrad,*)' '
                  if (yfrac.eq.1.0) then
                    write(lunrad,*)' '
                    write(lunrad,*)
     &                " radObjDivMag["//trim(chmag)//", {",
     &                nzdiv,",",nxdiv,",",nydiv,"},kxkykz->Numb];"
                  else
                    write(lunrad,*)' '
                    write(lunrad,*)
     &                " radObjDivMag["//trim(chmag)//", {",
     &                nzdiv,",",nxdiv,",{",nydiv,",",yfrac,"}},kxkykz->Numb];"
                  endif
                  write(lunrad,*)' '
                endif

                write(chmat,*)mater
                call util_string_trim(chmat,nfirst,nlast)
                chmat="MatRec"//chmat(nfirst:nlast)

                call util_string_trim(chmag,mi,me)

                write(lunrad,*)" "
                write(lunrad,*)"(***       radMatApl["//chmag(mi:me)//","//
     &            trim(chmat)//"]; ***)"
                write(lunrad,*)" "

                if (ncolor.eq.2) then
                  write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &              ",{1,0,0},0.0001];"
                else if (ncolor.eq.3) then
                  write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &              ",{0,1,0},0.0001];"
                else if (ncolor.eq.4) then
                  write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &              ",{0,0,1},0.0001];"
                else if (ncolor.eq.5) then
                  write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &              ",{1,1,0},0.0001];"
                else if (ncolor.eq.6) then
                  write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &              ",{1,0,1},0.0001];"
                else if (ncolor.eq.7) then
                  write(lunrad,*)"       radObjDrwAtr["//chmag(mi:me)//
     &              ",{0,1,1},0.0001];"
                endif

                write(lunrad,*)" "
                write(lunrad,*)"radObjAddToCnt["//chconts(kcont)//",{"//
     &            chmag(mi:me)//"}];"

              enddo !izsym
            enddo !iysym
          enddo !ixsym

        endif !Block, File, Corners etc.

      enddo !kread

      kforceradia=0
      if (iforce.ne.0.or.iforcedip.ne.0) then

        if (iforce.ne.9999.and.iforce.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_to_radia_old: Iforce not 9999 ***"
          write(lun6,*)"Force calculations within RADIA refer to ",chforcemag
          write(lun6,*)
          write(lun6,*)"*** Be careful ***"
          write(lun6,*)
          write(lunrad,*)' '
          write(lunrad,*)'Print["*** Warning in undumag_to_radia_old: Iforce not 9999 ***"];'
          write(lunrad,*)'Print["*** Be careful ***"];'
          write(lunrad,*)' '
        endif

        write(lunrad,*)' '
        write(lunrad,*)'Print["Force calculations refer to ',
     &    chforcemag,'"];'
        write(lunrad,*)' '
        kforceradia=1
      endif

      write(lunrad,*)' '
      write(lunrad,*)'iUnduForce = ',kforceradia,";"
      write(lunrad,*)' '

      write(lunrad,*)" "
      write(lunrad,*)'UnduSetUp = radObjCnt[{}];'
      write(lunrad,*)' '
      write(lunrad,*)"Coils =  radObjCnt[{}];"
      write(lunrad,*)' '

      if (ncwires.gt.0) then

        if (nrace.eq.0.and.nrbar.eq.0) then
          write(lun6,*)'*** Warning in undumag_to_radia_old: Only racetrack coils with rectangular '
          write(lun6,*)'cross-section and rectangular bars are written to RADIA notebook ***'
        endif

        do i=1,nrace

          curr=race(1,i)
          xx=race(2,i)
          yy=race(3,i)
          zz=race(4,i)
          vx=race(5,i)
          vy=race(6,i)
          vz=race(7,i)
          vn=sqrt(vx**2+vy**2+vz**2)
          vx=vx/vn
          vy=vy/vn
          vz=vz/vn
          alpha=race(8,i)
          xo=race(9,i)/2.0d0
          zi=race(10,i)/2.0d0
          zo=race(11,i)/2.0d0
          ri=race(12,i)
          w=zo-zi
          h=race(13,i)
          currden=curr/w/h
          ny=race(14,i)
          nz=race(15,i)
          nphi=race(16,i)
          kolor=race(17,i)

          write(c32y,*)race(3,i)
          write(lunrad,*)" RectCoil[",i,"] = radObjRaceTrk["
          write(c32x,*)xx
          write(c32y,*)yy
          write(c32z,*)zz
          call undumag_double_to_radia(c32x)
          call undumag_double_to_radia(c32y)
          call undumag_double_to_radia(c32z)
          write(lunrad,*)"           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"
          write(c32x,*)ri
          write(c32y,*)ri+w
          write(lunrad,*)"           {",trim(c32x),",",trim(c32y),"},"
          write(c32x,*)(xo-w-ri)*2.0d0
          write(c32z,*)(zi-ri)*2.0d0
          write(lunrad,*)"           {",trim(c32z),",",trim(c32x),"},"
          write(c32y,*)h
          write(c32x,*)currden
          write(lunrad,*)"           ",trim(c32y),",",nphi,",",trim(c32x),","
          write(lunrad,*)' "man"];'
          write(c32x,*)xx
          write(c32y,*)yy
          write(c32z,*)zz
          call undumag_double_to_radia(c32x)
          call undumag_double_to_radia(c32y)
          call undumag_double_to_radia(c32z)
          write(lunrad,*)' '
          write(lunrad,*)'RotC = radTrfRot['
          write(lunrad,*)"           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"
          write(c32x,*)vx
          write(c32y,*)vy
          write(c32z,*)vz
          call undumag_double_to_radia(c32x)
          call undumag_double_to_radia(c32y)
          call undumag_double_to_radia(c32z)
          write(lunrad,*)"           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"
          write(c32z,*)alpha/180.0d0*pi1
          call undumag_double_to_radia(c32z)
          write(lunrad,*)"           ",trim(c32z),'];'
          write(lunrad,*)' '
          write(lunrad,*)" RectCoil[",i,"] = radTrfOrnt[RectCoil[",i,"],RotC];"
          write(lunrad,*)' '

          if (kolor.eq.2) then
            write(lunrad,*)"       radObjDrwAtr[RectCoil[",i,"]"//
     &        ",{1,0,0},0.0001];"
          else if (kolor.eq.3) then
            write(lunrad,*)"       radObjDrwAtr[RectCoil[",i,"]"//
     &        ",{0,1,0},0.0001];"
          else if (kolor.eq.4) then
            write(lunrad,*)"       radObjDrwAtr[RectCoil[",i,"]"//
     &        ",{0,0,1},0.0001];"
          else if (kolor.eq.5) then
            write(lunrad,*)"       radObjDrwAtr[RectCoil[",i,"]"//
     &        ",{1,1,0},0.0001];"
          else if (kolor.eq.6) then
            write(lunrad,*)"       radObjDrwAtr[RectCoil[",i,"]"//
     &        ",{1,0,1},0.0001];"
          else if (kolor.eq.7) then
            write(lunrad,*)"       radObjDrwAtr[RectCoil[",i,"]"//
     &        ",{0,1,1},0.0001];"
          endif

          write(lunrad,*)
          write(lunrad,*)'radObjAddToCnt[Coils,{RectCoil[',i,']}];'
          write(lunrad,*)

        enddo !nrace

        if (nrace.gt.0) then
          write(lunrad,*)'radObjAddToCnt[UnduSetUp,{Coils}];'
          write(lunrad,*)
        endif

        do i=1,nrbar
        enddo !nrbar

      endif !ncwires

      write(lunrad,*)' '
      write(lunrad,*)'(*-- End of lines generated by UNDUMAG --*)'
      write(lunrad,*)' '

9999  close(lunrad)
      close(lunin)

      deallocate(x,y,z)
      deallocate(khull,kedge,kface)

      return
      end
+DECK,undumag_to_vrml.
*CMZ :  2.02/01 22/08/2023  09.03.52  by  Michael Scheer
*-- Author :    Michael Scheer   22/10/2021
      subroutine undumag_to_vrml

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      real xp1,yp1,zp1,xp2,yp2,zp2
      integer i,lunvrml,idatetime(8)

      character(2048) cline
      character(10) dtday,dttime,dtzone

      if (ivrml.eq.0) return

      if (coating.ne.0) then
        write(lun6,*)
        write(lun6,*)'*** Warning in undumag_to_vrml: Non-zero coating of magnets, items are bigger in reallity ***'
        write(lun6,*)
      endif

      write(lun6,*)
      write(lun6,*)'Writing geometry to CAD file undumag.wrl'
      write(lun6,*)

      call date_and_time(dtday,dttime,dtzone,idatetime)

      open(newunit=lunvrml,file="undumag.wrl")

      write(lunvrml,'(a)')"#VRML V2.0 utf8"
      write(lunvrml,*)
      cline=''
      write(cline,*) kundurun
      write(cline,'(a)')"# UNDUMAG: " // trim(cline) // ' '
     &  // trim(unducomment) // ' '
     &  // dttime(1:2) // ':' // dttime(3:4) // ':' // dttime(5:6) // ' '
     &  // dtday(7:8) // '.' // dtday(5:6) // '.' // dtday(3:4)
      write(lunvrml,*)trim(cline)
      write(lunvrml,*)" "

      if (ixsym.ne.0.and.iysym.ne.0.and.izsym.ne.0) then
        call clcmag_to_vrml(0,0,0,lunvrml)
        call clcmag_to_vrml(0,0,1,lunvrml)
        call clcmag_to_vrml(0,1,0,lunvrml)
        call clcmag_to_vrml(1,0,0,lunvrml)
        call clcmag_to_vrml(0,1,1,lunvrml)
        call clcmag_to_vrml(1,0,1,lunvrml)
        call clcmag_to_vrml(1,1,0,lunvrml)
        call clcmag_to_vrml(1,1,1,lunvrml)
      else if (ixsym.ne.0.and.iysym.ne.0) then
        call clcmag_to_vrml(0,0,0,lunvrml)
        call clcmag_to_vrml(0,1,0,lunvrml)
        call clcmag_to_vrml(1,0,0,lunvrml)
        call clcmag_to_vrml(1,1,0,lunvrml)
      else if (ixsym.ne.0.and.izsym.ne.0) then
        call clcmag_to_vrml(0,0,0,lunvrml)
        call clcmag_to_vrml(0,0,1,lunvrml)
        call clcmag_to_vrml(1,0,0,lunvrml)
        call clcmag_to_vrml(1,0,1,lunvrml)
      else if (iysym.ne.0.and.izsym.ne.0) then
        call clcmag_to_vrml(0,0,0,lunvrml)
        call clcmag_to_vrml(0,0,1,lunvrml)
        call clcmag_to_vrml(0,1,0,lunvrml)
        call clcmag_to_vrml(0,1,1,lunvrml)
      else if (ixsym.ne.0) then
        call clcmag_to_vrml(0,0,0,lunvrml)
        call clcmag_to_vrml(1,0,0,lunvrml)
      else if (iysym.ne.0) then
        call clcmag_to_vrml(0,0,0,lunvrml)
        call clcmag_to_vrml(0,1,0,lunvrml)
      else if (izsym.ne.0) then
        call clcmag_to_vrml(0,0,0,lunvrml)
        call clcmag_to_vrml(0,0,1,lunvrml)
      else
        call clcmag_to_vrml(0,0,0,lunvrml)
      endif

      if (ncwires.gt.0) then

        write(lunvrml,*)
        write(lunvrml,*)"# Coils"
        write(lunvrml,*)

        do i=1,ncwires
          xp1=sngl(wire(3,i))
          yp1=sngl(wire(4,i))
          zp1=sngl(wire(5,i))
          xp2=sngl(wire(6,i))
          yp2=sngl(wire(7,i))
          zp2=sngl(wire(8,i))
          if (((xp2-xp1)**2+(yp2-yp1)**2+(zp2-zp1)**2)*abs(wire(2,i)).lt.1.0d-12)
     &      cycle
          write(lunvrml,*)"Shape{"
          write(lunvrml,*)" "
          write(lunvrml,*)"  geometry IndexedLineSet {"
          write(lunvrml,*)
          write(lunvrml,*)"      coord Coordinate{"
          write(lunvrml,*)"         point ["
          write(lunvrml,*)"          ",xp1,yp1,zp1,","
          write(lunvrml,*)"          ",xp2,yp2,zp2,","
          write(lunvrml,*)"         ] # End of point"
          write(lunvrml,*)"      } # End of Coordinate"
          write(lunvrml,*)
          write(lunvrml,*)
          write(lunvrml,*)"       coordIndex ["
          write(lunvrml,*)"                 0,"
          write(lunvrml,*)"                 1, -1,"
          write(lunvrml,*)"       ] # End of coordIndex"

          write(lunvrml,*)"  } # End of Geometry"
          write(lunvrml,*)"} # End of Shape"
          write(lunvrml,*)" "

        enddo !ncwires

        write(lunvrml,*)
        write(lunvrml,*)"# End of Coils"
        write(lunvrml,*)

      endif !ncwires

      flush(lunvrml)
      close(lunvrml)

      write(lun6,*)
      write(lun6,*)'Done'
      write(lun6,*)

      return
      end
+DECK,clcmag_to_vrml.
*CMZ :  2.04/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 03/02/2022  12.01.28  by  Michael Scheer
*-- Author :    Michael Scheer   22/10/2021
      subroutine clcmag_to_vrml(kxsym,kysym,kzsym,lunvrml)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      Type(T_Magnet) tmag
      Type(T_Magnet_Copy) tmc
      Type(T_Voxel) tv
      Type(T_Voxel_Copy) tvc

      double precision gcen(3),x,y,z,scalx,scaly,scalz
      real color(3)

      integer nhull,korn,ipoi,ncorn,ncol,moth,lunvrml,kproto,iplan,
     &  icorn,ic,i,kxsym,kysym,kzsym,imag,iv

      character(4) chscal

+self,if=trace.
      print*,"-trace-: Entered clcmag_to_vrml"
+self.

      if (kxsym.ne.0.and.kysym.ne.0.and.kzsym.ne.0) then
        scalx=-1.0d0
        scaly=-1.0d0
        scalz=-1.0d0
        chscal="_111"
      else if (kxsym.ne.0.and.kysym.ne.0) then
        scalx=-1.0d0
        scaly=-1.0d0
        scalz=1.0d0
        chscal="_110"
      else if (kxsym.ne.0.and.kzsym.ne.0) then
        scalx=-1.0d0
        scaly=1.0d0
        scalz=-1.0d0
        chscal="_101"
      else if (kysym.ne.0.and.kzsym.ne.0) then
        scalx=1.0d0
        scaly=-1.0d0
        scalz=-1.0d0
        chscal="_011"
      else if (kxsym.ne.0) then
        scalx=-1.0d0
        scaly=1.0d0
        scalz=1.0d0
        chscal="_100"
      else if (kysym.ne.0.) then
        scalx=1.0d0
        scaly=-1.0d0
        scalz=1.0d0
        chscal="_010"
      else if (kzsym.ne.0.) then
        scalx=1.0d0
        scaly=1.0d0
        scalz=-1.0d0
        chscal="_001"
      else
        scalx=1.0d0
        scaly=1.0d0
        scalz=1.0d0
        chscal=""
      endif !syms

      if (ivrml.eq.1.or.ivrml.eq.2) then

        do moth=1,nmoth_t

          do ic=1,nmagtot_t

            tmc=t_magcopy(ic)
            if (tmc%cmoth.ne.tmc%cmoth) cycle

            write(lunvrml,*)" "
            write(lunvrml,*)"# --- ",trim(chmutts(moth)) // ":" //
     &        trim(tmc%cnam) // trim(chscal)
            write(lunvrml,*)" "

            kproto=tmc%kproto
            tmag=t_magnets(kproto)
            ncol=tmag%icol
            nhull=tmag%nhull
            gcen=tmc%gcen

            ! Magnet is represented by faces

            color(1)=1
            color(2)=1
            color(3)=1

            if (ncol.eq.1) then !black
              color(1)=0
              color(2)=0
              color(3)=0
            else if (ncol.eq.2) then !red
              color(1)=1
              color(2)=0
              color(3)=0
            else if (ncol.eq.3) then !bright green
              color(1)=0
              color(2)=1
              color(3)=0
            else if (ncol.eq.4) then !blue
              color(1)=0
              color(2)=0
              color(3)=1
            else if (ncol.eq.5) then !gelb
              color(1)=1.
              color(2)=1.
              color(3)=0
            else if (ncol.eq.6) then !magenta
              color(1)=1
              color(2)=0
              color(3)=1
            else if (ncol.eq.7) then !light blau
              color(1)=0
              color(2)=1
              color(3)=1
            else if (ncol.eq.8) then ! green
              color(1)=0.35
              color(2)=0.83
              color(3)=0.33
            else if (ncol.eq.9) then !dark blue
              color(1)=0.35
              color(2)=0.33
              color(3)=0.85
            endif

            write(lunvrml,*)"Shape{"
            write(lunvrml,*)" "
            write(lunvrml,*)"  appearance Appearance{"
            write(lunvrml,*)"    material Material{"

            write(lunvrml,*)"      diffuseColor", color

c            if (ivrml.eq.2)
c     &        write(lunvrml,*)"      transparency 0.8"

            write(lunvrml,*)"    } # End of Material"
            write(lunvrml,*)"  } # End of Appearance"
            write(lunvrml,*)" "

            write(lunvrml,*)"  geometry IndexedFaceSet {"
            write(lunvrml,*)
            write(lunvrml,*)"      coord Coordinate{"

            write(lunvrml,*)"         point ["

            do korn=1,nhull
              x=tmag%xhull(korn)+gcen(1)
              y=tmag%yhull(korn)+gcen(2)
              z=tmag%zhull(korn)+gcen(3)
              write(lunvrml,*)"          ",
     &          sngl(x*scalx),sngl(y*scaly),sngl(z*scalz),","
            enddo !nhull

            write(lunvrml,*)"         ] # End of point"

            write(lunvrml,*)"      } # End of Coordinate"
            write(lunvrml,*)

            write(lunvrml,*)"       coordIndex ["

            korn=1
            do iplan=1,tmag%nface
              ncorn=tmag%kface(korn)
              do icorn=1,ncorn
                korn=korn+1
                ipoi=tmag%kface(korn)-1
                if (icorn.eq.1) i=ipoi
                write(lunvrml,*)"              ",ipoi,","
              enddo
              write(lunvrml,*)"                 ",i,"-1,"
              korn=korn+1
            enddo !nplan

            write(lunvrml,*)"       ] # End of coordIndex"
            write(lunvrml,*)"  } # End of Geometry"
            write(lunvrml,*)"} # End of Shape"
            write(lunvrml,*)" "

          enddo !imag
        enddo !nmoth

      endif !ivrml.eq.1

! Magnets is represented by lines to visualize the segmentation

      if (ivrml.eq.2) then

        do iv=1,nvoxcopy_t

          tvc=t_voxcopy(iv)
          imag=tvc%kproto
          tmag=t_magnets(imag)
          ncol=tmag%icol
          tv=tmag%t_voxels(tvc%kvoxel)

          nhull=tv%nhull
          gcen=tvc%gcen

          if (
     &      tv%ixdiv.ne.1.and.tv%ixdiv.ne.tmag%nxdiv.and.
     &      tv%iydiv.ne.1.and.tv%iydiv.ne.tmag%nydiv.and.
     &      tv%izdiv.ne.1.and.tv%izdiv.ne.tmag%nzdiv) cycle

          write(lunvrml,*)"Shape{"
          write(lunvrml,*)" "

          write(lunvrml,*)"  appearance Appearance{"
          write(lunvrml,*)"    material Material{"
          write(lunvrml,*)"      diffuseColor 1 1 1 "
          write(lunvrml,*)"    } # End of Material"
          write(lunvrml,*)"  } # End of Appearance"
          write(lunvrml,*)" "

          write(lunvrml,*)"  geometry IndexedLineSet {"
          write(lunvrml,*)
          write(lunvrml,*)"      coord Coordinate{"

          write(lunvrml,*)"         point ["

          do korn=1,nhull
            x=tv%xhull(korn)+gcen(1)
            y=tv%yhull(korn)+gcen(2)
            z=tv%zhull(korn)+gcen(3)
            write(lunvrml,*)"          ",
     &        sngl(x*scalx),sngl(y*scaly),sngl(z*scalz),","
          enddo !nhull

          write(lunvrml,*)"         ] # End of point"

          write(lunvrml,*)"      } # End of Coordinate"
          write(lunvrml,*)

          write(lunvrml,*)
          write(lunvrml,*)"       coordIndex ["

          korn=1
          do iplan=1,tv%nface
            ncorn=tv%kface(korn)
            do icorn=1,ncorn
              korn=korn+1
              ipoi=tv%kface(korn)-1
              if (icorn.eq.1) i=ipoi
              write(lunvrml,*)"              ",ipoi,","
            enddo
            write(lunvrml,*)"                 ",i,"-1,"
            korn=korn+1
          enddo !nplan

          write(lunvrml,*)"       ] # End of coordIndex"

          write(lunvrml,*)"  } # End of Geometry"
          write(lunvrml,*)"} # End of Shape"
          write(lunvrml,*)" "

        enddo !nvoxels

      endif !vrml.eq.2

+self,if=trace.
      print*,"-trace-: Leaving clcmag_to_vrml"
+self.

      return
      end
+DECK,clccoil_to_coils.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/02 03/03/2022  12.09.38  by  Michael Scheer
*CMZ :  2.02/01 19/10/2021  13.27.41  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clccoil_to_coils

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      character(2048) cline,cline1
      character(128) cword,ckey

      double precision curr,x1,y1,z1,x2,y2,z2,
     &  wind19(19),bx,by,bz,p(100)

      integer i,ib,nw,icolor
      integer ipos(2,1000),nwords,nc,nwc,istat,nf,nfila

      integer lunf,ieof

      character(32) c32

      if (ncoils_t.le.0) return

      allocate(t_coils(ncoils_t))

      nrace=0
      nwind=0
      ncrace=0
      narc=0
      ncarc=0
      nrbar=0
      nthwir=0
      ncwires=0

      nw=0
      nwc=0
      nc=0
      ib=0

      if (kechocalc.ne.0) then
        print*,""
        print*,"Entered clcoil_to_coils:"
        print*,""
      endif

      do while (ib.lt.nclccoil-1)

        ib=ib+1
        cline=clccoil(ib)

        if (kechocalc.ne.0) print*,trim(cline)

        call clcstring_to_vars(cline)
        call util_string_split(cline,1000,nwords,ipos,istat)

        if (cline(ipos(1,1):ipos(2,1)).eq.'Coil') cycle

        ckey=trim(adjustl(cline(ipos(1,1):ipos(2,1))))
        nc=nc+1

        if (nwords.gt.1) then
          t_coils(nc)%cnam=cline(ipos(1,2):ipos(2,2))
        else
          write(c32,*)nc
          t_coils(nc)%cnam="Coil_" // adjustl(trim(c32))
        endif

        t_coils(nc)%ctype=trim(ckey)

        ib=ib+1
        cline=clccoil(ib)
        if (kechocalc.ne.0) print*,trim(cline)
        call clcstring_to_vars(cline)
        call util_string_split(cline,1000,nwords,ipos,istat)
        cword=cline(ipos(1,1):ipos(2,1))

        if (ckey.eq.'Filaments') then

          read(cword,*)nf
          t_coils(nc)%iibuff=ib

          nfila=0
          do i=1,nf
            ib=ib+1
            cline=clccoil(ib)
            if (kechocalc.ne.0) print*,trim(cline)
            call clcstring_to_vars(cline)
            call util_string_split(cline,1000,nwords,ipos,istat)
            cword=cline(ipos(1,1):ipos(2,1))
            read(cword,*)curr
            if (curr.eq.0.0d0) cycle
            cword=cline(ipos(1,2):ipos(2,2))
            read(cword,*)x1
            cword=cline(ipos(1,3):ipos(2,3))
            read(cword,*)y1
            cword=cline(ipos(1,4):ipos(2,4))
            read(cword,*)z1
            cword=cline(ipos(1,5):ipos(2,5))
            read(cword,*)x2
            cword=cline(ipos(1,6):ipos(2,6))
            read(cword,*)y2
            cword=cline(ipos(1,7):ipos(2,7))
            read(cword,*)z2
            if ((x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
            nfila=nfila+1
          enddo

          if (nfila.eq.0) then
            nc=nc-1
          endif

          ncwires=ncwires+nfila
          t_coils(nc)%iebuff=ib
          t_coils(nc)%params(1)=nfila

        else if (ckey.eq.'File') then

          nfila=0
          cline=trim(adjustl(clccoil(ib)))
          t_coils(nc)%cparams=trim(cline)
          open(newunit=lunf,file=cline,status='old')

          do while (.true.)
            call util_skip_comment_empty_end(lunf,ieof)
            if (ieof.ne.0) exit
            read(lunf,'(a)') cline
            if (kechocalc.ne.0) print*,trim(cline)
            call clcstring_to_vars(cline)
            read(cline,*)curr,x1,y1,z1,x2,y2,z2,icolor
            if (curr.eq.0.0d0.or.(x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
            nfila=nfila+1
          enddo
          close(lunf)

          if (nfila.eq.0) then
            nc=nc-1
          endif

          ncwires=ncwires+nfila
          t_coils(nc)%params(1)=nfila

        else if (ckey.eq.'RectWindings') then
          read(cline,*)t_coils(nc)%params(1:19)
          if (t_coils(nc)%params(1).eq.0.0d0) then
            nc=nc-1
            cycle
          endif
          nwind=nwind+1
        else if (ckey.eq.'Rectangular') then
          read(cline,*)t_coils(nc)%params(1:17)
          if (t_coils(nc)%params(1).eq.0.0d0) then
            nc=nc-1
            cycle
          endif
          nrace=nrace+1
        else if (ckey.eq.'RectangCirc') then
          read(cline,*)t_coils(nc)%params(1:17)
          if (t_coils(nc)%params(1).eq.0.0d0) then
            nc=nc-1
            cycle
          endif
          ncrace=ncrace+1
        else if (ckey.eq.'RectArc') then
          ib=ib+1
          cline1=clccoil(ib)
          if (kechocalc.ne.0) print*,trim(cline1)
          call clcstring_to_vars(cline1)
          cline=trim(adjustl(cline)) // " " // trim(adjustl(cline1))
          read(cline,*)t_coils(nc)%params(1:21)
          if (t_coils(nc)%params(1).eq.0.0d0) then
            nc=nc-1
            cycle
          endif
          narc=narc+1
        else if (ckey.eq.'CircArc') then
          ib=ib+1
          cline1=clccoil(ib)
          if (kechocalc.ne.0) print*,trim(cline1)
          call clcstring_to_vars(cline1)
          cline=trim(adjustl(cline)) // " " // trim(adjustl(cline1))
          read(cline,*)t_coils(nc)%params(1:20)
          if (t_coils(nc)%params(1).eq.0.0d0) then
            nc=nc-1
            cycle
          endif
          ncarc=ncarc+1
        else if (ckey.eq.'RectBar') then
          ib=ib+1
          cline1=clccoil(ib)
          if (kechocalc.ne.0) print*,trim(cline1)
          cline1=clccoil(ib)
          call clcstring_to_vars(cline1)
          cline=trim(adjustl(cline)) // " " // trim(adjustl(cline1))
          read(cline,*)t_coils(nc)%params(1:19)
          if (t_coils(nc)%params(1).eq.0.0d0) then
            nc=nc-1
            cycle
          endif
          nrbar=nrbar+1
        else if (ckey.eq.'ThickWire') then
          ib=ib+1
          cline1=clccoil(ib)
          if (kechocalc.ne.0) print*,trim(cline1)
          call clcstring_to_vars(cline1)
          cline=trim(adjustl(cline)) // " " // trim(adjustl(cline1))
          read(cline,*)t_coils(nc)%params(1:18)
          if (t_coils(nc)%params(1).eq.0.0d0) then
            nc=nc-1
            cycle
          endif
          nthwir=nthwir+1
        endif !ckey

      enddo !nclccoil

      if (ncwires.gt.0) then
        allocate(wire(nwitems,ncwires))
        wire=0.0d0
      endif

      if (nwind.gt.0) then
        allocate(wind(19,nwind))
        wind=0.0d0
      endif

      if (nrace.gt.0) then
        allocate(race(17,nrace))
        race=0.0d0
      endif

      if (ncrace.gt.0) then
        allocate(crace(17,ncrace))
        crace=0.0d0
      endif

      if (narc.gt.0) then
        allocate(arc(21,narc))
        arc=0.0d0
      endif

      if (ncarc.gt.0) then
        allocate(carc(20,ncarc))
        carc=0.0d0
      endif

      if (nrbar.gt.0) then
        allocate(rectbar(19,nrbar))
        rectbar=0.0d0
      endif

      if (nthwir.gt.0) then
        allocate(thickwire(18,nthwir))
        thickwire=0.0d0
      endif

      ncoils_t=nc

      ncwires=0
      nrace=0
      nwind=0
      ncrace=0
      narc=0
      ncarc=0
      nrbar=0
      nthwir=0

      nw=0
      nc=0
      ib=0

      do nc=1,ncoils_t

        p(1:100)=t_coils(nc)%params(1:100)
        ckey=trim(adjustl(t_coils(nc)%ctype))

        if (ckey.eq.'Filaments') then

          nwc=nwc+1

          do ib=t_coils(nc)%iibuff+1,t_coils(nc)%iebuff
            cline=clccoil(ib)
            call clcstring_to_vars(cline)
            call util_string_split(cline,1000,nwords,ipos,istat)
            cword=cline(ipos(1,1):ipos(2,1))
            read(cword,*)curr
            if (curr.eq.0.0d0) cycle
            cword=cline(ipos(1,2):ipos(2,2))
            read(cword,*)x1
            cword=cline(ipos(1,3):ipos(2,3))
            read(cword,*)y1
            cword=cline(ipos(1,4):ipos(2,4))
            read(cword,*)z1
            cword=cline(ipos(1,5):ipos(2,5))
            read(cword,*)x2
            cword=cline(ipos(1,6):ipos(2,6))
            read(cword,*)y2
            cword=cline(ipos(1,7):ipos(2,7))
            read(cword,*)z2
            if ((x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
            ncwires=ncwires+1
            cword=cline(ipos(1,8):ipos(2,8))
            read(cword,*)icolor
            wire(1,ncwires)=1 !type
            wire(2,ncwires)=curr
            wire(3,ncwires)=x1
            wire(4,ncwires)=y1
            wire(5,ncwires)=z1
            wire(6,ncwires)=x2
            wire(7,ncwires)=y2
            wire(8,ncwires)=z2
            wire(9,ncwires)=icolor
            wire(10,ncwires)=nc
            wire(11,ncwires)=nwc
          enddo

        else if (ckey.eq.'File') then
          cline=t_coils(nc)%cparams
          open(newunit=lunf,file=cline,status='old')
          nwc=nwc+1
          do i=1,nint(t_coils(nc)%params(1))
            call util_skip_comment_empty_end(lunf,ieof)
            read(lunf,'(a)') cline
            call clcstring_to_vars(cline)
            read(cline,*)curr,x1,y1,z1,x2,y2,z2,icolor
            if (curr.eq.0.0d0.or.(x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
            ncwires=ncwires+1
            wire(1,ncwires)=1 !type
            wire(2,ncwires)=curr
            wire(3,ncwires)=x1
            wire(4,ncwires)=y1
            wire(5,ncwires)=z1
            wire(6,ncwires)=x2
            wire(7,ncwires)=y2
            wire(8,ncwires)=z2
            wire(9,ncwires)=icolor
            wire(10,ncwires)=nc
            wire(11,ncwires)=nwc
          enddo
          close(lunf)
        else if (ckey.eq.'RectWindings') then
          wind19=t_coils(nc)%params(1:19)
          nwind=nwind+1
          wind(1,nwind)=wind19(1)
          wind(2:17,nwind)=wind19(4:19)
          wind(18:19,nwind)=wind19(2:3)
        else if (ckey.eq.'Rectangular') then
          nrace=nrace+1
          race(1:17,nrace)=t_coils(nc)%params(1:17)
        else if (ckey.eq.'RectangCirc') then
          ncrace=ncrace+1
          crace(1:17,ncrace)=t_coils(nc)%params(1:17)
        else if (ckey.eq.'RectArc') then
          narc=narc+1
          arc(1:21,narc)=t_coils(nc)%params(1:21)
        else if (ckey.eq.'CircArc') then
          ncarc=ncarc+1
          carc(1:20,ncarc)=t_coils(nc)%params(1:20)
        else if (ckey.eq.'RectBar') then
          nrbar=nrbar+1
          rectbar(1:19,nrbar)=t_coils(nc)%params(1:19)
        else if (ckey.eq.'ThickWire') then
          nthwir=nthwir+1
          thickwire(1:18,nthwir)=t_coils(nc)%params(1:18)
        endif !ckey

      enddo !nclccoil

      call undumag_bcoils(0.0d0,0.0d0,0.0d0,bx,by,bz,istat)

      return
      end
+DECK,UNDUMAG_BEFF.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/02 26/02/2022  12.52.35  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 29/03/2021  09.45.50  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.14.56  by  Michael Scheer
*CMZ :  2.01/05 05/06/2020  17.09.33  by  Michael Scheer
*CMZ :  2.01/04 29/07/2019  12.05.13  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.25.31  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  16.20.58  by  Michael Scheer
*CMZ :  2.00/03 19/04/2018  11.05.57  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  13.46.37  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  16.46.42  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  11.15.27  by  Michael Scheer
*CMZ :  1.25/03 03/04/2018  08.01.24  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.03.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.17.42  by  Michael Scheer
*CMZ :  1.25/00 14/03/2018  12.58.50  by  Michael Scheer
*CMZ :  1.24/01 13/10/2017  11.37.28  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  14.05.37  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.07.37  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  15.55.08  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.18.42  by  Michael Scheer
*CMZ :  1.22/02 04/08/2017  07.56.26  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.55.33  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.09.09  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  15.38.45  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.35.35  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  16.39.29  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.15.48  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.22.03  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  16.12.25  by  Michael Scheer
*CMZ :  1.18/00 02/06/2017  09.38.06  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  15.20.49  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  08.36.20  by  Michael Scheer
*CMZ :  1.17/06 18/05/2017  22.30.31  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  15.55.38  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  17.57.38  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.15.17  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  09.01.37  by  Michael Scheer
*CMZ :  1.15/07 04/04/2017  13.49.11  by  Michael Scheer
*CMZ :  1.15/05 03/04/2017  13.40.53  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.57.38  by  Michael Scheer
*CMZ :  1.15/03 02/04/2017  15.45.35  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.38.56  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  15.25.06  by  Michael Scheer
*CMZ :  1.15/00 27/03/2017  15.13.40  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  14.39.06  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.16.46  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.26.29  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.53.52  by  Michael Scheer
*CMZ :  1.11/04 23/01/2017  17.22.15  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.28  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.48.13  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.22.30  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.52.38  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.18.26  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.45.21  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.30.02  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.49.21  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.57.45  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.31.52  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  14.13.49  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  15.30.08  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  12.45.07  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.03.06  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.37.39  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  11.57.51  by  Michael Scheer
*CMZ :  0.00/11 18/07/2016  09.18.11  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.57.35  by  Michael Scheer
*CMZ :  0.00/09 28/06/2016  15.42.08  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/05 13/06/2016  12.45.02  by  Michael Scheer
*CMZ :  0.00/02 30/04/2016  13.12.13  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.02.34  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  15.51.06  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.38.32  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.40.54  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  15.11.21  by  Michael Scheer
*CMZ :  1.17/03 22/03/2016  07.59.20  by  Michael Scheer
*CMZ :  1.17/02 07/03/2016  16.32.54  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_beff(xminbeff,xmaxbeff,bmnbeff,bmxbeff,beff,dkeff,
     &  bmnbeffnor,bmxbeffnor,beffnor,dkeffnor,modus)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

+seq,seqdebug.
+seq,random.

      double precision, dimension (:,:,:,:), allocatable :: bmap
      double precision, dimension (:,:), allocatable :: hmvoxel,hmagvox
      double precision, dimension (:), allocatable ::
     &  xint,bxa,bya,byz,bza,bint,bint2,xinti,bxai,byai,bzai,bym,bzm,
     &  binti,bint2i,xintnor,bxanor,byanor,bzanor,bintnor,bint2nor,
     &  ws1,ws2,ws3,ws4,coef,byzanor

      integer, dimension (:), allocatable :: kfailbeff

      double precision bmnbeff,bmxbeff,beff,dkeff,bp(3),a(3),x,xx,y,z,
     &  xmaxbeff,xminbeff,dxkbmode,dx,yopt,yp(3),
     &  quadperlen,xopt,halfperlen,by,bx,bz,b,bprog,a3(3),x3(3),dkeffz,bmaxp,
     &  dkeffznor,dkeffnor,dum,bmxbeffnor,xbeffo,
     &  b3(3),beffnor,bmnbeffnor,bmaxbeffnor,bmaxbeff

      real g(3)

      integer modus,lun,idis,ixbeff,ixbeffnor,irecover,itry,ix,kfail,ibmax,
     &  ifail,ifail77,ibmin,i

      allocate (
     &  xintnor(nxbeff),bintnor(nxbeff),bint2nor(nxbeff),bxanor(nxbeff),
     &  byanor(nxbeff),bzanor(nxbeff),xint(nxbeff),bint(nxbeff),bint2(nxbeff),
     &  bxa(nxbeff),bya(nxbeff),bza(nxbeff),byz(nxbeff),
     &  ws1(nxbeff),ws2(nxbeff),ws3(nxbeff),ws4(nxbeff),coef(nxbeff),
     &  kfailbeff(nxbeff),byzanor(nxbeff))

      halfperlen=perlen/2.0d0
      quadperlen=perlen/4.0d0

      dx=(xmaxbeff-xminbeff)/(nxbeff-1)
      x=xminbeff-dx
      dxkbmode=abs(kbeffmode)*dx

      if (modus.eq.0) then
        call util_zeit_kommentar(lun6,"Writing undumag_bzeff.dat")
        open(newunit=lun,file="undumag_bzeff.dat")
      else
        call util_zeit_kommentar(lun6,"Writing undumag_byeff.dat")
        open(newunit=lun,file="undumag_byeff.dat")
      endif

      idis=0
      ixbeff=0
      ixbeffnor=0
      irecover=0
      itry=0

      do ix=1,nxbeff

12      x=xminbeff+(ix-1)*dx

        call util_random(3,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif
        xint(ix)=x
        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif
        if (randoz.ge.0.0d0) then
          z=g(3)*randoza
        else
          z=randoza
        endif

        if (kbeffmode.eq.0) then

          ifail=0

          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &      bxa(ix),bya(ix),bza(ix),ifail)

        else

          if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
            cycle
          endif

          if (abs(x-xbeff).le.quadperlen) then

            call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bxa(ix),bya(ix),bza(ix),ifail)

          else if (x.lt.xbeff) then

            ifail=0

            call undumag_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bxa(ix),bya(ix),bza(ix),ifail)

            bxa(ix)=-bxa(ix)
            bya(ix)=-bya(ix)
            bza(ix)=-bza(ix)

          else

            ifail=0

            call undumag_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bxa(ix),bya(ix),bza(ix),ifail)

            bxa(ix)=-bxa(ix)
            bya(ix)=-bya(ix)
            bza(ix)=-bza(ix)

          endif

        endif !kbeffmode

        if (ifail.ne.0.and.itry.lt.10.and.ifail.ne.-1) then
          itry=itry+1
          goto 12
        endif

        itry=0

        if (ifail.gt.0) then
          if (modus.eq.0) then
            write(lun6,*)"Undumag_field returned failure for Bzeff calculation at point ",ix,xint(ix)
          else
            write(lun6,*)"Undumag_field returned failure for Byeff calculation at point ",ix,xint(ix)
          endif
        else
          if (ifail.lt.0) then
            irecover=irecover+1
          endif

          ixbeff=ixbeff+1
          kfailbeff(ixbeff)=ifail
          xint(ixbeff)=xint(ix)

          bxa(ixbeff)=bxa(ix)
          bya(ixbeff)=bya(ix)
          bza(ixbeff)=bza(ix)

          if (ifail.eq.0.or.ifail.eq.-1) then
            ixbeffnor=ixbeffnor+1
            xintnor(ixbeffnor)=xint(ix)
            bxanor(ixbeffnor)=bxa(ix)
            byanor(ixbeffnor)=bya(ix)
            bzanor(ixbeffnor)=bza(ix)
          endif
        endif
      enddo

      if (irecover.ne.0) then
        write(lun6,*)
        if (modus.eq.0) then
          write(lun6,*)"*** Warning in undumag_beff:  BzEff calculations with ",irecover, " recovered errors ***"
        else
          write(lun6,*)"*** Warning in undumag_beff:  ByEff calculations with ",irecover, " recovered errors ***"
        endif
        write(lun6,*)
      endif

c{ BEff with recovered points
      if (ixbeff.gt.0) then

        x3=xint(1:3)
        b3=bya(1:3)
        call parabel_short(x3,b3,a3)
        xint(1)=xminbeff
        bya(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2
        b3=bza(1:3)
        call parabel_short(x3,b3,a3)
        bza(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2

        x3=xint(ixbeff-2:ixbeff)
        b3=bya(ixbeff-2:ixbeff)
        call parabel_short(x3,b3,a3)
        xint(ixbeff)=xmaxbeff
        bya(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2
        b3=bza(ixbeff-2:ixbeff)
        call parabel_short(x3,b3,a3)
        bza(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2

        do i=1,ixbeff
          write(lun,*)i,xint(i),bya(i),bza(i),kfailbeff(i)
        enddo

        if (modus.eq.0) then
          byz=bza
          byzanor=bzanor
        else
          byz=bya
          byzanor=byanor
        endif

        if (isimpson.eq.0) then
          call util_spline_running_integral(xint,byz,ixbeff,bint,coef,
     &      ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixbeff,xint,byz,bint)
        endif

        bmnbeff=1.0d30
        bmxbeff=-1.0d30
        bmaxbeff=-1.0d30

        do i=1,ixbeff
          if (byz(i).gt.bmxbeff) then
            bmxbeff=byz(i)
          endif
          if (byz(i).lt.bmnbeff) then
            bmnbeff=byz(i)
          endif
          if (abs(byz(i)).gt.bmaxbeff) then
            bmaxbeff=abs(byz(i))
            ibmax=i
          endif
          bint(i)=bint(i)**2
        enddo !i=1,ixbeff

        if (ibmax.eq.1) ibmax=2
        if (ibmax.eq.ixbeff) ibmax=ixbeff-1

        yp(1)=1.0d0
        yp(2)=2.0d0
        yp(3)=3.0d0

        bp(1)=abs(byz(ibmax-1))
        bp(2)=abs(byz(ibmax))
        bp(3)=abs(byz(ibmax+1))

        call util_max_parabel(3,yp,bp,dum,bmaxp,ws1,ws2,ifail)
        if (ifail.eq.0) bmaxbeff=bmaxp

        if (isimpson.eq.0) then
          call util_spline_running_integral(xint,bint,ixbeff,bint2,coef,
     &      ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixbeff,xint,bint,bint2)
        endif

        beff= sqrt(bint2(ixbeff)/(xint(ixbeff)-xint(1)))

c Correct for endpole effects
        if (bmaxbeff.ne.0.0d0) then
          beff=beff*(bmxbeff-bmnbeff)/2.0d0/bmaxbeff
        endif

        bmaxbeff=(bmxbeff-bmnbeff)/2.0d0

        dkeff = beff * sqrt(2.0d0)  * 3.0d8 / 0.511d6 / 1000.0d0
        beff = dkeff / ((xint(ixbeff)-xint(1))*100.0d0) / 0.934d0 * 1000.0d0

      else

        write(lun6,*)
        if (modus.eq.0) then
          write(lun6,*)"*** Warning in undumag_beff: No field data for BzEff *** "
        else
          write(lun6,*)"*** Warning in undumag_beff: No field data for ByEff *** "
        endif

      endif

      flush(lun)
      close(lun)
c} BEff with recovered points

c{ BEff without recovered points
      if (ixbeffnor.gt.0) then

        x3=xintnor(1:3)
        b3=byzanor(1:3)
        call parabel_short(x3,b3,a3)
        xintnor(1)=xminbeff
        byzanor(1)=a3(1)+a3(2)*xintnor(1)+a3(3)*xintnor(1)**2

        x3=xintnor(ixbeffnor-2:ixbeffnor)
        b3=byzanor(ixbeffnor-2:ixbeffnor)
        call parabel_short(x3,b3,a3)

        xintnor(ixbeffnor)=xmaxbeff
        byzanor(ixbeffnor)=a3(1)+a3(2)*xintnor(ixbeffnor)+
     &    a3(3)*xintnor(ixbeffnor)**2

        if (isimpson.eq.0) then
          call util_spline_running_integral(xintnor,byzanor,ixbeffnor,bintnor,
     &      coef,ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixbeffnor,xintnor,byzanor,bintnor)
        endif

        bmnbeffnor=1.0d30
        bmxbeffnor=-1.0d30
        bmaxbeffnor=-1.0d30

        do i=1,ixbeffnor
          if (byzanor(i).gt.bmxbeffnor) then
            bmxbeffnor=byzanor(i)
          endif
          if (byzanor(i).lt.bmnbeffnor) then
            bmnbeffnor=byzanor(i)
          endif
          if (abs(byzanor(i)).gt.bmaxbeffnor) then
            bmaxbeffnor=abs(byzanor(i))
            ibmax=i
          endif
          bintnor(i)=bintnor(i)**2
        enddo

        if (ibmax.eq.1) ibmax=2
        if (ibmax.eq.ixbeffnor) ibmax=ixbeffnor-1

        yp(1)=1.0d0
        yp(2)=2.0d0
        yp(3)=3.0d0

        bp(1)=abs(byzanor(ibmax-1))
        bp(2)=abs(byzanor(ibmax))
        bp(3)=abs(byzanor(ibmax+1))

        call util_max_parabel(3,yp,bp,dum,bmaxp,ws1,ws2,ifail)
        if (ifail.eq.0) bmaxbeffnor=bmaxp

        if (isimpson.eq.0) then
          call util_spline_running_integral(xintnor,bintnor,ixbeffnor,bint2nor,
     &      coef,ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixbeffnor,xintnor,bintnor,bint2nor)
        endif

        beffnor= sqrt(bint2(ixbeffnor)/(xintnor(ixbeffnor)-xintnor(1)))

c Correct for endpole effects

        if (bmaxbeffnor.ne.0.0d0) then
          beffnor=beffnor*(bmxbeffnor-bmnbeffnor)/2.0d0/bmaxbeffnor
        endif

        bmaxbeffnor=(bmxbeffnor-bmnbeffnor)/2.0d0
        dkeffnor = beffnor * sqrt(2.0d0)  * 3.0d8 / 0.511d6 / 1000.0d0
        beffnor = dkeffnor / ((xintnor(ixbeffnor)-xintnor(1))*
     &    100.0d0) / 0.934d0 * 1000.0d0

        bmnbeffnor=bmnbeffnor
        bmxbeffnor=bmxbeffnor
        beffnor=beffnor
        dkeffznor=dkeffnor

      else

        write(lun6,*)
        if (modus.eq.0) then
          write(lun6,*)"*** Warning in undumag_beff: No field data for BzEffNOR *** "
        else
          write(lun6,*)"*** Warning in undumag_beff: No field data for ByEffNOR *** "
        endif

      endif

c} Beff with recovered without points

      ! Check for discontinuities

      idis=0

      do ix=4,ixbeffnor

        ifail77=0
        x=xintnor(ix)

        call util_parabel(xintnor(ix-3),byzanor(ix-3),
     &    a,yp,xopt,yopt,kfail)

        b=a(1)+a(2)*x+a(3)*x*x

        if (kfail.ne.0.or.abs(b-byzanor(ix)).gt.rcvthron) then
          ifail77=1
        endif

        if (ifail77.eq.1) then
          if (modus.eq.0) then
            write(lun6,*)"Discontinuity or numerical problems for calc. of Bzeff discovered, check rcvthron, x, dB, randox etc."
          else
            write(lun6,*)"Discontinuity or numerical problems for calc. of Byeff discovered, check rcvthron, x, dB, randox etc."
          endif
          bprog=byzanor(ix)
          write(lun6,*)"x, B, Bexpected, dB:",x,b,bprog,
     &      abs((b-bprog)/(b+bprog))
          idis=1
        endif

      enddo !ix=1,ixbeffnor

      deallocate (
     &  xintnor,bintnor,bint2nor,bxanor,byanor,bzanor,xint,bint,bint2,bxa,bya,
     &  bza,ws1,ws2,ws3,ws4,coef,kfailbeff,byzanor)

      return
      end
+DECK,undumag_beffy_beffz.
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/02 26/02/2022  12.52.35  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 29/03/2021  09.45.50  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.14.56  by  Michael Scheer
*CMZ :  2.01/05 05/06/2020  17.09.33  by  Michael Scheer
*CMZ :  2.01/04 29/07/2019  12.05.13  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.25.31  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  16.20.58  by  Michael Scheer
*CMZ :  2.00/03 19/04/2018  11.05.57  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  13.46.37  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  16.46.42  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  11.15.27  by  Michael Scheer
*CMZ :  1.25/03 03/04/2018  08.01.24  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.03.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.17.42  by  Michael Scheer
*CMZ :  1.25/00 14/03/2018  12.58.50  by  Michael Scheer
*CMZ :  1.24/01 13/10/2017  11.37.28  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  14.05.37  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.07.37  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  15.55.08  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.18.42  by  Michael Scheer
*CMZ :  1.22/02 04/08/2017  07.56.26  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.55.33  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.09.09  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  15.38.45  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.35.35  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  16.39.29  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.15.48  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.22.03  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  16.12.25  by  Michael Scheer
*CMZ :  1.18/00 02/06/2017  09.38.06  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  15.20.49  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  08.36.20  by  Michael Scheer
*CMZ :  1.17/06 18/05/2017  22.30.31  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  15.55.38  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  17.57.38  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.15.17  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  09.01.37  by  Michael Scheer
*CMZ :  1.15/07 04/04/2017  13.49.11  by  Michael Scheer
*CMZ :  1.15/05 03/04/2017  13.40.53  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.57.38  by  Michael Scheer
*CMZ :  1.15/03 02/04/2017  15.45.35  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.38.56  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  15.25.06  by  Michael Scheer
*CMZ :  1.15/00 27/03/2017  15.13.40  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  14.39.06  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.16.46  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.26.29  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.53.52  by  Michael Scheer
*CMZ :  1.11/04 23/01/2017  17.22.15  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.28  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.48.13  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.22.30  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.52.38  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.18.26  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.45.21  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.30.02  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.49.21  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.57.45  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.31.52  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  14.13.49  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  15.30.08  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  12.45.07  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.03.06  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.37.39  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  11.57.51  by  Michael Scheer
*CMZ :  0.00/11 18/07/2016  09.18.11  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.57.35  by  Michael Scheer
*CMZ :  0.00/09 28/06/2016  15.42.08  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/05 13/06/2016  12.45.02  by  Michael Scheer
*CMZ :  0.00/02 30/04/2016  13.12.13  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.02.34  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  15.51.06  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.38.32  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.40.54  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  15.11.21  by  Michael Scheer
*CMZ :  1.17/03 22/03/2016  07.59.20  by  Michael Scheer
*CMZ :  1.17/02 07/03/2016  16.32.54  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_beffy_beffz(
     &  byint1f,bzint1f,
     &  byint2f,bzint2f,
     &  byint1inf,bzint1inf,
     &  byint1fnor,bzint1fnor,
     &  byint2fnor,bzint2fnor,
     &  byexint,bzexint)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

+seq,seqdebug.
+seq,random.
+seq,mshplt.

      double precision, dimension (:,:,:,:), allocatable :: bmap
      double precision, dimension (:,:), allocatable :: hmvoxel,hmagvox
      double precision, dimension (:), allocatable ::
     &  xint,bxa,bya,bza,
     &  byint,bzint,byint2,bzint2,
     &  xinti,bxai,byai,bzai,bym,bzm,
     &  byinti,bzinti,byint2i,bzint2i,
     &  xintnor,bxanor,byanor,bzanor,
     &  byintnor,bzintnor,byint2nor,bzint2nor,
     &  xintd,bxad,byad,bzad,
     &  byintd,bzintd,byint2d,bzint2d,
     &  ws1,ws2,ws3,ws4,coef

      integer, dimension (:), allocatable :: kfailbeff,kfailbyeff,kfailbzeff

      double precision bmnbeff,bmxbeff,beff,dkeff,bp(3),a(3),x,xx,y,z,
     &  xminbeffnor,xmaxbeffnor,xmaxbeff,xminbeff,dxkbmode,dx,yopt,yp(3),
     &  quadperlen,xopt,halfperlen,by,bx,bz,b,bprog,a3(3),x3(3),dkeffz,bmaxp,
     &  dkeffznor,dkeffnor,dum,bmxbeffznor,bmnbeffznor,bmxbeffz,bmxbeffnor,
     &  bmnbeffz,b3(3),beffnor,beffz,beffznor,bmnbeffnor,bmaxbeffnor,bmaxbeff,
     &  bmnbeffy,bmxbeffy,dkeffy,byint2fnor,bmnbeffynor,bmxbeffynor,dkeffynor

      double precision beffy,beffynor,byexint,bzexint,byint1f,
     &  byint1fnor,byint1inf,byint2f,bymaxbeff,bzint1f,bzint1fnor,
     &  bzint1inf,bzint2f,bzint2fnor,bzmaxbeff,xbeffo,xbymax,xbzmax

      real g(3),xpl(2),ypl(2),dxpl,yplmin,yplmax,xplmin,xplmax,dypl

      integer modus,lun,idis,ixbeff,ixbeffnor,irecover,itry,ix,kfail,ibmax,
     &  ifail,ibmin,i,nfirst,nlast

      character(64) ctitle,cline
      character(24) cbeff,cbint

      allocate (
     &  xintnor(nxbeff),
     &  byintnor(nxbeff),bzintnor(nxbeff),
     &  byint2nor(nxbeff),bzint2nor(nxbeff),
     &  bxanor(nxbeff),byanor(nxbeff),bzanor(nxbeff),
     &  xint(nxbeff),
     &  byint(nxbeff),bzint(nxbeff),
     &  byint2(nxbeff),bzint2(nxbeff),
     &  bxa(nxbeff),bya(nxbeff),bza(nxbeff),
     &  ws1(nxbeff),ws2(nxbeff),ws3(nxbeff),ws4(nxbeff),coef(nxbeff),
     &  kfailbeff(nxbeff))

c      if (xbeff.eq.9999.0d0) xbeff=xconv(nxconv/2+1)
      if (xbeff.eq.9999.0d0) xbeff=xcenter
      if (xbeff.eq.-9999.0d0) xbeff=(xmapmin+xmapmax)/2.0d0

      xbeffo=xbeff

      halfperlen=perlen/2.0d0
      quadperlen=perlen/4.0d0

      bymaxbeff=-1.0d30
      bzmaxbeff=-1.0d30

      if (kbeffmode.eq.0) then
        xminbeff=xbeff-perlen*0.51
        xmaxbeff=xbeff+perlen*0.51
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
        dxkbmode=abs(kbeffmode)*dx
      else
        xminbeff=xbeff-quadperlen
        xmaxbeff=xbeff+quadperlen
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        dxkbmode=abs(kbeffmode)*dx
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
      endif

      xbymax=xbeff
      xbzmax=xbeff

      do ix=1,nxbeff

        x=xminbeff+(ix-1)*dx
        xx=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          cycle
        endif

        call util_random(3,g)
        g=g-0.5
c+self,if=rando10.
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif

c+self.,if=rando10.
        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        xint(ix)=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          if (x.lt.xbeff) then
            x=xx+abs(xx-x)
          else
            x=xx-abs(xx-x)
          endif
        endif

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif
        if (randoz.ge.0.0d0) then
          z=g(3)*randoza
        else
          z=randoza
        endif

        if (kbeffmode.eq.0) then
          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &      bx,by,bz,ifail)
        else
          if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
            cycle
          endif
          if (abs(x-xbeff).le.quadperlen) then
            call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
          else if (x.lt.xbeff) then
            call undumag_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          else
            call undumag_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          endif
        endif !kbeffmode

        if (ifail.ne.0) cycle

        if (abs(by).gt.bymaxbeff) then
          bymaxbeff=abs(by)
          xbymax=xminbeff+(ix-1)*dx
        endif

        if (abs(bz).gt.bzmaxbeff) then
          bzmaxbeff=abs(bz)
          xbzmax=xminbeff+(ix-1)*dx
        endif

      enddo !ix

      if (bymaxbeff.lt.1.0d-4*bzmaxbeff) xbymax=xbzmax
      if (bzmaxbeff.lt.1.0d-4*bymaxbeff) xbzmax=xbymax

      xbeff=xbzmax
      xminbeff=xbeff-perlen/2.0d0
      xmaxbeff=xbeff+perlen/2.0d0

      if (abs(xbeffo-xminbeff).le.quadperlen) then
        xminbeff=xminbeff-halfperlen
        xmaxbeff=xmaxbeff-halfperlen
      else if (xbeffo-xminbeff.gt.halfperlen*1.001) then
        xminbeff=xminbeff+halfperlen
        xmaxbeff=xmaxbeff+halfperlen
      endif

      if (xbeffz.ne.-9999.0d0) then
        xbeff=xbeffz
        xminbeff=xbeff-perlen/2.0d0
        xmaxbeff=xbeff+perlen/2.0d0
      endif

      call undumag_beff(xminbeff,xmaxbeff,bmnbeffy,bmxbeffy,beffy,dkeffy,
     &  bmnbeffynor,bmxbeffynor,beffynor,dkeffynor,1)
      call undumag_beff(xminbeff,xmaxbeff,bmnbeffz,bmxbeffz,beffz,dkeffz,
     &  bmnbeffznor,bmxbeffznor,beffznor,dkeffznor,0)

      write(lun6,*)
      write(lun6,*)"XminBeff, XmaxBeff (with recovered points):",
     &  sngl(xminbeff),sngl(xmaxbeff)

      if (beffz.gt.0.0d0) then
        if (abs((bmxbeffz-bmnbeffz)/2.0d0/beffz-1.0d0).gt.0.1) then
          write(lun6,*)
          write(lun6,*)"*** WARNING: BzEff differs more than 10 percent from min/max-values of Bz ***"
          write(lun6,*)
        endif
      endif

      if (beffy.gt.0.0d0) then
        if (abs((bmxbeffy-bmnbeffy)/2.0d0/beffy-1.0d0).gt.0.1) then
          write(lun6,*)
          write(lun6,*)"*** WARNING: ByEff differs more than 10 percent from min/max values of By ***"
          write(lun6,*)
        endif
      endif

      write(lun6,*)"ByMin, ByMax, (ByMax-ByMin)/2, ByEff (with recovered points):",
     &  sngl(bmnbeffy),sngl(bmxbeffy),
     &  sngl((bmxbeffy-bmnbeffy)/2.0d0),sngl(beffy)

      write(lun6,*)"BzMin, BzMax, (BzMax-BzMin)/2, BzEff (with recovered points):",
     &  sngl(bmnbeffz),sngl(bmxbeffz),
     &  sngl((bmxbeffz-bmnbeffz)/2.0d0),sngl(beffz)

      dkeff=sqrt(dkeffy**2+dkeffz**2)
      beff=sqrt(beffy**2+beffz**2)

      write(lun6,*)
      write(lun6,*)"Beff = Sqrt( ByEff**2 + BzEff**2 ) (with recovered points):",
     &  sngl(beff)
      write(lun6,*)
      write(lun6,*)"Keff and first harmonic [eV] (with recovered points):",
     &  sngl(dkeff),sngl(950.0d0*ebeam**2/(1.0d0+dkeff**2/2.0d0)/(perlen/10.0d0))
      write(lun6,*)

      write(lun6,*)
      write(lun6,*)"XminBeff, XmaxBeff (without recovered points):",
     &  sngl(xminbeffnor),sngl(xmaxbeffnor)

      write(lun6,*)"ByMin, ByMax, (ByMax-ByMin)/2, ByEff (without recovered points):",
     &  sngl(bmnbeffynor),sngl(bmxbeffynor),
     &  sngl((bmxbeffynor-bmnbeffynor)/2.0d0),sngl(beffnor)

      write(lun6,*)"BzMin, BzMax, (BzMax-BzMin)/2, BzEff (without recovered points):",
     &  sngl(bmnbeffznor),sngl(bmxbeffznor),
     &  sngl((bmxbeffznor-bmnbeffznor)/2.0d0),sngl(beffznor)

      dkeffnor=sqrt(dkeffynor**2+dkeffznor**2)
      beffnor=sqrt(beffynor**2+beffznor**2)

      write(lun6,*)
      write(lun6,*)"Beff = Sqrt( ByEff**2 + BzEff**2 ) (without recovered points):",
     &  sngl(beffnor)
      write(lun6,*)
      write(lun6,*)"Keff and first harmonic [eV] (without recovered points):",
     &  sngl(dkeffnor),sngl(950.0d0*ebeam**2/(1.0d0+dkeffnor**2/2.0d0)/
     &  (perlen/10.0d0))
      write(lun6,*)

      call util_zeit_kommentar(lun6,"Writing undumag.beff")

      open(newunit=lun,file="undumag.beff")

      write(lun,*)"* Run:"
      write(lun,*)kundurun
      write(lun,*)"* XminBeff XmaxBeff:"
      write(lun,*)
     &  sngl(xminbeff),sngl(xmaxbeff)
      write(lun,*)"* ByMin, ByMax, (ByMax-ByMin)/2, ByEff:"
      write(lun,*)
     &  sngl(bmnbeffy),sngl(bmxbeffy),
     &  sngl((bmxbeffy-bmnbeffy)/2.0d0),sngl(beffy)
      write(lun,*)"* BzMin, BzMax, (BzMax-BzMin)/2, BzEff:"
      write(lun,*)
     &  sngl(bmnbeffz),sngl(bmxbeffz),
     &  sngl((bmxbeffz-bmnbeffz)/2.0d0),sngl(beffz)
      write(lun,*)"* Beff = Sqrt( ByEff**2 + BzEff**2 ), Keff, 1. Harm. [eV]:"
      write(lun,*) sngl(beff), sngl(dkeff)
     &  ,sngl(950.0d0*ebeam**2/(1.0d0+dkeff**2/2.0d0)/(perlen/10.0d0))
      write(lun,*)"* ByInt1, BzInt1, ByInt2, BzInt2:"
      write(lun,*)
     &  sngl(byint1f),sngl(bzint1f),
     &  sngl(byint2f),sngl(bzint2f)
      write(lun,*)"* ByInt1Inf, BzInt1Inf:"
      write(lun,*)
     &  sngl(byint1inf),sngl(bzint1inf)
      write(lun,*)"* ByMin, ByMax, (ByMax-ByMin)/2, ByEff, without recovered points:"
      write(lun,*)
     &  sngl(bmnbeffynor),sngl(bmxbeffynor),
     &  sngl((bmxbeffynor-bmnbeffynor)/2.0d0),sngl(beffynor)
      write(lun,*)"* BzMin, BzMax, (BzMax-BzMin)/2, BzEff, without recovered points:"
      write(lun,*)
     &  sngl(bmnbeffznor),sngl(bmxbeffznor),
     &  sngl((bmxbeffznor-bmnbeffznor)/2.0d0),sngl(beffznor)
      write(lun,*)"* Beff = Sqrt( ByEff**2 + BzEff**2 ), without recovered points:"
      write(lun,*)
     &  sngl(beffnor)
      write(lun,*)"* ByInt1, BzInt1, ByInt2, BzInt2, without recovered points:"
      write(lun,*)
     &  sngl(byint1fnor),sngl(bzint1fnor),
     &  sngl(byint2fnor),sngl(bzint2fnor)
      write(lun,*) "External field [T]:"
      write(lun,*) sngl(bxex),sngl(byex),sngl(bzex)
      write(lun,*)"1. Integrals ByI and BzI [Tmm] of external field:"
      write(lun,*)sngl(byexint),sngl(bzexint)
      flush(lun)
      close(lun)
c Calculate beff}

      call util_zeit_kommentar(lun6,"Writing undumag_beff.eps")

      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_beff.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (krunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

      gsiz_ps=0.4

      xplmin=xbeffo-perlen
      xplmax=xbeffo+perlen

! By
      yplmin=min(-beff,-sqrt(min(bmxbeffy**2,bmnbeffy**2)+bmxbeffz**2))
      yplmax=max(beff,sqrt(bmxbeffy**2+bmxbeffz**2))
      yplmin=-max(abs(bmnbeffy),abs(bmxbeffy),abs(bmnbeffz),abs(bmxbeffz))
      yplmax=-yplmin

      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(4.,19.,3.,18.)

      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.1,0.9,'B [T]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.1,'x [mm]')

      call mgset('CHHE',0.5)
      cbeff="Beff = "
      write(cbeff(7:14),'(f6.3)')beff
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.3,cbeff)
      cbeff="Keff = "
      write(cbeff(7:14),'(f6.3)')dkeff
      call mshplt_text_ndc(0.7,0.25,cbeff)

      call mshplt_set_text_color(0,1,0,0)

      cbeff="ByMax = "
      write(cbeff(7:14),'(f6.3)')bmxbeffy
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.9,cbeff)
      cbeff="ByMin = "
      write(cbeff(7:14),'(f6.3)')bmnbeffy
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.83,cbeff)

      call mshplt_set_text_color(0,0,0,1)

      cbeff="BzMax = "
      write(cbeff(7:14),'(f6.3)')bmxbeffz
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.75,cbeff)

      cbeff="BzMin = "
      write(cbeff(7:14),'(f6.3)')bmnbeffz
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.68,cbeff)

      call mshplt_set_text_color(1,0,0,0)
      call mgset('CHHE',0.4)

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  yplmin-dypl*0.1,
     &  yplmax+dypl*0.1,
     &  ' ',' ',' ')

      call mshplt_set_text_angle(0.)

      call mgset('PLCI',2.)
      open(newunit=lun,file="undumag_byeff.dat")

      read(lun,*,end=91)i,xpl(1),ypl(1),bz,i

      do ix=2,nxbeff
        read(lun,*,end=91)i,xpl(2),ypl(2),bz,i
        call mpl(2,xpl,ypl)
        xpl(1)=xpl(2)
        ypl(1)=ypl(2)
      enddo

91    close(lun)

      call mgset('PLCI',4.)
      open(newunit=lun,file="undumag_bzeff.dat")

      read(lun,*,end=92)i,xpl(1),by,ypl(1),i
      do ix=2,nxbeff
        read(lun,*,end=92)i,xpl(2),by,ypl(2),i
        call mpl(2,xpl,ypl)
        xpl(1)=xpl(2)
        ypl(1)=ypl(2)
      enddo

92    close(lun)

      call muwk(0,0)
      call mshplt_end

      return
      end
+DECK,clcmag_inhom.
*CMZ :  2.04/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/00 14/01/2023  14.39.42  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  18.33.07  by  Michael Scheer
*CMZ :  2.02/01 19/01/2022  10.38.36  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_inhom

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision coef
      double precision undumag_variable_getval

      integer imag,inh,l,nwords,ipos(2,10),istat,iend,nc,i1,i2,i3,mc,k,ibr,ixyz

      character(512) cnam,cmoth,cline
      character(32) cbr,cxyz

      do imag=1,nmag_t+nspecmag_t
        cmoth=t_magnets(imag)%cmoth
        cnam=t_magnets(imag)%cnam
        t_magnets(imag)%IsInhom=0
        do inh=1,ninhom_t
          cline=clcinhom(inh)
          call util_string_split(cline,10,nwords,ipos,istat)
          if (nwords.lt.1) cycle
          if (cline(ipos(1,1):ipos(2,1)).eq.cmoth) then
            nmaginhom_t=nmaginhom_t+1
            t_magnets(imag)%IsInhom=inh
            t_magnets(imag)%xyzinh(1)=
     &        undumag_variable_getval(cline(ipos(1,2):ipos(2,2)))
            t_magnets(imag)%xyzinh(2)=
     &        undumag_variable_getval(cline(ipos(1,3):ipos(2,3)))
            t_magnets(imag)%xyzinh(3)=
     &        undumag_variable_getval(cline(ipos(1,4):ipos(2,4)))

            cbr=cline(ipos(1,5):ipos(2,5))
            call util_lower_case(cbr)
            if (cbr(1:3).eq.'nor') then
              t_magnets(imag)%xyzinh(4)=1.0d0
            else
              t_magnets(imag)%xyzinh(4)=0.0d0
            endif
          endif
        enddo
      enddo !nmag_t

      !call util_break
      allocate(maginhom_t(nmaginhom_t))
      nmaginhom_t=0

      do imag=1,nmag_t+nspecmag_t

        cmoth=t_magnets(imag)%cmoth
        cnam=t_magnets(imag)%cnam
        inh=t_magnets(imag)%IsInhom

        if (inh.ne.0) then

          mc=0
          nc=0
          iend=0

          do l=inh+1,ninhom_t
            if (clcinhom(l)(1:5).eq.'! End') then
              iend=l
            endif
          enddo

          if (iend.eq.0) then
            print*,"*** Error in clcmag_inhom: End marker not found for inhomogeneity for magnet: ",
     &        trim(cnam),trim(cmoth)
            stop "*** Aborted ***"
          endif

          nc=iend-inh-1
          t_magnets(imag)%IsInhom=nc

          nmaginhom_t=nmaginhom_t+1
          maginhom_t(nmaginhom_t)=imag

          allocate(t_magnets(imag)%CInhom(nc))

          k=inh
          do l=1,nc
            k=k+1
            t_magnets(imag)%cinhom(l)=clcinhom(k)
          enddo

        endif

      enddo

      return
      end
+DECK,clcmag_mothers.
*CMZ :  2.04/09 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/02 25/02/2023  17.18.44  by  Michael Scheer
*CMZ :  2.04/00 13/01/2023  11.54.35  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  18.33.07  by  Michael Scheer
*CMZ :  2.02/01 19/01/2022  10.38.36  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_mothers

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision, dimension (:), allocatable :: xh,yh,zh
      double precision, dimension (:,:), allocatable :: hull
      double precision :: tol=1.0d-6,gcen(3),x,y,z

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: kface,khull

      integer im,moth,imag,nm,nmag,nhull,npoi,nh,nedge,nface,ifail,
     &  kfacelast,i,l,nhmag

      character(32) cnam,cmoth

      allocate(t_mothers(nmag_t+nspecmag_t))

      tol=hulltiny

      do imag=1,nmag_t+nspecmag_t
        cmoth=t_magnets(imag)%cmoth
        cnam=t_magnets(imag)%cnam
        moth=-1
        do im=1,nmoth_t
          if (t_mothers(im)%cmoth.eq.cmoth) then
            t_mothers(im)%nmagnets=t_mothers(im)%nmagnets+1
            t_mothers(im)%cmoth=cmoth
            moth=im
            exit
          endif
        enddo
        if (moth.eq.-1) then
          nmoth_t=nmoth_t+1
          im=nmoth_t
          t_mothers(im)%nmagnets=t_mothers(im)%nmagnets+1
          t_mothers(im)%cmoth=cmoth
        endif
      enddo !nmag_t

      do im=1,nmoth_t
        nm=t_mothers(im)%nmagnets
        allocate(t_mothers(im)%magnets(nm))
        t_mothers(im)%nhull=0
      enddo

      do imag=1,nmag_t+nspecmag_t
        cmoth=t_magnets(imag)%cmoth
        nmag=0
        nhmag=t_magnets(imag)%nhull
        do moth=1,nmoth_t
          if (t_mothers(moth)%cmoth.eq.cmoth) then
            nmag=nmag+1
            t_mothers(moth)%magnets(nmag)=imag
            t_mothers(moth)%nhull=t_mothers(moth)%nhull+nhmag
            nhull=max(nhull,t_mothers(moth)%nhull)
            exit
          endif
        enddo
      enddo !nmag_t

      allocate(hull(3,nhull))
      allocate(xh(nhull),yh(nhull),zh(nhull))
      allocate(khull(nhull))
      allocate(kedge(4,2*nhull-2),kface((nhull+1)*nhull))

      do moth=1,nmoth_t

        npoi=0
        nmag=t_mothers(moth)%nmagnets

        do imag=1,nmag
          x=t_magnets(imag)%xyz(1)
          y=t_magnets(imag)%xyz(2)
          z=t_magnets(imag)%xyz(3)
          do i=1,t_magnets(imag)%nhull
            npoi=npoi+1
            xh(npoi)=t_magnets(imag)%xhull(i)+x
            yh(npoi)=t_magnets(imag)%yhull(i)+y
            zh(npoi)=t_magnets(imag)%zhull(i)+z
          enddo
        enddo

        call util_convex_hull_3d_overwrite(npoi,xh,yh,zh,khull,kedge,kface,
     &    nh,nedge,nface,kfacelast,tol,ifail)

        if (ifail.ne.0) then
          print*,""
          print*,"*** Error in clcmag_mothers, bad return from util_convex_hull_3d for ",cmoth," ***"
          print*,""
          stop "*** UNDUAMG aborted ***"
        endif

        t_mothers(moth)%nhull=nh
        allocate(
     &    t_mothers(moth)%xhull(nh),
     &    t_mothers(moth)%yhull(nh),
     &    t_mothers(moth)%zhull(nh),
     &    t_mothers(moth)%khull(nh),
     &    t_mothers(moth)%kedge(4,2*nh-2),
     &    t_mothers(moth)%kface(kfacelast)
     &    )

        t_mothers(moth)%kfacelast=kfacelast
        t_mothers(moth)%kface(1:kfacelast)=kface(1:kfacelast)
        t_mothers(moth)%khull(1:nh)=khull(1:nh)
        t_mothers(moth)%kedge(1:4,1:nedge)=kedge(1:4,1:nedge)

        l=0
        gcen=0.0d0
        do i=1,nh
          t_mothers(moth)%xhull(i)=xh(i)
          t_mothers(moth)%yhull(i)=yh(i)
          t_mothers(moth)%zhull(i)=zh(i)
          gcen=gcen+[x,y,z]
        enddo

        gcen=gcen/nh
        t_mothers(moth)%xyz=gcen
        t_mothers(moth)%gcen=gcen

      enddo

      return
      end
+DECK,clcmag_br_inhom.
*CMZ :  2.04/07 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/06 29/03/2023  15.13.19  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/00 13/01/2023  11.36.00  by  Michael Scheer
*CMZ :  2.02/01 29/01/2022  10.13.35  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2021
      subroutine clcmag_br_inhom(imag,ivox,br)

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      integer,save :: ical=0

      type(T_Magnet) tma
      type(T_Voxel) vox

      double precision br(3),bra,xm,ym,zm,tmbr(3),tmbra,dxyz(3),dxyzn,coef,
     &  undumag_variable_getval

      integer imag,ivox,i,ix,iy,iz,k,ipos(2,10),istat,nwords

      character(8) cbr
      character(512) c512

      if (ical.eq.0) then
        call  clcmag_br_inhom_init
        ical=1
      endif

      tma=t_magnets(imag)

      xm=tma%xyzinh(1)
      ym=tma%xyzinh(2)
      zm=tma%xyzinh(3)

      tmbr=tma%Br
      tmbra=norm2(tmbr)

      vox=t_magnets(imag)%t_voxels(ivox)

      dxyz=[vox%xyz(1)-xm,vox%xyz(2)-ym,vox%xyz(3)-zm]
      dxyzn=norm2(dxyz)

      if (tma%IsPole.ne.0.or.tma%IsInhom.eq.0.or.
     &    tmbra.eq.0.0d0.or.dxyzn.eq.0.0d0) then
        br=tmbr
        return
      endif

      br=0.0d0
      do i=1,tma%IsInhom

        c512=tma%cinhom(i)
        call util_string_split(c512,10,nwords,ipos,istat)

        ix=nint(undumag_variable_getval(c512(ipos(1,2):ipos(2,2))))
        iy=nint(undumag_variable_getval(c512(ipos(1,3):ipos(2,3))))
        iz=nint(undumag_variable_getval(c512(ipos(1,4):ipos(2,4))))
        coef=undumag_variable_getval(c512(ipos(1,5):ipos(2,5)))

        !read(c512,*)cbr,ix,iy,iz
        read(c512,*)cbr
        if (cbr.eq.'x') then
          k=1
        else if (cbr.eq.'y') then
          k=2
        else if (cbr.eq.'z') then
          k=3
        endif
        br(k)=br(k)+coef*dxyz(1)**ix*dxyz(2)**iy*dxyz(3)**iz
      enddo

      if (tma%xyzinh(4).ne.0.0d0) then
        bra=norm2(br)
        if (bra.eq.0.0d0) return
        br=br/bra*tmbra
      endif

      return
      end
+DECK,clcmag_voxels_list.
*CMZ :  2.04/01 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/00 24/12/2022  14.05.39  by  Michael Scheer
*CMZ :  2.02/01 31/01/2022  08.57.51  by  Michael Scheer
*CMZ :  2.02/00 31/03/2021  20.30.51  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.27.23  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  16.04.15  by  Michael Scheer
*CMZ :  2.01/04 18/07/2019  13.56.54  by  Michael Scheer
*CMZ :  2.01/03 13/06/2019  15.03.29  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  14.56.07  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.15.25  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  14.30.21  by  Michael Scheer
*CMZ :  2.00/03 23/04/2018  17.47.12  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.39.07  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.09.03  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  16.25.38  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.30.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.59.20  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.35.49  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  19.08.03  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  13.53.24  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  11.50.12  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  18.37.06  by  Michael Scheer
*CMZ :  1.23/02 17/09/2017  11.21.15  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  16.23.00  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  14.53.35  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  08.50.03  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  11.30.39  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.56.28  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  12.48.09  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  13.11.48  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.31.54  by  Michael Scheer
*CMZ :  1.18/03 13/06/2017  15.30.31  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  14.09.42  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  09.19.34  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.04.28  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.55.08  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.22.37  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  12.23.38  by  Michael Scheer
*CMZ :  1.15/11 26/04/2017  11.23.30  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.22.06  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  14.32.29  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.29.10  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.46.33  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.15.21  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  19.50.52  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  11.26.05  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  09.16.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  10.00.53  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.14.36  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  15.40.55  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  16.37.53  by  Michael Scheer
*CMZ :  1.12/00 24/02/2017  08.47.15  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.24.23  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.18.36  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.27.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  10.13.44  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.40  by  Michael Scheer
*CMZ :  1.11/01 06/01/2017  13.46.07  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  15.56.40  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  15.36.58  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.12.02  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.10/00 01/11/2016  09.47.47  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.08.03  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  09.12.28  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  18.54.27  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.39.27  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.51.14  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.43.31  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.17  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.32.16  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.35.03  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.29.44  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.28  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  13.31.19  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.37.12  by  Michael Scheer
*CMZ :  1.02/02 12/09/2016  10.20.23  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.27.52  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  14.10.42  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  17.52.14  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.06.57  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.47  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.13.39  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  15.05.25  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  17.54.03  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  13.38.55  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.51.40  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.27.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.43  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  15.56.38  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.48.03  by  Michael Scheer
*CMZ :  1.17/15 19/04/2016  15.54.31  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  12.32.55  by  Michael Scheer
*CMZ :  1.17/13 08/04/2016  11.47.10  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.29.22  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  12.46.06  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.46.34  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.41.39  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.58.50  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.42.21  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine clcmag_voxels_list(modeaccess)

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure

      implicit none

      double precision facmode
      integer lun,imag,kmag,ivox,modeaccess

      if (modeaccess.eq.0) then
        open(newunit=lun,file='undumag_voxel.lis')
        facmode=0.0d0
      else
        open(newunit=lun,file='undumag_voxel.lis',access='append')
        facmode=1.0d0
      endif

      do ivox=1,nvoxcopy_t
        kmag=t_voxcopy(ivox)%kmagnet
        imag=t_magcopy(kmag)%kproto
        write(lun,*)
     &    t_magnets(imag)%cnam,t_magnets(imag)%cmoth,
     &    t_magnets(imag)%icol,
     &    t_voxcopy(ivox)%kmodule,
     &    t_voxcopy(ivox)%kmagnet,
     &    t_voxcopy(ivox)%kproto,
     &    t_voxcopy(ivox)%kvoxel,
     &    t_voxcopy(ivox)%kcopy,
     &    sngl(t_voxcopy(ivox)%gcen(1)),
     &    sngl(t_voxcopy(ivox)%gcen(2)),
     &    sngl(t_voxcopy(ivox)%gcen(3)),
     &    t_voxcopy(ivox)%br,
     &    bpebc(4:6,ivox)*facmode,
     &    t_voxcopy(ivox)%Ispole
      enddo !ivox

      flush(lun)
      close(lun)

      return
      end
+DECK,clcmag_update_magnet.
*CMZ :  2.04/05 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/02 25/02/2023  17.13.46  by  Michael Scheer
*CMZ :  2.04/01 21/01/2023  11.47.09  by  Michael Scheer
*CMZ :  2.04/00 17/01/2023  09.24.20  by  Michael Scheer
*CMZ :  2.03/00 22/08/2022  12.31.51  by  Michael Scheer
*CMZ :  2.02/01 29/01/2022  15.17.16  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_update_magnet(tmag)

      ! To update magnet if points corners have changed

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

+seq,grarad.

      Type(T_Magnet) tmag

      double precision, dimension (:), allocatable :: x,y,z,xc,yc,zc
      double precision gcen(3)

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface

      integer i,m,npoi,nface,nedge,kfacelast,nhull
      integer ifailhull

      npoi=tmag%nhull

      allocate(
     &  x(npoi),y(npoi),z(npoi),
     &  xc(npoi),yc(npoi),zc(npoi),
     &  kface((npoi+1)*npoi),kedge(4,2*npoi-2),khull(npoi))

      x=tmag%xhull
      y=tmag%yhull
      z=tmag%zhull

      call util_convex_hull_3d_overwrite(npoi,x,y,z,khull,kedge,kface,
     &  nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

      if (ifailhull.ne.0.or.nhull.lt.4) then
        write(lun6,*)"*** Error in clcmag_update_magnet: Subroutine util_convex_hull_3d failed for ",
     &    trim(tmag%cnam)
        stop
      endif

      do i=1,nhull
        m=khull(i)
        xc(i)=x(m)
        yc(i)=y(m)
        zc(i)=z(m)
      enddo

      call util_convex_hull_3d_overwrite(nhull,xc,yc,zc,khull,kedge,kface,
     &  nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

      deallocate(tmag%xhull0,tmag%yhull0,tmag%zhull0,
     &  tmag%xhull,tmag%yhull,tmag%zhull,
     &  tmag%kedge,tmag%kface,tmag%khull)

      allocate(
     &  tmag%xhull0(nhull),tmag%yhull0(nhull),tmag%zhull0(nhull),
     &  tmag%xhull(nhull),tmag%yhull(nhull),tmag%zhull(nhull),
     &  tmag%kface(kfacelast),tmag%kedge(4,nedge),tmag%khull(nhull))

      tmag%nhull=nhull

      gcen=0.0d0
      do i=1,npoi
        m=khull(i)
        tmag%xhull0(i)=xc(m)
        tmag%yhull0(i)=yc(m)
        tmag%zhull0(i)=zc(m)
        gcen=gcen+[xc(m),yc(m),zc(m)]
      enddo

      gcen=gcen/npoi
      tmag%gcen=gcen

      do i=1,npoi
        m=khull(i)
        tmag%xhull(i)=xc(m)-gcen(1)
        tmag%yhull(i)=yc(m)-gcen(2)
        tmag%zhull(i)=zc(m)-gcen(3)
      enddo

      tmag%khull(1:npoi)=khull(1:npoi)

      tmag%kedge(:,1:nedge)=kedge(:,1:nedge)
      tmag%nedge=nedge
      tmag%kedge(:,1:nedge)=kedge(:,1:nedge)
      tmag%nface=nface
      tmag%kfacelast=kfacelast
      tmag%kface(1:kfacelast)=kface(1:kfacelast)

      deallocate(x,y,z,xc,yc,zc,kface,kedge,khull)

      return
      end
+DECK,clcmag_corn_to_vox.
*CMZ :  2.04/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/01 25/01/2023  06.16.23  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  18.19.49  by  Michael Scheer
*CMZ :  2.02/02 15/02/2022  16.00.05  by  Michael Scheer
*CMZ :  2.02/01 23/01/2022  14.52.10  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021

      subroutine clcmag_corn_to_vox(ncorn,corn,tvox,x0,y0,z0)

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision corn(3,2*ncornmax,2*nplanmax),x0,y0,z0
      double precision, dimension (:), allocatable :: xh,yh,zh,xhc,yhc,zhc

      double precision
     &  gcenv(3),xmin,xmax,ymin,ymax,zmin,zmax

      integer i,k,npoi,iplan,icorn,ncorn(nplanmax),
     &  ifailhull,nhull,nedge,nface,kfacelast

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface

      type(T_Voxel) :: tvox

      !call util_break

      npoi=0
      do iplan=1,nplanmax
        do icorn=1,ncorn(iplan)
          npoi=npoi+1
          xh(npoi)=corn(1,icorn,iplan)
          yh(npoi)=corn(2,icorn,iplan)
          zh(npoi)=corn(3,icorn,iplan)
        enddo
      enddo

      call util_convex_hull_3d_overwrite(npoi,
     &  xh,yh,zh,khull,kedge,kface,nhull,nedge,nface,kfacelast,
     &  hulltiny,ifailhull)

      do i=1,nhull
        k=khull(i)
        xhc(i)=xh(k)
        yhc(i)=yh(k)
        zhc(i)=zh(k)
      enddo

      npoi=nhull
      call util_convex_hull_3d_overwrite(npoi,
     &  xhc,yhc,zhc,khull,kedge,kface,nhull,nedge,nface,kfacelast,
     &  hulltiny,ifailhull)

      allocate(tvox%xhull(nhull))
      allocate(tvox%yhull(nhull))
      allocate(tvox%zhull(nhull))
      allocate(tvox%khull(nhull))
      allocate(tvox%kedge(4,nedge))
      allocate(tvox%kface(kfacelast))

      tvox%xyz=gcenv+[x0,y0,z0]
      tvox%gcen=gcenv+[x0,y0,z0]
      tvox%nhull=nhull
      tvox%khull=khull
      tvox%nface=nface
      tvox%kface=kface
      tvox%kfacelast=kfacelast
      tvox%nedge=nedge
      tvox%kedge=kedge

      xmin=1.0d30
      xmax=-1.0d30
      ymin=1.0d30
      ymax=-1.0d30
      zmin=1.0d30
      zmax=-1.0d30

      do i=1,nhull
        k=khull(i)
        tvox%xhull(i)=xhc(k)
        tvox%yhull(i)=yhc(k)
        tvox%zhull(i)=zhc(k)
        if (xhc(k).lt.xmin) xmin=xhc(k)
        if (xhc(k).gt.xmax) xmax=xhc(k)
        if (yhc(k).lt.ymin) ymin=yhc(k)
        if (yhc(k).gt.ymax) ymax=yhc(k)
        if (zhc(k).lt.zmin) zmin=zhc(k)
        if (zhc(k).gt.zmax) zmax=zhc(k)
      enddo

      tvox%size=[xmax-xmin,ymax-ymin,zmax-zmin]

      tvox%xmin=xmin
      tvox%xmax=xmax
      tvox%ymin=ymin
      tvox%ymax=ymax
      tvox%zmin=zmin
      tvox%zmax=zmax

      deallocate(xh,yh,zh,xhc,yhc,zhc,kedge,kface)

      !call util_break
      return
      end
+DECK,clcmag_check_orient.
*CMZ :  2.04/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  13.19.45  by  Michael Scheer
*CMZ :  2.03/00 31/07/2022  18.19.49  by  Michael Scheer
*CMZ :  2.02/02 15/02/2022  16.00.05  by  Michael Scheer
*CMZ :  2.02/01 23/01/2022  14.52.10  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_check_orient(imag)

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision x,y,z,gcen(3),p1(3),p2(3),p3(3),vnormal(3),dist

      integer :: kdebug=1,
     &  l,iplan,n,ivox,imag,nvox,ip,j,iover,istat

      type(T_Magnet) :: tmag
      type(T_Voxel) :: tvox

      if (kdebug.gt.0) call util_break

      tmag=t_magnets(imag)
      gcen=t_magnets(imag)%gcen

      l=0
      ivox=0
      do iplan=1,tmag%nface
        l=l+1
        n=tmag%kface(l)
        do j=1,n
          l=l+1
          ip=tmag%kface(l)
          x=tmag%xhull(ip)
          y=tmag%yhull(ip)
          z=tmag%zhull(ip)
          vnormal=0.0d0
          if (j.eq.1) then
            p1=[x,y,z]
          else if (j.eq.2) then
            p2=[x,y,z]
          else if (j.eq.3) then
            p3=[x,y,z]
            call util_plane(p1,p2,p3,tmag%gcen,vnormal,dist,iover,istat)
          endif
          if (kdebug.ne.0) then
            write(802,*) imag,ivox,iplan,j,l,x,y,z,vnormal
          else
            exit
          endif
        enddo
      enddo

      nvox=t_magnets(imag)%nvoxels

      do ivox=1,nvox
        tvox=t_magnets(imag)%t_voxels(ivox)
        l=0
        do iplan=1,tvox%nface
          l=l+1
          n=tvox%kface(l)
          do j=1,n
            l=l+1
            ip=tvox%kface(l)
            x=tvox%xhull(ip)
            y=tvox%yhull(ip)
            z=tvox%zhull(ip)
            if (j.eq.1) then
              p1=[x,y,z]
            else if (j.eq.2) then
              p2=[x,y,z]
            else if (j.eq.3) then
              p3=[x,y,z]
            endif
            call util_plane(p1,p2,p3,tvox%gcen,vnormal,dist,iover,istat)
            if (kdebug.ne.0) then
              write(802,*) imag,ivox,iplan,j,l,x,y,z,vnormal
            else
              exit
            endif
          enddo
        enddo
      enddo

      return
      end
+DECK,clcmag_hull_to_mag.
*CMZ :  2.04/05 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/02 25/02/2023  17.13.46  by  Michael Scheer
*CMZ :  2.04/01 22/01/2023  13.04.45  by  Michael Scheer
*CMZ :  2.04/00 17/01/2023  09.24.20  by  Michael Scheer
*CMZ :  2.03/00 22/08/2022  12.31.51  by  Michael Scheer
*CMZ :  2.02/01 29/01/2022  15.17.16  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clcmag_hull_to_mag(imag)

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

+seq,grarad.

      double precision, dimension (:), allocatable :: xp,yp,zp,xpc,ypc,zpc
      double precision gcen(3)

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: khull,kface

      integer i,npoi,nhull,nface,nedge,kfacelast,ifailhull,imag
      integer :: iallo=0

      save iallo

      ! To make indices of hull and faces consistent
      ! The hull must already be calculated!

      if (iallo.eq.0) then
        allocate(
     &    xp(ncornmax_t),yp(ncornmax_t),zp(ncornmax_t),
     &    xpc(ncornmax_t),ypc(ncornmax_t),zpc(ncornmax_t),
     &    kface((ncornmax_t+1)*ncornmax_t),kedge(4,2*ncornmax_t-2),khull(ncornmax_t))
        iallo=1
      endif

      do i=1,nhull
        xp(i)=t_magnets(imag)%xhull(i)
        yp(i)=t_magnets(imag)%yhull(i)
        zp(i)=t_magnets(imag)%zhull(i)
      enddo

      call util_convex_hull_3d_overwrite(npoi,xp,yp,zp,khull,kedge,kface,
     &  nhull,nedge,nface,kfacelast,hulltiny,ifailhull)

      if (ifailhull.ne.0.or.nhull.lt.4) then
        write(lun6,*)"*** Error in clcmag_hull_to_mag: Subroutine util_convex_hull_3d failed for ",
     &    trim(t_magnets(imag)%cnam)
        stop
      endif

      t_magnets(imag)%nhull=nhull
      t_magnets(imag)%khull(1:npoi)=khull(1:npoi)

      gcen=0.0d0
      do i=1,npoi
        t_magnets(imag)%xhull(i)=xp(i)
        t_magnets(imag)%yhull(i)=yp(i)
        t_magnets(imag)%zhull(i)=zp(i)
        gcen=gcen+[xp(i),yp(i),zp(i)]
      enddo

      gcen=gcen/npoi
      t_magnets(imag)%gcen=gcen

      t_magnets(imag)%kedge(:,1:nedge)=kedge(:,1:nedge)
      t_magnets(imag)%nedge=nedge
      t_magnets(imag)%kedge(:,1:nedge)=kedge(:,1:nedge)
      t_magnets(imag)%nface=nface
      t_magnets(imag)%kfacelast=kfacelast
      t_magnets(imag)%kface(1:kfacelast)=kface(1:kfacelast)

      return
      end
+DECK,clcmag_voxel_volume.
*CMZ :  2.04/10 23/08/2023  08.09.00  by  Michael Scheer
*CMZ :  2.04/07 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  19.29.01  by  Michael Scheer
*CMZ :  2.04/02 26/02/2023  21.47.15  by  Michael Scheer
*CMZ :  2.04/00 09/12/2022  11.08.58  by  Michael Scheer
*CMZ :  2.02/01 29/01/2022  10.13.35  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2021

      subroutine clcmag_voxel_volume(imag,ivox)

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      type(T_Voxel) tvox

      double precision vol
      integer imag,ivox,kfail
+self,if=debvoxvol.
      integer ix,iy,iz
+self.
      character(32) ctype

      ctype=t_magnets(imag)%ctype

      tvox=t_magnets(imag)%t_voxels(ivox)

      if (tvox%isblock.eq.0.or.t_magnets(imag)%IsRotated.ne.0) then
        call util_volume(tvox%nhull,tvox%xhull,tvox%yhull,tvox%zhull,hulltiny,vol,kfail)
      else
        vol=t_magnets(imag)%volume/t_magnets(imag)%nvoxels
      endif

      t_magnets(imag)%t_voxels(ivox)%volume=vol

+self,if=debvoxvol.
      ix=tvox%ixdiv
      iy=tvox%iydiv
      iz=tvox%izdiv
      if (vol.ne.t_magnets(imag)%t_xyzcuts(ix,iy,iz)%volume) then
        print*,ix,iy,iz,vol,t_magnets(imag)%t_xyzcuts(ix,iy,iz)%volume
        stop
      endif
+self.
      if (kfail.ne.0) then
        write(lun6,*)"*** Error in clcbuff_to_magnets: Subroutine util_volume failed for ",
     &    trim(t_magnets(nmag)%cnam)
        stop
        endif

      return
      end
+DECK,clcbuff_reallocate.
*CMZ :  2.04/05 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  14.34.23  by  Michael Scheer
*-- Author :    Michael Scheer   05/03/2023
      subroutine clcbuff_reallocate

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none

      deallocate(
     &  xpuffer1,ypuffer1,zpuffer1,
     &  xpuffer2,ypuffer2,zpuffer2,
     &  xpuffer3,ypuffer3,zpuffer3)

      allocate(
     &  xpuffer1(ncornmax),ypuffer1(ncornmax),zpuffer1(ncornmax),
     &  xpuffer2(ncornmax),ypuffer2(ncornmax),zpuffer2(ncornmax),
     &  xpuffer3(ncornmax),ypuffer3(ncornmax),zpuffer3(ncornmax))

      return
      end
+DECK,clcmag_br_inhom_init.
*CMZ :  2.04/10 23/08/2023  13.17.43  by  Michael Scheer
*CMZ :  2.04/07 09/08/2023  12.57.46  by  Michael Scheer
*CMZ :  2.04/06 29/03/2023  15.13.19  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/00 13/01/2023  11.36.00  by  Michael Scheer
*CMZ :  2.02/01 29/01/2022  10.13.35  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2021
      subroutine clcmag_br_inhom_init

      use magnets_structure

      implicit none

      double precision undumag_variable_getval,coef

      integer imag,i,ix,iy,iz,ipos(2,10),istat,nwords

      character(512) c512

      do imag=1,nmag_t+nspecmag_t

        do i=1,t_magnets(imag)%IsInhom

          c512=t_magnets(imag)%cinhom(i)
          call util_string_split(c512,10,nwords,ipos,istat)

          ix=nint(undumag_variable_getval(c512(ipos(1,2):ipos(2,2))))
          iy=nint(undumag_variable_getval(c512(ipos(1,3):ipos(2,3))))
          iz=nint(undumag_variable_getval(c512(ipos(1,4):ipos(2,4))))
          coef=undumag_variable_getval(c512(ipos(1,5):ipos(2,5)))

          write(t_magnets(imag)%cinhom(i),*) c512(ipos(1,1):ipos(2,1))," ",
     &      ix,iy,iz,coef

        enddo
      enddo !imag=1,nmag_t+nspecmag_t

      return
      end
+DECK,transrotcopcyl.
*CMZ :  2.04/10 23/08/2023  08.07.21  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.49.50  by  Michael Scheer
*CMZ :  2.04/07 09/08/2023  09.15.04  by  Michael Scheer
*CMZ :  2.04/06 01/08/2023  15.05.17  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  20.06.46  by  Michael Scheer
*CMZ :  2.04/01 20/01/2023  08.02.02  by  Michael Scheer
*CMZ :  2.04/00 16/01/2023  15.35.00  by  Michael Scheer
*CMZ :  2.02/01 26/01/2022  11.22.41  by  Michael Scheer
*-- Author :    Michael Scheer   29/12/2021
      subroutine transrotcopcyl

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      use displacement

      implicit none
+seq,grarad.

      type(T_magnet) tmag
      double precision rm(3,3),t8(8),r(3)
      integer imag,itr,ipoi,istat,ifound,iold,iv

+self,if=trace.
      print*,"-trace-: Entered transrotcopcyl "
+self.

      if(nmagcyl.eq.0) return

      iold=0
      do itr=1,ntransrotcop
        ifound=0
        do imag=1,nmagtot_t
          tmag=t_magnets(imag)
          t8=transrotcop(:,itr)
          if(
     &        tmag%cmoth.eq.ctransrotcop(itr).or.
     &        tmag%cnam.eq.ctransrotcop(itr)
     &        ) then
            ifound=itr
            if (tmag%ctype.ne.'Cylinder') then
              ifound=-itr
              cycle
            endif
            if (t8(8).eq.0.0d0) then
              t_magnets(imag)%xmin=t_magnets(imag)%xmin+t8(1)
              t_magnets(imag)%xmax=t_magnets(imag)%xmax+t8(1)
              t_magnets(imag)%ymin=t_magnets(imag)%ymin+t8(2)
              t_magnets(imag)%ymax=t_magnets(imag)%ymax+t8(2)
              t_magnets(imag)%zmin=t_magnets(imag)%zmin+t8(3)
              t_magnets(imag)%zmax=t_magnets(imag)%zmax+t8(3)
              t_magnets(imag)%xyz=t_magnets(imag)%xyz+t8(1:3)
              t_magnets(imag)%gcen=t_magnets(imag)%gcen+t8(1:3)
              do ipoi=1,tmag%nhull
                t_magnets(imag)%xhull(ipoi)=t_magnets(imag)%xhull(ipoi)+t8(1)
                t_magnets(imag)%yhull(ipoi)=t_magnets(imag)%yhull(ipoi)+t8(2)
                t_magnets(imag)%zhull(ipoi)=t_magnets(imag)%zhull(ipoi)+t8(3)
              enddo
              do iv=1,t_magnets(imag)%nvoxels
c                t_magnets(imag)%t_voxels(iv)%xmin=t_magnets(imag)%t_voxels(iv)%xmin+t8(1)
c                t_magnets(imag)%t_voxels(iv)%xmax=t_magnets(imag)%t_voxels(iv)%xmax+t8(1)
c                t_magnets(imag)%t_voxels(iv)%ymin=t_magnets(imag)%t_voxels(iv)%ymin+t8(2)
c                t_magnets(imag)%t_voxels(iv)%ymax=t_magnets(imag)%t_voxels(iv)%ymax+t8(2)
c                t_magnets(imag)%t_voxels(iv)%zmin=t_magnets(imag)%t_voxels(iv)%zmin+t8(3)
c                t_magnets(imag)%t_voxels(iv)%zmax=t_magnets(imag)%t_voxels(iv)%zmax+t8(3)
c                t_magnets(imag)%t_voxels(iv)%xyz=t_magnets(imag)%t_voxels(iv)%xyz+t8(1:3)
c                t_magnets(imag)%t_voxels(iv)%gcen=t_magnets(imag)%t_voxels(iv)%gcen+t8(1:3)
                do ipoi=1,t_magnets(imag)%t_voxels(iv)%nhull
                  t_magnets(imag)%t_voxels(iv)%xhull(ipoi)=t_magnets(imag)%t_voxels(iv)%xhull(ipoi)+t8(1)
                  t_magnets(imag)%t_voxels(iv)%yhull(ipoi)=t_magnets(imag)%t_voxels(iv)%yhull(ipoi)+t8(2)
                  t_magnets(imag)%t_voxels(iv)%zhull(ipoi)=t_magnets(imag)%t_voxels(iv)%zhull(ipoi)+t8(3)
                enddo
              enddo
            else if (t8(8).eq.3.0d0) then
              if (tmag%IsPole.ne.0) then
                write(lun6,*)"*** Warning in clctransrotcop: Setting remanence not allowed for iron ***"
                write(lun6,*)"*** Pole:",tmag%cnam
                cycle
              endif
              t_magnets(imag)%Brn=t8(1)
              t_magnets(imag)%Br=0.0d0
              if(norm2(t8(2:4)).ne.0.0d0)
     &          t_magnets(imag)%Br=t8(1)*t8(2:4)/norm2(t8(2:4))
              t_magnets(imag)%imat=int(t8(5))
              t_magnets(imag)%icol=int(t8(6))
            else if (t8(8).eq.1.0d0.or.t8(8).eq.2.0d0) then
              if (t8(8).eq.2.0d0) t_magnets(imag)%IsRotated=1
              call util_rotmat(t8(4:6),t8(7)*grarad1,rm,istat)
              if (t8(8).eq.2) then
                call util_mat_mul_vec_3x3(rm,tmag%br,t_magnets(imag)%br)
              endif
              r=tmag%xyz-t8(1:3)
              call util_mat_mul_vec_3x3(rm,r,r)
              t_magnets(imag)%xyz=r+t8(1:3)
              r=tmag%gcen-t8(1:3)
              call util_mat_mul_vec_3x3(rm,r,r)
              t_magnets(imag)%gcen=r+t8(1:3)
              !xmin=1.0d30
              !xmax=-1.0d30
              !ymin=1.0d30
              !ymax=-1.0d30
              !zmin=1.0d30
              !zmax=-1.0d30
              do ipoi=1,tmag%nhull
                r=[tmag%xhull(ipoi)-t8(1),tmag%yhull(ipoi)-t8(2),tmag%zhull(ipoi)-t8(3)]
                call util_mat_mul_vec_3x3(rm,r,r)
                t_magnets(imag)%xhull(ipoi)=r(1)+t8(1)
                t_magnets(imag)%yhull(ipoi)=r(2)+t8(2)
                t_magnets(imag)%zhull(ipoi)=r(3)+t8(3)
                !if (r(1)+t8(1).lt.xmin) xmin=r(1)+t8(1)
                !if (r(1)+t8(1).gt.xmax) xmax=r(1)+t8(1)
                !if (r(2)+t8(2).lt.ymin) ymin=r(2)+t8(2)
                !if (r(2)+t8(2).gt.ymax) ymax=r(2)+t8(2)
                !if (r(3)+t8(3).lt.zmin) zmin=r(3)+t8(3)
                !if (r(3)+t8(3).gt.zmax) zmax=r(3)+t8(3)
              enddo
              do iv=1,t_magnets(imag)%nvoxels
                if (t8(8).eq.2) then
                  call util_mat_mul_vec_3x3(rm,tmag%br,t_magnets(imag)%t_voxels(iv)%br)
                endif
                r=t_magnets(imag)%t_voxels(iv)%xyz-t8(1:3)
                call util_mat_mul_vec_3x3(rm,r,r)
                t_magnets(imag)%t_voxels(iv)%xyz=r+t8(1:3)
                r=t_magnets(imag)%t_voxels(iv)%gcen-t8(1:3)
                call util_mat_mul_vec_3x3(rm,r,r)
                t_magnets(imag)%t_voxels(iv)%gcen=r+t8(1:3)
                !xmin=1.0d30
                !xmax=-1.0d30
                !ymin=1.0d30
                !ymax=-1.0d30
                !zmin=1.0d30
                !zmax=-1.0d30
                do ipoi=1,t_magnets(imag)%t_voxels(iv)%nhull
                  r=[t_magnets(imag)%t_voxels(iv)%xhull(ipoi)-t8(1),
     &              t_magnets(imag)%t_voxels(iv)%yhull(ipoi)-t8(2),
     &              t_magnets(imag)%t_voxels(iv)%zhull(ipoi)-t8(3)]
                  call util_mat_mul_vec_3x3(rm,r,r)
                  t_magnets(imag)%t_voxels(iv)%xhull(ipoi)=r(1)+t8(1)
                  t_magnets(imag)%t_voxels(iv)%yhull(ipoi)=r(2)+t8(2)
                  t_magnets(imag)%t_voxels(iv)%zhull(ipoi)=r(3)+t8(3)
                  !if (r(1)+t8(1).lt.xmin) xmin=r(1)+t8(1)
                  !if (r(1)+t8(1).gt.xmax) xmax=r(1)+t8(1)
                  !if (r(2)+t8(2).lt.ymin) ymin=r(2)+t8(2)
                  !if (r(2)+t8(2).gt.ymax) ymax=r(2)+t8(2)
                  !if (r(3)+t8(3).lt.zmin) zmin=r(3)+t8(3)
                  !if (r(3)+t8(3).gt.zmax) zmax=r(3)+t8(3)
                enddo
              enddo
            else if (t8(8).lt.0.0d0) then
              call clcmag_copy(-int(t8(8)))
            else
              ifound=0
            endif
          endif
        enddo !imag

        if (ifound.eq.0) then
          write(lun6,*)"*** Warning in transrotcopcyl: No magnet found or undefined action ***"
          write(lun6,*)"Action, Magnet:",itr,ctransrotcop(itr)
          write(lun6,*)
          iold=itr
        endif
      enddo !ntransrotcop

+self,if=trace.
      print*,"-trace-: Leaving transrotcopcyl "
+self.

      return
      end
+PATCH,KUMAC,T=KUMAC.
*CMZ :  0.00/00 20/04/2016  13.01.38  by  Michael Scheer
+DECK,uout,T=KUMAC.
*CMZ :  2.04/10 21/08/2023  16.20.42  by  Michael Scheer
*CMZ :  2.02/00 20/03/2021  11.24.41  by  Michael Scheer
*CMZ :  2.01/08 08/08/2020  10.38.47  by  Michael Scheer
*CMZ :  1.15/00 22/03/2017  13.30.00  by  Michael Scheer
*CMZ :  1.10/00 09/11/2016  13.40.00  by  Michael Scheer
*CMZ :  1.02/01 08/09/2016  09.43.15  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  12.55.38  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.37.19  by  Michael Scheer
*CMZ :  1.17/06 31/03/2016  15.45.38  by  Michael Scheer
*CMZ :  1.17/02 08/03/2016  14.57.46  by  Michael Scheer
*CMZ :  1.17/01 03/10/2014  10.49.36  by  Michael Scheer
*CMZ :  1.17/00 25/08/2014  15.26.02  by  Michael Scheer
*CMZ :  1.16/04 17/04/2014  12.22.05  by  Michael Scheer
*CMZ :  1.16/01 14/03/2014  10.19.54  by  Michael Scheer
*CMZ :  1.15/02 30/04/2008  13.28.31  by  Michael Scheer
*CMZ :  1.15/01 24/04/2008  11.30.03  by  Michael Scheer
*CMZ :  1.12/16 04/06/2007  06.18.51  by  Michael Scheer
*CMZ :  1.12/15 21/05/2007  15.22.52  by  Michael Scheer
*CMZ :  1.12/05 02/07/2006  12.51.11  by  Michael Scheer
*-- Author :    Michael Scheer   02/07/2006
macro uout

* +PATCH,//POLYMAG/KUMAC
* +DECK,uout,T=KUMAC.

*wait '*** uout is obsolete, switching to uout_omp ***' 2

exec uout_incl
exitm

exec uout_omp
exitm

sel -omp

she rm -f $UNDUMAG/bin/undumag_main.exe 2>/dev/null

exec dfor

set $UNDUMAG/for/uradfield.f -f
cx //undumag/urad/undumag_uradfield
set $UNDUMAG/for/uradbmap.f -f
cx //undumag/urad/undumag_uradbmap
set $UNDUMAG/for/uradrndm.f -f
cx //undumag/urad/undumag_uradrndm

set $UNDUMAG/for/undumag_main.f -f
cx /main/undumag_main /for //wave/urad/urad //wave/urad/uradstep //wave/urad/uradestep //wave/urad/uradphoton

exec dfor
exitm
+DECK,dnamgh,T=KUMAC.
*CMZ :  2.04/10 23/08/2023  16.13.17  by  Michael Scheer
*-- Author :    Michael Scheer   22/08/2023
exec dnam
set $UNDUMAG_GITHUB/input/nam/*.nam -f
set
+DECK,dmod,T=KUMAC.
*CMZ :  2.04/10 23/08/2023  08.10.42  by  Michael Scheer
*-- Author :    Michael Scheer   22/08/2023
exec dgfor
set $UNDUMAG_INCL/for/mod/*.f -f
set $UNDUMAG_INCL/libundu_modules -l
cd /modules
+DECK,dmodgh,T=KUMAC.
*CMZ :  2.04/10 23/08/2023  16.10.27  by  Michael Scheer
*-- Author :    Michael Scheer   22/08/2023
exec dforgh
set $UNDUMAG_GITHUB/for/mod/*.f -f
set $UNDUMAG_GITHUB/libundu_modules -l
cd /modules
+PATCH,SYSTEM,T=KUMAC.
*CMZ :  0.00/00 20/04/2016  13.01.46  by  Michael Scheer
+DECK,dutilgh,T=KUMAC.
*CMZ :  2.04/10 18/08/2023  19.25.33  by  Michael Scheer
*CMZ :  2.04/09 15/08/2023  12.09.09  by  Michael Scheer
*CMZ :  1.11/05 15/02/2017  08.54.57  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  10.24.32  by  Michael Scheer
*CMZ :  1.09/01 05/10/2016  09.35.38  by  Michael Scheer
*CMZ :  1.17/00 25/08/2014  14.26.53  by  Michael Scheer
*CMZ :  1.15/02 30/04/2008  13.25.06  by  Michael Scheer
*-- Author :    Michael Scheer   30/04/2008
macro dutil

* +PATCH,//POLYMAG/SYSTEM
* +DECK,dutilgh,T=KUMAC.

exec dgford
cd /util

set $UNDUMAG_GITHUB/util/*.f -f

exec lastdir util

lmodl

she echo && echo UNDUMAG_GITHUB: $UNDUMAG_GITHUB

exitm
+PATCH,INPUT,T=TEXT.
*CMZ :  0.00/00 20/04/2016  13.01.52  by  Michael Scheer
+DECK,cylinder_neu,T=TEXT.
*CMZ :  2.04/10 18/08/2023  21.31.43  by  Michael Scheer
*CMZ :  2.02/01 19/01/2022  20.19.13  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  09.52.44  by  Michael Scheer
*CMZ :  1.11/04 23/01/2017  14.16.04  by  Michael Scheer
*-- Author :    Michael Scheer   23/01/2017

* +PATCH,//UNDUMAG/INPUT
* +DECK,cylinder_neu,T=TEXT.

$Mcoating=0.1
$PerLen=100. !Dummy

& User_Comment (one line)
Cylinder

& Magnet
Cylinder cyl Cyl 2 ! key, name, mother, color
50. 30. 0. ! x y z
1.62 0.0 1.0 0.0 1 ! M Mx My Mz, material index
10. 20. 50. 90. 2 3 5 !inner radius, outer radius, height, angle
2 3 5 1. 1. ! divisions in radius, angle and height

************
& Module
 0. 0. 0. 1 1 !offset of module, number and number of associated module
****
 1 !number of arrays within module
 17. 1. 0. 0. 0. !spacing and direction of arrangement, rotation angle
 1. 1. 1. !scaling and symmetry of magnetization vector
************

& Materials
************
1 ! number of materials
1 1 1 undumag_mu_unity.dat
1 1 1 undumag_mu_77K.dat
2 2 0 iron_muinf_sat-2.34.dat
2 2 2 Vanadium_Permendur_Radia.dat
************
+PATCH,NAM,T=TEXT.
*CMZ :  0.00/00 20/04/2016  13.01.58  by  Michael Scheer
+DECK,undumag,T=TEXT.
*CMZ :  2.04/10 21/08/2023  16.26.25  by  Michael Scheer
*CMZ :  2.04/09 16/08/2023  11.08.45  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  15.04.20  by  Michael Scheer
*CMZ :  2.04/00 08/09/2022  16.06.28  by  Michael Scheer
*CMZ :  2.03/00 14/08/2022  12.46.46  by  Michael Scheer
*CMZ :  2.02/02 01/07/2022  18.04.41  by  Michael Scheer
*CMZ :  2.02/01 10/02/2022  11.42.19  by  Michael Scheer
*CMZ :  2.02/00 18/09/2020  17.00.52  by  Michael Scheer
*CMZ :  2.01/08 14/08/2020  09.08.09  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  15.56.43  by  Michael Scheer
*CMZ :  2.01/04 18/07/2019  11.10.22  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.27.19  by  Michael Scheer
*CMZ :  2.00/01 12/04/2018  16.29.19  by  Michael Scheer
*CMZ :  1.25/00 31/01/2018  17.15.36  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  09.22.13  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.33.31  by  Michael Scheer
*CMZ :  1.23/03 21/09/2017  14.53.30  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  13.37.21  by  Michael Scheer
*CMZ :  1.22/02 24/07/2017  15.38.16  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  12.24.35  by  Michael Scheer
*CMZ :  1.22/00 04/07/2017  09.44.57  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  14.24.01  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.58.32  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.20.19  by  Michael Scheer
*CMZ :  1.18/02 09/06/2017  13.19.02  by  Michael Scheer
*CMZ :  1.17/07 22/05/2017  12.01.34  by  Michael Scheer
*CMZ :  1.17/06 19/05/2017  20.24.02  by  Michael Scheer
*CMZ :  1.17/05 18/05/2017  10.19.46  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  13.27.26  by  Michael Scheer
*CMZ :  1.15/11 23/04/2017  10.34.16  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.21.42  by  Michael Scheer
*CMZ :  1.15/07 05/04/2017  09.32.44  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.30.52  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  11.20.35  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.32.08  by  Michael Scheer
*CMZ :  1.15/00 24/03/2017  09.41.27  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  12.53.22  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  16.40.41  by  Michael Scheer
*CMZ :  1.13/01 06/03/2017  10.12.59  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  16.58.19  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  16.06.24  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.47.37  by  Michael Scheer
*CMZ :  1.11/03 13/01/2017  12.25.40  by  Michael Scheer
*CMZ :  1.11/01 09/01/2017  11.31.03  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  15.47.32  by  Michael Scheer
*CMZ :  1.10/00 01/11/2016  09.40.28  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  13.35.33  by  Michael Scheer
*CMZ :  1.08/00 27/09/2016  20.15.56  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.48.49  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.50.46  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.26.30  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  14.08.40  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  14.46.19  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.13  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  13.34.11  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  15.28.35  by  Michael Scheer
*CMZ :  1.02/00 22/08/2016  17.09.12  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  11.39.57  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  17.54.08  by  Michael Scheer
*CMZ :  0.00/13 09/08/2016  17.01.43  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  08.31.14  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  15.12.04  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  15.00.16  by  Michael Scheer
*CMZ :  0.00/09 27/06/2016  10.04.07  by  Michael Scheer
*CMZ :  0.00/04 10/05/2016  09.09.12  by  Michael Scheer
*CMZ :  0.00/02 26/04/2016  16.10.51  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.51.24  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.10.05  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2016
+seq,inputver.
 ! Name list file, to control UNDUMAG

 $undumagn

 nuthreads=-1 ! >0:   Number of CPU cores to be used
              ! else: Use all cores

 kechocalc=0 ! echo read lines of undumag.clc and undumag.in

 kpreset=0 ! Initial magnetization is read from undumag.pre

 matrix=1  ! Matrix mode: Fast, but can require much memory
           ! >0: Matrix is calculated
	   ! >1: Matrix is written to file undumag_matrix.pst	
	   ! <0: Matrix is read from file undumag_matrix.pre
	
 ixsym=0 ! Mirror all magnets and poles in y-z plane at xsym
 xsym=0. ! 9999: xsym is xcenter

 iysym=0 ! Mirror all magnets and poles in x-z plane at origin
 izsym=0 ! Mirror all magnets and poles in x-y plane at origin

 kxcenter=1   ! Center magnetic structure
 xcenter=0.   ! Magnetic structure is centered around xcenter

 maxiter=1000 ! Maximum number of iterations of main loop
 kprint=10    ! Test convergence and print progress every kprintth cycle
              ! Must be > 0 for option kresiron

 maxiterrec=5 ! Maximum number of iterations for magnets for each
                ! cycle of the main loop
 maxiteriron=100 ! Dito for iron poles
                ! -9999: (1-dampiron)**(2*maxiteriron-1) = 0.001
		
 nchiiron=100   ! number of iterations on magnetization curve M(H) for iron
 chicut=1.0e-8  ! Precision cut of Chi(H), -9999.: chicut = max(hconv,1.e-10)

 dampiron=1.0   ! Damping factor for the relaxation of iron
                ! 1: No damping
	        ! >0: Damping
	        ! 0 or missing: No damping

 kbextern=0     ! superimpose external field (bxex,byex,bzex)
 bxex=0.0       ! No symmetry operations are performed for this field
 byex=0.0
 bzex=0.0

 isplinefm=0    ! spline M(H) table, linear interpolation otherwize

 ibulk=0     ! bulk update of iron voxel

 kdumpconv=0 ! dump progress of relaxation for iron

 ! if dampfac.ne.0:
 hconvbase=1.0d0 ! hconv -> hconvbase*dampiron**hconvexp
                 ! and dampiron -> dampiron*dampfac
 hconvexp=0.0d0  ! This is applied when the current hconv is reached
 dampfac=0.0d0   !

 kresiron=1   ! RMS of iron residuals used as convergence critirion
              ! 1: UNDUMAG stops if resiron is reached
              ! 2: UNDUMAG stops if resiron and hconv are reached
	
 resiron=3.0d-3 ! convergence critirion according to kresiron, CHECK kprint

 hconv=1.0d-6 ! Convergence criterion,
              ! i.e. the rel. change of B at the reference point
	      ! hconv<0: Stop if deviation has reached a minimum
	      ! hconv<-1000: Stop if deviation, when sign of deviation has
	      ! changed (s.a. kresiron)

 xconvmin=9999. ! reference points, where convergence is tested
                ! is randomized according to randox
		! 9999: automatic
	
 xconvmax=9999. ! reference points, where convergence is tested
                ! is randomized according to randox
	        ! 9999: automatic
		
 dxconv=-0.9  ! spacing of reference points
              ! 9999: perlen/2.
	      ! <0: abs(dxconv) is factor of intervall size, i.e.
              ! exponential spacing between xconvmin and xconvmax,
              ! nxconv must be greater 0
	
 nxconv=9999  ! number of reference points (must be < 100 ),
              ! if dxconv is zero
	      ! 9999: twice the number of periods between xconvmax and xconvmin

 yconv=0.0
 zconv=0.0    ! is randomized according to randoz if zero

 killbadmag=0 ! To ignore problematic voxel listet in undumag.kll
              ! undumag.bad is written for killbadmag<0 according to
	      ! warnings of UNDUMAG
	      ! killbadmag=-9999: Kill all but the bad voxel
	
 iwarn2pi=1   ! Warning and attempt to recover of 2 Pi jump in undumag_bpeq

 rcvthron=0.1 ! allowed rel. deviation of the on-axis field from
               ! neighbouring values before recovering starts

 irecrepl=0   ! replace rectangular polyhedrons by blocks
	
+self,if=randos.
 randos=0.01  ! add noise to voxel positons to avoid boundary effects
+self.
 randox=0.001   ! add noise to x for field calculations to avoid boundary effects
              ! <0: means offset, no randomization
 randoy=0.0   ! add noise to y for field calculations to avoid boundary effects
              ! <0: means offset, no randomization
 randoz=0.001  ! add noise to z for field calculations to avoid boundary effects
              ! <0: means offset, no randomization

 irandmag=0   ! randomize calculation point inside voxel as well
              ! <0: Real deposition of the voxel center
	
 kshuffle=0   ! shuffle the iron voxel for each main iteration cycle

 corrtiny=0.123e-3 ! x,y,z-shift for corrections of boundary errors [mm]

 cuttiny=0.1   ! minimum size of cut volume relative to volume to be cut
               ! 0: will be set to 0.1
	       ! (only for new input format of undumag.clc)
	
 hulltiny=1.e-6 ! precision parameter for routine util_convex_hull_3d
                ! change may help in case of trouble
		! 0: will be set to 1.e-6

 iunduplot=1 ! Write Encapsulated PostScript files to show geometry
	     ! iunduplot<0: stop UNDUMAG after writing undumag.eps

 iundugeo=1  ! Write geometry file
	     ! iundugeo<0: stop UNDUMAG after writing undumag.geo

 ivrml=1     ! Write CAD file of setup
             ! 1: Display items
             ! 2: Display items with segmentation
	     ! ivrml<0: stop UNDUMAG after writing undumag.wrl	
	
 kplsym=1    ! Plot symmetric items for ixsym, iysym, or izsym
 kcomment=1  ! Print comment of input file undumag.clc to plots
 krunnum=1  ! Print run number to plots
 kdate=1  ! Print date to plots

 unduplot_mode=0   ! Plotting mode
                   !0: Overview
		   !else: Only 3d view according to unduplot_theta/phi
 unduplot_theta=0. ! Polar plotting angle
 unduplot_phi=0.   ! Azimut plotting angle

 ! Plotting window for set-up plots
 xminpl=9999.      !9999.: Automatically
 xmaxpl=9999.      !9999.: Automatically
 yminpl=9999.      !9999.: Automatically
 ymaxpl=9999.      !9999.: Automatically
 zminpl=9999.      !9999.: Automatically
 zmaxpl=9999.      !9999.: Automatically

 uwindow=1000. ! Only items with x-uwindow <= x <= x-uwindow contribute
               ! to field at x

 kmapmode=0    ! Format of field map
               ! 0: Field map includes material properties, magnetization etc.
	       ! else: Only x y z Bx By Bz iFail are given

 kmapnohead=0  ! No header line of map file

 knointmap=1   ! no map of field integrals
 	
 knomagmap=0   ! No field map inside magnets
 knopolmap=0   ! No field map inside poles

 intmaglis=0   ! Read magnets, that contribute to map from file undumag_magmap.lis
               ! otherwize take all
	
 iforcegrid=1  ! write x,y,z of grid nodes to map, not the noisy
               ! real position of calculation

 xmapmin=9999. ! xmin for field map
                ! 9999.: Auto scaling
		! 9000.: -PerLen / 2
		! -9000.: -PerLen / 4
 xmapmax=9999. ! xmax for field map
                ! 9999.: Auto scaling
		! 9000.: PerLen / 2
		! -9000.: +PerLen / 4
	
 dxmap=1.      ! Step size of field map in x
               ! 9999.: Same as for Beff calculations, i.e. perlen/(nxbeff-1)
	
 nxmap=1       ! Number of steps in x, if dxmap is zero

 ymapmin=-1.0  ! ymin for field map
 ymapmax=1.0   ! ymax for field map
 nymap=1       ! Number of steps for field map in y.
               ! nymap=1 means y=(ymapmax+ymapmin)/2 is used

 zmapmin=-20.0 ! zmin for field map
 zmapmax=20.0  ! zmax for field map
 nzmap=1       ! Number of steps for field map in z
               ! nzmap=1 means z=(zmapmax+zmapmin)/2 is used

 angmaprotx=0.0d0  ! rotation angle of map around x-axis
 cenmaprotxy=0.0d0 ! y of center of rotation for angmaprotx
 cenmaprotxz=0.0d0 ! z of center of rotation for angmaprotx

 isimpson=0  ! Spline (0) or Simpson (1) integration for magnetic field
             ! and force integrals
	     ! See subroutine util_spline_or_simpson_integral

 xbeff=-9999. ! Center for Beff calculations
              ! 9999: xcenter
              !-9999: (xmapmin+xmapmax)/2.
	      ! This value is adjusted by UNDUMAG within half a period
              ! around the original value
	
 xbeffy=-9999.0d0 ! if not -9999. xbeff for ByEff is forced to xbeffy
 xbeffz=-9999.0d0 ! if not -9999. xbeff for BzEff is forced to xbeffz

 perlen=9999.   ! Period-length for the calculation of the Beff
              ! 9999: Read it from undumag.clc
	
 nxbeff=101   ! Number of points for the calculation of Beff

 kbeffmode=9999  ! 0: Take full period for calculation
                 ! else: Take half period,
		 !       omit Abs(kbeffmode)*dx around Abs(perlen/4.),
		 !       check undumag_beff.dat!
		 !9999: automatic, i.e. if nperiods>0 is found in undumag.clc
		 !      kbeffmode is set zero, else one.
	
 iforce=0     ! Calculation of forces and torques
              ! iforce<0: Parameters for force calculations are taken
	      ! from undumag.clc
	      ! iforce=9999: The force box is calculated for chforcemag,
	      ! used for iforcedip
	
 iplforce=0   ! Write fields of force box to file undumag_force.fbx

 ubfcenx=0.0   ! center of box for forces and torques
 ubfceny=0.0
 ubfcenz=0.0

 ubflenx=100.0   ! dimensions of box for forces and torques,
                 ! dedgefb will be added
 ubfleny=100.0
 ubflenz=100.0

 dedgefb=0.02 ! expansion of force box for numerical reasons,
              ! is set to 0.02 if zero, should be greater than corrtiny,
	      ! to avoid force calculations inside of the magnet

 utorqcenx=9999.   ! reference point for torques, 9999.: box center
 utorqceny=9999.
 utorqcenz=9999.

 mbforcex=10 ! number of integration points
 mbforcey=10 ! number of integration points
 mbforcez=10 ! number of integration points

 ndivfboxy=1 ! Divide force box to calculate vertical force and torque
             ! distribution. Ndivfboxy should be different from number of
	     ! vertical division of the considered magnet or pole

 mfcolor=1   ! color index of force box

 idipoles=0      ! Calculate dipole representation of voxels

 iforcedip=0     ! Calculation of forces using dipole approximation for magnets
                 ! >0: Only the considered magnet or pole is approximated
                 ! <0: All magnets and poles are approximated

 chforcemag=''   ! Name of magnet for which forces are calculated
                 ! If the magnet appears in different modules, check
		 ! undumag_magnets.lis for the unique name (third column).

 kurad=0     ! call urad to calculate trajectory and radiation
 ebeam=1.722 ! Total beam energy in GeV

 xelec=9999. !x at start (longitudinal coordinate)
             !9999: xmapmin
 yelec=0.0 !y at start (vertical coord.)
 zelec=0.0 !z at start

 !the velocity is internally normalized according to the beam energy
 vxelec=1.0 !x comp. of velocity at start
 vyelec=0.0 !y comp. of velocity at start
 vzelec=0.0 !z comp. of velocity at start

 ds=0.2  !step size
 nstep=1 ! the trajectory is written for every nstepth tracking step
         ! nstep.le.zero means no output

 xf=9999. !x of end plane, where tracking stops
         !9999: xmapmax
 yf=0.0 !y of end plane, where tracking stops
 zf=0.0 !z of end plane, where tracking stops

 efx=1.0 !x of normal vector of end plane, where tracking stops
 efy=0.0 !y of normal vector of end plane, where tracking stops
 efz=0.0 !z of normal vector of end plane, where tracking stops

 traxyz_theta=30. ! Polar plotting angle for 3D-trajectory
 traxyz_phi=30.   ! Azimut plotting angle for 3D-trajectory

 xobsv=10000. ! x of observation point in millimeter
 yobsv=0.0    ! y of observation point in millimeter
 zobsv=0.0    ! z of observation point in millimeter

 phelow=1. ! lowest photon energy (eV)
 phehig=1000. ! highest photon energy (eV)
 nphener=1000 ! number of photon equidistant energies

 ieneloss=-1 ! energy loss due to radiation
            ! 0: no energy loss
	    ! 1: continous energy loss
	    !-1: discrete energy loss with quantum fluctuations
	
 ivelofield=0 ! to control the calculation of the velocity field
              ! 0: velocity field is included
              ! 1: velocity field is not included
              !-1: velocity field is only

 kudebug=0    ! debug flag

 $end

 $RANDOMN
 ! Seeds to initialize the FORTRAN random generator.
 ! Twelfe seed values are require; the first four seem to have no effect
 ! under Linux and gfortran

   irnmode=1 ! 1:  Seeds of this namelist are taken
	     ! 2:  Seeds are taken from namelist, but runnumber is added to
	     !     IRNSEED(12)
	     ! <0: Seeds are read from file wave.seeds
	     !
	     ! else:
	     !     Seed is initialize automatically, i.e. via
	     !     call random_seed(isize) with isize=12
	     !     giving reproducable seeds

   IRNSEED(1)=287027030
   IRNSEED(2)=-719361131
   IRNSEED(3)=574274270
   IRNSEED(4)=292048305
   IRNSEED(5)=185733336
   IRNSEED(6)=-1598963619
   IRNSEED(7)=572469522
   IRNSEED(8)=1446716853
   IRNSEED(9)=437591706
   IRNSEED(10)=1398099429
   IRNSEED(11)=570932571
   IRNSEED(12)=-1177695979

 $END
+PATCH,SEQ.
*CMZ :  0.00/00 20/04/2016  13.03.34  by  Michael Scheer
+KEEP,magnet_struct.
*CMZ :  2.04/10 22/08/2023  09.01.13  by  Michael Scheer
*CMZ :  2.04/03 03/03/2023  16.41.34  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  16.37.47  by  Michael Scheer
*CMZ :  2.04/01 23/01/2023  09.51.15  by  Michael Scheer
*CMZ :  2.04/00 13/01/2023  10.56.20  by  Michael Scheer
*CMZ :  2.02/02 16/02/2022  15.17.02  by  Michael Scheer
*CMZ :  2.02/01 06/02/2022  11.20.01  by  Michael Scheer
*-- Author :    Michael Scheer   25/04/2021
      module magnets_structure

      double precision ::
     &  xcwmin=1.0d30,xcwmax=-1.0d30,
     &  ycwmin=1.0d30,ycwmax=-1.0d30,
     &  zcwmin=1.0d30,zcwmax=-1.0d30,
     &  xmin_t=1.0d30,xmax_t=-1.0d30,
     &  ymin_t=1.0d30,ymax_t=-1.0d30,
     &  zmin_t=1.0d30,zmax_t=-1.0d30,
     &  xsymmm_t

      integer nclcbuff,nclcspec,nclcmag,nclccoil,nclcvar,nclcmod,nclcmat,
     &  kunduplot_mode

      integer :: nvar_t=0,nmag_t=0,nvox_t=0,niron_t=0,kvox=0,kfirstiron_t=0,
     &  nspecmag_t=0,kfirstiron_spec_t=0,ncoils_t=0,ncwires_t=0,nmagtot_t=0,
     &  ncornmax_t=8,nplanmax_t=16, nmodule_t=0, nmagcopy_t=0,nvoxcopy_t=0,
     &  nclccop_t=0,nmoth_t=0,nmothtot_t=0,nmagsym_t=0,ninhom_t=0,nmaginhom_t=0

      integer, dimension (:), allocatable :: ksort_t,kmaglist_t,maginhom_t

      character(512), dimension (:), allocatable :: clcbuff,clcmag,clccoil,
     &  clcvar,clcmod,clcmat,clctrarot,clccop,clcspec,clcinhom

      type T_variable
        character(128) cname
        double precision val
      end type T_variable

      type(T_variable), dimension(:), allocatable :: t_variables

      type T_Voxel

      double precision, dimension (:), allocatable :: xhull,yhull,zhull
      double precision, dimension (:,:), allocatable :: plan, vnorm

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: kface,khull

      double precision xyz(3),size(3),trans(3),rot(3,3),Br(3),
     &  gcen(3),volume,xmin,xmax,ymin,ymax,zmin,zmax

      integer nhull,ixdiv,iydiv,izdiv,nedge,nface,kfacelast,
     &  IsPole,IsBlock,mxdiv,mydiv,mzdiv

      end type T_Voxel

      type T_Voxel_Copy
        integer kmagnet,kmodule,kcopy,kvoxel,kproto,ispole
        double precision Br(3),gcen(3)
      end type T_Voxel_Copy

      type T_Magnet_Copy
        integer kproto,kmodule,kcopy,IsPole,IsSpecial
        double precision gcen(3),Br(3),BrN,xmin,xmax,ymin,ymax,zmin,zmax,
     &    size(3),volume
        character(32) ctype,cnam,cmoth
      end type T_Magnet_Copy

      type T_Magnet_Sym
        integer kproto,kmodule,kcopy,IsPole,IsSpecial
        double precision gcen(3),Br(3),BrN,xmin,xmax,ymin,ymax,zmin,zmax
        character(32) ctype,cnam,cmoth
      end type T_Magnet_Sym

      type T_Magnet

        double precision, dimension (:,:), allocatable :: plan
        double precision, dimension (:), allocatable :: xhull0,yhull0,zhull0,
     &    xhull,yhull,zhull,ydivs,zdivs

        integer, dimension (:,:,:), allocatable :: kvoxels
        integer, dimension (:,:), allocatable :: kedge
        integer, dimension (:), allocatable :: kface,khull,kcopy

        character(512), dimension (:), allocatable :: cinhom

        double precision xyz(3),size(3),trans(3),rot(3,3),Br(3),yfracdiv,
     &    xmin,ymin,zmin,xmax,ymax,zmax,volume,gcen(3),dxdiv,dydiv,dzdiv,yfrac,
     &    zfracdiv,zfrac,uschamf,dschamf,cylphi,BrN,xyzinh(4),xvolume,yvolume,
     &    zvolume

        integer :: nface,nhull,icol,imat,nxdiv,nydiv,nzdiv,matindex,mattype,
     &    kfacelast,nedge,nvoxels,IsPole,IsSpecial,IsBlock,nhull0,IsPart,
     &    ncopy=0,kmodule=0,IsInhom=0,mxdiv,mydiv,mzdiv

        character(32) ctype,cnam,cmoth
        character(1024) cfile

        type(T_Voxel), dimension(:), allocatable ::  t_voxels, t_xcuts
        type(T_Voxel), dimension(:,:), allocatable :: t_xycuts
        type(T_Voxel), dimension(:,:,:), allocatable :: t_xyzcuts

      end type T_Magnet

      type T_Mother

        double precision, dimension (:), allocatable :: xhull,yhull,zhull

        integer, dimension (:,:), allocatable :: kedge
        integer, dimension (:), allocatable :: kface,khull,magnets

        double precision xyz(3),xmin,ymin,zmin,xmax,ymax,zmax,gcen(3)

        integer :: nmagnets=0,nhull,kfacelast

        character(32) :: cmoth=''

      end type T_Mother

      type T_Filament
        double precision curr,x1,y1,z1,x2,y2,z2
        integer icolor
      end type T_Filament

      type T_Coil
        integer ncwireI,ncwireE,iibuff,iebuff
        character(128) ctype,cnam
        character(1024) cparams
        double precision params(100)
      endtype T_Coil

      type(T_Magnet), dimension(:), allocatable ::  t_magnets, t_magnets_copy
      type(T_Coil), dimension(:), allocatable ::  t_coils

      type T_Module
        integer ncopy
        double precision offset(3),phi,vspace(3), scalmag(3),rotmat(3,3)
      end type T_Module

      character(32), dimension(:), allocatable :: chmutts

      integer, dimension (:), allocatable :: magmodule
      integer, parameter :: ntransrotcop_p=1000, nmat_p=1000

      integer :: ntransrotcop=0, nmat_t=0, t_matrec(3,nmat_p), nowarnugv=0
      double precision transrotcop(8,ntransrotcop_p)
      character(128) ctransrotcop(ntransrotcop_p)

      type(T_Mother), dimension(:), allocatable ::  t_mothers
      type(T_Module), dimension(:), allocatable ::  t_modules
      type(T_Magnet_Copy), dimension(:), allocatable ::  t_magcopy
      type(T_Magnet_Sym), dimension(:), allocatable ::  t_magsym
      type(T_Voxel_Copy), dimension(:), allocatable ::  t_voxcopy

      double precision, dimension (:), allocatable ::
     &  xpuffer1,ypuffer1,zpuffer1,
     &  xpuffer2,ypuffer2,zpuffer2,
     &  xpuffer3,ypuffer3,zpuffer3

      end module magnets_structure
+KEEP,unduver.
*CMZ :  2.04/10 23/08/2023  16.14.31  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.16.48  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.57.08  by  Michael Scheer
*CMZ :  2.04/07 10/08/2023  09.14.02  by  Michael Scheer
*CMZ :  2.04/06 07/08/2023  10.05.29  by  Michael Scheer
*CMZ :  2.04/05 15/03/2023  13.22.48  by  Michael Scheer
*CMZ :  2.04/04 14/03/2023  11.22.26  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.38.01  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.57.20  by  Michael Scheer
*CMZ :  2.04/01 17/01/2023  13.16.06  by  Michael Scheer
*CMZ :  2.04/00 02/09/2022  07.23.21  by  Michael Scheer
*CMZ :  2.03/00 26/07/2022  07.27.06  by  Michael Scheer
*CMZ :  2.02/02 11/02/2022  10.16.30  by  Michael Scheer
*CMZ :  2.02/00 06/04/2021  15.55.28  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.40.43  by  Michael Scheer
*CMZ :  2.01/07 28/07/2020  10.27.15  by  Michael Scheer
*CMZ :  2.01/06 27/07/2020  12.07.59  by  Michael Scheer
*CMZ :  2.01/05 27/07/2020  10.28.00  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.36.59  by  Michael Scheer
*CMZ :  2.01/02 02/05/2018  14.22.15  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.18.04  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  15.17.18  by  Michael Scheer
*CMZ :  2.00/03 24/04/2018  13.33.50  by  Michael Scheer
*CMZ :  2.00/02 17/04/2018  13.44.53  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  15.48.23  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.51.26  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.30.01  by  Michael Scheer
*CMZ :  1.25/04 05/04/2018  16.14.01  by  Michael Scheer
*CMZ :  1.25/03 03/04/2018  08.32.34  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  15.10.45  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.23.14  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  15.06.30  by  Michael Scheer
*CMZ :  1.24/01 17/10/2017  10.11.38  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  15.01.01  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.31.17  by  Michael Scheer
*CMZ :  1.23/06 06/10/2017  14.22.02  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  12.51.05  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.36.30  by  Michael Scheer
*CMZ :  1.23/03 27/09/2017  09.39.17  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.33.46  by  Michael Scheer
*CMZ :  1.23/01 09/08/2017  08.38.14  by  Michael Scheer
*CMZ :  1.23/00 04/08/2017  09.35.04  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  15.02.00  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.36.01  by  Michael Scheer
*CMZ :  1.21/00 29/06/2017  16.12.16  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  16.11.17  by  Michael Scheer
*CMZ :  1.20/02 23/06/2017  14.23.56  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  14.46.47  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  11.27.31  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.34.58  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  11.29.53  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  15.11.00  by  Michael Scheer
*CMZ :  1.18/01 09/06/2017  08.54.59  by  Michael Scheer
*CMZ :  1.18/00 06/06/2017  14.48.14  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.29.12  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  13.12.04  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  14.25.54  by  Michael Scheer
*CMZ :  1.17/05 18/05/2017  12.07.07  by  Michael Scheer
*CMZ :  1.17/04 12/05/2017  13.52.43  by  Michael Scheer
*CMZ :  1.17/03 09/05/2017  13.37.52  by  Michael Scheer
*CMZ :  1.17/02 09/05/2017  13.11.36  by  Michael Scheer
*CMZ :  1.17/01 08/05/2017  20.51.09  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  16.57.03  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  14.11.11  by  Michael Scheer
*CMZ :  1.15/13 05/05/2017  10.21.44  by  Michael Scheer
*CMZ :  1.15/11 03/05/2017  09.26.17  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.48.35  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  15.00.04  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  15.01.20  by  Michael Scheer
*CMZ :  1.15/07 05/04/2017  16.02.20  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.33.09  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.48.22  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  13.12.53  by  Michael Scheer
*CMZ :  1.15/03 03/04/2017  11.00.07  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.46.32  by  Michael Scheer
*CMZ :  1.15/01 30/03/2017  11.37.22  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  12.03.00  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  12.54.38  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  17.18.19  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.35.51  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  17.07.42  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  17.04.56  by  Michael Scheer
*CMZ :  1.12/00 27/02/2017  15.49.37  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.25.07  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.48.56  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  16.08.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.58.21  by  Michael Scheer
*CMZ :  1.11/03 18/01/2017  09.43.51  by  Michael Scheer
*CMZ :  1.11/02 10/01/2017  10.20.14  by  Michael Scheer
*CMZ :  1.11/01 09/01/2017  13.56.32  by  Michael Scheer
*CMZ :  1.11/00 05/01/2017  09.37.44  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  16.30.30  by  Michael Scheer
*CMZ :  1.10/02 01/12/2016  13.35.11  by  Michael Scheer
*CMZ :  1.10/01 21/11/2016  13.02.21  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.20.28  by  Michael Scheer
*CMZ :  1.09/01 10/10/2016  10.18.30  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  12.55.22  by  Michael Scheer
*CMZ :  1.08/00 30/09/2016  13.55.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  19.17.35  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.41.46  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.51.16  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  15.02.55  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.52.28  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.46  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.38.28  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.33.46  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.26.25  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  13.37.05  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  14.36.16  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.55.27  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.34.04  by  Michael Scheer
*CMZ :  1.02/00 30/08/2016  13.27.12  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.52.29  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.47.41  by  Michael Scheer
*CMZ :  0.00/14 19/08/2016  14.37.09  by  Michael Scheer
*CMZ :  0.00/13 19/08/2016  14.12.39  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.27.38  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.30.10  by  Michael Scheer
*CMZ :  0.00/10 14/07/2016  14.01.01  by  Michael Scheer
*CMZ :  0.00/09 06/07/2016  08.51.18  by  Michael Scheer
*CMZ :  0.00/08 23/06/2016  15.45.45  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  14.00.43  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.56.01  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.51.39  by  Michael Scheer
*CMZ :  0.00/03 04/05/2016  11.43.21  by  Michael Scheer
*CMZ :  0.00/02 02/05/2016  10.24.12  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  16.04.05  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.51.37  by  Michael Scheer
*-- Author :    Michael Scheer   12/02/2004
      print *
      print *
      print *
      write(lun6,*)'     **********************************************************'
      write(lun6,*)'     *                                                        *'
      write(lun6,*)'     *                       UNDUMAG                          *'
      write(lun6,*)'     *                                                        *'
      write(lun6,*)'     *                    Version 2.04/10                     *'
      write(lun6,*)'     *                        23.8.2023                       *'
      write(lun6,*)'     *                                                        *'
      write(lun6,*)'     *                     Michael Scheer                     *'
      write(lun6,*)'     *                       HZB/BESSY                        *'
      write(lun6,*)'     *                                                        *'
      write(lun6,*)'     **********************************************************'
      print *
      print *
      print *

      call util_zeit_kommentar(lun6,"")

      open(unit=999,file="undumag.ver")
      chuvers="2.04/10"
      write(999,*)chuvers
      close(999)
+KEEP,UNDUMAGF90M.
*CMZ :  2.04/10 22/08/2023  08.59.12  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  15.03.22  by  Michael Scheer
*CMZ :  2.03/00 22/08/2022  12.27.43  by  Michael Scheer
*CMZ :  2.02/02 03/03/2022  11.56.47  by  Michael Scheer
*CMZ :  2.02/01 26/04/2021  07.33.54  by  Michael Scheer
*CMZ :  2.02/00 16/02/2021  14.20.30  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.30.15  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  14.58.35  by  Michael Scheer
*CMZ :  2.01/04 16/07/2019  14.49.37  by  Michael Scheer
*CMZ :  2.01/03 15/07/2019  15.06.29  by  Michael Scheer
*CMZ :  2.01/02 26/04/2018  12.28.16  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  13.52.25  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  15.53.14  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  10.11.25  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  13.49.06  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  13.28.25  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  09.19.11  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  08.36.08  by  Michael Scheer
*CMZ :  1.23/05 05/10/2017  16.45.51  by  Michael Scheer
*CMZ :  1.23/04 28/09/2017  13.54.36  by  Michael Scheer
*CMZ :  1.23/03 21/09/2017  14.46.49  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  14.00.28  by  Michael Scheer
*CMZ :  1.22/02 27/07/2017  09.16.11  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  12.02.40  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  10.53.36  by  Michael Scheer
*CMZ :  1.20/00 20/06/2017  17.32.50  by  Michael Scheer
*CMZ :  1.19/00 19/06/2017  18.04.00  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.16.03  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  12.18.33  by  Michael Scheer
*CMZ :  1.17/07 21/05/2017  18.28.26  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.01.23  by  Michael Scheer
*CMZ :  1.17/05 18/05/2017  09.20.21  by  Michael Scheer
*CMZ :  1.17/04 10/05/2017  11.17.06  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  13.25.33  by  Michael Scheer
*CMZ :  1.16/00 06/05/2017  12.55.04  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  15.51.52  by  Michael Scheer
*CMZ :  1.15/11 23/04/2017  10.38.05  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.19.13  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  09.03.14  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.28.20  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  11.21.37  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.38.33  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  16.23.04  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  09.37.22  by  Michael Scheer
*CMZ :  1.13/01 06/03/2017  10.14.22  by  Michael Scheer
*CMZ :  1.13/00 01/03/2017  09.19.24  by  Michael Scheer
*CMZ :  1.11/05 27/01/2017  09.42.57  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.52.23  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.07  by  Michael Scheer
*CMZ :  1.11/01 05/01/2017  14.35.46  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.38.34  by  Michael Scheer
*CMZ :  1.10/03 01/12/2016  14.58.46  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.20.40  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.05.14  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.44.47  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.38.45  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.27.14  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  11.55.19  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.46  by  Michael Scheer
*CMZ :  1.02/00 22/08/2016  17.13.11  by  Michael Scheer
*CMZ :  0.00/13 28/07/2016  09.47.14  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.35  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  11.39.48  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.56.05  by  Michael Scheer
*CMZ :  0.00/09 05/07/2016  16.04.35  by  Michael Scheer
*CMZ :  0.00/07 22/06/2016  14.09.40  by  Michael Scheer
*CMZ :  0.00/04 10/05/2016  09.06.41  by  Michael Scheer
*CMZ :  0.00/02 27/04/2016  09.26.25  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.57.22  by  Michael Scheer
*CMZ :  1.17/13 07/04/2016  14.37.11  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  12.17.38  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  13.37.17  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.08.54  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  13.18.15  by  Michael Scheer
*CMZ :  1.17/06 31/03/2016  09.17.56  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  09.00.04  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  16.12.04  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  09.38.56  by  Michael Scheer
*CMZ :  1.17/02 11/03/2016  16.56.25  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      module undumagf90m

c +PATCH,//UNDUMAG/SEQ
c +KEEP,UNDUMAGF90M.

      implicit none

      integer nthreadp,nwitems
      parameter (nthreadp=1000,nwitems=11)

!      double precision, dimension (:,:,:,:), allocatable :: wwmatrix

      double precision, dimension (:,:,:), allocatable :: bcmat
      double precision, dimension (:,:), allocatable :: bc0,bc00,bpm,
     &  bpebc0,wire,race,wind,arc,carc,crace,rectbar,thickwire,brnmat

      double precision, dimension (:), allocatable ::
     &  feh1,feh2,feh3,fem1,fem2,fem3,ufespl1,
     &  fespl1,fewspl1,fewspl2,fewspl3,fewspl4,
     &  bxconvw,byconvw,bzconvw

      double precision, dimension (:,:), allocatable :: dipoles
      double precision, dimension (:,:,:), allocatable :: cornpoles

      real*4, dimension (:,:,:,:), allocatable :: wwmatrix4,convmat
c      real*4, dimension (:,:,:), allocatable :: wwmatrix

      integer, dimension (:), allocatable :: kspecmag,idamp8,ncornpoles
      integer, dimension(:,:), allocatable :: magcyl

      double precision
     &  unduplot_phi,unduplot_theta,traxyz_theta,traxyz_phi,permu,parmu,perksi,parksi,
     &  xmapmin,xmapmax,ymapmin,ymapmax,zmapmin,zmapmax,dxmap,
     &  xminpl,xmaxpl,yminpl,ymaxpl,zminpl,zmaxpl,
     &  xconvmin,xconvmax,dxconv,xconv(100),yconv,zconv,hconv,hconva,uwindow,xsym,
     &  xbeff,xbeffy,xbeffz,perlen,
     &  ebeam,zslit,xcenter,xmaxinf,xcentershift,xelec,yelec,zelec,
     &  vxelec,vyelec,vzelec,
     &  ds,xf,yf,zf,efx,efy,efz,xobsv,yobsv,zobsv,phelow,phehig,dampiron,dampi,
     &  ubfcenx,ubfceny,ubfcenz,ubflenx,ubfleny,ubflenz,
     &  utorqcenx,utorqceny,utorqcenz,
     &  fxdip,fydip,fzdip,
     &  txdip,tydip,tzdip,
     &  uservar(100),corrtiny,cuttiny,hulltiny,randos,randox,randoy,randoz
     &  ,dampfac,hconvbase,hconvexp,chicut,damp8,rcvthron,angmaprotx,
     &  cenmaprotxy,cenmaprotxz,zminprof,zmaxprof,
     &  bxex,byex,bzex,hresidiron,resiron,halt,dedgefb,coating

      real randoxa,randoya,randoza,randox10,randoy10,randoz10,
     &  randomx,randomy,randomz

      integer
     &  maxiter,maxiterrec,maxiteriron,nchiiron,ibulk,nchimax,kesti,
     &  ktetmesh,iunduplot_mode,
     &  kiter,iterrectot,iterirontot,
     &  iunduplot,kcomment,krunnum,kdate,kplsym,nrec,niron,nxmap,intmaglis,noduplis,nymap,nzmap
     &  ,mode,ncornmax,nplanmax,ncornadd,nplanadd,niterrec,niteriron,niter,
     &  kconvrec,kconviron,kconv,lunconv,kdumpconv,nmatfiles,
     &  matmaps(4,1000),kpreset,matrix,
     &  magmatrix,nuthreads,
     &  ixsym,iysym,izsym,nspecmag,nxbeff,kbeffmode,
     &  ixsymo,iysymo,izsymo,
     &  ieneloss,ivelofield,nphener,nstep,kxcenter,kudebug,kcalcvars,isimpson,
     &  nxconv,kdisplace,kechocalc,knomagmap,knopolmap,isplinefm,
     &  iforce,ivrml,iundugeo,idipoles,iforcedip,iplforce,itorque,mbforcex,mbforcey,mbforcez,mfcolor,
     &  kmapmode,kmapnohead,knointmap,konv,iwarnsum,maxpoints,nmagpols,kallodip,
     &  nwarnbound, iwarnin,iwarn2pi,iwarnbound,ndipoles,killbadmag,irecrepl,kwarncom,irandmag,kshuffle,
     &  kforcemag,kurad,kbextern,kresiron,kprint,ndivfboxy,
     &  ncwires,nrace,nwind,ncrace,ncfila,narc,ncarc,nwcarc,nwrace,nwwind,
     &  nwcrace,nwarc,ncoil,newclc,
     &  nrbar,nwrbar,nthwir,nwthwir,nmagcyl,kwave,iforcegrid,modegui,nbrnmat

      character(256) unducomment
      character(512) cundutit
      character(16) chuvers

      character, dimension (:,:), allocatable :: chmags, chmoths,
     &  chmagsm,chmothsm,chmagsi,chmothsi,chmagpols,chmothso

      character(32) chmag,chmoth,chforcemag

      namelist/undumagn/
     &  maxiter,maxiterrec,maxiteriron,nchiiron,ibulk,iunduplot,kcomment,
     &  krunnum,kdate,ktetmesh,kesti,
     &  kplsym,nxmap,intmaglis,noduplis,nymap,nzmap
     &  ,mode,kdumpconv,dxmap,iunduplot_mode,
     &  unduplot_phi,unduplot_theta,traxyz_theta,traxyz_phi,
     &  xmapmin,xmapmax,ymapmin,ymapmax,zmapmin,zmapmax,
     &  xconvmin,xconvmax,dxconv,nxconv,yconv,zconv,hconv,kpreset,uwindow,matrix,nuthreads,
     &  xminpl,xmaxpl,yminpl,ymaxpl,zminpl,zmaxpl,
     &  ixsym,iysym,izsym,xsym,
     &  xbeff,xbeffy,xbeffz,perlen,nxbeff,kbeffmode,kurad,ebeam,zslit,xcenter,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  ds,xf,yf,zf,efx,efy,efz,xobsv,yobsv,zobsv,phelow,phehig,
     &  ieneloss,ivelofield,nphener,nstep,kxcenter,kcalcvars,
     &  dampiron,isimpson,isplinefm,kdisplace,kechocalc,knomagmap,knopolmap,
     &  kmapmode,kmapnohead,knointmap,
     &  iforce,ivrml,iundugeo,idipoles,iforcedip,iplforce,itorque,mbforcex,mbforcey,mbforcez,mfcolor,
     &  ubfcenx,ubfceny,ubfcenz,ubflenx,ubfleny,ubflenz,
     &  utorqcenx,utorqceny,utorqcenz,chforcemag,nwarnbound, iwarnin,iwarn2pi,
     &  killbadmag,corrtiny,cuttiny,hulltiny,randos,randox,randoy,randoz,irecrepl
     &  ,dampfac,hconvbase,hconvexp,chicut,irandmag,kshuffle,
     &  randomx,randomy,randomz,rcvthron,angmaprotx,cenmaprotxy,cenmaprotxz,
     &  bxex,byex,bzex,kbextern,kresiron,resiron,kprint,ndivfboxy,dedgefb,
     &  iforcegrid,kudebug,newclc

      end module undumagf90m
+KEEP,inputver.
*CMZ :  2.04/10 23/08/2023  16.14.31  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.16.48  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.57.08  by  Michael Scheer
*CMZ :  2.04/07 10/08/2023  09.14.02  by  Michael Scheer
*CMZ :  2.04/06 07/08/2023  10.05.29  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.38.01  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.57.20  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  14.22.34  by  Michael Scheer
*CMZ :  2.04/00 02/09/2022  07.23.44  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.40.43  by  Michael Scheer
*CMZ :  2.01/07 28/07/2020  10.27.15  by  Michael Scheer
*CMZ :  2.01/02 02/05/2018  14.22.15  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.18.04  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  15.17.18  by  Michael Scheer
*CMZ :  2.00/03 24/04/2018  13.33.50  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.51.26  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.30.01  by  Michael Scheer
*CMZ :  1.25/04 05/04/2018  16.14.01  by  Michael Scheer
*CMZ :  1.25/02 22/03/2018  15.10.45  by  Michael Scheer
*CMZ :  1.25/01 16/03/2018  15.07.26  by  Michael Scheer
*CMZ :  1.24/01 17/10/2017  10.11.38  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  15.01.01  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.31.17  by  Michael Scheer
*CMZ :  1.23/06 06/10/2017  14.22.02  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  12.51.05  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.36.30  by  Michael Scheer
*CMZ :  1.23/03 27/09/2017  09.39.17  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.33.46  by  Michael Scheer
*CMZ :  1.23/01 09/08/2017  08.38.14  by  Michael Scheer
*CMZ :  1.23/00 04/08/2017  09.35.04  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  15.02.00  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.36.01  by  Michael Scheer
*CMZ :  1.21/00 29/06/2017  16.12.16  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  16.11.17  by  Michael Scheer
*CMZ :  1.20/02 23/06/2017  14.23.56  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  14.46.47  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  11.27.31  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.34.58  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  11.29.53  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  15.11.00  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.29.12  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  13.12.04  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  14.25.54  by  Michael Scheer
*CMZ :  1.17/05 18/05/2017  12.07.07  by  Michael Scheer
*CMZ :  1.17/04 12/05/2017  13.52.43  by  Michael Scheer
*CMZ :  1.17/03 09/05/2017  13.37.52  by  Michael Scheer
*CMZ :  1.17/02 09/05/2017  13.11.36  by  Michael Scheer
*CMZ :  1.17/01 08/05/2017  20.51.09  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  16.57.03  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  14.11.11  by  Michael Scheer
*CMZ :  1.15/13 05/05/2017  10.21.44  by  Michael Scheer
*CMZ :  1.15/11 03/05/2017  09.26.17  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.48.35  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  15.00.04  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  15.01.20  by  Michael Scheer
*CMZ :  1.15/07 05/04/2017  16.02.20  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.33.09  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.48.22  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  13.12.53  by  Michael Scheer
*CMZ :  1.15/03 03/04/2017  11.00.07  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.46.32  by  Michael Scheer
*CMZ :  1.15/01 30/03/2017  11.37.22  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  12.54.38  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  17.18.19  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.35.51  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  17.07.42  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  17.04.56  by  Michael Scheer
*CMZ :  1.12/00 27/02/2017  15.49.37  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.25.07  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.48.56  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  16.08.44  by  Michael Scheer
*CMZ :  1.10/01 21/11/2016  13.02.21  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.20.28  by  Michael Scheer
*CMZ :  1.09/01 10/10/2016  10.18.30  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  12.55.22  by  Michael Scheer
*CMZ :  1.08/00 30/09/2016  13.55.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  19.17.35  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.41.46  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.51.16  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  15.02.55  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.52.28  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.46  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.39.52  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.38.28  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.33.46  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.26.25  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  13.37.05  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  14.36.16  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.55.27  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.34.04  by  Michael Scheer
*CMZ :  1.02/00 30/08/2016  13.27.12  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.52.29  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.47.41  by  Michael Scheer
*CMZ :  0.00/14 19/08/2016  14.37.09  by  Michael Scheer
*CMZ :  0.00/13 19/08/2016  14.12.39  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.27.38  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.30.10  by  Michael Scheer
*CMZ :  0.00/10 14/07/2016  14.01.01  by  Michael Scheer
*CMZ :  0.00/09 06/07/2016  08.51.18  by  Michael Scheer
*CMZ :  0.00/08 23/06/2016  15.45.45  by  Michael Scheer
*CMZ :  0.00/07 23/06/2016  15.45.22  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  14.00.43  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.56.01  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.51.39  by  Michael Scheer
*CMZ :  0.00/03 04/05/2016  11.43.21  by  Michael Scheer
*CMZ :  0.00/02 02/05/2016  10.24.12  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  16.04.05  by  Michael Scheer
*-- Author :    Michael Scheer   27/02/2004
* Version 2.04/10
+PATCH,$VERSION.
*CMZ :  0.00/00 20/04/2016  13.04.28  by  Michael Scheer
+DECK,V2_04.
*CMZ :  2.04/10 23/08/2023  16.14.31  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.16.48  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.57.08  by  Michael Scheer
*CMZ :  2.04/07 10/08/2023  09.14.03  by  Michael Scheer
*CMZ :  2.04/06 07/08/2023  10.05.29  by  Michael Scheer
*CMZ :  2.04/05 15/03/2023  13.22.48  by  Michael Scheer
*CMZ :  2.04/04 14/03/2023  11.22.26  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.38.01  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.57.20  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  14.22.34  by  Michael Scheer
*CMZ :  2.04/00 17/01/2023  13.14.13  by  Michael Scheer
*-- Author :    Michael Scheer   17/01/2023
*________________________________________________________________________
*
*::>          VERSION  2.04/10   23/08/2023 16.14.31
*
* Postscript 3d graphic improved, bug in undumag_drop_zero_magnets removed
*________________________________________________________________________
*
*::>          VERSION  2.04/09   18/08/2023 19.16.48
*
* Bugs in undugui.py
*________________________________________________________________________
*
*::>          VERSION  2.04/08   11/08/2023 14.57.08
*
* Treatment of cylinders implemented for new syntax
*
*________________________________________________________________________
*
*::>          VERSION  2.04/07   10/08/2023 09.14.03
*
* Bug in CLCTRANSROTCOP removed. Check for rectangular block improved.
* Check for size of interaction matrix implemented
*________________________________________________________________________
*
*::>          VERSION  2.04/06   07/08/2023 10.05.29
*
* Bugs... Variables for translations etc., translations etc. in GUI
*
*________________________________________________________________________
*
*::>          VERSION  2.04/05   15/03/2023 13.22.48
*
* First GITLAB-Version
*________________________________________________________________________
*
*::>          VERSION  2.04/04   14/03/2023 11.22.26
*
* Before GITLAB-Version
*________________________________________________________________________
*
*::>          VERSION  2.04/03   05/03/2023 16.38.01
*
* Bugs of segmentation removed
*________________________________________________________________________
*
*::>          VERSION  2.04/02   27/02/2023 20.57.20
*
* Bugs of segmentation removed
*________________________________________________________________________
*
*::>          VERSION  2.04/01   13/02/2023 14.22.34
*
* Bugs of segmentation removed
*________________________________________________________________________
*
*::>          VERSION  2.04/00   17/01/2023 13.14.13
*
* Inhomogenities, bugs removed
*
+PATCH,MAIN.
*CMZ :  0.00/01 20/04/2016  13.05.30  by  Michael Scheer
+DECK,undumag_main,T=F77.
*CMZ :  2.04/05 22/08/2023  09.04.09  by  Michael Scheer
*CMZ :  2.03/00 25/07/2022  22.23.37  by  Michael Scheer
*CMZ :  2.02/02 02/03/2022  12.40.00  by  Michael Scheer
*CMZ :  2.02/01 30/01/2022  10.32.11  by  Michael Scheer
*CMZ :  2.02/00 27/02/2021  13.25.00  by  Michael Scheer
*CMZ :  2.01/03 17/07/2018  11.18.30  by  Michael Scheer
*CMZ :  1.24/01 12/10/2017  16.29.21  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  14.10.57  by  Michael Scheer
*CMZ :  1.18/01 09/06/2017  08.53.53  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.56.02  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.23.14  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  17.47.09  by  Michael Scheer
*CMZ :  1.04/00 13/09/2016  15.21.39  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  14.54.42  by  Michael Scheer
*CMZ :  1.17/02 11/03/2016  15.08.19  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003

+seq,gplhint.

!-----------------------------------------------------------------------
c+seq,phyconmod.

+self,if=-uout_incl.

+seq,magnet_struct.
+seq,bpolyederf90m.
+seq,undumagf90m.
+seq,commandlinef90m.

+self.

      program undumag_main

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

+seq,phyconparam.

      integer lunst
      integer :: kseg=0

+self,if=debfil.
      call util_break
+self.
      lun6=6

      Fclc='undumag.clc'
      Fnam='undumag.nam'

+seq,commandargs.

      do iarg_cl=1,narg_cl
        if(carg_cl(iarg_cl)(1:7).eq.'STDOUT=') then
          open(newunit=lun6,file=carg_cl(iarg_cl)(8:len_trim(carg_cl(iarg_cl))))
        else if(carg_cl(iarg_cl)(1:4).eq.'CLC=') then
          fclc=carg_cl(iarg_cl)(5:len_trim(carg_cl(iarg_cl)))
        else if(carg_cl(iarg_cl)(1:4).eq.'NAM=') then
          fnam=carg_cl(iarg_cl)(5:len_trim(carg_cl(iarg_cl)))
        else if(carg_cl(iarg_cl).eq.'SEGMENTATION') then
          Fclc='undumag.clc'
          kseg=1
        else if(carg_cl(iarg_cl).eq.'FILAMENTS') then
          Fclc='filaments.clc'
          kseg=2
        else
          print*
          print*,"Allowed argument keys and their default values:"
          print*
          print*,"STDOUT=Terminal"
          print*,"CLC=undumag.clc"
          print*,"NAM=undumag.nam"
          print*,"SEGMENTATION"
          print*
          stop
        endif
      enddo

+self,showargs.

      call util_zeit_kommentar(lun6,"")

      if (narg_cl.ne.0) then
        write(lun6,*)
        write(lun6,*)"Arguments passed to UNDUMAG:"
        write(lun6,*)
        do iarg_cl=1,narg_cl
          write(lun6,*)iarg_cl, trim(carg_cl(iarg_cl))
        enddo
        write(lun6,*)
      endif
+self.

      iundumag=1 ! flag to indicate enviroment of undumag

      konv=-9

      newclc=0
      call undumag_check_newclc

      if (kseg.eq.1) then
        open(newunit=lunst,file="undumag.sta")
        write(lunst,*)"-9999",konv
        write(lunst,*)"Starting segmentation"
        close(lunst)
      else if (kseg.eq.2) then
        open(newunit=lunst,file="undumag.sta")
        write(lunst,*)"-9999",konv
        write(lunst,*)"Starting calculation of coil filaments"
        close(lunst)
      endif

      if (newclc.ne.0) then
        call undumag_ini(kseg)
      else
        call undumag_ini_old(kseg)
      endif

      if (kseg.eq.1) then

        call util_zeit_kommentar(lun6,"--- Program undumag finished ---")
        open(newunit=lunst,file="undumag.sta")
        write(lunst,*)"-9999",konv
        write(lunst,*)"Segmentation finished"
        close(lunst)

      else if (kseg.eq.2) then

        call util_zeit_kommentar(lun6,"--- Program undumag finished ---")
        open(newunit=lunst,file="undumag.sta")
        write(lunst,*)"-9999",konv
        write(lunst,*)"Calculation of coil filaments finished"
        close(lunst)

      else !kseg

        if (maxiter.gt.0) then
          call undumag_proc
          if (iforcedip.ne.0) call undumag_force_dipoles
          if (iforce.ne.0.or.itorque.ne.0) call undumag_force
        endif

        call undumag_end

        call util_zeit_kommentar(lun6,"--- Program undumag finished ---")

        if (lun6.ne.6) then
          close(lun6)
        endif

      endif !kseg

      end

+self,if=-uout_incl.
      include "uradfield.f"
      include "uradrndm.f"
+self.
+DECK,undumag_test_main,T=F77.
*CMZ :  1.25/00 22/08/2023  09.04.09  by  Michael Scheer
*CMZ :  1.24/01 12/10/2017  16.29.21  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  14.10.57  by  Michael Scheer
*CMZ :  1.18/01 09/06/2017  08.53.53  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.56.02  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.23.14  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  17.47.09  by  Michael Scheer
*CMZ :  1.04/00 13/09/2016  15.21.39  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  14.54.42  by  Michael Scheer
*CMZ :  1.17/02 11/03/2016  15.08.19  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003

+seq,gplhint.

!-----------------------------------------------------------------------
+seq,bpolyederf90m.
+seq,undumagf90m.

      program undumag_test_main

      use bpolyederf90m
      use undumagf90m

      implicit none

      double precision wire(8),x,y,z,bx,by,bz
      integer lunwire

+seq,phycon.
+seq,phycon1.

      open(newunit=lunwire,file='wire.dat')
      read(lunwire,*)x,y,z
      read(lunwire,*)wire
      close(lunwire)

      call undumag_bwirenum(wire,x,y,z,bx,by,bz)
      print*,sngl(bx),sngl(by),sngl(bz)

      call undumag_bwireana(wire,x,y,z,bx,by,bz)
      print*,sngl(bx),sngl(by),sngl(bz)

      end
      include "undumag_bwirenum.f"
      include "undumag_bwireana.f"
+PATCH,OBSOLETE.
*CMZ :  0.00/01 25/04/2016  08.11.13  by  Michael Scheer
+DECK,clcmag_bpolyplot.
*CMZ :  2.04/10 22/08/2023  12.41.28  by  Michael Scheer
*CMZ :  2.04/09 16/08/2023  09.50.47  by  Michael Scheer
*CMZ :  2.04/07 07/08/2023  12.29.11  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  17.12.50  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  14.10.28  by  Michael Scheer
*CMZ :  2.03/00 23/07/2022  08.30.04  by  Michael Scheer
*CMZ :  2.02/02 18/02/2022  10.24.23  by  Michael Scheer
*CMZ :  2.02/01 30/01/2022  08.39.29  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  13.07.52  by  Michael Scheer
*CMZ :  2.01/02 25/04/2018  11.48.35  by  Michael Scheer
*CMZ :  1.25/01 19/03/2018  16.23.08  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.02.34  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.20.09  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  12.45.15  by  Michael Scheer
*CMZ :  1.17/08 27/05/2017  10.32.42  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  14.33.44  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.09.14  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.50  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.39.32  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.47.10  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.49.25  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.46.16  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.01.00  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  13.31.06  by  Michael Scheer
*CMZ :  1.02/01 08/09/2016  15.25.02  by  Michael Scheer
*CMZ :  1.02/00 23/08/2016  12.01.08  by  Michael Scheer
*CMZ :  0.00/13 31/07/2016  16.05.11  by  Michael Scheer
*CMZ :  0.00/01 25/04/2016  15.07.20  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.27.40  by  Michael Scheer
*CMZ :  1.17/02 09/10/2014  14.52.20  by  Michael Scheer
*CMZ :  1.17/01 03/10/2014  11.25.46  by  Michael Scheer
*CMZ :  1.17/00 25/08/2014  15.14.09  by  Michael Scheer
*CMZ :  1.16/04 16/04/2014  15.34.26  by  Michael Scheer
*CMZ :  1.16/01 14/03/2014  12.26.15  by  Michael Scheer
*CMZ :  1.12/16 01/06/2007  11.17.50  by  Michael Scheer
*CMZ :  1.12/08 02/08/2006  17.03.41  by  Michael Scheer
*CMZ :  1.11/03 21/06/2005  12.56.55  by  Michael Scheer
*CMZ :  1.11/01 01/03/2005  09.45.36  by  Michael Scheer
*CMZ :  1.10/04 25/02/2005  11.55.05  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  08.54.30  by  Michael Scheer
*CMZ :  1.01/01 11/08/2004  13.30.53  by  Michael Scheer
*CMZ :  1.01/00 02/03/2004  17.00.13  by  Michael Scheer
*CMZ :  1.00/01 27/02/2004  14.29.35  by  Michael Scheer
*CMZ :  1.00/00 26/02/2004  17.21.29  by  Michael Scheer
*CMZ :  0.99/13 26/02/2004  16.14.57  by  Michael Scheer
*CMZ :  0.99/12 26/02/2004  12.02.34  by  Michael Scheer
*CMZ :  0.99/11 25/02/2004  15.21.06  by  Michael Scheer
*CMZ :  0.99/10 25/02/2004  13.42.35  by  Michael Scheer
*CMZ :  0.99/09 20/02/2004  17.26.48  by  Michael Scheer
*CMZ :  0.99/08 20/02/2004  16.32.55  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  15.21.29  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  13.55.05  by  Michael Scheer
*CMZ :  0.99/00 26/01/2004  17.03.49  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  12.52.23  by  Michael Scheer
*CMZ :  0.00/07 16/01/2004  11.05.44  by  Michael Scheer
*CMZ :  0.00/06 09/01/2004  15.55.17  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  14.52.54  by  Michael Scheer
*CMZ :  0.00/04 23/12/2003  10.15.07  by  Michael Scheer
*CMZ :  0.00/02 15/12/2003  12.43.34  by  Michael Scheer
*CMZ :  0.00/01 10/12/2003  17.56.52  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine clcmag_bpolyplot(iplot,xmin,xmax,ymin,ymax,zmin,zmax,
     &  theta,phi,nwitems,ncwires,wire)

+seq,bpolyederf90u.

      use commandlinef90m
      use magnets_structure

      implicit none

+seq,mshplt.
+seq,bpolyeder,if=static.

      integer npawp
      parameter (npawp=10000)

      integer nwitems,ncwires
      double precision wire(nwitems,ncwires)

      real, dimension (:), allocatable :: rmothb,rmagb,rcolb,rplanb,rcornb,
     &  xb,yb,zb,bxb,byb,bzb,rmatb,xyzmin,xyzmax

      real, dimension (:), allocatable :: xpl,ypl,zpl,zplm,xmpl,ympl,zmpl
      integer, dimension (:), allocatable :: ispole

      real
     &  xplb(2),yplb(2),zplb(2),
     &  xplbo(2),yplbo(2),zplbo(2),rmtyp31,rmtyp24,rmtyp20,rlwidth,rlwidtho

      real xmin,xmax,ymin,ymax,zmin,zmax,theta,phi,
     &  x,y,z,bx,by,bz,dx,dy,dz,bxo,byo,bzo,bo,eps,
     &  xmn,xmx,ymn,ymx,zmn,zmx,
     &  xmmn,xmmx,ymmn,ymmx,zmmn,zmmx,
     &  xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &  rmoth,rmag,rcol,rplan,rcorn,rmat,
     &  xc,yc,zc,xmc(1),ymc(1),zmc(1),dot0,circ0,pscal,vn,vnx,vnz

      integer i,iplot,iplot1,iplot10,iplot100,idev,
     &  imag,icol,iplan,icorn,kpole,
     &  iplano,ncorno,iline,iw,nline,iallo,
     &  ncorn,ncornmax,igird,imago,impl,izero,nfirst,nlast

      integer luncnf,lunmag

      character(64) ctitle,cline
      character(32), dimension(:), allocatable ::  cnam,cmoth

      data dot0/25./
      data circ0/5./
      data rmtyp20/20./
      data rmtyp24/-9999./
      data rmtyp31/31./

      data eps/0.01/

      iallo=0

      write(lun6,*)
      if (kunduplot_mode.eq.0) then
        write(lun6,*) "Reading file undumag.mag and writing geometry to plotfile undumag.eps"
      else
        write(lun6,*) "Reading file undumag.mag and writing geometry to plotfile undumag_3d.eps"
      endif
      write(lun6,*)

      open(newunit=luncnf,file='.mshplt.cnf')

      write(luncnf,'(a)')"0 !idev, 0: viewer is not used"
      write(luncnf,'(a)')"-20. -20. !plot size in cm, negative values indicate HIGZ compatible mode"
      write(luncnf,'(a)')"0.8 !rescaling factor; if not one, plot files are copied and rescaled"
      write(luncnf,'(a)')"0 0 800 800 !bounding box"
      if (kunduplot_mode.ne.0) then
        write(luncnf,'(a)')"undumag_3d.eps !base name of plotfiles"
      else
        write(luncnf,'(a)')"undumag.eps !base name of plotfiles"
      endif
      write(luncnf,'(a)')"$UNDUMAG/shell/undumag_viewer.sh"
      write(luncnf,'(a)')"$UNDUMAG/shell/undumag_kill_viewer.sh"

      close(luncnf)

      iplano=0
      nline=0

      xmn=sngl(xmin_t)
      xmx=sngl(xmax_t)
      ymn=sngl(ymin_t)
      ymx=sngl(ymax_t)
      zmn=sngl(zmin_t)
      zmx=sngl(zmax_t)

      if (jrunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      ncornmax=ncornmax_t
      if (ncwires.gt.0) then
        ncornmax=max(2,ncornmax_t)
      endif

      open(newunit=lunmag,file='undumag.mag',status='old')
      read(lunmag,'(a)')cline
1     read(lunmag,*,end=9) rmoth,rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz,rmat
      if (bx**2+by**2+bz**2.eq.0.0d0) goto 1
      nline=nline+1
      goto 1
9     rewind(lunmag)

      allocate(
     &  rmothb(nline),rmagb(nline),rcolb(nline),rplanb(nline),rcornb(nline),
     &  xb(nline),yb(nline),zb(nline),bxb(nline),byb(nline),bzb(nline),
     &  rmatb(nline),cnam(nline),cmoth(nline),ispole(nline))

      read(lunmag,'(a)')cline

      do i=1,nline
        read(lunmag,*)
     &  rmothb(i),rmagb(i),rcolb(i),rplanb(i),rcornb(i),
     &  xb(i),yb(i),zb(i),bxb(i),byb(i),bzb(i),
     &    rmatb(i),cnam(i),cmoth(i),ispole(i)
        if (rmatb(i).eq.0) then
          bxb(i)=0.0
          byb(i)=0.0
          bzb(i)=0.0
        endif
        imag=nint(rmagb(i))
        ispole(imag)=ispole(i)
      enddo

      close(lunmag)

      if (ncornmax.eq.0.and.ncwires.le.0) then
        write(lun6,*)"*** Warning in clcmag_bpolyplot: Nothing to plot!?"
        goto 9999
      endif

      allocate(xpl(ncornmax))
      allocate(ypl(ncornmax))
      allocate(zpl(ncornmax))
      allocate(zplm(ncornmax))

      allocate(xmpl(ncornmax*nplanmax_t))
      allocate(ympl(ncornmax*nplanmax_t))
      allocate(zmpl(ncornmax*nplanmax_t))

      iallo=1

      call mlimit(npawp)

      if (jdate.ne.0) then
        call mplopt('DATE',1)
      else
        call mplopt('NDAT',1)
      endif

      call mplint(idev)

      if (jdate.ne.0) then
        call mplopt('DATE',1)
      else
        call mplopt('NDAT',1)
      endif

      call mplset('YGTI',0.)
      call mplset('GSIZ',0.3)
      call mgset('TXCI',1.)

      iplot100=abs(iplot)/100
      iplot10=(abs(iplot)-iplot100*100)/10
      iplot1=abs(iplot)-iplot100*100-iplot10*10

      call mshplt_get_line_width(rlwidtho)
      rlwidth=rlwidtho
      call mshplt_set_line_width(rlwidtho/2.)

c--- Open plotfiles {

      if (iplot.gt.0) then

        if (idev.ne.0) then
          call mgmeta(98,-111)    !seite 22
        else
          call mgmeta(-98,-111)    !seite 22
        endif

      else if (iplot.lt.0) then

        if (idev.ne.0) then
          call mgmeta(98,-113)    !seite 22
        else
          call mgmeta(-98,-113)    !seite 22
        endif

      endif !iplot

c--- Open plotfiles }

      iplano=1

      if (xmin.eq.9999.) then
        xplmin=xmn
      else
        xplmin=xmin
      endif

      if (xmax.eq.9999.) then
        xplmax=xmx
      else
        xplmax=xmax
      endif

      if (ymin.eq.9999.) then
        yplmin=ymn
      else
        yplmin=ymin
      endif

      if (ymax.eq.9999.) then
        yplmax=ymx
      else
        yplmax=ymax
      endif

      if (zmin.eq.9999.) then
        zplmin=zmn
      else
        zplmin=zmin
      endif

      if (zmax.eq.9999.) then
        zplmax=zmx
      else
        zplmax=zmax
      endif

      if (nbforcx*nbforcy*nbforcy.ne.0) then
        dx=(sngl(outbox(2,1))-sngl(outbox(1,1)))*0.1
        if (xplmin.ge.sngl(outbox(1,1))) xplmin=sngl(outbox(1,1))-dx
        if (xplmax.le.sngl(outbox(2,1))) xplmax=sngl(outbox(2,1))+dx
        dy=(sngl(outbox(2,2))-sngl(outbox(1,2)))*0.1
        if (yplmin.ge.sngl(outbox(1,2))) yplmin=sngl(outbox(1,2))-dy
        if (yplmax.le.sngl(outbox(2,2))) yplmax=sngl(outbox(2,2))+dy
        dz=(sngl(outbox(2,3))-sngl(outbox(1,3)))*0.1
        if (zplmin.ge.sngl(outbox(1,3))) zplmin=sngl(outbox(1,3))-dz
        if (zplmax.le.sngl(outbox(2,3))) zplmax=sngl(outbox(2,3))+dz
      endif

      dx=(xplmax-xplmin)*0.05
      if (xmin.eq.9999.) then
        xplmin=xplmin-dx
      endif

      if (xmax.eq.9999.) then
        xplmax=xplmax+dx
      endif

      dy=(yplmax-yplmin)*0.05
      if (ymin.eq.9999.) then
        yplmin=yplmin-dy
      endif

      if (ymax.eq.9999.) then
        yplmax=yplmax+dy
      endif

      dz=(zplmax-zplmin)*0.05
      if (zmin.eq.9999.) then
        zplmin=zplmin-dz
      endif

      if (zmax.eq.9999.) then
        zplmax=zplmax+dz
      endif

      if (dx.eq.0.0d0) then
        dx=1.05
        xplmin=xplmin-dx
        xplmax=xplmax+dx
      endif

      if (dy.eq.0.0d0) then
        dy=1.05
        yplmin=yplmin-dy
        yplmax=yplmax+dy
      endif

      if (dz.eq.0.0d0) then
        dz=1.05
        zplmin=zplmin-dz
        zplmax=zplmax+dz
      endif

      if (xplmax.le.xplmin.or.zplmax.le.zplmin.or.zplmax.le.zplmin) then
        write(lun6,*)'*** Warning in clcmag_bpolyplot: Bad coordinate system for plotting '
        goto 9999
      endif

      pscal=min(3.,sqrt(10000./((xplmax-xplmin)*(zplmax-zplmin))))

c--- 3D, top and side views {

      if (jcomment.ne.0) call mtitle(trim(ctitle))

      if (kunduplot_mode.eq.0) then
        call mplset('YMGL',0.5)
        call mplzon(1,1,1,' ')
        call mplfra(0.,10.,0.,10.,'AB')

        call mgset('CHHE',0.4)
        xpl(1)=0.2
        ypl(1)=6.

        xpl(2)=xpl(1)+cosd(phi)*cosd(theta)*0.8
        ypl(2)=ypl(1)+sind(phi)*cosd(theta)*0.8
        call mpl(2,xpl,ypl)
        dx=xpl(2)-xpl(1)
        dy=ypl(2)-ypl(1)
        call mtx(xpl(1)+dx*1.2,ypl(1)+dy*1.2,'x')

        xpl(2)=xpl(1)
        ypl(2)=ypl(1)+cosd(theta)*0.8
        call mpl(2,xpl,ypl)
        dx=xpl(2)-xpl(1)
        dy=ypl(2)-ypl(1)
        call mtx(xpl(1)+dx*1.2,ypl(1)+dy*1.2,'y')

        xpl(2)=xpl(1)+sind(phi)*cosd(theta)*0.8
        ypl(2)=ypl(1)-cosd(phi)*cosd(theta)*0.8
        call mpl(2,xpl,ypl)
        dx=xpl(2)-xpl(1)
        dy=ypl(2)-ypl(1)
        call mtx(xpl(1)+dx*1.2,ypl(1)+dy*1.2,'z')

        call mgset('CHHE',0.5)
        call mtx(4.1,4.7,'upper magnets')
        call mtx(4.1,1.8,'lower magnets')
        call mgset('CHHE',0.4)
        call mtx(4.6,-0.75,'x[mm]')
        call mshplt_set_text_angle(90.)
        call mtx(-1.,2.4,'z[mm]')
        call mshplt_set_text_angle(0.)
        call mplset('YMGL',2.)
        call mplset('YMGL',0.5)
        call mgset('CHHE',0.4)
        call muwk(0,0)
        call mplzon(2,2,1,'S')
      else
        call mplset('YMGL',0.5)
        call mplzon(1,1,1,' ')
        call mplfra(0.,10.,0.,10.,'AB')
        call mgset('CHHE',0.4)

        xpl(1)=1.
        ypl(1)=1.

        xpl(2)=xpl(1)+cosd(phi)*cosd(theta)*0.8
        ypl(2)=ypl(1)+sind(phi)*cosd(theta)*0.8
        call mpl(2,xpl,ypl)
        dx=xpl(2)-xpl(1)
        dy=ypl(2)-ypl(1)
        call mtx(xpl(1)+dx*1.2,ypl(1)+dy*1.2,'x')

        xpl(2)=xpl(1)
        ypl(2)=ypl(1)+cosd(theta)*0.8
        call mpl(2,xpl,ypl)
        dx=xpl(2)-xpl(1)
        dy=ypl(2)-ypl(1)
        call mtx(xpl(1)+dx*1.2,ypl(1)+dy*1.2,'y')

        xpl(2)=xpl(1)+sind(phi)*cosd(theta)*0.8
        ypl(2)=ypl(1)-cosd(phi)*cosd(theta)*0.8
        call mpl(2,xpl,ypl)
        dx=xpl(2)-xpl(1)
        dy=ypl(2)-ypl(1)
        call mtx(xpl(1)+dx*1.2,ypl(1)+dy*1.2,'z')

        call mplzon(1,1,1,'S')
      endif

      iplano=1

c y is vertical (WAVE-system)
      if (theta.eq.0.0.and.phi.eq.0.0.and.kunduplot_mode.eq.0) then

        !call mplfra(xplmin,xplmax,yplmin,yplmax,' ')
        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'x[mm]','y[mm]',' ')
        !call mplax('x (mm)', 'y (mm)')
        !call muwk(0,0)

        if (nbforcx*nbforcy*nbforcz.ne.0)
     &    call undumag_bpolypl2(forxpl,forypl,forcol,12)

        do iline=1,nline

          x=xb(iline)
          y=yb(iline)
          z=zb(iline)
          bx=bxb(iline)
          by=byb(iline)
          bz=bzb(iline)

          if (bx**2+by**2+bz**2.eq.0.0d0) cycle

          imag=nint(rmagb(iline))
          icol=nint(rcolb(iline))
          iplan=nint(rplanb(iline))
          icorn=nint(rcornb(iline))

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &          xpl(i).lt.xplmin.or.
     &          xpl(i).gt.xplmax.or.
     &          ypl(i).lt.yplmin.or.
     &          ypl(i).gt.yplmax.or.
     &          zpl(i).lt.zplmin.or.
     &          zpl(i).gt.zplmax
     &          ) cycle
            enddo

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mshplt_set_line_width(rlwidth/5.)
            call mgset('PLCI',1.)
            call mpl(ncorno,xpl,ypl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*5.0*rlwidth
              ypl(i)=ypl(i)+(yc-ypl(i))*5.0*rlwidth
              zpl(i)=zpl(i)+(zc-zpl(i))*5.0*rlwidth
              zplm(i)=-zpl(i)
            enddo

            call mshplt_set_line_width(rlwidth/2.)
            call mgset('PLCI',rcol)
            call mpl(ncorno,xpl,ypl)

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)

        enddo !nline

        call mshplt_set_line_width(rlwidth*2.)
        do iw=1,ncwires
          rcol=sngl(wire(9,iw))
          call mgset('PLCI',rcol)
          xpl(1)=sngl(wire(3,iw))
          xpl(2)=sngl(wire(6,iw))
          ypl(1)=sngl(wire(4,iw))
          ypl(2)=sngl(wire(7,iw))
          call mpl(2,xpl,ypl)
        enddo
        call mshplt_set_line_width(rlwidth/2.)

      else !:if (theta.eq.0.0.and.phi.eq.0.0) then

        xyzmin=min(xplmin,yplmin,zplmin)
        xyzmax=max(xplmax,yplmax,zplmax)

        call mplfr3(xyzmin,xyzmax,-xyzmax,-xyzmin,xyzmin,xyzmax,theta,phi,'W')

        do iline=1,nline

          x=xb(iline)
          y=yb(iline)
          z=zb(iline)
          bx=bxb(iline)
          by=byb(iline)
          bz=bzb(iline)

          if (bx**2+by**2+bz**2.eq.0.0d0) cycle

          imag=nint(rmagb(iline))
          icol=nint(rcolb(iline))
          iplan=nint(rplanb(iline))
          icorn=nint(rcornb(iline))

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &          xpl(i).lt.xplmin.or.
     &          xpl(i).gt.xplmax.or.
     &          ypl(i).lt.yplmin.or.
     &          ypl(i).gt.yplmax.or.
     &          zpl(i).lt.zplmin.or.
     &          zpl(i).gt.zplmax
     &          ) cycle
            enddo

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',1.)
            call mpl3(ncorno,xpl,zplm,ypl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*0.015*rcol
              ypl(i)=ypl(i)+(yc-ypl(i))*0.015*rcol
              zpl(i)=zpl(i)+(zc-zpl(i))*0.015*rcol
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',rcol)
            call mpl3(ncorno,xpl,zplm,ypl)

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)

        enddo !nline

        call mshplt_set_line_width(rlwidth*2.)
        do iw=1,ncwires
          rcol=sngl(wire(9,iw))
          call mgset('PLCI',rcol)
          xpl(1)=sngl(wire(3,iw))
          xpl(2)=sngl(wire(6,iw))
          ypl(1)=sngl(wire(4,iw))
          ypl(2)=sngl(wire(7,iw))
          zpl(1)=-sngl(wire(5,iw))
          zpl(2)=-sngl(wire(8,iw))
          call mpl3(2,xpl,zpl,ypl)
        enddo
        call mshplt_set_line_width(rlwidth/2.)

      endif !(theta.eq.0.0.and.phi.eq.0.0) then


c      dxt=(xplmax-xplmin)*0.1
c      dyt=(yplmax-yplmin)*0.1
c      dzt=(zplmax-zplmin)*0.1

c      xpl(1)=xplmin
c      xpl(2)=xpl(1)+dxt
c      ypl(1)=yplmin
c      ypl(2)=ypl(1)+dyt
c      zpl(1)=zplmin
c      zpl(2)=zpl(1)+dzt
c
c      call mpl3(2,xpl,zpl,ypl)
c
c      call mgset('CHHE',0.4)
c      call mtx(xpl(1)+dxt,ypl(1),zpl(1),'x')

      call muwk(0,0)

      if (kunduplot_mode.ne.0) goto 9999

c--- 3D }

c--- y vs z or z vs y {

      !call mplfra(zplmin,zplmax,yplmin,yplmax,' ')
      !call mplax('z (mm)', 'y (mm)')
      call mshplt_frame(zplmin,zplmax,yplmin,yplmax,'z[mm]','y[mm]',' ')
      if (nbforcx*nbforcy*nbforcz.ne.0)
     &  call undumag_bpolypl2(forzpl,forypl,forcol,23)

      iplano=1

      do iline=1,nline

        x=xb(iline)
        y=yb(iline)
        z=zb(iline)
        bx=bxb(iline)
        by=byb(iline)
        bz=bzb(iline)

        if (bx**2+by**2+bz**2.eq.0.0d0) cycle

        imag=nint(rmagb(iline))
        icol=nint(rcolb(iline))
        iplan=nint(rplanb(iline))
        icorn=nint(rcornb(iline))

        ncorn=abs(icorn)

        if (iline.eq.nline) then

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)

        endif !(iline.eq.nline

        if(iplan.ne.iplano.or.iline.eq.nline) then

          do i=1,ncorno
            zplm(i)=-zpl(i)
          enddo

          call mshplt_set_line_width(rlwidth/5.)
          call mgset('PLCI',1.)
          call mpl(ncorno,zpl,ypl)

          xc=0.
          yc=0.
          zc=0.

          do i=1,ncorno-1
            xc=xc+xpl(i)
            yc=yc+ypl(i)
            zc=zc+zpl(i)
          enddo

          xc=xc/(ncorno-1)
          yc=yc/(ncorno-1)
          zc=zc/(ncorno-1)

          izero=0
          do i=1,ncorno
            if (
     &        abs(yc-ypl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &        ) izero=1
            xpl(i)=xpl(i)+(xc-xpl(i))*2.0*rlwidth
            ypl(i)=ypl(i)+(yc-ypl(i))*2.0*rlwidth
            zpl(i)=zpl(i)+(zc-zpl(i))*2.0*rlwidth
            zplm(i)=-zpl(i)
          enddo

          call mgset('PLCI',rcol)

          if (izero.ne.0) call mpl(ncorno,zpl,ypl)

        endif !iplano

        xpl(ncorn)=x
        ypl(ncorn)=y
        zpl(ncorn)=z

        iplano=iplan
        ncorno=ncorn
        rcol=rcolb(iline)

      enddo !nline

      call mshplt_set_line_width(rlwidth*2.)
      do iw=1,ncwires
        rcol=sngl(wire(9,iw))
        call mgset('PLCI',rcol)
        xpl(1)=sngl(wire(3,iw))
        xpl(2)=sngl(wire(6,iw))
        ypl(1)=sngl(wire(4,iw))
        ypl(2)=sngl(wire(7,iw))
        zpl(1)=sngl(wire(5,iw))
        zpl(2)=sngl(wire(8,iw))
        call mpl(2,zpl,ypl)
      enddo
      call mshplt_set_line_width(rlwidth/2.)

      call mshplt_set_line_width(rlwidtho)

      if (nbforcx*nbforcy*nbforcz.ne.0)
     &  call undumag_bpolypl2(forzpl,forypl,forcol,23)

c--- y vs z or z vs y }

c--- top views of girder {

      call muwk(0,0)
      call mplzon(1,4,3,'S')

      do igird=1,2

c--- z vs x, y is vertical coordinate {
        !hier
        call mplfra(xplmin,xplmax,zplmin,zplmax,' ')
        !call mplax('x (mm)', 'z (mm)')
        !call mshplt_frame(xplmin,xplmax,zplmin,zplmax,'x[mm]','z[mm]',' ')

        if (nbforcx*nbforcy*nbforcz.ne.0)
     &    call undumag_bpolypl2(forxpl,forzpl,forcol,13)

        if (nline.gt.0) then
          imago=int(rmagb(nline))
          kpole=ispole(imago)
          iplano=1
          impl=0
        endif

        do iline=1,nline

          x=xb(iline)
          y=yb(iline)
          z=zb(iline)
          bx=bxb(iline)
          by=byb(iline)
          bz=bzb(iline)

          if (bx**2+by**2+bz**2.eq.0.0d0) cycle

          imag=nint(rmagb(iline))
          icol=nint(rcolb(iline))
          iplan=nint(rplanb(iline))
          icorn=nint(rcornb(iline))

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if (imag.ne.imago.or.iline.eq.nline) then

            xmc(1)=0.
            ymc(1)=0.
            zmc(1)=0.

            xmmx=-1.0e30
            xmmn= 1.0e30
            ymmx=-1.0e30
            ymmn= 1.0e30
            zmmx=-1.0e30
            zmmn= 1.0e30

            do i=1,impl-1
              xmc(1)=xmc(1)+xmpl(i)
              ymc(1)=ymc(1)+ympl(i)
              zmc(1)=zmc(1)+zmpl(i)
              if (xmpl(i).gt.xmmx) xmmx=xmpl(i)
              if (xmpl(i).lt.xmmn) xmmn=xmpl(i)
              if (ympl(i).gt.ymmx) ymmx=ympl(i)
              if (ympl(i).lt.ymmn) ymmn=ympl(i)
              if (zmpl(i).gt.zmmx) zmmx=zmpl(i)
              if (zmpl(i).lt.zmmn) zmmn=zmpl(i)
            enddo

            xmc(1)=xmc(1)/(impl-1)
            ymc(1)=ymc(1)/(impl-1)
            zmc(1)=zmc(1)/(impl-1)

            dx=xmmx-xmmn
            dy=ymmx-ymmn
            dz=zmmx-zmmn

            impl=0

          endif !imag.ne.imago

          impl=impl+1

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            xmpl(impl)=x
            ympl(impl)=y
            zmpl(impl)=z

            bxo=bx
            byo=by
            bzo=bz

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            if (igird.eq.1.and.yc.ge.0.0) then

              do i=1,ncorno
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',1.)
              call mpl(ncorno,xpl,zpl)

              izero=0
              do i=1,ncorno
                if (
     &            abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &            ) izero=1
                xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcol
                ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcol
                zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcol
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcol)
              if (izero.ne.0) call mpl(ncorno,xpl,zpl)

              if (imag.ne.imago.or.iline.eq.nline) then

                bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                if (abs(bxo).lt.bo*eps) bxo=0.0
                if (abs(byo).lt.bo*eps) byo=0.0
                if (abs(bzo).lt.bo*eps) bzo=0.0

                xplb(1)=xmc(1)-2.*bxo/bo*dx/6.
                xplb(2)=xmc(1)+2.*bxo/bo*dx/6.
                yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                zplb(1)=zmc(1)-2.*bzo/bo*dz/5.
                zplb(2)=zmc(1)+2.*bzo/bo*dz/5.

                xplbo(1)=xplb(1)
                xplbo(2)=xplb(2)
                yplbo(1)=yplb(1)
                yplbo(2)=yplb(2)
                zplbo(1)=zplb(1)
                zplbo(2)=zplb(2)

                if (kpole.eq.0) call mpl(2,xplbo,zplbo)

                vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                if (vn.ne.0.0d0) then

                  vnx=(xplbo(2)-xplbo(1))/vn
                  vnz=(zplbo(2)-zplbo(1))/vn

                  xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                  xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                endif !vn

                if (byo.gt.1.e-9) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp20)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                else if (byo.lt.0.0) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp31)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                endif

              endif !imago

            else if (igird.eq.2.and.yc.le.0.0) then

              do i=1,ncorno
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',1.)
              call mpl(ncorno,xpl,zpl)

              izero=0
              do i=1,ncorno
                if (
     &            abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &            ) izero=1
                xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcol
                ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcol
                zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcol
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcol)
              if (izero.ne.0) call mpl(ncorno,xpl,zpl)

              if (imag.ne.imago.or.iline.eq.nline) then

                bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)
                if (abs(bxo).lt.bo*eps) bxo=0.0
                if (abs(byo).lt.bo*eps) byo=0.0
                if (abs(bzo).lt.bo*eps) bzo=0.0

                xplb(1)=xmc(1)-2.*bxo/bo*dx/6.
                xplb(2)=xmc(1)+2.*bxo/bo*dx/6.
                yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                zplb(1)=zmc(1)-2.*bzo/bo*dz/5.
                zplb(2)=zmc(1)+2.*bzo/bo*dz/5.

                xplbo(1)=xplb(1)
                xplbo(2)=xplb(2)
                yplbo(1)=yplb(1)
                yplbo(2)=yplb(2)
                zplbo(1)=zplb(1)
                zplbo(2)=zplb(2)

                if (kpole.eq.0) call mpl(2,xplbo,zplbo)

                vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                if (vn.ne.0.0d0) then

                  vnx=(xplbo(2)-xplbo(1))/vn
                  vnz=(zplbo(2)-zplbo(1))/vn

                  xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                  xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                endif !vn

                if (byo.gt.1.e-9) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp20)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                else if (byo.lt.0.0) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp31)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                endif

              endif !imago

            endif !yc

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          xmpl(impl)=x
          ympl(impl)=y
          zmpl(impl)=z

          bxo=bx
          byo=by
          bzo=bz

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)
          imago=imag
          kpole=ispole(imago)

        enddo !nline

        if (nbforcx*nbforcy*nbforcz.ne.0) call undumag_bpolypl2(forxpl,forzpl,forcol,13)

        if (igird.eq.1) then
          call mshplt_set_line_width(rlwidth*2.)
          do iw=1,ncwires
            rcol=sngl(wire(9,iw))
            call mgset('PLCI',rcol)
            xpl(1)=sngl(wire(3,iw))
            xpl(2)=sngl(wire(6,iw))
            ypl(1)=sngl(wire(4,iw))
            ypl(2)=sngl(wire(7,iw))
            zpl(1)=sngl(wire(5,iw))
            zpl(2)=sngl(wire(8,iw))
            if (ypl(1).gt.0.0.or.ypl(2).gt.0.0) call mpl(2,xpl,zpl)
          enddo
          call mshplt_set_line_width(rlwidth/2.)
        else
          call mshplt_set_line_width(rlwidth*2.)
          do iw=1,ncwires
            rcol=sngl(wire(9,iw))
            call mgset('PLCI',rcol)
            xpl(1)=sngl(wire(3,iw))
            xpl(2)=sngl(wire(6,iw))
            ypl(1)=sngl(wire(4,iw))
            ypl(2)=sngl(wire(7,iw))
            zpl(1)=sngl(wire(5,iw))
            zpl(2)=sngl(wire(8,iw))
            if (ypl(1).lt.0.0.or.ypl(2).lt.0.0) call mpl(2,xpl,zpl)
          enddo
          call mshplt_set_line_width(rlwidth/2.)
        endif

      enddo !igird

      call muwk(0,0)

c--- y vs x }

c--- top views of girder}

c--- 3D, top and side views }

9999  continue

      if (iallo.eq.1) then
        deallocate(xpl)
        deallocate(ypl)
        deallocate(zpl)
        deallocate(zplm)
        deallocate(xmpl)
        deallocate(ympl)
        deallocate(zmpl)
      endif

c      call mgmeta(0,0)
c      call mplend

      call mshplt_end

      write(lun6,*)"Done"
      write(lun6,*)

      deallocate(rmothb,rmagb,rcolb,rplanb,rcornb,
     &  xb,yb,zb,bxb,byb,bzb,rmatb)

      return
      end
+PATCH,TEX,T=LATEX.
*CMZ :  1.02/01 05/09/2016  08.18.58  by  Michael Scheer
+KEEP,udocvers,T=LATEX.
*CMZ :  2.04/10 23/08/2023  16.14.31  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.16.48  by  Michael Scheer
*CMZ :  2.04/08 11/08/2023  14.57.08  by  Michael Scheer
*CMZ :  2.04/07 10/08/2023  09.14.02  by  Michael Scheer
*CMZ :  2.04/06 07/08/2023  10.05.29  by  Michael Scheer
*CMZ :  2.04/04 14/03/2023  11.22.26  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  16.38.01  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  20.57.20  by  Michael Scheer
*CMZ :  2.04/00 17/01/2023  13.14.13  by  Michael Scheer
*CMZ :  2.03/00 02/09/2022  07.21.32  by  Michael Scheer
*CMZ :  2.02/02 07/07/2022  18.13.06  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.40.43  by  Michael Scheer
*CMZ :  2.01/07 28/07/2020  10.27.15  by  Michael Scheer
*CMZ :  2.01/06 27/07/2020  12.07.59  by  Michael Scheer
*CMZ :  2.01/05 27/07/2020  10.28.00  by  Michael Scheer
*CMZ :  2.01/04 29/07/2019  12.06.40  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  15.17.18  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.51.26  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  15.06.30  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  15.01.01  by  Michael Scheer
*CMZ :  1.23/00 04/08/2017  09.35.04  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.36.01  by  Michael Scheer
*CMZ :  1.21/00 29/06/2017  16.12.16  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  11.27.31  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.34.58  by  Michael Scheer
*CMZ :  1.18/00 06/06/2017  14.48.14  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  16.57.03  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  14.11.11  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  12.03.00  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  12.54.38  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  17.04.56  by  Michael Scheer
*CMZ :  1.12/00 27/02/2017  15.49.37  by  Michael Scheer
*CMZ :  1.11/00 05/01/2017  09.37.44  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.20.28  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  12.55.22  by  Michael Scheer
*CMZ :  1.08/00 30/09/2016  13.55.02  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  15.02.55  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  18.55.37  by  Michael Scheer
*CMZ :  1.02/01 05/09/2016  08.41.09  by  Michael Scheer
*-- Author :    Michael Scheer   05/09/2016
Version 2.04/10
+PATCH,PYTHON,T=PYTHON.
*CMZ :  2.01/05 26/02/2020  09.19.37  by  Michael Scheer
+KEEP,listcoils,T=PYTHON.
*CMZ :  2.04/10 20/08/2023  11.16.14  by  Michael Scheer
*CMZ :  2.03/00 18/07/2022  08.56.07  by  Michael Scheer
*CMZ :  2.02/02 08/03/2022  12.31.36  by  Michael Scheer
*CMZ :  2.02/00 16/03/2021  16.15.56  by  Michael Scheer
*-- Author :    Michael Scheer   02/02/2021
S_CylrIn = StringVar()
S_CylrOut = StringVar()
S_CylHeight = StringVar()
S_CyldPhi = StringVar()

S_Current_Coil = StringVar()
S_Name_Coil = StringVar()
S_nWindings_Coil = StringVar()
S_Filling_Coil = StringVar()
S_Xcen_Coil = StringVar()
S_Ycen_Coil = StringVar()
S_Zcen_Coil = StringVar()
S_VnX_Coil = StringVar()
S_VnY_Coil = StringVar()
S_VnZ_Coil = StringVar()
S_AngRot_Coil = StringVar()
S_xLenOut_Coil = StringVar()
S_zLenIn_Coil = StringVar()
S_zLenOut_Coil = StringVar()
S_RadiusIn_Coil = StringVar()
S_Height_Coil = StringVar()
S_nDivHeight_Coil = StringVar()
S_nDivWidth_Coil = StringVar()
S_nDivArc_Coil = StringVar()
S_Color_Coil = StringVar()

S_CylrIn.set('0.0')
S_CylrOut.set('40.')
S_CylHeight.set('40.')
S_CyldPhi.set('360.')

S_Current_Coil.set('1.0')
S_Name_Coil.set('CoilName')
S_Filling_Coil.set('1.0')
S_nWindings_Coil.set('1')
S_Xcen_Coil.set('30.')
S_Zcen_Coil.set('0.0')
S_VnX_Coil.set('0.0')
S_VnY_Coil.set('1.0')
S_VnZ_Coil.set('0.0')
S_AngRot_Coil.set('0.0')
S_xLenOut_Coil.set('50.0')
S_zLenIn_Coil.set('20.')
S_zLenOut_Coil.set('30.')
S_RadiusIn_Coil.set('10.')
height = 20.
S_Height_Coil.set(str(height))
S_nDivHeight_Coil.set('11')
S_Ycen_Coil.set(str(height))
S_nDivWidth_Coil.set('11')
S_nDivArc_Coil.set('6')
S_Color_Coil.set('green')

def _Check_Coil(coil):
    for var in coil[1]:
        try:
            val = calc_var(var)
        except:
            wError("Bad item " + var)
            return 1
        #endtry
    #endfor ic in range(len(coil))
    return 0
#enddef _Check_Coil()

def Set_Coil(k):
+seq,uguiglobind.

  color = S_Color_Coil.get()

  if color[0] != '$':
    try: color = str(DictUnduColors[color])
    except:
      wError("Unkown color: " + color)
      return
  #endif

  print(k,NL,Coils[k])
  Quit("Ende in set_coil")

  coil = [Coils[k][0],[S_Current_Coil.get(),S_Filling_Coil.get(),S_nWindings_Coil.get(), \
  S_Xcen_Coil.get(),S_Ycen_Coil.get(),S_Zcen_Coil.get(),S_VnX_Coil.get(), \
  S_VnY_Coil.get(),S_VnZ_Coil.get(),S_AngRot_Coil.get(),S_xLenOut_Coil.get(), \
  S_zLenIn_Coil.get(),S_zLenOut_Coil.get(),S_RadiusIn_Coil.get(),S_Height_Coil.get(), \
  S_nDivHeight_Coil.get(),S_nDivWidth_Coil.get(),S_nDivArc_Coil.get(), \
  color]]

  if _Check_Coil(coil): return 1

  Coils[k] = coil
#  try: coil[1][18] = UnduColors[int(coil[1][18])]
#  except: pass

  undu_coils_to_filaments()

  return 0

#enddef Set_Coil(k)

def Get_Coil(k):
+seq,uguiglobind.
  global Coils

  print(k,NL,Coils[k])
  Quit("Ende in set_coil")

  if Coils[k][0][0] == 'RectWindings':
    par = Coils[k][1]
    S_Name_Coil.set(str(par[0]))
    S_Current_Coil.set(str(par[1]))
    S_Filling_Coil.set(str(par[2]))
    S_nWindings_Coil.set(str(par[3]))
    S_Xcen_Coil.set(str(par[4]))
    S_Ycen_Coil.set(str(par[5]))
    S_Zcen_Coil.set(str(par[6]))
    S_VnX_Coil.set(str(par[7]))
    S_VnY_Coil.set(str(par[8]))
    S_VnZ_Coil.set(str(par[9]))
    S_AngRot_Coil.set(str(par[10]))
    S_xLenOut_Coil.set(str(par[11]))
    S_zLenIn_Coil.set(str(par[12]))
    S_zLenOut_Coil.set(str(par[13]))
    S_RadiusIn_Coil.set(str(par[14]))
    S_Height_Coil.set(str(par[15]))
    S_nDivHeight_Coil.set(str(par[16]))
    S_nDivWidth_Coil.set(str(par[17]))
    S_nDivArc_Coil.set(str(par[18]))
    color = str(par[19])
    try: color = UnduColors[int(color)]
    except:pass
    try: color = DictUnduColors[color]
    except:pass
    S_Color_Coil.set(color)
  #endif

#enddef Get_Coil(k)

global WediCoil

def update_coils():
+seq,uguiglobind.

  NCoil = len(Coils)
  DictCoils = {}
  idxcoil = 0

  for coil in Coils:
    key = coil[0][0]
    if not key in DictCoils: DictCoils[key] = []
    DictCoils[key].append(idxcoil)
    idxcoil += 1
  #endfor

#enddef updatecoils()

def _WaddCoils(key=''):
+seq,uguiglobind.

  WaddCoils = Toplevel()
  WaddCoils.title("Add Coil")
  WaddCoils.attributes('-topmost', 1)

  ewid=50
  elab=20

  bRace = Button(WaddCoils,text='Racetrack, rect. wind.',
                 command = _WaddCoilRace,width=elab)
  bRace.pack(expand=TRUE,fill=X)

  fbott = Frame(WaddCoils)
  bCancel = Button(fbott,text='Cancel',command = _cnWaddCoils,width=elab)
  bCancel.pack(fill=X)
  fbott.pack(expand=TRUE,fill=X)

  x,y = Umaster.winfo_pointerxy()
  sgeo = '+' + str(x) + '+' + str(y)
  WaddCoils.geometry(sgeo)

  Umaster.wait_window(WaddCoils)

#enddef _WaddCoils(key)

def _WaddCoilRace():
+seq,uguiglobind.

  WaddCoilRace = Toplevel()
  WaddCoilRace.title("Add Racetrack Coil")
  WaddCoilRace.attributes('-topmost', 1)

  ewid=50
  elab=20

  fname = Frame(WaddCoilRace)
  tname = 'Name'
  lname = Label(fname,text=tname,font=MyFont,width=elab)
  ename = Entry(fname,text=S_Name_Coil,justify=CENTER,font=MyFont,width=ewid)
  lname.pack(side=LEFT,fill=X)
  ename.pack(side=RIGHT,fill=X)
  fname.pack(fill=X)

  fCurr = Frame(WaddCoilRace)
  tCurr = 'Current [A]'
  lCurr = Label(fCurr,text=tCurr,font=MyFont,width=elab)
  eCurr = Entry(fCurr,text=S_Current_Coil,justify=CENTER,font=MyFont,width=ewid)
  lCurr.pack(side=LEFT,fill=X)
  eCurr.pack(side=RIGHT,fill=X)
  fCurr.pack(fill=X)

  fFilling = Frame(WaddCoilRace)
  tFilling = 'Fillfactor'
  lFilling = Label(fFilling,text=tFilling,font=MyFont,width=elab)
  eFilling = Entry(fFilling,text=S_Filling_Coil,justify=CENTER,font=MyFont,width=ewid)
  lFilling.pack(side=LEFT,fill=X)
  eFilling.pack(side=RIGHT,fill=X)
  fFilling.pack(fill=X)

  fnWindings = Frame(WaddCoilRace)
  tnWindings = 'Number of windings'
  lnWindings = Label(fnWindings,text=tnWindings,font=MyFont,width=elab)
  enWindings = Entry(fnWindings,text=S_nWindings_Coil,justify=CENTER,font=MyFont,width=ewid)
  lnWindings.pack(side=LEFT,fill=X)
  enWindings.pack(side=RIGHT,fill=X)
  fnWindings.pack(fill=X)

  fXcen = Frame(WaddCoilRace)
  tXcen = 'X center'
  lXcen = Label(fXcen,text=tXcen,font=MyFont,width=elab)
  eXcen = Entry(fXcen,text=S_Xcen_Coil,justify=CENTER,font=MyFont,width=ewid)
  lXcen.pack(side=LEFT,fill=X)
  eXcen.pack(side=RIGHT,fill=X)
  fXcen.pack(fill=X)

  fYcen = Frame(WaddCoilRace)
  tYcen = 'Y center'
  lYcen = Label(fYcen,text=tYcen,font=MyFont,width=elab)
  eYcen = Entry(fYcen,text=S_Ycen_Coil,justify=CENTER,font=MyFont,width=ewid)
  lYcen.pack(side=LEFT,fill=X)
  eYcen.pack(side=RIGHT,fill=X)
  fYcen.pack(fill=X)

  fZcen = Frame(WaddCoilRace)
  tZcen = 'Z center'
  lZcen = Label(fZcen,text=tZcen,font=MyFont,width=elab)
  eZcen = Entry(fZcen,text=S_Zcen_Coil,justify=CENTER,font=MyFont,width=ewid)
  lZcen.pack(side=LEFT,fill=X)
  eZcen.pack(side=RIGHT,fill=X)
  fZcen.pack(fill=X)

  fVnX = Frame(WaddCoilRace)
  tVnX = 'X of normal vector'
  lVnX = Label(fVnX,text=tVnX,font=MyFont,width=elab)
  eVnX = Entry(fVnX,text=S_VnX_Coil,justify=CENTER,font=MyFont,width=ewid)
  lVnX.pack(side=LEFT,fill=X)
  eVnX.pack(side=RIGHT,fill=X)
  fVnX.pack(fill=X)

  fVnY = Frame(WaddCoilRace)
  tVnY = 'Y of normal vector'
  lVnY = Label(fVnY,text=tVnY,font=MyFont,width=elab)
  eVnY = Entry(fVnY,text=S_VnY_Coil,justify=CENTER,font=MyFont,width=ewid)
  lVnY.pack(side=LEFT,fill=X)
  eVnY.pack(side=RIGHT,fill=X)
  fVnY.pack(fill=X)

  fVnZ = Frame(WaddCoilRace)
  tVnZ = 'Z of normal vector'
  lVnZ = Label(fVnZ,text=tVnZ,font=MyFont,width=elab)
  eVnZ = Entry(fVnZ,text=S_VnZ_Coil,justify=CENTER,font=MyFont,width=ewid)
  lVnZ.pack(side=LEFT,fill=X)
  eVnZ.pack(side=RIGHT,fill=X)
  fVnZ.pack(fill=X)

  fAngRot = Frame(WaddCoilRace)
  tAngRot = 'Rotation angle'
  lAngRot = Label(fAngRot,text=tAngRot,font=MyFont,width=elab)
  eAngRot = Entry(fAngRot,text=S_AngRot_Coil,justify=CENTER,font=MyFont,width=ewid)
  lAngRot.pack(side=LEFT,fill=X)
  eAngRot.pack(side=RIGHT,fill=X)
  fAngRot.pack(fill=X)

  fxLenOut = Frame(WaddCoilRace)
  txLenOut = 'Total length'
  lxLenOut = Label(fxLenOut,text=txLenOut,font=MyFont,width=elab)
  exLenOut = Entry(fxLenOut,text=S_xLenOut_Coil,justify=CENTER,font=MyFont,width=ewid)
  lxLenOut.pack(side=LEFT,fill=X)
  exLenOut.pack(side=RIGHT,fill=X)
  fxLenOut.pack(fill=X)

  fzLenIn = Frame(WaddCoilRace)
  tzLenIn = 'Inner width'
  lzLenIn = Label(fzLenIn,text=tzLenIn,font=MyFont,width=elab)
  ezLenIn = Entry(fzLenIn,text=S_zLenIn_Coil,justify=CENTER,font=MyFont,width=ewid)
  lzLenIn.pack(side=LEFT,fill=X)
  ezLenIn.pack(side=RIGHT,fill=X)
  fzLenIn.pack(fill=X)

  fzLenOut = Frame(WaddCoilRace)
  tzLenOut = 'Total width'
  lzLenOut = Label(fzLenOut,text=tzLenOut,font=MyFont,width=elab)
  ezLenOut = Entry(fzLenOut,text=S_zLenOut_Coil,justify=CENTER,font=MyFont,width=ewid)
  lzLenOut.pack(side=LEFT,fill=X)
  ezLenOut.pack(side=RIGHT,fill=X)
  fzLenOut.pack(fill=X)

  fRadiusIn = Frame(WaddCoilRace)
  tRadiusIn = 'Inner radius of arcs'
  lRadiusIn = Label(fRadiusIn,text=tRadiusIn,font=MyFont,width=elab)
  eRadiusIn = Entry(fRadiusIn,text=S_RadiusIn_Coil,justify=CENTER,font=MyFont,width=ewid)
  lRadiusIn.pack(side=LEFT,fill=X)
  eRadiusIn.pack(side=RIGHT,fill=X)
  fRadiusIn.pack(fill=X)

  fHeight = Frame(WaddCoilRace)
  tHeight = 'Height'
  lHeight = Label(fHeight,text=tHeight,font=MyFont,width=elab)
  eHeight = Entry(fHeight,text=S_Height_Coil,justify=CENTER,font=MyFont,width=ewid)
  lHeight.pack(side=LEFT,fill=X)
  eHeight.pack(side=RIGHT,fill=X)
  fHeight.pack(fill=X)


  fnDivHeight = Frame(WaddCoilRace)
  tnDivHeight = 'Number of vert. divisions'
  lnDivHeight = Label(fnDivHeight,text=tnDivHeight,font=MyFont,width=elab)
  enDivHeight = Entry(fnDivHeight,text=S_nDivHeight_Coil,justify=CENTER,font=MyFont,width=ewid)
  lnDivHeight.pack(side=LEFT,fill=X)
  enDivHeight.pack(side=RIGHT,fill=X)
  fnDivHeight.pack(fill=X)

  fnDivWidth = Frame(WaddCoilRace)
  tnDivWidth = 'Number of hori. divisions'
  lnDivWidth = Label(fnDivWidth,text=tnDivWidth,font=MyFont,width=elab)
  enDivWidth = Entry(fnDivWidth,text=S_nDivWidth_Coil,justify=CENTER,font=MyFont,width=ewid)
  lnDivWidth.pack(side=LEFT,fill=X)
  enDivWidth.pack(side=RIGHT,fill=X)
  fnDivWidth.pack(fill=X)

  fnDivArc = Frame(WaddCoilRace)
  tnDivArc = 'Number arc divisions'
  lnDivArc = Label(fnDivArc,text=tnDivArc,font=MyFont,width=elab)
  enDivArc = Entry(fnDivArc,text=S_nDivArc_Coil,justify=CENTER,font=MyFont,width=ewid)
  lnDivArc.pack(side=LEFT,fill=X)
  enDivArc.pack(side=RIGHT,fill=X)
  fnDivArc.pack(fill=X)

  fColor = Frame(WaddCoilRace)
  tColor = 'Color'
  lColor = Label(fColor,text=tColor,font=MyFont,width=elab)
  eColor = Entry(fColor,text=S_Color_Coil,justify=CENTER,font=MyFont,width=ewid)
  lColor.pack(side=LEFT,fill=X)
  eColor.pack(side=RIGHT,fill=X)
  fColor.pack(fill=X)

  #debug("+ Race")
  fbott = Frame(WaddCoilRace)

  bCancel = Button(fbott,text='Cancel',command = _cnWaddCoilRace,width=elab)
  bCancel.pack(side=LEFT,fill=X)

  bClose = Button(fbott,text='Ok',command = lambda ct = 'RectWindings': _clWaddCoils(ct))
  bClose.pack(expand=TRUE,fill=X,side=LEFT)

  fbott.pack(expand=TRUE,fill=X)

#  x,y = Umaster.winfo_pointerxy()
#  sgeo = '+' + str(x) + '+' + str(y)
#  WaddCoilRace.geometry(sgeo)

  Umaster.wait_window(WaddCoilRace)

#enddef _WaddCoilRace(key)

def _WeditCoil():
+seq,uguiglobind.

  global WediCoil

  if Selected_Coil == None or Selected_Coil < 0 or Selected_Coil > NCoil:
    wError("No coil selected")
    return
  #endif not Selected_Coil:

  key = Coils[Selected_Coil][0][0]

  if key != 'RectWindings':
    wError("Unknown key " + key + " in WaddCoils")
    return
  #endif key != 'RectWindings'

  WediCoil = Toplevel()
  WediCoil.title("Edit Coil")
  WediCoil.attributes('-topmost', 1)

  Get_Coil(Selected_Coil)

  ewid=20
  elab=20

  fCurr = Frame(WediCoil)
  tCurr = 'Current [A]'
  lCurr = Label(fCurr,text=tCurr,font=MyFont,width=elab)
  eCurr = Entry(fCurr,text=S_Current_Coil,justify=CENTER,font=MyFont,width=ewid)
  lCurr.pack(side=LEFT,fill=X)
  eCurr.pack(side=RIGHT,fill=X)
  fCurr.pack(fill=X)

  fFilling = Frame(WediCoil)
  tFilling = 'Fillfactor'
  lFilling = Label(fFilling,text=tFilling,font=MyFont,width=elab)
  eFilling = Entry(fFilling,text=S_Filling_Coil,justify=CENTER,font=MyFont,width=ewid)
  lFilling.pack(side=LEFT,fill=X)
  eFilling.pack(side=RIGHT,fill=X)
  fFilling.pack(fill=X)

  fnWindings = Frame(WediCoil)
  tnWindings = 'Number of windings'
  lnWindings = Label(fnWindings,text=tnWindings,font=MyFont,width=elab)
  enWindings = Entry(fnWindings,text=S_nWindings_Coil,justify=CENTER,font=MyFont,width=ewid)
  lnWindings.pack(side=LEFT,fill=X)
  enWindings.pack(side=RIGHT,fill=X)
  fnWindings.pack(fill=X)

  fXcen = Frame(WediCoil)
  tXcen = 'X center'
  lXcen = Label(fXcen,text=tXcen,font=MyFont,width=elab)
  eXcen = Entry(fXcen,text=S_Xcen_Coil,justify=CENTER,font=MyFont,width=ewid)
  lXcen.pack(side=LEFT,fill=X)
  eXcen.pack(side=RIGHT,fill=X)
  fXcen.pack(fill=X)

  fYcen = Frame(WediCoil)
  tYcen = 'Y center'
  lYcen = Label(fYcen,text=tYcen,font=MyFont,width=elab)
  eYcen = Entry(fYcen,text=S_Ycen_Coil,justify=CENTER,font=MyFont,width=ewid)
  lYcen.pack(side=LEFT,fill=X)
  eYcen.pack(side=RIGHT,fill=X)
  fYcen.pack(fill=X)

  fZcen = Frame(WediCoil)
  tZcen = 'Z center'
  lZcen = Label(fZcen,text=tZcen,font=MyFont,width=elab)
  eZcen = Entry(fZcen,text=S_Zcen_Coil,justify=CENTER,font=MyFont,width=ewid)
  lZcen.pack(side=LEFT,fill=X)
  eZcen.pack(side=RIGHT,fill=X)
  fZcen.pack(fill=X)

  fVnX = Frame(WediCoil)
  tVnX = 'X of normal vector'
  lVnX = Label(fVnX,text=tVnX,font=MyFont,width=elab)
  eVnX = Entry(fVnX,text=S_VnX_Coil,justify=CENTER,font=MyFont,width=ewid)
  lVnX.pack(side=LEFT,fill=X)
  eVnX.pack(side=RIGHT,fill=X)
  fVnX.pack(fill=X)

  fVnY = Frame(WediCoil)
  tVnY = 'Y of normal vector'
  lVnY = Label(fVnY,text=tVnY,font=MyFont,width=elab)
  eVnY = Entry(fVnY,text=S_VnY_Coil,justify=CENTER,font=MyFont,width=ewid)
  lVnY.pack(side=LEFT,fill=X)
  eVnY.pack(side=RIGHT,fill=X)
  fVnY.pack(fill=X)

  fVnZ = Frame(WediCoil)
  tVnZ = 'Z of normal vector'
  lVnZ = Label(fVnZ,text=tVnZ,font=MyFont,width=elab)
  eVnZ = Entry(fVnZ,text=S_VnZ_Coil,justify=CENTER,font=MyFont,width=ewid)
  lVnZ.pack(side=LEFT,fill=X)
  eVnZ.pack(side=RIGHT,fill=X)
  fVnZ.pack(fill=X)

  fAngRot = Frame(WediCoil)
  tAngRot = 'Rotation angle'
  lAngRot = Label(fAngRot,text=tAngRot,font=MyFont,width=elab)
  eAngRot = Entry(fAngRot,text=S_AngRot_Coil,justify=CENTER,font=MyFont,width=ewid)
  lAngRot.pack(side=LEFT,fill=X)
  eAngRot.pack(side=RIGHT,fill=X)
  fAngRot.pack(fill=X)

  fxLenOut = Frame(WediCoil)
  txLenOut = 'Total length'
  lxLenOut = Label(fxLenOut,text=txLenOut,font=MyFont,width=elab)
  exLenOut = Entry(fxLenOut,text=S_xLenOut_Coil,justify=CENTER,font=MyFont,width=ewid)
  lxLenOut.pack(side=LEFT,fill=X)
  exLenOut.pack(side=RIGHT,fill=X)
  fxLenOut.pack(fill=X)

  fzLenIn = Frame(WediCoil)
  tzLenIn = 'Inner width'
  lzLenIn = Label(fzLenIn,text=tzLenIn,font=MyFont,width=elab)
  ezLenIn = Entry(fzLenIn,text=S_zLenIn_Coil,justify=CENTER,font=MyFont,width=ewid)
  lzLenIn.pack(side=LEFT,fill=X)
  ezLenIn.pack(side=RIGHT,fill=X)
  fzLenIn.pack(fill=X)

  fzLenOut = Frame(WediCoil)
  tzLenOut = 'Total width'
  lzLenOut = Label(fzLenOut,text=tzLenOut,font=MyFont,width=elab)
  ezLenOut = Entry(fzLenOut,text=S_zLenOut_Coil,justify=CENTER,font=MyFont,width=ewid)
  lzLenOut.pack(side=LEFT,fill=X)
  ezLenOut.pack(side=RIGHT,fill=X)
  fzLenOut.pack(fill=X)

  fRadiusIn = Frame(WediCoil)
  tRadiusIn = 'Inner radius of arcs'
  lRadiusIn = Label(fRadiusIn,text=tRadiusIn,font=MyFont,width=elab)
  eRadiusIn = Entry(fRadiusIn,text=S_RadiusIn_Coil,justify=CENTER,font=MyFont,width=ewid)
  lRadiusIn.pack(side=LEFT,fill=X)
  eRadiusIn.pack(side=RIGHT,fill=X)
  fRadiusIn.pack(fill=X)

  fHeight = Frame(WediCoil)
  tHeight = 'Height'
  lHeight = Label(fHeight,text=tHeight,font=MyFont,width=elab)
  eHeight = Entry(fHeight,text=S_Height_Coil,justify=CENTER,font=MyFont,width=ewid)
  lHeight.pack(side=LEFT,fill=X)
  eHeight.pack(side=RIGHT,fill=X)
  fHeight.pack(fill=X)


  fnDivHeight = Frame(WediCoil)
  tnDivHeight = 'Number of vert. divisions'
  lnDivHeight = Label(fnDivHeight,text=tnDivHeight,font=MyFont,width=elab)
  enDivHeight = Entry(fnDivHeight,text=S_nDivHeight_Coil,justify=CENTER,font=MyFont,width=ewid)
  lnDivHeight.pack(side=LEFT,fill=X)
  enDivHeight.pack(side=RIGHT,fill=X)
  fnDivHeight.pack(fill=X)

  fnDivWidth = Frame(WediCoil)
  tnDivWidth = 'Number of hori. divisions'
  lnDivWidth = Label(fnDivWidth,text=tnDivWidth,font=MyFont,width=elab)
  enDivWidth = Entry(fnDivWidth,text=S_nDivWidth_Coil,justify=CENTER,font=MyFont,width=ewid)
  lnDivWidth.pack(side=LEFT,fill=X)
  enDivWidth.pack(side=RIGHT,fill=X)
  fnDivWidth.pack(fill=X)

  fnDivArc = Frame(WediCoil)
  tnDivArc = 'Number arc divisions'
  lnDivArc = Label(fnDivArc,text=tnDivArc,font=MyFont,width=elab)
  enDivArc = Entry(fnDivArc,text=S_nDivArc_Coil,justify=CENTER,font=MyFont,width=ewid)
  lnDivArc.pack(side=LEFT,fill=X)
  enDivArc.pack(side=RIGHT,fill=X)
  fnDivArc.pack(fill=X)

  fColor = Frame(WediCoil)
  tColor = 'Color'
  lColor = Label(fColor,text=tColor,font=MyFont,width=elab)
  try: S_Color_Coil.set(UnduColors[int(S_Color_Coil.get())])
  except: pass
  eColor = Entry(fColor,text=S_Color_Coil,justify=CENTER,font=MyFont,width=ewid)
  lColor.pack(side=LEFT,fill=X)
  eColor.pack(side=RIGHT,fill=X)
  fColor.pack(fill=X)

  fbott = Frame(WediCoil)
  bCancel = Button(fbott,text='Cancel',command = _cnWediCoil,width=elab)
  bCancel.pack(side=LEFT,fill=X)
  bClose = Button(fbott,text='Ok',command = lambda kw=key: _clWediCoil(kw))
  bClose.pack(expand=TRUE,fill=X,side=LEFT)
  fbott.pack(expand=TRUE,fill=X)

  x,y = Umaster.winfo_pointerxy()
  sgeo = '+' + str(x) + '+' + str(y)
  WediCoil.geometry(sgeo)

  Umaster.wait_window(WediCoil)

#enddef _WeditCoil(key)

def _clWaddCoils(key):
+seq,uguiglobind.

  color = S_Color_Coil.get()

  if color[0] != '$':
    try: color = DictUnduColors[color]
    except:
      wError("Unkown color: " + color)
      return
  #endif

  if key == 'RectWindings':

    coil = \
    [S_Current_Coil.get(),S_Filling_Coil.get(),S_nWindings_Coil.get(), \
    S_Xcen_Coil.get(),S_Ycen_Coil.get(),S_Zcen_Coil.get(),S_VnX_Coil.get(), \
    S_VnY_Coil.get(),S_VnZ_Coil.get(),S_AngRot_Coil.get(),S_xLenOut_Coil.get(), \
    S_zLenIn_Coil.get(),S_zLenOut_Coil.get(),S_RadiusIn_Coil.get(),S_Height_Coil.get(), \
    S_nDivHeight_Coil.get(),S_nDivWidth_Coil.get(),S_nDivArc_Coil.get(), \
    str(color)]

  #endif key

  Coils.append([[key,S_Name_Coil.get()],coil])
  NCoil = len(Coils)

  undu_coils_to_filaments(NCoil-1)
  _ucoilplot(mode='notsame',item=NCoil-1)

  if key == 'RectWindings': WaddCoilRace.destroy()
#enddef _clWaddCoils()

def _clWediCoil(key):
  global WediCoil, Selected_Coil

  istat = Set_Coil(Selected_Coil)
  if istat: return

  WediCoil.destroy()
  _listCoils()
#enddef _clWediCoil()

def _cnWaddCoilRace():
+seq,uguiglobind.
  WaddCoilRace.destroy()
#enddef _cnWaddCoilRace()

def _cnWaddCoil():
+seq,uguiglobind.
  WaddCoil.destroy()
#enddef _clWaddCoils()

def _cnWaddCoils():
+seq,uguiglobind.
  WaddCoils.destroy()
#enddef _clWaddCoils()

def _cnWediCoil():
  global WediCoil
  WediCoil.destroy()
#enddef _clWaddCoils()

def _addCoils(key):
  _WaddCoils(key)
#enddef _addCoils()

def _clWlistCoils():
+seq,uguiglobind.
  global WlistCoils
  WlistCoils.destroy()
#enddef _clWlistCoils()

def _listCoils(modecoil='first'):
+seq,uguiglobind.

  global WlistCoils

  update_coils()
  #debug("debug: List coils 1")

  try:
    sgeo = WlistCoils.destroy()
  except: sgeo = None

  WlistCoils = Toplevel()
  WlistCoils.title("List of Coils")
  WlistCoils.attributes('-topmost', 1)

  if len(Coils) == 1: Selected_Coil = 0

  global ButtCoil
  ButtCoil = []

  for key in DictCoils:

    #debug("debug: key")

    fkey = Frame(WlistCoils)
    fhead = Frame(fkey)

    lab = Label(fhead,text="Index",font=MyFont,width=5)
    lab.pack(side=LEFT)
    lab = Label(fhead,text="Type",font=MyFont,width=15)
    lab.pack(side=LEFT)
    lab = Label(fhead,text="Name",font=MyFont,width=15)
    lab.pack(side=LEFT)

    header = DictCoilsHeader[key]
    nhead = len(header)
    lheader = []
    for t in header: lheader.append(len(t))

    ih = -1
    for t in header:
      ih += 1
      lab = Label(fhead,text=t,font=MyFont,width=max(5,lheader[ih]))
      lab.pack(side=LEFT)
    #endfor

    #debug("debug: lhead")
    fhead.pack(side=TOP,fill=X)

    fc = Frame(fkey)

    for icoil in DictCoils[key]:

      iVar = 0

      cidx = str(icoil+1)
      coil = Coils[icoil]
      cnam = coil[0][1]
      fila = Filaments[icoil]
      icol = int(fila[0][8])

      try:
        color = UnduColors[icol]
      except:
        print("*** Error in _listCoils: Unknown color index ***")
        icol = 2
      #endtry

      lab = Label(fc,text=cidx,font=MyFont,bg='white',width=5)
      lab.pack(side=LEFT)
      lab = Label(fc,text=key,font=MyFont,bg='white',width=15)
      lab.pack(side=LEFT)
      lab = Label(fc,text=cnam,font=MyFont,bg='white',width=15)
      lab.pack(side=LEFT)

      #debug("debug:" + key)

      if key == 'Filaments':

        nfil = int(coil[1])

        for ifi in range(nfil):
          fil = coil[2][ifi]
          filfil = Filaments[icoil][ifi]
          iVar = 0
          for var in fil:
            if var[0] == '$':
              iVar = 1
              break
            #endif
          #endfor var in fil
          ic = -1
          for var in fil:
            ic += 1
            if var[0] == '$':
              val = calc_var(var)
              lab = Label(fc,text=var+"\n" +str(val),font=MyFont,bg='white',width=max(5,lheader[ic]))
            else:
              if iVar: lab = Label(fc,text="---\n"+var,font=MyFont,bg='white',width=max(5,lheader[ic]))
              else: lab = Label(fc,text=var,font=MyFont,bg='white',width=max(5,lheader[ic]))
            #endif var[0] == '$'
            lab.pack(side=LEFT)
          #endfor var in fil
          if iVar: lab = Label(fc,text="---\n"+str(filfil[9]),font=MyFont,bg='white',width=max(5,lheader[ic]))
          else: lab = Label(fc,text=str(filfil[9]),font=MyFont,bg='white',width=max(5,lheader[ic]))
          lab.pack(side=LEFT)
        #endfor ic in range(nfil)

      elif key == 'File':

        lab = Label(fc,text=coil[1],font=MyFont,bg='white')
        lab.pack(side=LEFT)

      elif key == "RectArc" or key == "RectBar" or \
      key == "ThickWire" or key == "CircArc":

        ic = -1
        iVar = 0
        for iv in [0,1]:
          for var in coil[1][iv]:
            if var[0] == '$':
              iVar = 1
              break
            #endif
            if iVar: break
          #endfor
        #endfor
        for iv in [0,1]:
          for var in coil[1][iv]:
            ic += 1
            if var[0] == '$':
              val = calc_var(var)
              lab = Label(fc,text=var+"\n" +str(val),font=MyFont,bg='white',width=max(5,lheader[ic]))
            else:
              if iVar: lab = Label(fc,text="---\n"+var,font=MyFont,bg='white',width=max(5,lheader[ic]))
              else: lab = Label(fc,text=var,font=MyFont,bg='white',width=max(5,lheader[ic]))
            #endif var[0] == '$'
            lab.pack(side=LEFT)
          #endfor var
        #endfor

      else: #key

        #print("*** key:",key)
        iVar = 0
        for var in coil[1]:
          if var[0] == '$':
            iVar = 1
            break
          #endif
        #endfor var
        ic = -1
        for var in coil[1]:
          ic += 1
          if var[0] == '$':
            val = calc_var(var)
            lab = Label(fc,text=var+"\n" +str(val),font=MyFont,bg='white',width=max(5,lheader[ic]))
          else:
            if iVar: lab = Label(fc,text="---\n"+var,font=MyFont,bg='white',width=max(5,lheader[ic]))
            else: lab = Label(fc,text=var,font=MyFont,bg='white',width=max(5,lheader[ic]))
          #endif var[0] == '$'
          lab.pack(side=LEFT)
        #endfor var

      #endif key

      lab = Label(fc,text="  ",font=MyFont,bg='white',width=5)
      lab.pack(side=LEFT)

      bi = Button(fc,text='select',command= lambda kcoil=icoil: _SelCoil(kcoil))
      bi.pack(side=LEFT)

      if len(Coils) > 1:
        bi.configure(bg='white')
      else:
        bi.configure(bg='yellow')
        Selected_Coil = 0
      #endif

      ButtCoil.append(bi)

      try:
        if Selected_Coil == icoil: ButtCoil[k].configure(bg='yellow')
      except: pass

      fc.pack(side=BOTTOM,fill=X)

    #endfor i in range(len(coil))

    fkey.pack(side=TOP,fill=X)

  #endfor key

  #debug("debug: List coils 2")

  fbench = Frame(WlistCoils)
  fbottom = Frame(WlistCoils)

  bedit = Button(fbench,text='Edit',command=_editCoil)
  bedit.pack(side=LEFT,expand=TRUE,fill=X)

  bcopy = Button(fbench,text='Copy',command=_copyCoil)
  bcopy.pack(side=LEFT,expand=TRUE,fill=X)

  bdel = Button(fbench,text='Delete',command=_delCoil)
  bdel.pack(side=LEFT,expand=TRUE,fill=X)

  bplot = Button(fbench,text='Plot',command=_plotCoil)
  bplot.pack(side=LEFT,expand=TRUE,fill=X)

  bClose = Button(fbottom,text='Ok',command=_clWlistCoils)
  bClose.pack(expand=TRUE,fill=X)

  fbench.pack(expand=TRUE,fill=X)
  fbottom.pack(expand=TRUE,fill=X)

  WlistCoils.update()

  if not sgeo:
    sgeo = Umaster.geometry()
  else:
    sgeo = sgeo.split('+')
  #endif not len(sgeo)
  x = str(int(sgeo[1]) + 30)
  y = str(int(sgeo[2]) + 80)
  sgeo = '+' + x + '+' + y
  WlistCoils.geometry(sgeo)

#enddef _listCoils()

def _editCoil():
  global Coils,Selected_Coil

  if Selected_Coil == None or Selected_Coil < 0 or Selected_Coil > NCoil:
    wError("No coil seleted")
    return
  #endif

  _WeditCoil()

#enddef _editCoil()

def _copyCoil():
  global Coils,Selected_Coil

  if Selected_Coil == None or Selected_Coil < 0 or Selected_Coil > NCoil:
    wError("No coil seleted")
    return
  #endif

  Coils.append(Coils[Selected_Coil])
  _listCoils()

#enddef _copyCoil()

def _delCoil():
  global Coils,Selected_Coil,Restore_Coil

  if Selected_Coil == None or Selected_Coil < 0 or Selected_Coil > NCoil:
    wError("No coil seleted")
    return
  #endif

  Restore_Coil = Coils.pop(Selected_Coil)
  _listCoils()

#enddef _delCoil()

def _plotCoil():
  global Selected_Coil, NCoil

  if Selected_Coil == None or Selected_Coil < 0 or Selected_Coil >= NCoil:
    wError("No coil seleted")
    return
  #endif not Seletec_Coil

  _ucoilplot(mode='notsame',item=Selected_Coil)
#enddef _plotCoil()

def _SelCoil(k):
  global Selected_Coil,ButtCoil

  if Selected_Coil == k:
    ButtCoil[k].configure(bg='white')
    Selected_Coil = None
  else:
    ButtCoil[k].configure(bg='yellow')
    Selected_Coil = k
  #endif

#enddef _SelCoil(k)
+KEEP,listmags,T=PYTHON.
*CMZ :  2.04/10 21/08/2023  12.38.26  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.15.12  by  Michael Scheer
*CMZ :  2.04/06 07/07/2023  16.37.01  by  Michael Scheer
*CMZ :  2.02/02 05/03/2022  07.51.22  by  Michael Scheer
*CMZ :  2.02/01 21/10/2021  12.11.52  by  Michael Scheer
*CMZ :  2.02/00 30/03/2021  10.36.21  by  Michael Scheer
*-- Author :    Michael Scheer   07/12/2020

# +KEEP,listmags,T=PYTHON.{

S_Iron_Cmag = StringVar()
S_Iron_Cmoth = StringVar()

S_Iron_Ispec = StringVar()

S_Iron_Xcen = StringVar()
S_Iron_Ycen = StringVar()
S_Iron_Zcen = StringVar()

S_Iron_Xlen = StringVar()
S_Iron_Ylen = StringVar()
S_Iron_Zlen = StringVar()

S_Iron_ChamfUs = StringVar()
S_Iron_ChamfDs = StringVar()
S_Iron_Coating = StringVar()

S_Iron_corns = StringVar()
S_Iron_Ncorn = StringVar()
S_Iron_CornFile = StringVar()

S_Iron_nXdiv = StringVar()
S_Iron_nYdiv = StringVar()
S_Iron_nZdiv = StringVar()
S_Iron_FracDivY = StringVar()
S_Iron_FracDivZ = StringVar()

S_Iron_Key = StringVar()
S_Iron_Mat = StringVar()

S_Iron_Bc = StringVar()
S_Iron_Bxn = StringVar()
S_Iron_Byn = StringVar()
S_Iron_Bzn = StringVar()

S_Iron_Color = StringVar()

S_Cmag = StringVar()
S_Cmoth = StringVar()

S_Ispec = StringVar()

S_Xcen = StringVar()
S_Ycen = StringVar()
S_Zcen = StringVar()

S_Xlen = StringVar()
S_Ylen = StringVar()
S_Zlen = StringVar()

S_ChamfUs = StringVar()
S_ChamfDs = StringVar()
S_Coating = StringVar()

S_corns = StringVar()
S_Ncorn = StringVar()
S_CornFile = StringVar()

S_nXdiv = StringVar()
S_nYdiv = StringVar()
S_nZdiv = StringVar()
S_FracDivY = StringVar()
S_FracDivZ = StringVar()

S_Key = StringVar()
S_Mat = StringVar()

S_Bc = StringVar()
S_Bxn = StringVar()
S_Byn = StringVar()
S_Bzn = StringVar()

S_Color = StringVar()

MaddMag.add_command(label='REC block', command= lambda key='Block': _WaddMag(key), font=MyFont)
MaddMag.add_command(label='REC polyhedron', command= lambda key='File': _WaddMag(key), font=MyFont)
MaddMag.add_command(label='REC cylinder', command= lambda key='Cylinder': _WaddMag(key), font=MyFont)
MaddMag.add_command(label='Iron block', command= lambda key='Block': _WaddPol(key), font=MyFont)
MaddMag.add_command(label='Iron polyhedron', command= lambda key='File': _WaddPol(key), font=MyFont)
MaddMag.add_command(label='Iron cylinder', command= lambda key='Cylinder': _WaddPol(key), font=MyFont)

def varlis_to_num(varlis):
  vnum = []

  for v in varlis:
    try:
      val = calc_var(v)
      vnum.append(val)
    except:
      vnum = []
      break
  #endfor v in varlis

  return vnum
#enddef varlis_to_num(varlis)

def read_cornfile(cornfile):

  corns = []

  if not os.path.exists(cornfile):
    wError("File " + cornfile + " not found!")
    return corns
  #endif not os.path.exists(cornfile)

  try:
    Fcorn = open(cornfile,'r')
    lines = Fcorn.readlines()
    Fcorn.close()
  except:  pass
  #endtry

  for line in lines:
    varis = line.strip().split()
    for var in varis:
      try:
        val = calc_var(var)
      except:
        corns = []
        wError("Could not resolve: " + var)
        return ifail, corns
      #endtry
      corns.append(varis)
  #endfor line in lines

  try:
    cornsnum = []
    for c in corns:
      c1 = calc_var(c[0])
      c2 = calc_var(c[1])
      c3 = calc_var(c[2])
      cornsnum.append([c1,c2,c3])
    #endfor
+self,if=-oldhull3d.
    verts,ifaces,faces = hull3d(cornsnum)
    if type(verts) != Tdf:
      hull = pd.DataFrame(verts)
    else:
      hull = verts
    #endif
+self,if=oldhull3d.
    hull = hull3d(cornsnum)
+self.
  except:
    corns = []
  #endtry

  return corns
#enddef read_cornfile()

def update_magnets():
+seq,uguiglobind.

  if MagPolsTot == MagPolsUpdate: return

  Nmoth = 0
  Moths = []
  DictMoths = {}
  DictMagPolsTot = {}
  DictCoils = {}
  DictCoilsHead = {}
  MyMoth = {}
  Hulls = []
  SpecMagPols = []

  for mag in MagPolsDel:
    cnam = mag[0][0]
    if cnam in DictMagPolsSel:
      isel = DictMagPolsSel[mag]
      mpop = MagPolsSel.pop(isel)
    #endif
  #endfor mag in MagPolSel

  NMagPolTot = len(MagPolsTot)
  NMagPolSel = len(MagPolsSel)
  NMagPolDel = len(MagPolsDel)

  for m in range(NMagPolTot):

    mp = MagPolsTot[m]

    cnam = mp[0][0]
    cmoth = mp[0][1]
    typ = mp[3]

    DictMagPolsTot[cnam] = m

    if cmoth in DictMoths:
      moth = DictMoths[cmoth]
      Moths[moth].append(cnam)
    else:
      Nmoth += 1
      Moths.append([])
      Moths[Nmoth-1].append(cnam)
      DictMoths[cmoth] = Nmoth - 1
    #endif cmoth in DictMothHulls

    cen = mp[4]

    xcen = cen[0]
    ycen = cen[1]
    zcen = cen[2]

    xcen = calc_var(xcen)
    ycen = calc_var(ycen)
    zcen = calc_var(zcen)

    if typ.find('Block') > -1:
      corns = blockcorners(mp)
    elif typ == 'Cylinder':
      #print("update_magnets: Cyl hier einfgen")
      MagPolsTot[m][-1] = [xcen,ycen,zcen]
      continue
    elif typ == 'Corners':
      corns = []
      for corn in mp[7]:
        c1 = calc_var(corn[0])
        c2 = calc_var(corn[1])
        c3 = calc_var(corn[2])
        corns.append([c1,c2,c3])
      #endfor
    elif typ == 'File':
      corns = []
      for ic in range(len(mp[7])):
        c1 = calc_var(mp[7][ic][0])
        c2 = calc_var(mp[7][ic][1])
        c3 = calc_var(mp[7][ic][2])
        corns.append([c1,c2,c3])
      #endfor ic in range(len(mp[7]))
    else:
      print("*** Bad key " + typ + " in ureadclc ***")
    #endif typ == 'Block'

    xmin = 1.e30
    xmax = -1.e30
    ymin = 1.e30
    ymax = -1.e30
    zmin = 1.e30
    zmax = -1.e30

    for corn in corns:
      x = corn[0] + xcen
      y = corn[1] + ycen
      z = corn[2] + zcen
      if x < xmin: xmin = x
      if x > xmax: xmax = x
      if y < ymin: ymin = y
      if y > ymax: ymax = y
      if z < zmin: zmin = z
      if z > zmax: zmax = z
    #endfor corn in corns

    x = (xmin+xmax)/2.
    y = (ymin+ymax)/2.
    z = (zmin+zmax)/2.

    MagPolsTot[m][-1] = [x,y,z]

    verts,ifaces,faces = hull3d(corns)
    if type(verts) != Tdf:
      hull = pd.DataFrame(verts)
    else:
      hull = verts
    #endif
    hull.columns = ['xr','yr','zr']

    hull['x'] = hull.xr+xcen
    hull['y'] = hull.yr+ycen
    hull['z'] = hull.zr+zcen

    Hulls.append(hull)

  #endfor m in range(NMagPolTot)

  if NMagPolTot:

    # sort mothers by x

    xmins = 1.e30
    xmaxs = -1.e30
    ymins = 1.e30
    ymaxs = -1.e30
    zmins = 1.e30
    zmaxs = -1.e30

    moli = []

    for mo in range(Nmoth):

      moth = Moths[mo]

      xmin = 1.e30
      xmax = -1.e30
      ymin = 1.e30
      ymax = -1.e30
      zmin = 1.e30
      zmax = -1.e30

      for cmag in moth:
        mag = DictMagPolsTot[cmag]
        mp = MagPolsTot[mag]
        typ = mp[3]
        if typ == 'Cylinder':
          cyl = Ntcyls[DictCyls[cmag]]
          nc = nget(cyl[2])
          nh = Nhead[Ind]
          xmn = nh[6][1]
          xmx = nh[6][2]
          zmn = nh[5][1]
          zmx = nh[7][2]
          ymn = nh[8][1]
          ymx = nh[9][2]
        else:
          nhu = DictHulls[cmag]
          xmn = Hulls[nhu].x.min()
          xmx = Hulls[nhu].x.max()
          ymn = Hulls[nhu].y.min()
          ymx = Hulls[nhu].y.max()
          zmn = Hulls[nhu].z.min()
          zmx = Hulls[nhu].z.max()
        #endif Cyl
        if xmn < xmin: xmin = xmn
        if xmx > xmax: xmax = xmx
        if ymn < ymin: ymin = ymn
        if ymx > ymax: ymax = ymx
        if zmn < zmin: zmin = zmn
        if zmx > zmax: zmax = zmx
        if MagPolsTot[mag][2] == 'yes':
          if xmn < xmins: xmins = xmn
          if xmx > xmaxs: xmaxs = xmx
          if ymn < ymins: ymins = ymn
          if ymx > ymaxs: ymaxs = ymx
          if zmn < zmins: zmins = zmn
          if zmx > zmaxs: zmaxs = zmx
        #endif MagPolsTot[mag][2] == 'yes'
      #endfor mag in moth

      moli.append([mo,
                   xmin,xmax,(xmin+xmax)/2.,
                   ymin,ymax,(ymin+ymax)/2.,
                   zmin,zmax,(zmin+zmax)/2.])

    #endfor mo in range(len(Moths))

    SpecXYZ = [xmins,xmaxs,ymins,ymaxs,zmins,zmaxs]

    MothsXYZ = pd.DataFrame(moli)
    MothsXYZ.columns = ['imoth',
                        'xmin','xmax','x',
                        'ymin','ymax','y',
                        'zmin','zmax','z']
    MothsXYZ = MothsXYZ.sort_values(by=['x','y','z']).reset_index()
    #print("lima:,MothsXYZ",MothsXYZ.query("imoth==0"))
    #print(MothsXYZ)

    mocop = Moths
    Moths = []

    for mo in range(len(mocop)):
      Moths.append(mocop[MothsXYZ.imoth[mo]])
    #endfor mo in range(len(mocop))

    # sort by mothers

    mpcop = MagPolsTot

    MagPolsTot = []

    for mo in range(len(Moths)):
      moth = Moths[mo]
      for mag in moth:
        MyMoth[mag] = mo
        mag = DictMagPolsTot[mag]
        mag = mpcop[mag]
        MagPolsTot.append(mag)
        if mag[2] == 'yes': SpecMagPols.append(mag)
      #endfor mag in moth
    #endfor mo in range(len(Moths))

    NspecMagPol = len(SpecMagPols)

  #endif NMagPolTot

  xmin = 1.e30
  xmax = -1.e30
  ymin = 1.e30
  ymax = -1.e30
  zmin = 1.e30
  zmax = -1.e30

  for mp in SpecMagPols:
    xyz = mp[-1]
    if xyz[0] < xmin: xmin = xyz[0]
    if xyz[0] > xmax: xmax = xyz[0]
    if xyz[1] < ymin: ymin = xyz[1]
    if xyz[1] > ymax: ymax = xyz[1]
    if xyz[2] < zmin: zmin = xyz[2]
    if xyz[2] > zmax: zmax = xyz[2]
  #endfor mp in range(SpecMagPols)

  SpecXYZ = [xmin,xmax,ymin,ymax,zmin,zmax]

  MagPolsUpdate = deepcopy(MagPolsTot)

  Moths = []
  Nmoth = 0
  DictMoths = {}

  for m in range(NMagPolTot):

    mp = MagPolsTot[m]

    cnam = mp[0][0]
    cmoth = mp[0][1]
    typ = mp[3]

    DictMagPolsTot[cnam] = m

    if cmoth in DictMoths:
      moth = DictMoths[cmoth]
      Moths[moth].append(cnam)
    else:
      Nmoth += 1
      Moths.append([])
      Moths[Nmoth-1].append(cnam)
      DictMoths[cmoth] = Nmoth - 1
    #endif cmoth in DictMothHulls

  #endfor

#enddef update_magnets()

def default_mag(key):
+seq,uguiglobind.

  Npol = 0
  for mp in MagPolsTot:
    if mp[1] == 'Iron': Npol += 1
  #endfor mp in MagPolsTot

  if key == 'Block':

    ifound = -1
    l = NMagPol

    for i in range(NMagPol):

      l -= 1

      mp = MagPolsTot[l]
      cnam = mp[0][0]
      cmoth = mp[0][1]
      mattype = mp[1]
      magkey = mp[3]

#      if mattype == 'Iron': Npol += 1

      if mattype == 'REC' and magkey.find('Block') > -1:

        ispec = mp[2]
        cen = mp[4]
        xcen = cen[0]
        ycen = cen[1]
        zcen = cen[2]
        vmat = mp[5]
        bc = calc_var(vmat[0])
        bxn = calc_var(vmat[1])
        byn = calc_var(vmat[2])
        bzn = calc_var(vmat[3])
        mat = vmat[4]
        col = vmat[5]
        siz = mp[6]
        xlen = siz[0]
        ylen = siz[1]
        zlen = siz[2]
        div = mp[7]
        nxdiv = div[0]
        nydiv = div[1]
        nzdiv = div[2]
        fracdivy = div[3]
        fracdivz = div[4]

        if magkey != 'Block':
          chamfus = siz[3]
          chamfds = siz[3]
          if magkey == "BlockUsChamf": chamfds = 0.0
          elif magkey == "BlockDsChamf": chamfus = 0.0
          #endif magkey == "BlockUsChamf"
        #endif magkey != 'Block'

        ifound = l
        break

      #endif mattype == 'REC' and magkey == 'Block'

    #endfor i in range(NMagPlot)

    if ifound > -1:
      S_Cmag.set(cnam)
      S_Cmoth.set(cmoth)
      S_Mat.set(mat)
      S_Color.set(col)
      S_Bc.set(bc)
      S_Bxn.set(bxn)
      S_Byn.set(byn)
      S_Bzn.set(bzn)
      S_Ispec.set(ispec)
      S_Xcen.set(xcen)
      S_Ycen.set(ycen)
      S_Zcen.set(zcen)
      S_Xlen.set(xlen)
      S_Ylen.set(ylen)
      S_Zlen.set(zlen)
      S_ChamfUs.set(chamfus)
      S_ChamfDs.set(chamfds)
      S_nXdiv.set(nxdiv)
      S_nYdiv.set(nydiv)
      S_nZdiv.set(nzdiv)
      S_FracDivY.set(fracdivy)
      S_FracDivZ.set(fracdivz)
      #endif ifound > -1
    else:
      S_Mat.set("1")
      S_Color.set("red")
      S_Bc.set("1.62")
      S_Bxn.set("0.0")
      S_Byn.set("1.0")
      S_Bzn.set("0.0")
      S_Ispec.set("yes")
      S_Xcen.set("-15.0")
      S_Ycen.set("-25.0")
      S_Zcen.set("-20.0")
      S_Xlen.set("10.0")
      S_Ylen.set("40.")
      S_Zlen.set("40.")
      S_ChamfUs.set("0.3")
      S_ChamfDs.set("0.3")
      S_nXdiv.set("1")
      S_nYdiv.set("3")
      S_nZdiv.set("3")
      S_FracDivY.set("1.")
      S_FracDivZ.set("1.")
    #endif NMagPols > 0

  elif key == 'Cylinder':

    ifound = -1
    l = NMagPol

    for i in range(NMagPol):

      l -= 1

      mp = MagPolsTot[l]
      cnam = mp[0][0]
      cmoth = mp[0][1]
      mattype = mp[1]
      magkey = mp[3]

      if mattype == 'REC' and key == 'Cylinder':

        ispec = mp[2]
        cen = mp[4]
        xcen = cen[0]
        ycen = cen[1]
        zcen = cen[2]
        vmat = mp[5]
        bc = calc_var(vmat[0])
        bxn = calc_var(vmat[1])
        byn = calc_var(vmat[2])
        bzn = calc_var(vmat[3])
        mat = vmat[4]
        col = vmat[5]

        size = mp[6]
        rin = float(size[0])
        rout = float(size[1])
        h = float(size[2])
        dphi = float(size[3])
        nphi = int(size[6])+1
        if nphi < int(dphi/45.)+3: nphi = int(dphi/45.)+3

        size = mp[6]
        rin = float(size[0])
        rout = float(size[1])
        h = float(size[2])
        dphi = float(size[3])
        nphi = int(size[6])+1
        if nphi < int(dphi/45.)+3: nphi = int(dphi/45.)+3
        div = mp[7]
        nxdiv = div[0]
        nydiv = div[1]
        nzdiv = nphi
        fracdivy = div[3]
        fracdivz = div[4]
        ifound = l
        break

      #endif mattype == 'REC' and magkey == 'Block'

    #endfor i in range(NMagPlot)

    if ifound > -1:
      S_Cmag.set(cnam)
      S_Cmoth.set(cmoth)
      S_Mat.set(mat)
      S_Color.set(col)
      S_Bc.set(bc)
      S_Bxn.set(bxn)
      S_Byn.set(byn)
      S_Bzn.set(bzn)
      S_Ispec.set(ispec)
      S_Xcen.set(xcen)
      S_Ycen.set(ycen)
      S_Zcen.set(zcen)

      S_CylrIn.set(rin)
      S_CylrOut.set(rout)
      S_CylHeight.set(h)
      S_CyldPhi.set(dphi)

      S_nXdiv.set(nxdiv)
      S_nYdiv.set(nydiv)
      S_nZdiv.set(nzdiv)
      S_FracDivY.set(fracdivy)
      S_FracDivZ.set(fracdivz)
      #endif ifound > -1
    else:
      S_Mat.set("1")
      S_Color.set("red")
      S_Bc.set("1.62")
      S_Bxn.set("0.0")
      S_Byn.set("1.0")
      S_Bzn.set("0.0")
      S_Ispec.set("yes")
      S_Xcen.set("-15.0")
      S_Ycen.set("-25.0")
      S_Zcen.set("-20.0")

      S_CylrIn.set('0.0')
      S_CylrOut.set('40')
      S_CylHeight.set('40.')
      S_CyldPhi.set('360.')

      S_nXdiv.set('1')
      S_nYdiv.set('1')
      S_nZdiv.set('5')
      S_FracDivY.set("1.")
      S_FracDivZ.set("1.")
    #endif NMagPols > 0

  elif key == 'File':

    if NMagPol > 0:

      ifound = -1
      l = NMagPol

      for i in range(NMagPol):

        l -= 1
        mp = MagPolsTot[l]
        cnam = mp[0][0]
        cmoth = mp[0][1]
        mattype = mp[1]
        magkey = mp[3]

        if mattype == 'REC' and magkey == 'File':
          ispec = mp[2]
          cen = mp[4]
          xcen = cen[0]
          ycen = cen[1]
          zcen = cen[2]
          vmat = mp[5]
          bc = calc_var(vmat[0])
          bxn = calc_var(vmat[1])
          byn = calc_var(vmat[2])
          bzn = calc_var(vmat[3])
          mat = vmat[4]
          col = vmat[5]
          div = mp[8]
          nxdiv = div[0]
          nydiv = div[1]
          nzdiv = div[2]
          fracdivy = div[3]
          fracdivz = div[4]
          ifound = l
          break
        #endif mattype == 'REC' and magkey == 'Block'
      #endfor i in range(NMagPlot)

      if ifound > -1:
        S_Cmag.set(cnam)
        S_Cmoth.set(cmoth)
        S_Mat.set(mat)
        S_Color.set(col)
        S_Bc.set(bc)
        S_Bxn.set(bxn)
        S_Byn.set(byn)
        S_Bzn.set(bzn)
        S_Ispec.set(ispec)
        S_Xcen.set(xcen)
        S_Ycen.set(ycen)
        S_Zcen.set(zcen)
        S_CornFile.set("")
        S_nXdiv.set(str(int(nxdiv)))
        S_nYdiv.set(str(int(nydiv)))
        S_nZdiv.set(str(int(nzdiv)))
        S_FracDivY.set(fracdivy)
        S_FracDivZ.set(fracdivz)
      #endif ifound > -1
    else:
      S_Mat.set("1")
      S_Color.set("red")
      S_Bc.set("1.62")
      S_Bxn.set("0.0")
      S_Byn.set("1.0")
      S_Bzn.set("0.0")
      S_Ispec.set("yes")
      S_Xcen.set("-20.0")
      S_Ycen.set("-25.0")
      S_Zcen.set("0.0")
      S_CornFile.set("")
      S_nXdiv.set("1")
      S_nYdiv.set("1")
      S_nZdiv.set("1")
      S_FracDivY.set("1.")
      S_FracDivZ.set("1.")
    #endif NMagPols > 0

  else:
    wError("In default_mag fehlt noch key " + key)
    return
  #endif key == 'Block'

#enddef default_mag(key)

def default_pol(key):
+seq,uguiglobind.

  if key == 'Block':

    if NMagPol > 0:

      ifound = -1
      l = NMagPol

      for i in range(NMagPol):

        l -= 1
        mp = MagPolsTot[l]
        cnam = mp[0][0]
        cmoth = mp[0][1]
        mattype = mp[1]
        magkey = mp[3]

        if mattype == 'Iron' and magkey.find('Block') > -1:

          ispec = mp[2]
          cen = mp[4]
          xcen = cen[0]
          ycen = cen[1]
          zcen = cen[2]
          vmat = mp[5]
          bc = calc_var(vmat[0])
          if bc == 0.0:  bc = 0.001
          mat = vmat[4]
          col = vmat[5]
          siz = mp[6]
          xlen = siz[0]
          ylen = siz[1]
          zlen = siz[2]
          div = mp[7]
          nxdiv = div[0]
          nydiv = div[1]
          nzdiv = div[2]
          fracdivy = div[3]
          fracdivz = div[4]

          if magkey != 'Block':
            chamfus = siz[3]
            chamfds = siz[3]
            if magkey == "BlockUsChamf": chamfds = 0.0
            elif magkey == "BlockDsChamf": chamfus = 0.0
            #endif magkey == "BlockUsChamf"
          #endif magkey != 'Block'

          ifound = l
          break

        #endif mattype == 'REC' and magkey == 'Block'

      #endfor i in range(NMagPlot)

      if ifound > -1:
        S_Iron_Cmag.set(cnam)
        S_Iron_Cmoth.set(cmoth)
        S_Iron_Mat.set(mat)
        S_Iron_Color.set(col)
        S_Iron_Bc.set(bc)
        S_Iron_Ispec.set(ispec)
        S_Iron_Xcen.set(xcen)
        S_Iron_Ycen.set(ycen)
        S_Iron_Zcen.set(zcen)
        S_Iron_Xlen.set(xlen)
        S_Iron_Ylen.set(ylen)
        S_Iron_Zlen.set(zlen)
        S_Iron_ChamfUs.set(chamfus)
        S_Iron_ChamfDs.set(chamfds)
        S_Iron_nXdiv.set(nxdiv)
        S_Iron_nYdiv.set(nydiv)
        S_Iron_nZdiv.set(nzdiv)
        S_Iron_FracDivY.set(fracdivy)
        S_Iron_FracDivZ.set(fracdivz)
      #endif ifound > -1
    else:
      if len(Materials):
        im = 0
        for m in Materials:
          im += 1
          if m[1] == 'Iron':
            S_Iron_Mat.set(str(im))
            break
          #endif
        #endfor
      else:
        S_Iron_Mat.set("2")
      #endif
      S_Iron_Color.set("blue")
      S_Iron_Bc.set("0.001")
      S_Iron_Ispec.set("yes")
      S_Iron_Xcen.set("-5.0")
      S_Iron_Ycen.set("-22.5")
      S_Iron_Zcen.set("-17.5")
      S_Iron_Xlen.set("10.0")
      S_Iron_Ylen.set("35.")
      S_Iron_Zlen.set("35.")
      S_Iron_ChamfUs.set("0.1")
      S_Iron_ChamfDs.set("0.1")
      S_Iron_nXdiv.set("3")
      S_Iron_nYdiv.set("5")
      S_Iron_nZdiv.set("5")
      S_Iron_FracDivY.set("1.")
      S_Iron_FracDivZ.set("1.")
    #endif NMagPols > 0

  elif key == 'File':
    if NMagPol > 0:

      ifound = -1
      l = NMagPol

      for i in range(NMagPol):
        l -= 1
        mp = MagPolsTot[l]
        cnam = mp[0][0]
        cmoth = mp[0][1]
        mattype = mp[1]
        magkey = mp[3]
        if mattype == 'Iron' and magkey == 'File':
          ispec = mp[2]
          cen = mp[4]
          xcen = cen[0]
          ycen = cen[1]
          zcen = cen[2]
          vmat = mp[5]
          bc = calc_var(vmat[0])
          if bc == 0.0:  bc = 0.001
          mat = vmat[4]
          col = vmat[5]
          div = mp[8]
          nxdiv = div[0]
          nydiv = div[1]
          nzdiv = div[2]
          fracdivy = div[3]
          fracdivz = div[4]
          ifound = l
          break
        #endif mattype == 'REC' and magkey == 'Block'
      #endfor i in range(NMagPlot)

      if ifound > -1:
        S_Iron_Cmag.set(cnam)
        S_Iron_Cmoth.set(cmoth)
        S_Iron_Mat.set(mat)
        S_Iron_Color.set(col)
        S_Iron_Bc.set(bc)
        S_Iron_Ispec.set(ispec)
        S_Iron_Xcen.set(xcen)
        S_Iron_Ycen.set(ycen)
        S_Iron_Zcen.set(zcen)
        S_Iron_CornFile.set("")
        S_Iron_nXdiv.set(str(int(nxdiv)))
        S_Iron_nYdiv.set(str(int(nydiv)))
        S_Iron_nZdiv.set(str(int(nzdiv)))
        S_Iron_FracDivY.set(fracdivy)
        S_Iron_FracDivZ.set(fracdivz)
      #endif ifound > -1
    else:
      S_Iron_Mat.set("1")
      S_Iron_Color.set("blue")
      S_Iron_Bc.set("0.001")
      S_Iron_Ispec.set("yes")
      S_Iron_Xcen.set("-20.0")
      S_Iron_Ycen.set("-25.0")
      S_Iron_Zcen.set("0.0")
      S_Iron_CornFile.set("")
      S_Iron_nXdiv.set("1")
      S_Iron_nYdiv.set("1")
      S_Iron_nZdiv.set("1")
      S_Iron_FracDivY.set("1.")
      S_Iron_FracDivZ.set("1.")
    #endif NMagPols > 0

  else:
    wError("In default_pol fehlt noch key " + key)
    return
  #endif key == 'Block'

#enddef default_pol(key)

def _WaddMag(key):
+seq,uguiglobind.

  #print("_WaddMag")
  WaddMag = Toplevel()

  ewid=20

  S_Cmag.set("mag" + str(NMagPolTot+1))
  fName = Frame(WaddMag)
  tName = 'name'
  lName = Label(fName,text=tName,font=MyFont)
  eName = Entry(fName,text=S_Cmag,justify=CENTER,font=MyFont,width=ewid)
  lName.pack(side=LEFT,fill=X)
  eName.pack(side=RIGHT,fill=X)
  fName.pack(fill=X)

  S_Cmoth.set("Moth" + str(Nmoth+1))
  fMoth = Frame(WaddMag)
  tMoth = 'mother volume'
  lMoth = Label(fMoth,text=tMoth,font=MyFont)
  eMoth = Entry(fMoth,text=S_Cmoth,justify=CENTER,font=MyFont,width=ewid)
  lMoth.pack(side=LEFT,fill=X)
  eMoth.pack(side=RIGHT,fill=X)
  fMoth.pack(fill=X)

  default_mag(key)

#  fMatType = Frame(WaddMag)
#  tMatType = 'material type'
#  lMatType = Label(fMatType,text=tMatType,font=MyFont)
#  eMatType = Entry(fMatType,text=S_MateType,justify=CENTER,font=MyFont,width=ewid)
#  lMatType.pack(side=LEFT,fill=X)
#  eMatType.pack(side=RIGHT,fill=X)
#  fMatType.pack(fill=X)

  fMat = Frame(WaddMag)
  tMat = 'material index'
  lMat = Label(fMat,text=tMat,font=MyFont)
  eMat = Entry(fMat,text=S_Mat,justify=CENTER,font=MyFont,width=ewid)
  lMat.pack(side=LEFT,fill=X)
  eMat.pack(side=RIGHT,fill=X)
  fMat.pack(fill=X)

  fColor = Frame(WaddMag)
  tColor = 'color'
  lColor = Label(fColor,text=tColor,font=MyFont)
  eColor = Entry(fColor,text=S_Color,justify=CENTER,font=MyFont,width=ewid)
  lColor.pack(side=LEFT,fill=X)
  eColor.pack(side=RIGHT,fill=X)
  fColor.pack(fill=X)

  fBc = Frame(WaddMag)
  tBc = 'remanence'
  lBc = Label(fBc,text=tBc,font=MyFont)
  eBc = Entry(fBc,text=S_Bc,justify=CENTER,font=MyFont,width=ewid)
  lBc.pack(side=LEFT,fill=X)
  eBc.pack(side=RIGHT,fill=X)
  fBc.pack(fill=X)

  fBxn = Frame(WaddMag)
  tBxn = 'x - component'
  lBxn = Label(fBxn,text=tBxn,font=MyFont)
  eBxn = Entry(fBxn,text=S_Bxn,justify=CENTER,font=MyFont,width=ewid)
  lBxn.pack(side=LEFT,fill=X)
  eBxn.pack(side=RIGHT,fill=X)
  fBxn.pack(fill=X)

  fByn = Frame(WaddMag)
  tByn = 'y - component'
  lByn = Label(fByn,text=tByn,font=MyFont)
  eByn = Entry(fByn,text=S_Byn,justify=CENTER,font=MyFont,width=ewid)
  lByn.pack(side=LEFT,fill=X)
  eByn.pack(side=RIGHT,fill=X)
  fByn.pack(fill=X)

  fBzn = Frame(WaddMag)
  tBzn = 'z - component'
  lBzn = Label(fBzn,text=tBzn,font=MyFont)
  eBzn = Entry(fBzn,text=S_Bzn,justify=CENTER,font=MyFont,width=ewid)
  lBzn.pack(side=LEFT,fill=X)
  eBzn.pack(side=RIGHT,fill=X)
  fBzn.pack(fill=X)

  fIspec = Frame(WaddMag)
  tIspec = 'non-periodic'
  lIspec = Label(fIspec,text=tIspec,font=MyFont)
  eIspec = Entry(fIspec,text=S_Ispec,justify=CENTER,font=MyFont,width=ewid)
  lIspec.pack(side=LEFT,fill=X)
  eIspec.pack(side=RIGHT,fill=X)
  fIspec.pack(fill=X)

  fXcen = Frame(WaddMag)
  tXcen = 'Xref'
  lXcen = Label(fXcen,text=tXcen,font=MyFont)
  eXcen = Entry(fXcen,text=S_Xcen,justify=CENTER,font=MyFont,width=ewid)
  lXcen.pack(side=LEFT,fill=X)
  eXcen.pack(side=RIGHT,fill=X)
  fXcen.pack(fill=X)

  fYcen = Frame(WaddMag)
  tYcen = 'Yref'
  lYcen = Label(fYcen,text=tYcen,font=MyFont)
  eYcen = Entry(fYcen,text=S_Ycen,justify=CENTER,font=MyFont,width=ewid)
  lYcen.pack(side=LEFT,fill=X)
  eYcen.pack(side=RIGHT,fill=X)
  fYcen.pack(fill=X)

  fZcen = Frame(WaddMag)
  tZcen = 'Zref'
  lZcen = Label(fZcen,text=tZcen,font=MyFont)
  eZcen = Entry(fZcen,text=S_Zcen,justify=CENTER,font=MyFont,width=ewid)
  lZcen.pack(side=LEFT,fill=X)
  eZcen.pack(side=RIGHT,fill=X)
  fZcen.pack(fill=X)

  if key == 'Block':

    WaddMag.title("Add Magnet Block")

    fXlen = Frame(WaddMag)
    tXlen = 'Xlen'
    lXlen = Label(fXlen,text=tXlen,font=MyFont)
    eXlen = Entry(fXlen,text=S_Xlen,justify=CENTER,font=MyFont,width=ewid)
    lXlen.pack(side=LEFT,fill=X)
    eXlen.pack(side=RIGHT,fill=X)
    fXlen.pack(fill=X)

    fYlen = Frame(WaddMag)
    tYlen = 'Ylen'
    lYlen = Label(fYlen,text=tYlen,font=MyFont)
    eYlen = Entry(fYlen,text=S_Ylen,justify=CENTER,font=MyFont,width=ewid)
    lYlen.pack(side=LEFT,fill=X)
    eYlen.pack(side=RIGHT,fill=X)
    fYlen.pack(fill=X)

    fZlen = Frame(WaddMag)
    tZlen = 'Zlen'
    lZlen = Label(fZlen,text=tZlen,font=MyFont)
    eZlen = Entry(fZlen,text=S_Zlen,justify=CENTER,font=MyFont,width=ewid)
    lZlen.pack(side=LEFT,fill=X)
    eZlen.pack(side=RIGHT,fill=X)
    fZlen.pack(fill=X)

    fChamfUS = Frame(WaddMag)
    tChamfUS = 'Up-stream chamfer'
    lChamfUS = Label(fChamfUS,text=tChamfUS,font=MyFont)
    eChamfUS = Entry(fChamfUS,text=S_ChamfUs,justify=CENTER,font=MyFont,width=ewid)
    lChamfUS.pack(side=LEFT,fill=X)
    eChamfUS.pack(side=RIGHT,fill=X)
    fChamfUS.pack(fill=X)

    fChamfDS = Frame(WaddMag)
    tChamfDS = 'Down-stream chamfer'
    lChamfDS = Label(fChamfDS,text=tChamfDS,font=MyFont)
    eChamfDS = Entry(fChamfDS,text=S_ChamfDs,justify=CENTER,font=MyFont,width=ewid)
    lChamfDS.pack(side=LEFT,fill=X)
    eChamfDS.pack(side=RIGHT,fill=X)
    fChamfDS.pack(fill=X)

  elif key == 'Cylinder':

    WaddMag.title("Add Magnet Cylinder")

    fXlen = Frame(WaddMag)
    tXlen = 'R_inner'
    lXlen = Label(fXlen,text=tXlen,font=MyFont)
    eXlen = Entry(fXlen,text=S_CylrIn,justify=CENTER,font=MyFont,width=ewid)
    lXlen.pack(side=LEFT,fill=X)
    eXlen.pack(side=RIGHT,fill=X)
    fXlen.pack(fill=X)

    fYlen = Frame(WaddMag)
    tYlen = 'R_outer'
    lYlen = Label(fYlen,text=tYlen,font=MyFont)
    eYlen = Entry(fYlen,text=S_CylrOut,justify=CENTER,font=MyFont,width=ewid)
    lYlen.pack(side=LEFT,fill=X)
    eYlen.pack(side=RIGHT,fill=X)
    fYlen.pack(fill=X)

    fZlen = Frame(WaddMag)
    tZlen = 'Height'
    lZlen = Label(fZlen,text=tZlen,font=MyFont)
    eZlen = Entry(fZlen,text=S_CylHeight,justify=CENTER,font=MyFont,width=ewid)
    lZlen.pack(side=LEFT,fill=X)
    eZlen.pack(side=RIGHT,fill=X)
    fZlen.pack(fill=X)

    fPhi = Frame(WaddMag)
    tPhi = 'Angle range'
    lPhi = Label(fPhi,text=tPhi,font=MyFont)
    ePhi = Entry(fPhi,text=S_CyldPhi,justify=CENTER,font=MyFont,width=ewid)
    lPhi.pack(side=LEFT,fill=X)
    ePhi.pack(side=RIGHT,fill=X)
    fPhi.pack(fill=X)

  elif key == 'File':

    WaddMag.title("Add REC Polyhedron")

    fcfil = Frame(WaddMag)
    tcfil = 'Filename'
    lcfil = Label(fcfil,text=tcfil,font=MyFont)
    ecfil = Entry(fcfil,text=S_CornFile.get(),justify=CENTER,font=MyFont,width=ewid)
    lcfil.pack(side=LEFT,fill=X)
    ecfil.pack(side=RIGHT,fill=X)
    fcfil.pack(fill=X)

  else:
    wError("In _WaddMag fehlt noch key " + key)
    return
  #endif key == 'Block'

  if key != 'Cylinder':

    fnXdiv = Frame(WaddMag)
    tnXdiv = 'nXdiv'
    lnXdiv = Label(fnXdiv,text=tnXdiv,font=MyFont)
    enXdiv = Entry(fnXdiv,text=S_nXdiv,justify=CENTER,font=MyFont,width=ewid)
    lnXdiv.pack(side=LEFT,fill=X)
    enXdiv.pack(side=RIGHT,fill=X)
    fnXdiv.pack(fill=X)

    fnYdiv = Frame(WaddMag)
    tnydiv = 'nYdiv'
    lnYdiv = Label(fnYdiv,text=tnydiv,font=MyFont)
    enYdiv = Entry(fnYdiv,text=S_nYdiv,justify=CENTER,font=MyFont,width=ewid)
    lnYdiv.pack(side=LEFT,fill=X)
    enYdiv.pack(side=RIGHT,fill=X)
    fnYdiv.pack(fill=X)

    fnZdiv = Frame(WaddMag)
    tnzdiv = 'nZdiv'
    lnZdiv = Label(fnZdiv,text=tnzdiv,font=MyFont)
    enZdiv = Entry(fnZdiv,text=S_nZdiv,justify=CENTER,font=MyFont,width=ewid)
    lnZdiv.pack(side=LEFT,fill=X)
    enZdiv.pack(side=RIGHT,fill=X)
    fnZdiv.pack(fill=X)

    fFracDivY = Frame(WaddMag)
    tfracdivy = 'FracDivY'
    lFracDivY = Label(fFracDivY,text=tfracdivy,font=MyFont)
    eFracDivY = Entry(fFracDivY,text=S_FracDivY,justify=CENTER,font=MyFont,width=ewid)
    lFracDivY.pack(side=LEFT,fill=X)
    eFracDivY.pack(side=RIGHT,fill=X)
    fFracDivY.pack(fill=X)
    fFracDivY = Frame(WaddMag)

    fFracDivZ = Frame(WaddMag)
    tfracdivz = 'FracDivZ'
    lFracDivZ = Label(fFracDivZ,text=tfracdivz,font=MyFont)
    eFracDivZ = Entry(fFracDivZ,text=S_FracDivZ,justify=CENTER,font=MyFont,width=ewid)
    lFracDivZ.pack(side=LEFT,fill=X)
    eFracDivZ.pack(side=RIGHT,fill=X)
    fFracDivZ.pack(fill=X)
  else:

    fnXdiv = Frame(WaddMag)
    tnXdiv = 'nR_div'
    lnXdiv = Label(fnXdiv,text=tnXdiv,font=MyFont)
    enXdiv = Entry(fnXdiv,text=S_nXdiv,justify=CENTER,font=MyFont,width=ewid)
    lnXdiv.pack(side=LEFT,fill=X)
    enXdiv.pack(side=RIGHT,fill=X)
    fnXdiv.pack(fill=X)

    fnYdiv = Frame(WaddMag)
    tnydiv = 'nH_div'
    lnYdiv = Label(fnYdiv,text=tnydiv,font=MyFont)
    enYdiv = Entry(fnYdiv,text=S_nYdiv,justify=CENTER,font=MyFont,width=ewid)
    lnYdiv.pack(side=LEFT,fill=X)
    enYdiv.pack(side=RIGHT,fill=X)
    fnYdiv.pack(fill=X)

    fnZdiv = Frame(WaddMag)
    tnzdiv = 'nAng_div'
    lnZdiv = Label(fnZdiv,text=tnzdiv,font=MyFont)
    enZdiv = Entry(fnZdiv,text=S_nZdiv,justify=CENTER,font=MyFont,width=ewid)
    lnZdiv.pack(side=LEFT,fill=X)
    enZdiv.pack(side=RIGHT,fill=X)
    fnZdiv.pack(fill=X)

    #fFracDivY = Frame(WaddMag)
    #tfracdivy = 'FracDivY'
    #lFracDivY = Label(fFracDivY,text=tfracdivy,font=MyFont)
    #eFracDivY = Entry(fFracDivY,text=S_FracDivY,justify=CENTER,font=MyFont,width=ewid)
    #lFracDivY.pack(side=LEFT,fill=X)
    #eFracDivY.pack(side=RIGHT,fill=X)
    #fFracDivY.pack(fill=X)
    #fFracDivY = Frame(WaddMag)

    #fFracDivZ = Frame(WaddMag)
    #tfracdivz = 'FracDivZ'
    #lFracDivZ = Label(fFracDivZ,text=tfracdivz,font=MyFont)
    #eFracDivZ = Entry(fFracDivZ,text=S_FracDivZ,justify=CENTER,font=MyFont,width=ewid)
    #lFracDivZ.pack(side=LEFT,fill=X)
    #eFracDivZ.pack(side=RIGHT,fill=X)
    #fFracDivZ.pack(fill=X)

  #endif Cylinder

  WaddMag.attributes('-topmost', 1)

  fbott = Frame(WaddMag)
  bCancel = Button(fbott,text='Cancel',command = _cnWaddMag)
  bCancel.pack(expand=TRUE,side=LEFT,fill=X)
  bClose = Button(fbott,text='Ok',width=ewid+2,command = lambda kw=key: _clWaddMag(kw))
  bClose.pack(side=LEFT)
  fbott.pack(expand=TRUE,fill=X)

  sgeo = Wmaster.geometry().split('+')
  whw = sgeo[0].split('x')
  ww = int(whw[0])
  wh = int(whw[1])
  xw = int(sgeo[1])
  yw = int(sgeo[2])
  x = xw + int(ww/10)
  y = yw + int(wh/10)
  sgeo = '+' + str(x) + '+' + str(y)
  WaddMag.geometry(sgeo)
#  smgeo = Umaster.geometry()
#  smoff = smgeo.split('+')
#  WaddMag.geometry("+" + str(int(smoff[1])+50) + "+" + str(int(smoff[1])+20))

  Umaster.wait_window(WaddMag)

#enddef _WaddMag(key)

def _WaddPol(key):
+seq,uguiglobind.

  #print("_WaddPol")
  WaddPol = Toplevel()
  sgeo = Wmaster.geometry().split('+')
  whw = sgeo[0].split('x')
  ww = int(whw[0])
  wh = int(whw[1])
  xw = int(sgeo[1])
  yw = int(sgeo[2])
  x = xw + int(ww/10)
  y = yw + int(wh/10)
  sgeo = '+' + str(x) + '+' + str(y)
  WaddPol.geometry(sgeo)
  WaddPol.attributes('-topmost', 1)

  ewid=20

  S_Iron_Cmag.set("pol" + str(Npol+1))
  fName = Frame(WaddPol)
  tName = 'name'
  lName = Label(fName,text=tName,font=MyFont)
  eName = Entry(fName,text=S_Iron_Cmag,justify=CENTER,font=MyFont,width=ewid)
  lName.pack(side=LEFT,fill=X)
  eName.pack(side=RIGHT,fill=X)
  fName.pack(fill=X)

  S_Iron_Cmoth.set("Moth" + str(Nmoth+1))
  fMoth = Frame(WaddPol)
  tMoth = 'mother volume'
  lMoth = Label(fMoth,text=tMoth,font=MyFont)
  eMoth = Entry(fMoth,text=S_Iron_Cmoth,justify=CENTER,font=MyFont,width=ewid)
  lMoth.pack(side=LEFT,fill=X)
  eMoth.pack(side=RIGHT,fill=X)
  fMoth.pack(fill=X)

  default_pol(key)

  fMat = Frame(WaddPol)
  tMat = 'material index'
  lMat = Label(fMat,text=tMat,font=MyFont)
  eMat = Entry(fMat,text=S_Iron_Mat,justify=CENTER,font=MyFont,width=ewid)
  lMat.pack(side=LEFT,fill=X)
  eMat.pack(side=RIGHT,fill=X)
  fMat.pack(fill=X)

  fColor = Frame(WaddPol)
  tColor = 'color'
  lColor = Label(fColor,text=tColor,font=MyFont)
  eColor = Entry(fColor,text=S_Iron_Color,justify=CENTER,font=MyFont,width=ewid)
  lColor.pack(side=LEFT,fill=X)
  eColor.pack(side=RIGHT,fill=X)
  fColor.pack(fill=X)

  fIspec = Frame(WaddPol)
  tIspec = 'non-periodic'
  lIspec = Label(fIspec,text=tIspec,font=MyFont)
  eIspec = Entry(fIspec,text=S_Iron_Ispec,justify=CENTER,font=MyFont,width=ewid)
  lIspec.pack(side=LEFT,fill=X)
  eIspec.pack(side=RIGHT,fill=X)
  fIspec.pack(fill=X)

  fXcen = Frame(WaddPol)
  tXcen = 'Xref'
  lXcen = Label(fXcen,text=tXcen,font=MyFont)
  eXcen = Entry(fXcen,text=S_Iron_Xcen,justify=CENTER,font=MyFont,width=ewid)
  lXcen.pack(side=LEFT,fill=X)
  eXcen.pack(side=RIGHT,fill=X)
  fXcen.pack(fill=X)

  fYcen = Frame(WaddPol)
  tYcen = 'Yref'
  lYcen = Label(fYcen,text=tYcen,font=MyFont)
  eYcen = Entry(fYcen,text=S_Iron_Ycen,justify=CENTER,font=MyFont,width=ewid)
  lYcen.pack(side=LEFT,fill=X)
  eYcen.pack(side=RIGHT,fill=X)
  fYcen.pack(fill=X)

  fZcen = Frame(WaddPol)
  tZcen = 'Zref'
  lZcen = Label(fZcen,text=tZcen,font=MyFont)
  eZcen = Entry(fZcen,text=S_Iron_Zcen,justify=CENTER,font=MyFont,width=ewid)
  lZcen.pack(side=LEFT,fill=X)
  eZcen.pack(side=RIGHT,fill=X)
  fZcen.pack(fill=X)

  if key == 'Block':

    WaddPol.title("Add Iron Block")

    fXlen = Frame(WaddPol)
    tXlen = 'Xlen'
    lXlen = Label(fXlen,text=tXlen,font=MyFont)
    eXlen = Entry(fXlen,text=S_Iron_Xlen,justify=CENTER,font=MyFont,width=ewid)
    lXlen.pack(side=LEFT,fill=X)
    eXlen.pack(side=RIGHT,fill=X)
    fXlen.pack(fill=X)

    fYlen = Frame(WaddPol)
    tYlen = 'Ylen'
    lYlen = Label(fYlen,text=tYlen,font=MyFont)
    eYlen = Entry(fYlen,text=S_Iron_Ylen,justify=CENTER,font=MyFont,width=ewid)
    lYlen.pack(side=LEFT,fill=X)
    eYlen.pack(side=RIGHT,fill=X)
    fYlen.pack(fill=X)

    fZlen = Frame(WaddPol)
    tZlen = 'Zlen'
    lZlen = Label(fZlen,text=tZlen,font=MyFont)
    eZlen = Entry(fZlen,text=S_Iron_Zlen,justify=CENTER,font=MyFont,width=ewid)
    lZlen.pack(side=LEFT,fill=X)
    eZlen.pack(side=RIGHT,fill=X)
    fZlen.pack(fill=X)

    fChamfUS = Frame(WaddPol)
    tChamfUS = 'Up-stream chamfer'
    lChamfUS = Label(fChamfUS,text=tChamfUS,font=MyFont)
    eChamfUS = Entry(fChamfUS,text=S_Iron_ChamfUs,justify=CENTER,font=MyFont,width=ewid)
    lChamfUS.pack(side=LEFT,fill=X)
    eChamfUS.pack(side=RIGHT,fill=X)
    fChamfUS.pack(fill=X)

    fChamfDS = Frame(WaddPol)
    tChamfDS = 'Down-stream chamfer'
    lChamfDS = Label(fChamfDS,text=tChamfDS,font=MyFont)
    eChamfDS = Entry(fChamfDS,text=S_Iron_ChamfDs,justify=CENTER,font=MyFont,width=ewid)
    lChamfDS.pack(side=LEFT,fill=X)
    eChamfDS.pack(side=RIGHT,fill=X)
    fChamfDS.pack(fill=X)

  elif key == 'File':

    WaddPol.title("Add Iron Polyhedron")

    fcfil = Frame(WaddPol)
    tcfil = 'Filename'
    lcfil = Label(fcfil,text=tcfil,font=MyFont)
    ecfil = Entry(fcfil,text=S_Iron_CornFile.get(),justify=CENTER,font=MyFont,width=ewid)
    lcfil.pack(side=LEFT,fill=X)
    ecfil.pack(side=RIGHT,fill=X)
    fcfil.pack(fill=X)

  else:
    wError("In _WaddPol fehlt noch key " + key)
    return
  #endif key == 'Block'

  fnXdiv = Frame(WaddPol)
  tnXdiv = 'nXdiv'
  lnXdiv = Label(fnXdiv,text=tnXdiv,font=MyFont)
  enXdiv = Entry(fnXdiv,text=S_Iron_nXdiv,justify=CENTER,font=MyFont,width=ewid)
  lnXdiv.pack(side=LEFT,fill=X)
  enXdiv.pack(side=RIGHT,fill=X)
  fnXdiv.pack(fill=X)

  fnYdiv = Frame(WaddPol)
  tnydiv = 'nYdiv'
  lnYdiv = Label(fnYdiv,text=tnydiv,font=MyFont)
  enYdiv = Entry(fnYdiv,text=S_Iron_nYdiv,justify=CENTER,font=MyFont,width=ewid)
  lnYdiv.pack(side=LEFT,fill=X)
  enYdiv.pack(side=RIGHT,fill=X)
  fnYdiv.pack(fill=X)

  fnZdiv = Frame(WaddPol)
  tnzdiv = 'nZdiv'
  lnZdiv = Label(fnZdiv,text=tnzdiv,font=MyFont)
  enZdiv = Entry(fnZdiv,text=S_Iron_nZdiv,justify=CENTER,font=MyFont,width=ewid)
  lnZdiv.pack(side=LEFT,fill=X)
  enZdiv.pack(side=RIGHT,fill=X)
  fnZdiv.pack(fill=X)

  fFracDivY = Frame(WaddPol)
  tfracdivy = 'FracDivY'
  lFracDivY = Label(fFracDivY,text=tfracdivy,font=MyFont)
  eFracDivY = Entry(fFracDivY,text=S_Iron_FracDivY,justify=CENTER,font=MyFont,width=ewid)
  lFracDivY.pack(side=LEFT,fill=X)
  eFracDivY.pack(side=RIGHT,fill=X)
  fFracDivY.pack(fill=X)

  fFracDivZ = Frame(WaddPol)
  tfracdivz = 'FracDivZ'
  lFracDivZ = Label(fFracDivZ,text=tfracdivz,font=MyFont)
  eFracDivZ = Entry(fFracDivZ,text=S_Iron_FracDivZ,justify=CENTER,font=MyFont,width=ewid)
  lFracDivZ.pack(side=LEFT,fill=X)
  eFracDivZ.pack(side=RIGHT,fill=X)
  fFracDivZ.pack(fill=X)

  fbott = Frame(WaddPol)
  bCancel = Button(fbott,text='Cancel',command = _cnWaddPol)
  bCancel.pack(expand=TRUE,side=LEFT,fill=X)

  bClose = Button(fbott,text='Ok',width=ewid+2,command = lambda kw=key: _clWaddPol(kw))
  bClose.pack(side=LEFT)
  fbott.pack(expand=TRUE,fill=X)

  Umaster.wait_window(WaddPol)

#enddef _WaddPol(key)

def try_calc_var(stvar):
  try:
    calc_var(stvar)
    return 'ok'
  except:
    wError("Bad input: " + stvar)
  #endtry
#enddef try_calc_var(stvar)

def _cnWaddMag():
  global WaddMag
  WaddMag.destroy()
#enddef _cnWaddMag()

def _cnWaddPol():
  global WaddPol
  WaddPol.destroy()
#enddef _cnWaddPol()

def _clWaddPol(key):
+seq,uguiglobind.

  mp = []

  cnam = S_Iron_Cmag.get()
  if cnam.strip() == "": wError("Name must be given!"); return
  if NMagPol and  cnam in DictMagPolsTot: wError("Magnet is already defined"); return

  cmoth = S_Iron_Cmoth.get()
  if cmoth.strip() == "": wError("Name of mother volume must be given!"); return

  mp.append([cnam,cmoth])

  #smattype = S_Iron_MatType.get().strip()
  #if smattype != 'REC': wError("Unknown material " + mattype); return
  mp.append('Iron')

  sispec = S_Iron_Ispec.get().strip().lower()
  if sispec[0] == 'y' or sispec == '1': sis = 'yes'
  elif sispec[0] == 'n' or sispec == '0': sis = 'no'
  else: wError("Bad input " + sispec); return
  mp.append(sis)

  if key == 'Block':
    schamfus = S_Iron_ChamfUs.get().strip()
    if try_calc_var(schamfus) != 'ok': return
    chamfus = calc_var(schamfus)
    schamfds = S_Iron_ChamfDs.get().strip()
    if try_calc_var(schamfds) != 'ok': return
    chamfds = calc_var(schamfds)
    if chamfus == 0.0 and chamfds == 0.0: mp.append('Block')
    elif chamfus != 0.0 and chamfds != 0.0:
      if chamfus != chamfds:
        wError("Chamfer must be equal or one must be zero")
        return
      #endif chamfus != chamfds
      mp.append('BlockChamf')
    elif chamfus != 0.0: mp.append('BlockUsChamf')
    elif chamdus != 0.0: mp.append('BlockDsChamf')
  elif key == 'File':
    mp.append('File')
  else:
    wError("In _clWaddPol fehlt noch key " + key)
    return
  #endif key == 'RECBlock'

  sxcen = S_Iron_Xcen.get().strip()
  if try_calc_var(sxcen) != 'ok': return
  sycen = S_Iron_Ycen.get().strip()
  if try_calc_var(sycen) != 'ok': return
  szcen = S_Iron_Zcen.get().strip()
  if try_calc_var(szcen) != 'ok': return

  mp.append([sxcen,sycen,szcen])

  sBc = S_Iron_Bc.get().strip()
  if try_calc_var(sBc) != 'ok': return

  scolor = S_Iron_Color.get().strip()
  if scolor not in Variables and scolor not in DictUnduColors:
    wError(scolor + " not in: " + str(DictUnduColors))
    return
  #endif scolor not in UnduColors

  if try_calc_var(sxcen) != 'ok': return

  smatindex = S_Iron_Mat.get()
  ifound = 0

  if smatindex[0] == '$':
    if try_calc_var(smatindex) != 'ok': return
    sval = str(calc_var(smatindex))
  else:
    sval = smatindex
  #endif smatindex[0] == '$'

  for mat in Materials:
    if mat[0] == sval:
      ifound = 1
      break
  #endfor mat in Materials

  if ifound == 0:
    wError("Undefined material index in _clWaddPole")
    _MaddMatIron()
    return
  #endif ifound == 0

  mp.append([sBc,"0.0","1.0","0.0",smatindex,scolor])

  if key == 'Block':

    sxlen = S_Iron_Xlen.get().strip()
    if try_calc_var(sxlen) != 'ok': return
    sylen = S_Iron_Ylen.get().strip()
    if try_calc_var(sylen) != 'ok': return
    szlen = S_Iron_Zlen.get().strip()
    if try_calc_var(szlen) != 'ok': return

    if chamfus == 0.0 and chamfds == 0.0: mp.append([sxlen,sylen,szlen,'0.0'])
    elif chamfus != 0.0: mp.append([sxlen,sylen,szlen,schamfus])
    else: mp.append([sxlen,sylen,szlen,schamfds])

  elif key == 'File':
    cfile = S_Iron_CornFile.get().strip()
    if cfile == "": wError("Filename must be given!")
    corns = read_cornfile(cfile)
    if corns == []:
      wError("Problems with " + cfile)
      return
    #endif corns == []
    mp.append(corns)

  #endif key == 'RECBlock'

  snxdiv = S_Iron_nXdiv.get().strip()
  if try_calc_var(snxdiv) != 'ok': return
  snydiv = S_Iron_nYdiv.get().strip()
  if try_calc_var(snydiv) != 'ok': return
  snzdiv = S_Iron_nZdiv.get().strip()
  if try_calc_var(snzdiv) != 'ok': return
  sfracdivy = S_Iron_FracDivY.get().strip()
  if try_calc_var(sfracdivy) != 'ok': return
  sfracdivz = S_Iron_FracDivZ.get().strip()
  if try_calc_var(sfracdivz) != 'ok': return

  mp.append([snxdiv,snydiv,snzdiv,sfracdivy,sfracdivz])

  xloc=None
  yloc = None
  zloc = None
  mp.append([xloc,yloc,zloc])

  MagPolsTot.append(mp)
  NMagPolTot += 1
  update_magnets()

  WaddPol.destroy()
#enddef _clWaddPol()

def _clWaddMag(key):
+seq,uguiglobind.
  global UnduColors, DictUnduColors

  mp = []

  cnam = S_Cmag.get()
  if cnam.strip() == "": wError("Name must be given!"); return
  if NMagPol and  cnam in DictMagPolsTot: wError("Magnet is already defined"); return

  cmoth = S_Cmoth.get()
  if cmoth.strip() == "": wError("Name of mother volume must be given!"); return

  mp.append([cnam,cmoth])

  #smattype = S_MateType.get().strip()
  #if smattype != 'REC': wError("Unknown material " + mattype); return
  mp.append('REC')

  sispec = S_Ispec.get().strip().lower()

  if sispec[0] == 'y' or sispec == '1': sis = 'yes'
  elif sispec[0] == 'n' or sispec == '0': sis = 'no'
  else: wError("Bad input " + sispec); return

  mp.append(sis)

  if key == 'Block':

    schamfus = S_ChamfUs.get().strip()

    if try_calc_var(schamfus) != 'ok': return

    chamfus = calc_var(schamfus)
    schamfds = S_ChamfDs.get().strip()

    if try_calc_var(schamfds) != 'ok': return
    chamfds = calc_var(schamfds)

    if chamfus == 0.0 and chamfds == 0.0:
      mp.append('Block')
    elif chamfus != 0.0 and chamfds != 0.0:
      if chamfus != chamfds:
        wError("Chamfer must be equal or one must be zero")
        return
      #endif chamfus != chamfds
      mp.append('BlockChamf')
    elif chamfus != 0.0: mp.append('BlockUsChamf')
    elif chamdus != 0.0: mp.append('BlockDsChamf')
    #endif

  elif key == 'Cylinder':

    mp.append('Cylinder')

  elif key == 'File':
    mp.append('File')
  else:
    wError("In _clWaddMag fehlt noch key " + key)
    return
  #endif key == 'RECBlock'

  sxcen = S_Xcen.get().strip()
  if try_calc_var(sxcen) != 'ok': return
  sycen = S_Ycen.get().strip()
  if try_calc_var(sycen) != 'ok': return
  szcen = S_Zcen.get().strip()
  if try_calc_var(szcen) != 'ok': return

  mp.append([sxcen,sycen,szcen])

  sBc = S_Bc.get().strip()
  if try_calc_var(sBc) != 'ok': return
  sBxn = S_Bxn.get().strip()
  if try_calc_var(sBxn) != 'ok': return
  sByn = S_Byn.get().strip()
  if try_calc_var(sByn) != 'ok': return
  sBzn = S_Bzn.get().strip()
  if try_calc_var(sBzn) != 'ok': return

  scolor = S_Color.get().strip()
  if scolor not in Variables and scolor not in DictUnduColors:
    wError(scolor + " not in: " + str(DictUnduColors))
    return
  #endif scolor not in UnduColors

  if try_calc_var(sxcen) != 'ok': return

  smatindex = S_Mat.get()
  ifound = 0

  if smatindex[0] == '$':
    if try_calc_var(smatindex) != 'ok': return
    sval = str(calc_var(smatindex))
  else:
    sval = smatindex
  #endif smatindex[0] == '$'

  for mat in Materials:
    if mat[0] == sval:
      ifound = 1
      break
  #endfor mat in Materials

  if ifound == 0:
    wError("Undefined material index _clWaddMag")
    _MaddMatREClin()
    return
  #endif ifound == 0

  mp.append([sBc,sBxn,sByn,sBzn,smatindex,scolor])

  if key == 'Block':

    sxlen = S_Xlen.get().strip()
    if try_calc_var(sxlen) != 'ok': return
    sylen = S_Ylen.get().strip()
    if try_calc_var(sylen) != 'ok': return
    szlen = S_Zlen.get().strip()
    if try_calc_var(szlen) != 'ok': return

    if chamfus == 0.0 and chamfds == 0.0: mp.append([sxlen,sylen,szlen,'0.0'])
    elif chamfus != 0.0: mp.append([sxlen,sylen,szlen,schamfus])
    else: mp.append([sxlen,sylen,szlen,schamfds])

  elif key == 'Cylinder':

    srin = S_CylrIn.get().strip()
    if try_calc_var(srin) != 'ok': return
    srout = S_CylrOut.get().strip()
    if try_calc_var(srout) != 'ok': return
    shig = S_CylHeight.get().strip()
    if try_calc_var(shig) != 'ok': return
    sdphi = S_CyldPhi.get().strip()
    if try_calc_var(sdphi) != 'ok': return

    mp.append([srin,srout,shig,sdphi])

  elif key == 'File':
    cfile = S_CornFile.get().strip()
    if cfile == "": wError("Filename must be given!")
    corns = read_cornfile(cfile)
    if corns == []:
      wError("Problems with " + cfile)
      return
    #endif corns == []
    mp.append(corns)

  #endif key == 'Block'

  snxdiv = S_nXdiv.get().strip()
  if try_calc_var(snxdiv) != 'ok': return
  snydiv = S_nYdiv.get().strip()
  if try_calc_var(snydiv) != 'ok': return
  snzdiv = S_nZdiv.get().strip()
  if try_calc_var(snzdiv) != 'ok': return
  sfracdivy = S_FracDivY.get().strip()
  if try_calc_var(sfracdivy) != 'ok': return
  sfracdivz = S_FracDivZ.get().strip()
  if try_calc_var(sfracdivz) != 'ok': return

  mp.append([snxdiv,snydiv,snzdiv,sfracdivy,sfracdivz])

  xloc=None
  yloc = None
  zloc = None

  mp.append([xloc,yloc,zloc])
  MagPolsTot.append(mp)

  if mp[3] == 'Cylinder':
    size = mp[6]
    Quit(mp,'\n',size)
    rin = float(size[0])
    rout = float(size[1])
    h = float(size[2])
    dphi = float(size[3])
    nphi = int(size[4][3])+1
    if nphi < int(dphi/45.)+3: nphi = int(dphi/45.)+3
    Ncylinder += 1
    ccyl = 'ncyl_' + str(Ncylinder)
    ncyl = ncylinder(ccyl,
                     xcen,ycen,zcen,rout-rin,rin,rin,h,0.0,90.,dphi,nphi,1)
    poly = cylinderpoly(ccyl)
    Ntcyls.append([imp,mp,ccyl,poly])
  #endif

  NMagPolTot += 1

  update_magnets()

  WaddMag.destroy()
#enddef _clWaddMag()

def _EditMagGet(mag):
+seq,uguiglobind.

  #print("Baustelle _EditMagGet")

# Concept of magnets

# Block:
#  mp[0] = [name, mother]
#  mp[1] = material Type
#  mp[2] = special flag
#  mp[3] = shape key-word
#  mp[4] = [xcen,ycen,zcen]
#  mp[5] = [Bc, Bxn, Byn, Bzn, material index, color index]
#  mp[6] = [xlen,ylen,zlen,chamf]
#  mp[7] = [nxdiv,nydiv,nzdiv,fracdivy]
#  mp[8] = [xloc,yloc,zloc]

# File:
#  mp[0] = [name, mother]
#  mp[1] = material Type
#  mp[2] = special flag
#  mp[3] = shape key-word
#  mp[4] = [xcen,ycen,zcen]
#  mp[5] = [Bc, Bxn, Byn, Bzn, material index, color index]
#  mp[6] = number of points
#  mp[7] = points
#  mp[8] = [nxdiv,nydiv,nzdiv,fracdivy]
#  mp[9] = [xloc,yloc,zloc]

  MagPol = MagPolsTot[mag]

#  mattype = _EditMagGetSplit(MagPol[1],S_MateType.get())
#  MagPol[1] = mattype

  key = S_Key.get()
  if key != MagPol[3]:
    wError("Shape key-word can not be changed!")
  #endif key != MagPol[4]

  cen = MagPol[4]

  xcen = _EditMagGetSplit(cen[0],S_Xcen.get())
  ycen = _EditMagGetSplit(cen[1],S_Ycen.get())
  zcen = _EditMagGetSplit(cen[2],S_Zcen.get())

  cen = [xcen,ycen,zcen]
  MagPol[4] = [xcen,ycen,zcen]

  vmat = MagPol[5]
  bc = _EditMagGetSplit(vmat[0],S_Bc.get())
  bxn = _EditMagGetSplit(vmat[1],S_Bxn.get())
  byn = _EditMagGetSplit(vmat[2],S_Byn.get())
  bzn = _EditMagGetSplit(vmat[3],S_Bzn.get())
  mat = _EditMagGetSplit(vmat[4],S_Mat.get())
  col = _EditMagGetSplit(vmat[5],S_Color.get())
  MagPol[5] = [bc,bxn,byn,bzn,mat,col]

  if key.find('Block') > -1:

    leng = MagPol[6]
    xlen = _EditMagGetSplit(leng[0],S_Xlen.get())
    ylen = _EditMagGetSplit(leng[1],S_Ylen.get())
    zlen = _EditMagGetSplit(leng[2],S_Zlen.get())

    chamf = '0.0'
    chamfus = _EditMagGetSplit(leng[3],S_ChamfUs.get())
    chamfds = _EditMagGetSplit(leng[3],S_ChamfDs.get())

    if key == 'BlockChamf':
      if chamfus != chamfds:
        wError("Up-stream and down-stream chamfer must be the same for key 'BlockChamf'")
        return
      #endif chamfus != chamfds
      chamf = chamfus
    elif key == 'BlockUsChamf':
      if chamfds != '0.0':
        wError("Down-stream chamfer must be zero for key 'BlockUsChamf'")
        return
      #endif chamfus != chamfds
      chamf = chamfus
    elif key == 'BlockDsChamf':
      if chamfus != '0.0':
        wError("Up-stream chamfer must be zero for key 'BlockUsChamf'")
        return
      #endif chamfus != chamfds
      chamf = chamfds
    #endif key == 'BlockChamf')

    MagPol[6] = [xlen,ylen,zlen,chamf]

    div = MagPol[7]

    nxdiv = _EditMagGetSplit(div[0],S_nXdiv.get())
    nydiv = _EditMagGetSplit(div[1],S_nYdiv.get())
    nzdiv = _EditMagGetSplit(div[2],S_nZdiv.get())

    fracdivy = _EditMagGetSplit(div[3],S_FracDivY.get())
    fracdivz = _EditMagGetSplit(div[4],S_FracDivZ.get())

    MagPol[7] = [nxdiv,nydiv,nzdiv,fracdivy,fracdivz]

  elif key == 'File':

    cmag = MagPol[0][0]
    fnam = DictCornFiles[cmag]
    fget = S_CornFile.get()
    corns = MagPol[7]

    if fnam != fget:
      if not os.path.exists(fget):
        wError("File " + fget + " not found!")
      else:
        try:
          corns = read_cornfile(fget)
          cornsnum = []
          for c in corns:
            c1 = calc_var(c[0])
            c2 = calc_var(c[1])
            c3 = calc_var(c[2])
            cornsnum.append([c1,c2,c3])
          #endfor
+self,if=-oldhull3d.
          verts,ifaces,faces = hull3d(cornsnum)
          if type(verts) != Tdf:
            hull = pd.DataFrame(verts)
          else:
            hull = verts
          #endif
+self,if=oldhull3d.
          hull = hull3d(cornsnum)
+self.
          DictCornFiles[cname[0]] = cmag
          MagPol[7] = corns
          MagPol[6] = str(len(corns))
        except:
          wError("Could not process " + fget + "!")
        #endtry
      #endif not os.path.exists(fnam)
    #endif fnam != S_CornFile

    div = MagPol[8]
    nxdiv = _EditMagGetSplit(div[0],S_nXdiv.get())
    nydiv = _EditMagGetSplit(div[1],S_nYdiv.get())
    nzdiv = _EditMagGetSplit(div[2],S_nZdiv.get())
    fracdivy = _EditMagGetSplit(div[3],S_FracDivY.get())
    fracdivz = _EditMagGetSplit(div[4],S_FracDivZ.get())
    MagPol[8] = [nxdiv,nydiv,nzdiv,fracdivy,fracdivz]

  else:
    wError("_EditMagGet: " + key + " einfgen!")
  #endif key == 'Block'

  MagPolsTot[mag] = MagPol
  #print("_EditMagGet:",MagPolsTot[mag])

  WEditMag.destroy()

#enddef _EditMagGet(mag)

def _EditMagGetSplit(var,stvar):

  split = stvar.split('=')

  if var != split[0]:
    try :
      var = calc_var(split[0])
    except:
      wError("Bad input " + stvar)
    #endtry
  #endif cenold[0] != split[0]

  return str(var)

#enddef _EditMagGetSplit(stvar)

MagPolsDel = []
NMagPolDel = 0

def _delmagpol(imp):
  global DictMagPolsTot, MagPolsTot, MagPolsDel

  print("_delmagpol",imp)

  mag = MagPolsTot[imp]
  cnam = mag[0][0]
  cmoth = mag[0][1]

  if not cnam in DictMagPolsTot:
    wError("Magnet is not defined")
    return
  #endif cnam in MagPolsTot

  mp = MagPolsTot.pop(imp)
  MagPolsDel.append(mp)

  update_magnets()
  _listMags('update')
#enddef _delmagpol(imp)

def _resmagpol(imp):
  global DictMagPolsTot, MagPolsTot, MagPolsDel

  print("_resmagpol",imp)

  mp = MagPolsTotDel.pop(imp)
  MagPolsTots.append(mp)

  update_magnets()
  _listMags('update')
#enddef _resmagpol(imp)

def addmagpol_to_list(mag):
  global DictMagPolsTot, MagPolsTot
  cnam = mag[0][0]
  cmoth = mag[0][1]
  if cnam in DictMagPolsTot:
    wError("Magnet is already defined")
    return
  #endif cnam in MagPolsTot
  MagPolsTot.append(mag)
  update_magnets()
#enddef addmagpol_to_list()

def _clWCopyMag(mag):
  global MagPolsTot, S_newname, S_newmother, NMagPol, WCopyMag

  mp = deepcopy(MagPolsTot[mag])

  CopyMagX = -1
  CopyMagY = -1
  CopyMag_CheckMode = 0

  mp[0][0] = S_newname.get()
  mp[0][1] = S_newmother.get()

  NMagPol += 1
  MagPolsTot.append(mp)
  update_magnets()

  WCopyMag.destroy()
  _listMags('update')

#def _clWCopyMag(mag)

def _cnWCopyMag(mag):
  WCopyMag.destroy()
#def _cnWCopyMag(mag)

def _copyMag(imp):
  global MagPolsTot, S_newname, S_newmother, WCopyMag

  mp = MagPolsTot[imp]

  cmag = mp[0][0]
  cmoth = mp[0][1]

  WCopyMag = Toplevel()
  WCopyMag.title("Copy Magnetic Item")

  try:
    if CopyMagX: pass
  except:
    CopyMag_CheckMode = 0
    CopyMagX = -1
    CopyMagY = -1
  #endtry

  if CopyMagX == -1: CopyMagX, CopyMagY = Umaster.winfo_pointerxy()

  sgeo = '+' + str(CopyMagX-200) + '+' + str(CopyMagY)
  WCopyMag.geometry(sgeo)

  WCopyMag.title("Copy of " + cmag)
  WCopyMag.attributes('-topmost', 1)

  ewid = 25

  S_newname = StringVar()
  S_newname.set("")
  fnewname = Frame(WCopyMag)
  tnewname = 'name'
  lnewname = Label(fnewname,text=tnewname,font=MyFont)
  enewname = Entry(fnewname,text=S_newname,justify=CENTER,font=MyFont,width=ewid)
  lnewname.pack(side=LEFT,fill=X)
  enewname.pack(side=RIGHT,fill=X)
  fnewname.pack(fill=X)

  S_newmother = StringVar()
  S_newmother.set("")
  fnewmother = Frame(WCopyMag)
  tnewmother = 'mother volume'
  lnewmother = Label(fnewmother,text=tnewmother,font=MyFont)
  enewmother = Entry(fnewmother,text=S_newmother,justify=CENTER,font=MyFont,width=ewid)
  lnewmother.pack(side=LEFT,fill=X)
  enewmother.pack(side=RIGHT,fill=X)
  fnewmother.pack(fill=X)

  fC = Frame(WCopyMag)

  bCancel = Button(fC,text='Cancel',command= lambda mag=imp: _cnWCopyMag(mag))
  bCancel.bind('<Return>', lambda event, mag=imp: _cnWCopyMag(mag))
  bCancel.pack(expand=TRUE,side=LEFT,fill=X)

  bClose = Button(fC,text='Ok',command= lambda mag=imp: _clWCopyMag(mag),width=ewid)
  bClose.bind('<Return>',lambda event, mag=imp: _clWCopyMag(mag))
  bClose.pack(side=LEFT,fill=X)

  fC.pack(fill=X)

#enddef _copyMag(imp)

def _ccWEditMag(mag):
  # Check
  global EditMag_CheckMode,CopyMag_CheckMode,  WEditMag, MagPolsTot,MagPolOld
  global SgeoWeditMag
  #print("_ccWEditMag(mag):",mag)

  EditMag_CheckMode = 1
  sgeo = WEditMag.geometry().split('+')
  SgeoWeditMag = '+' + sgeo[1] + '+' + sgeo[2]
  WEditMag.destroy()

  _editMag(mag)
  #print("Check:",stat)

  EditMag_CheckMode = 0
#def _ccWEditMag(mag)

def _cnWEditMag(mag):
  # Cancel
  global EditMag_CheckMode,CopyMag_CheckMode,EditMagX,EditMagY,WEditMag, \
  WCopyMag,MagPol,MagPolOld, MagPolsTot, \
  Nvar,Ncalc,Variables,Calcs,VariablesOld,CalcOld

  #print("_cnWEditMag(mag):",mag)
  EditMag_CheckMode = 0
  EditMagX = -1
  EditMagY = -1
  #print("_cn:",MagPolOld)
  MagPolsTot[mag] = MagPolOld
  Variables = VariablesOld
  Calcs = CalcsOld
  Nvar = len(Variables)
  Ncalc = len(Calcs)
  WEditMag.destroy()
#def _cnWEditMag(mag)

def _crWEditMag(mag):
  # Restore
  global MagPolOld,MagPolsTot
  #print("_cr:",NL,MagPolOld)
  MagPolsTot[mag] = MagPolOld
  WEditMag.destroy()
  _editMag(mag)
#def _crWEditMag(mag)

def _clWEditMag(mag):
+seq,uguiglobind.

  EditMagX = -1
  EditMagY = -1
  EditMag_CheckMode = 0

  _EditMagGet(mag)

  WEditMag.destroy()
  _listMags('update')

#def _clWEditMag(mag)

def _focoEditMag(ev,imp,idx,kdx):
+seq,uguiglobind.
  print(ev,imp,idx,kdx)
#enddef focoEditMag(imp,idx,kdx)

def _editMag(imp):
+seq,uguiglobind.
  global SgeoWeditMag, VariablesOld, CalcsOld

  #print("_editMag::CheckMode:",EditMag_CheckMode)
  #print("_editMag::imp:",imp)

  if not EditMag_CheckMode:
    MagPolOld = deepcopy(MagPolsTot[imp])
    VariablesOld = deepcopy(Variables)
    CalcsOld = deepcopy(Calcs)
  else:
    _EditMagGet(imp)
  #endif not EditMag_CheckMode

  MagPol = MagPolsTot[imp]
  #print(MagPol)
  mp = MagPol

  cmag = mp[0][0]
  cmoth = mp[0][1]

  WEditMag = Toplevel()
  WEditMag.title("Edit Magnetic Item")

  try:
    if EditMagX: pass
  except:
    EditMag_CheckMode = 0
    EditMagX = -1
    EditMagY = -1
  #endtry

  if EditMagX == -1:
    EditMagX, EditMagY = Umaster.winfo_pointerxy()
    EditMagX -= 200
  #endif EditMagX == -1

  if not EditMag_CheckMode:
    sgeo = '+' + str(EditMagX) + '+' + str(EditMagY)
  else:
    sgeo = SgeoWeditMag
  #endif not EditMag_CheckMode

  WEditMag.geometry(sgeo)

  WEditMag.title(cmag)
  WEditMag.attributes('-topmost', 1)

  #([cname,mag,ispec,key,cen,vmat,siz,div]

  ewid = 30

  mattype = mp[1]

  if mattype.find("$") > -1:
    V_MatType = calc_var(mattype)
    tvmattype = mattype + " = " + str(V_MatType)
  else:
    tvmattype = mattype
  #endif mattype.find("$") > -1

  S_MateType.set(mattype)

#  ewid = max(ewid,len(tvmattype))

  #ewid = len(mattype)
  ispec = mp[2]
  ewid = max(ewid,len(ispec))

  key = mp[3]
  ewid = max(ewid,len(key))

  cen = mp[4]

  xcen = cen[0]
  ycen = cen[1]
  zcen = cen[2]

  if type(xcen) == str and xcen.find("$") > -1:
    V_Xcen = calc_var(xcen)
    tvxcen = xcen + " = " + str(V_Xcen)
  else:
    tvxcen = xcen
  #endif xcen.find("$")

  ewid = max(ewid,len(tvxcen))

  if type(ycen) == str and ycen.find("$") > -1:
    V_Ycen = calc_var(ycen)
    tvycen = ycen + " = " + str(V_Ycen)
  else:
    tvycen = ycen
  #endif ycen.find("$")

  ewid = max(ewid,len(tvycen))

  if type(zcen) == str and ycen.find("$") > -1:
    V_Zcen = calc_var(zcen)
    tvzcen = zcen + " = " + str(V_Zcen)
  else:
    tvzcen = zcen
  #endif zcen.find("$")

  ewid = max(ewid,len(tvzcen))

  vmat = mp[5]
  bc = vmat[0]

  if type(bc) == str and bc.find("$") > -1:
    V_Bc = calc_var(bc)
    tvbc = bc + " = " + str(V_Bc)
  else:
    tvbc = bc
  #endif bc.find("$")

  ewid = max(ewid,len(tvbc))

  bxn = calc_var(vmat[1])
  byn = calc_var(vmat[2])
  bzn = calc_var(vmat[3])

  if type(bxn) == str and bxn.find("$") > -1:
    V_Bxn = calc_var(bxn)
    tvbxn = bxn + " = " + str(V_Bxn)
  else:
    tvbxn = str(bxn)
  #endif bxn.find("$") > -1

  ewid = max(ewid,len(tvbxn))

  if type(byn) == str and byn.find("$") > -1:
    V_Byn = calc_var(byn)
    tvbyn = byn + " = " + str(V_Byn)
  else:
    tvbyn = str(byn)
  #endif byn.find("$") > -1

  ewid = max(ewid,len(tvbyn))

  if type(bzn) == str and bzn.find("$") > -1:
    V_Bzn = calc_var(bzn)
    tvbzn = bzn + " = " + str(V_Bzn)
  else:
    tvbzn = str(bzn)
  #endif bzn.find("$") > -1

  ewid = max(ewid,len(tvbzn))

  mat = vmat[4]
  col = vmat[5]

  if type(mat) == str and mat.find("$") > -1:
    V_Mat = calc_var(mat)
    tvmat = mat + " = " + str(V_Mat)
  else:
    tvmat = mat
  #endif mat.find("$") > -1

  ewid = max(ewid,len(tvmat))

  if type(col) == str and col.find("$") > -1:
    vcol = calc_var(col)
    tvcol = col + " = " + str(vcol)
  else:
    tvcol = col
  #endif col.find("$") > -1

  ewid = max(ewid,len(tvcol))

  siz = mp[6]

  if key.find('Block') > -1:

    xlen = siz[0]
    ylen = siz[1]
    zlen = siz[2]

    chamf = siz[3]

    tvchus = '0.0'
    tvchds = '0.0'

    if type(chamf) == str and chamf.find("$") > -1:
      V_Chamf = calc_var(chamf)
      if key == 'BlockUsChamf':
        tvchus = chamf + " = " + str(V_Chamf)
      elif key == 'BlockDsChamf':
        tvchds = chamf + " = " + str(V_Chamf)
      elif key == 'BlockChamf':
        tvchus = chamf + " = " + str(V_Chamf)
        tvchds = chamf + " = " + str(V_Chamf)
      #endif key == 'BlockUsChamf'
    else:
      if key == 'BlockUsChamf':
        tvchus = chamf
      elif key == 'BlockDsChamf':
        tvchds = chamf
      elif key == 'BlockChamf':
        tvchus = chamf
        tvchds = chamf
      #endif key == 'BlockUsChamf'
    #endif xlen.find("$")

    ewid = max(ewid,len(tvchus))
    ewid = max(ewid,len(tvchds))

    if type(xlen) == str and xlen.find("$") > -1:
      V_Xlen = calc_var(xlen)
      tvxlen = xlen + " = " + str(V_Xlen)
    else:
      tvxlen = xlen
    #endif xlen.find("$")
    ewid = max(ewid,len(tvxlen))

    if type(ylen) == str and ylen.find("$") > -1:
      V_Ylen = calc_var(ylen)
      tvylen = ylen + " = " + str(V_Ylen)
    else:
      tvylen = ylen
    #endif ylen.find("$")
    ewid = max(ewid,len(tvylen))

    if type(zlen) == str and zlen.find("$") > -1:
      V_Zlen = calc_var(zlen)
      tvzlen = zlen + " = " + str(V_Zlen)
    else:
      tvzlen = zlen
    #endif zlen.find("$")
    ewid = max(ewid,len(tvzlen))

    div = mp[7]

  elif key == 'File':

    div = mp[8]
    ewid = max(ewid,len(DictCornFiles[cmag]))

  else:
    Quit("In _editMag fehlt noch key " + key)
  #endif key == 'Block'

  nxdiv = div[0]
  nydiv = div[1]
  nzdiv = div[2]
  fracdivy = div[3]
  fracdivz = div[4]

  vxcen = calc_var(xcen)
  vycen = calc_var(ycen)
  vzcen = calc_var(zcen)

  vbc = calc_var(bc)
  vbxn = calc_var(bxn)
  vbyn = calc_var(byn)
  vbzn = calc_var(bzn)

  vnxdiv = calc_var(nxdiv)
  vnydiv = calc_var(nydiv)
  vnzdiv = calc_var(nzdiv)
  vfracdivy = calc_var(fracdivy)

  if type(nxdiv) == str and nxdiv.find("$") > -1:
    tnxdiv = nxdiv + " = " + str(vnxdiv)
  else:
    tnxdiv = nxdiv
  #endif nxdiv.find("$")
  ewid = max(ewid,len(tnxdiv))

  if type(nydiv) == str and nydiv.find("$") > -1:
    tnydiv = nydiv + " = " + str(vnydiv)
  else:
    tnydiv = nydiv
  #endif nydiv.find("$")
  ewid = max(ewid,len(tnydiv))

  if type(nzdiv) == str and nzdiv.find("$") > -1:
    tnzdiv = nzdiv + " = " + str(vnzdiv)
  else:
    tnzdiv = nzdiv
  #endif nzdiv.find("$")
  ewid = max(ewid,len(tnzdiv))

  if type(fracdivy) == str and fracdivy.find("$") > -1:
    tfracdivy = fracdivy + " = " + str(vfracdivy)
  else:
    tfracdivy = fracdivy
  #endif fracdivy.find("$")
  ewid = max(ewid,len(tfracdivy))

  #S_MateType.set(tvmattype)
  #fMatType = Frame(WEditMag)
  #tMatType = 'material type'
  #lMatType = Label(fMatType,text=tMatType,font=MyFont)
  #eMatType = Entry(fMatType,text=S_MateType,justify=CENTER,font=MyFont,width=ewid)
  #lMatType.pack(side=LEFT,fill=X)
  #eMatType.pack(side=RIGHT,fill=X)
  #fMatType.pack(fill=X)

  S_Mat.set(tvmat)
  fMat = Frame(WEditMag)
  tMat = 'material index'
  lMat = Label(fMat,text=tMat,font=MyFont)
  eMat = Entry(fMat,text=S_Mat,justify=CENTER,font=MyFont,width=ewid)
  lMat.pack(side=LEFT,fill=X)
  eMat.pack(side=RIGHT,fill=X)
  fMat.pack(fill=X)

  S_Color.set(tvcol)
  fcol = Frame(WEditMag)
  tcol = 'color'
  lcol = Label(fcol,text=tcol,font=MyFont)
  ecol = Entry(fcol,text=S_Color,justify=CENTER,font=MyFont,width=ewid)
  lcol.pack(side=LEFT,fill=X)
  ecol.pack(side=RIGHT,fill=X)
  fcol.pack(fill=X)

  S_Bc.set(tvbc)
  fBc = Frame(WEditMag)
  tBc = 'remanence'
  lBc = Label(fBc,text=tBc,font=MyFont)
  eBc = Entry(fBc,text=S_Bc,justify=CENTER,font=MyFont,width=ewid)
  lBc.pack(side=LEFT,fill=X)
  eBc.pack(side=RIGHT,fill=X)
  fBc.pack(fill=X)

  S_Bxn.set(tvbxn)
  fBxn = Frame(WEditMag)
  tBxn = 'x - component'
  lBxn = Label(fBxn,text=tBxn,font=MyFont)
  eBxn = Entry(fBxn,text=S_Bxn,justify=CENTER,font=MyFont,width=ewid)
  lBxn.pack(side=LEFT,fill=X)
  eBxn.pack(side=RIGHT,fill=X)
  fBxn.pack(fill=X)

  S_Byn.set(tvbyn)
  fByn = Frame(WEditMag)
  tByn = 'y - component'
  lByn = Label(fByn,text=tByn,font=MyFont)
  eByn = Entry(fByn,text=S_Byn,justify=CENTER,font=MyFont,width=ewid)
  lByn.pack(side=LEFT,fill=X)
  eByn.pack(side=RIGHT,fill=X)
  fByn.pack(fill=X)

  S_Bzn.set(tvbzn)
  fBzn = Frame(WEditMag)
  tBzn = 'z - component'
  lBzn = Label(fBzn,text=tBzn,font=MyFont)
  eBzn = Entry(fBzn,text=S_Bzn,justify=CENTER,font=MyFont,width=ewid)
  lBzn.pack(side=LEFT,fill=X)
  eBzn.pack(side=RIGHT,fill=X)
  fBzn.pack(fill=X)

  S_Ispec.set(ispec)
  fIspec = Frame(WEditMag)
  tIspec = 'non-periodic'
  lIspec = Label(fIspec,text=tIspec,font=MyFont)
  eIspec = Entry(fIspec,text=S_Ispec,justify=CENTER,font=MyFont,width=ewid)
  lIspec.pack(side=LEFT,fill=X)
  eIspec.pack(side=RIGHT,fill=X)
  fIspec.pack(fill=X)

  S_Key.set(key)
#  fKey = Frame(WEditMag)
#  tKey = 'shape key-word'
#  lKey = Label(fKey,text=tKey,font=MyFont)
#  eKey = Entry(fKey,text=S_Key,justify=CENTER,font=MyFont,width=ewid)
#  lKey.pack(side=LEFT,fill=X)
#  eKey.pack(side=RIGHT,fill=X)
#  fKey.pack(fill=X)

#  if key == 'File':
#    S_CornFile.set(DictCornFiles[cmag])
#    ffile = Frame(WEditMag)
#    tfile = 'filename'
#    lfile = Label(ffile,text=tfile,font=MyFont)
#    efile = Entry(ffile,text=S_CornFile,justify=CENTER,font=MyFont,width=ewid)
#    lfile.pack(side=LEFT,fill=X)
#    efile.pack(side=RIGHT,fill=X)
#    ffile.pack(fill=X)
#  #endif key == 'File'

  S_Xcen.set(tvxcen)
  fXcen = Frame(WEditMag)
  tXcen = 'Xref'
  lXcen = Label(fXcen,text=tXcen,font=MyFont)
  eXcen = Entry(fXcen,text=S_Xcen,justify=CENTER,font=MyFont,width=ewid)
  lXcen.pack(side=LEFT,fill=X)
  eXcen.pack(side=RIGHT,fill=X)
  fXcen.pack(fill=X)

  S_Ycen.set(tvycen)
  fYcen = Frame(WEditMag)
  tYcen = 'Yref'
  lYcen = Label(fYcen,text=tYcen,font=MyFont)
  eYcen = Entry(fYcen,text=S_Ycen,justify=CENTER,font=MyFont,width=ewid)
  lYcen.pack(side=LEFT,fill=X)
  eYcen.pack(side=RIGHT,fill=X)
  fYcen.pack(fill=X)

  S_Zcen.set(tvzcen)
  fZcen = Frame(WEditMag)
  tZcen = 'Zref'
  lZcen = Label(fZcen,text=tZcen,font=MyFont)
  eZcen = Entry(fZcen,text=S_Zcen,justify=CENTER,font=MyFont,width=ewid)
  lZcen.pack(side=LEFT,fill=X)
  eZcen.pack(side=RIGHT,fill=X)
  fZcen.pack(fill=X)

  if key.find('Block') > -1:

    S_Xlen.set(tvxlen)
    fXlen = Frame(WEditMag)
    tXlen = 'Xlen'
    lXlen = Label(fXlen,text=tXlen,font=MyFont)
    eXlen = Entry(fXlen,text=S_Xlen,justify=CENTER,font=MyFont,width=ewid)
    lXlen.pack(side=LEFT,fill=X)
    eXlen.pack(side=RIGHT,fill=X)
    fXlen.pack(fill=X)

    S_Ylen.set(tvylen)
    fYlen = Frame(WEditMag)
    tYlen = 'Ylen'
    lYlen = Label(fYlen,text=tYlen,font=MyFont)
    eYlen = Entry(fYlen,text=S_Ylen,justify=CENTER,font=MyFont,width=ewid)
    lYlen.pack(side=LEFT,fill=X)
    eYlen.pack(side=RIGHT,fill=X)
    fYlen.pack(fill=X)

    S_Zlen.set(tvzlen)
    fZlen = Frame(WEditMag)
    tZlen = 'Zlen'
    lZlen = Label(fZlen,text=tZlen,font=MyFont)
    eZlen = Entry(fZlen,text=S_Zlen,justify=CENTER,font=MyFont,width=ewid)
    lZlen.pack(side=LEFT,fill=X)
    eZlen.pack(side=RIGHT,fill=X)
    fZlen.pack(fill=X)

    S_ChamfUs.set(tvchus)
    fChUs = Frame(WEditMag)
    tChUs = 'Up-stream chamfer'
    lChUs = Label(fChUs,text=tChUs,font=MyFont)
    eChUs = Entry(fChUs,text=S_ChamfUs,justify=CENTER,font=MyFont,width=ewid)
    lChUs.pack(side=LEFT,fill=X)
    eChUs.pack(side=RIGHT,fill=X)
    fChUs.pack(fill=X)

    S_ChamfDs.set(tvchds)
    fChDs = Frame(WEditMag)
    tChDs = 'Down-stream chamfer'
    lChDs = Label(fChDs,text=tChDs,font=MyFont)
    eChDs = Entry(fChDs,text=S_ChamfDs,justify=CENTER,font=MyFont,width=ewid)
    lChDs.pack(side=LEFT,fill=X)
    eChDs.pack(side=RIGHT,fill=X)
    fChDs.pack(fill=X)

  elif key == 'File':
    pass
  else:
    Quit("In _editMag fehlt noch key " + key)
  #endif key == 'Block'

  S_nXdiv.set(tnxdiv)
  fnXdiv = Frame(WEditMag)
  tnxdiv = 'nXdiv'
  lnXdiv = Label(fnXdiv,text=tnxdiv,font=MyFont)
  enXdiv = Entry(fnXdiv,text=S_nXdiv,justify=CENTER,font=MyFont,width=ewid)
  lnXdiv.pack(side=LEFT,fill=X)
  enXdiv.pack(side=RIGHT,fill=X)
  fnXdiv.pack(fill=X)

  S_nYdiv.set(tnydiv)
  fnYdiv = Frame(WEditMag)
  tnydiv = 'nYdiv'
  lnYdiv = Label(fnYdiv,text=tnydiv,font=MyFont)
  enYdiv = Entry(fnYdiv,text=S_nYdiv,justify=CENTER,font=MyFont,width=ewid)
  lnYdiv.pack(side=LEFT,fill=X)
  enYdiv.pack(side=RIGHT,fill=X)
  fnYdiv.pack(fill=X)

  S_nZdiv.set(tnzdiv)
  fnZdiv = Frame(WEditMag)
  tnzdiv = 'nZdiv'
  lnZdiv = Label(fnZdiv,text=tnzdiv,font=MyFont)
  enZdiv = Entry(fnZdiv,text=S_nZdiv,justify=CENTER,font=MyFont,width=ewid)
  lnZdiv.pack(side=LEFT,fill=X)
  enZdiv.pack(side=RIGHT,fill=X)
  fnZdiv.pack(fill=X)

  S_FracDivY.set(tfracdivy)
  fFracDivY = Frame(WEditMag)
  tfracdivy = 'FracDivY'
  lFracDivY = Label(fFracDivY,text=tfracdivy,font=MyFont)
  eFracDivY = Entry(fFracDivY,text=S_FracDivY,justify=CENTER,font=MyFont,width=ewid)
  lFracDivY.pack(side=LEFT,fill=X)
  eFracDivY.pack(side=RIGHT,fill=X)
  fFracDivY.pack(fill=X)

  S_FracDivZ.set(tfracdivz)
  fFracDivZ = Frame(WEditMag)
  tfracdivz = 'FracDivZ'
  lFracDivZ = Label(fFracDivZ,text=tfracdivz,font=MyFont)
  eFracDivZ = Entry(fFracDivZ,text=S_FracDivZ,justify=CENTER,font=MyFont,width=ewid)
  lFracDivZ.pack(side=LEFT,fill=X)
  eFracDivZ.pack(side=RIGHT,fill=X)
  fFracDivZ.pack(fill=X)

  WEditMag.update()

  widtot = WEditMag.winfo_width()
  wide = eXcen.winfo_width()
  wscale = ewid / wide
  wforce = int(widtot/2.*wscale) + 2

  fCheckRestore = Frame(WEditMag)
  fCheckRestore.pack(fill=X)

  bCheck = Button(fCheckRestore,text='Check',command= lambda mag=imp: _ccWEditMag(mag))
  bCheck.bind('<Return>',lambda event, mag=imp: _ccWEditMag(mag))
  bCheck.pack(expand=TRUE,side=LEFT,fill=X)

  bRestore = Button(fCheckRestore,text='Restore',command= lambda mag=imp: _crWEditMag(mag),width=wforce)
  bRestore.bind('<Return>',lambda event, mag=imp: _crWEditMag(mag))
  bRestore.pack(side=LEFT,fill=X)

  fC = Frame(WEditMag)
  fC.pack(fill=X)

  bClose = Button(fC,text='Ok',command= lambda mag=imp: _clWEditMag(mag),width=wforce)
  bClose.bind('<Return>',lambda event, mag=imp: _clWEditMag(mag))
  bClose.pack(expand=TRUE,side=LEFT,fill=X)

  WEditMag.update()

  #print("Leaving _editMag")

#enddef _editMag(imp)

def _clWallListMags():
  global WallListMags
  WallListMags.destroy()
#enddef _clWallListMags()

def _clWselListMags():
#+seq,uguiglobind.
  global WselListMags
  WselListMags.destroy()
#enddef _clWselListMags()

def _clWdelListMags():
#+seq,uguiglobind.
  global WdelListMags
  WdelListMags.destroy()
#enddef _clWdelListMags()

NMagPolSel = -1
DictMagPolsSel = {}
MagPolsSel = []

def _selectMag(cmag):

  global NMagPolSel, MagPolsSel,DictMagPolsSel,WallListMags, \
  DictMagPolsTot, MyMoth, Moths, NMothSel, DictMothsSel

  #print('_selectMag(cmag):',cmag)
  #print('_selectMag(cmag):',DictMagPolsSel)

  if cmag in DictMagPolsSel:

    #print('_selectMag(cmag): cmag in DictMagPolsSel')

    mag = MagPolsTot[DictMagPolsTot[cmag]]
    cmoth = mag[0][1]
    moth = MyMoth[cmag]

    NMagPolSel -= 1
    DictMagPolsSel.pop(cmag)

    MagPolsSel = []
    dm = {}
    i = -1

    for cm in DictMagPolsSel:
      MagPolsSel.append(cm)
      i += 1
      dm[cm] = i
    #endfor cm in DictMagPolsSel

    DictMagPolsSel = dm

    if NMothSel > 0 and cmoth in DictMothsSel:
      NMothSel -= 1
      DictMothsSel.pop(cmoth)
      MothsSel = []
      dm = {}
      i = -1
      for cm in DictMothsSel:
        MothsSel.append(cm)
        i += 1
        dm[cm] = i
      #endfor cm in DictMothsSel
      DictMothsSel = dm
    #endif NMothSel > 0

  else:

    #print('_selectMag(cmag): cmag NOT in DictMagPolsSel')
    MagPolsSel.append(cmag)
    DictMagPolsSel[cmag] = NMagPolSel
    NMagPolSel += 1

  #endif not mag in DictMagsSel
  _configMagButts()
  WallListMags.update()

#enddef _selectMag(mag)

NMothSel = 0
DictMothsSel = {}
MothsSel = []

def _selectMoth(cmoth):

  global NMothSel, MothsSel,DictMothsSel, DictMoths,DictMagPolsSel

  #print("selecMoth:cmoth",cmoth)

  if cmoth in DictMothsSel:
    moth = DictMoths[cmoth]
    for cmag in Moths[moth]:
      if cmag in DictMagPolsSel:
        _selectMag(cmag)
#        break
      #endif cmag in DictMagPolsSeleted
    #endfor mag in Moths[moth]
  else:
    MothsSel.append(cmoth)
    DictMothsSel[cmoth] = NMothSel
    moth = DictMoths[cmoth]
    NMothSel += 1
    for mag in Moths[moth]: _selectMag(mag)
  #endif not moth in DictMothsSel

#enddef _selectMag(imp)

def _configMagButts():

  global NMagPolSel, MagPolsSel,DictMagPolsSel
  global All_butts, ndmp, NMothSel

  #print('configMagButts()?\n',DictMothsSel,'\n',DictMagPolsSel)
  for i in range(len(All_butts)):
    butts = All_butts[i]
    cmoth = butts[0]['text']
    butts[0].configure(fg= 'black', bg='white')
    cmag = butts[1]['text']
    #print(cmoth,cmag)
    if cmag in DictMagPolsSel:
      for j in range(1,len(All_butts[i])):
        b = All_butts[i][j]
        b.configure(fg= 'black', bg='cyan')
    else:
      for b in All_butts[i]: b.configure(fg= 'black', bg='white')
    #endif cmag in DictMagPolsSel

  for i in range(len(All_butts)):
    butts = All_butts[i]
    cmoth = butts[0]['text']
    if cmoth in DictMothsSel:
      butts[0].configure(fg= 'black', bg='cyan')
    #endif cmag in DictMothsSel
  #endfor i in range(ndmp)
  #print('configMagButts()!\n')

#enddef _configMagButts()

def _selectAll():

  global DictMagPolsSel, DictMothsSel,NMothSel,NMagPolSel,MagPolsSel,MothSel
  global MagPolsTot,Moths

  DictMagPolsSel = {}
  DictMothsSel = {}
  MothsSel = []
  MagPolsSel = []
  NMothSel = 0
  NMagPolSel = 0

  for cmoth in DictMoths:
    imoth = DictMoths[cmoth]
    MothsSel.append(Moths[imoth])
    DictMothsSel[cmoth] = NMothSel
    NMothSel += 1
  #endif

  for mag in MagPolsTot:
    cmag = mag[0][0]
    MagPolsSel.append(cmag)
    DictMagPolsSel[cmag] = NMagPolSel
    NMagPolSel += 1
  #endif

  #print("_selectAll:\n",DictMothsSel,'\n',DictMagPolsSel)

  _configMagButts()
#enddef _selectAll()

def _deselectAll():
  global DictMagPolsSel, DictMothsSel,NMothSel,NMagPolSel,MagPolsSel,MothSel
  DictMagPolsSel = {}
  DictMothsSel = {}
  MothsSel = []
  MagPolsSel = []
  NMothSel = 0
  NMagPolSel = 0
  _configMagButts()
#enddef _deselectAll()

def _listMags(mode='all'):
+seq,uguiglobind.

  global WselListMags, WdelListMags
  global ndmp, WselGeo, WallGeo, WdelGeo
  global all_fmagmoth, all_fmoth, all_fmag, All_butts, all_lastmp, \
  all_firstmp, all_fxyz, all_fbott, all_fpn, bPrev,bCont, all_fb, all_fedi, \
  all_fcop, all_fdel, all_fplot, isopen_all,isopen_sel,isopen_del, \
  all_fplotxy, all_fplotxz, all_fplotyz

  global sel_fmagmoth, sel_fmoth, sel_fmag, sel_butts, sel_lastmp, \
  sel_firstmp, sel_fxyz, sel_fbott, sel_fpn, bPrev,bCont, sel_width, \
  sel_width_old, sel_width_ini, sel_fb, sel_fedi, sel_del, sel_fplot, sel_fcop

  global del_fmagmoth, del_fmoth, del_fmag, del_butts, del_lastmp, \
  del_firstmp, del_fxyz, del_fbott, del_fpn, bPrev,bCont, del_width, \
  del_width_old, del_width_ini, del_fb, del_fedi, del_del, del_fplot, del_fcop

  if not NMagPolTot:
    wError("No magnets or poles defined so far")
    return
  #endif NMagPolTot

  # counter, i.e. indices + 1
  try:
    all_firstmp = all_lastmp + 1
  except:
    EditMag_CheckMode = 0
    CopyMag_CheckMode = 0
    ndmp = 10
    all_firstmp = 1
  #endtry:

  #print('_listMags:mode,all_firstmp',mode,all_firstmp)
  iupdateall = 0
  iupdatesel = 0
  iupdatedel = 0

  try:
    WallGeo = WallListMags.geometry()
    if mode == 'update':
      iupdateall = 1
      mode = 'all'
      WallListMags.destroy()
    #endif
  except: WallGeo = WallMags=""
  try:
    WselGeo = WselListMags.geometry()
    if mode == 'update':
      iupdatesel = 1
      mode = 'selected'
      WselListMags.destroy()
    #endif
  except: WselGeo=""
  try:
    WdelGeo = WdelListMags.geometry()
    if mode == 'update':
      iupdatedel = 1
      mode = 'deleted'
      WalldelMags.destroy()
    #endif
  except: WdelGeo=""

  #print('_listMags:mode,all_firstmp vor update_magnets',mode,all_firstmp)
  update_magnets()
  #print('_listMags:mode,all_firstmp nach update_magnets',mode,all_firstmp)

  if mode == 'all' or iupdateall == 1:

    if mode == 'all':
      all_lastmp = all_firstmp + ndmp - 1
      all_firstmp = 1
      all_lastmp = min(ndmp,NMagPolTot)
    else:
      if all_lastmp > NMagPolTot - 1:
        all_lastmp = NMagPolTot -1
        all_firstmp = all_lastmp - ndmp
      #if all_lastmp > NMagPolTot - 1
      WallListMags.destroy()
    #endif mode == 'all'

    WallListMags = Toplevel()
    WallListMags.title("List of Magnetic Items")
    WallListMags.attributes('-topmost', 1)

    All_butts = []
    all_frames = []

    all_fmagmoth = Frame(WallListMags)
    all_fmoth = Frame(all_fmagmoth)
    all_fmag = Frame(all_fmagmoth)
    all_fkey = Frame(all_fmagmoth)
    all_fxyz = Frame(all_fmagmoth)
    all_fb = Frame(all_fmagmoth)
    all_fedi = Frame(all_fmagmoth)
    all_fdel = Frame(all_fmagmoth)
    all_fcop = Frame(all_fmagmoth)
    all_fplot = Frame(all_fmagmoth)
    all_fplotxy = Frame(all_fmagmoth)
    all_fplotxz = Frame(all_fmagmoth)
    all_fplotzy = Frame(all_fmagmoth)
    all_fsel = Frame(WallListMags)
    all_fbott = Frame(WallListMags)
    all_fpn = Frame(WallListMags)

    all_fmoth.pack(side=LEFT)

    #print("List:",mode,NL,MagPolsTot[0])

    for imp in range(all_lastmp):

      mp = MagPolsTot[imp]

      cmag = mp[0][0]
      cmoth = mp[0][1]

      buttmoth = Button(all_fmoth,text=cmoth,
                        command= lambda moth=cmoth: _selectMoth(moth))
      buttmoth.pack(side=TOP,fill=X)

      buttmag = Button(all_fmag,text=cmag,
                       command= lambda mag = cmag: _selectMag(mag))
      buttmag.pack(side=TOP,fill=X)

      ckey = mp[3]
      buttkey = Button(all_fkey,text=ckey,bg='white')
      buttkey.pack(side=TOP,fill=X)

      mp1 = round(mp[-1][0],3)
      mp2 = round(mp[-1][1],3)
      mp3 = round(mp[-1][2],3)
      txyz = str([mp1,mp2,mp3])
      buttxyz = Button(all_fxyz,text=txyz)
      buttxyz.pack(side=TOP,fill=X)

      vmat = mp[5]

      bc = calc_var(vmat[0])
      bxn = calc_var(vmat[1])
      byn = calc_var(vmat[2])
      bzn = calc_var(vmat[3])

      mat = vmat[4]

      tb = " P " #Pole

      if mat in Variables and Variables[mat] == 1 or mat == '1':
        sxyz = ""
        if bxn > 0: sxyz += "   +X"
        if bxn < 0: sxyz += "   -X"
        if byn > 0: sxyz += "   +Y"
        if byn < 0: sxyz += "   -Y"
        if bzn > 0: sxyz += "   +Z"
        if bzn < 0: sxyz += "   -Z"
        try: tb = str(bc) + sxyz
        except: tb = bc + sxyz
      #endif Variables[mat] == 1

      buttb = Button(all_fb,text=tb)
      buttb.pack(side=TOP,fill=X)

      buttcop = Button(all_fcop,text='Copy',
                       command= lambda mag = imp: _copyMag(mag))
      buttcop.pack(side=TOP,fill=X)

      buttedi = Button(all_fedi,text='Edit',
                       command= lambda mag = imp: _editMag(mag))
      buttedi.pack(side=TOP,fill=X)

      buttdel = Button(all_fdel,text='Delete',
                       command= lambda mag = imp: _delmagpol(mag))
      buttdel.pack(side=TOP,fill=X)

      buttplot = Button(all_fplot,text='Plot 3d',
                       command= lambda mag = imp, key = '3d': _plotMag(mag,key))
      buttplot.pack(side=TOP,fill=X)

      buttplotxy = Button(all_fplotxy,text='XY',
                       command= lambda mag = imp, key = 'xy': _plotMag(mag,key))
      buttplotxy.pack(side=TOP,fill=X)

      buttplotxy = Button(all_fplotxz,text='XZ',
                       command= lambda mag = imp, key = 'xz': _plotMag(mag,key))
      buttplotxy.pack(side=TOP,fill=X)

      buttplotxy = Button(all_fplotzy,text='ZY',
                       command= lambda mag = imp, key = 'zy': _plotMag(mag,key))
      buttplotxy.pack(side=TOP,fill=X)

#      All_butts.append([buttmoth,buttmag,buttkey,buttxyz,buttb,buttedi,buttcop,\
#      buttdel,buttplot])
      All_butts.append([buttmoth,buttmag,buttkey,buttxyz,buttb])
    #endfor imp in range( NMagPolsTot)

    WallListMags.update()

    if NMagPolTot > ndmp:
      bPrev = Button(all_fpn,text='Previous',command= lambda key='all_prev': _listMags(key))
      bPrev.pack(expand=TRUE,side=LEFT,fill=X)
      bPlotSel = Button(all_fpn,text='Plot Selection',command= lambda item=-2: _showGeo('3d',item))
      bPlotSel.pack(expand=TRUE,side=LEFT,fill=X)
      bCont = Button(all_fpn,text='Next',command= lambda key='all_next': _listMags(key))
      bCont.pack(expand=TRUE,side=RIGHT,fill=X)
    #endif NMagPolTot > 0

    #bsel = Button(all_fsel,text='Select All',command=_selectAll)
    #bsel.pack(side=LEFT,expand=TRUE,fill=BOTH)
    #bdsel = Button(all_fsel,text='Deselect All',command=_deselectAll)
    #bdsel.pack(side=RIGHT,expand=TRUE,fill=BOTH)
    bdsel = Button(all_fsel,text='Plot whole device',command=_showGeo)
    bdsel.pack(side=RIGHT,expand=TRUE,fill=BOTH)
    bClose = Button(all_fbott,text='Close',command=_clWallListMags)
    bClose.pack(side=BOTTOM,fill=BOTH)

    all_fmag.pack(side=LEFT)
    all_fmoth.pack(side=LEFT)
    all_fkey.pack(side=LEFT)
    all_fxyz.pack(side=LEFT)
    all_fb.pack(side=LEFT)
    all_fedi.pack(side=LEFT)
    all_fcop.pack(side=LEFT)
    all_fdel.pack(side=LEFT)
    all_fplot.pack(side=LEFT)
    all_fplotxy.pack(side=LEFT)
    all_fplotxz.pack(side=LEFT)
    all_fplotzy.pack(side=LEFT)

    all_fmagmoth.pack(side=TOP)
    all_fpn.pack(side=TOP,fill=X)
    all_fsel.pack(side=TOP,fill=X)
    all_fbott.pack(side=TOP,fill=X)

    if iupdateall == 1:
      sgeo = WallGeo.split('+')
      sgeo = '+' + sgeo[1] + '+' + sgeo[2]
      WallListMags.geometry(sgeo)
    else:
      sgeo = Wmaster.geometry().split('+')
      whw = sgeo[0].split('x')
      ww = int(whw[0])
      wh = int(whw[1])
      xw = int(sgeo[1])
      yw = int(sgeo[2])
      x = xw + int(ww/3)
      y = yw + int(wh/10)
      sgeo = '+' + str(x) + '+' + str(y)
      #WallListMags.geometry(sgeo)
    #endif mode == 'update'

    _configMagButts()
    WallListMags.update()

  elif mode == 'all_prev':

    all_lastmp = all_firstmp + ndmp - 1
    all_lastmp = max(all_lastmp-2*ndmp, ndmp)
    all_firstmp = max(all_firstmp-2*ndmp,1)

    ibut = ndmp
    for imp in range(all_lastmp-1,all_firstmp-2,-1):
      mp = MagPolsTot[imp]
      cmag = mp[0][0]
      cmoth = mp[0][1]
      All_butts[ibut-1][0].config(text=cmoth, command= lambda moth = MyMoth[cmag]: _selectMoth(cmoth))
      All_butts[ibut-1][1].config(text=cmag,command= lambda mag = imp: _selectMag(cmag))
      txyz = str(MagPolsTot[imp][-1])
      All_butts[ibut-1][2].configure(text=txyz)
      vmat = mp[5]
      bc = calc_var(vmat[0])
      bxn = calc_var(vmat[1])
      byn = calc_var(vmat[2])
      bzn = calc_var(vmat[3])
      mat = vmat[4]
      if mat in Variables and Variables[mat] == 1 or mat == '1':
        sxyz = ""
        if bxn > 0: sxyz += "+X"
        if bxn < 0: sxyz += "-X"
        if byn > 0: sxyz += "+Y"
        if byn < 0: sxyz += "-Y"
        if bzn > 0: sxyz += "+Z"
        if bzn < 0: sxyz += "-Z"
        tb = str(bc) + "   " + sxyz
      else:
        tb = " P "
      #endif Variables[mat] == 1
      All_butts[ibut-1][3].configure(text=tb)
      All_butts[ibut-1][4].config(text='Edit',command= lambda mag = imp: _editMag(mag))
      All_butts[ibut-1][5].config(text='Copy',command= lambda mag = imp: _copyMag(mag))
      All_butts[ibut-1][6].config(text='Plot',command= lambda mag = imp: _plotMag(mag))
      ibut -= 1
    #endfor imp in range(all_lastmp,all_firstmp,-1)

    _configMagButts()
    WallListMags.update()

  elif mode == 'all_next':

    all_lastmp = all_firstmp + ndmp - 1

    if all_lastmp > NMagPolTot - 1:
      all_lastmp = NMagPolTot -1
      all_firstmp = all_lastmp - ndmp
    #if all_lastmp > NMagPolTot - 1

    ibut = ndmp
    for imp in range(all_lastmp-1,all_firstmp-2,-1):
      mp = MagPolsTot[imp]
      cmag = mp[0][0]
      cmoth = mp[0][1]
      All_butts[ibut-1][0].config(text=cmoth, command= lambda moth = MyMoth[cmag]: _selectMoth(cmoth))
      All_butts[ibut-1][1].config(text=cmag,command= lambda mag = imp: _selectMag(cmag))
      txyz = str(MagPolsTot[imp][-1])
      All_butts[ibut-1][2].configure(text=txyz)
      vmat = mp[5]
      bc = calc_var(vmat[0])
      bxn = calc_var(vmat[1])
      byn = calc_var(vmat[2])
      bzn = calc_var(vmat[3])
      mat = vmat[4]
      if mat in Variables and Variables[mat] == 1 or mat == '1':
        sxyz = ""
        if bxn > 0: sxyz += "+X"
        if bxn < 0: sxyz += "-X"
        if byn > 0: sxyz += "+Y"
        if byn < 0: sxyz += "-Y"
        if bzn > 0: sxyz += "+Z"
        if bzn < 0: sxyz += "-Z"
        tb = str(bc) + "   " + sxyz
      else:
        tb = " P "
      #endif Variables[mat] == 1
      All_butts[ibut-1][3].configure(text=tb)
      All_butts[ibut-1][4].config(text='Edit',command= lambda mag = imp: _editMag(mag))
      All_butts[ibut-1][4].config(text='Copy',command= lambda mag = imp: _copyMag(mag))
      All_butts[ibut-1][5].config(text='Plot',command= lambda mag = imp: _plotMag(mag))
      ibut -= 1
    #endfor imp in range(all_lastmp,all_firstmp,-1)

    _configMagButts()
    WallListMags.update()

  #endif mode == 'all'

  # counter, i.e. indices + 1
  try:
    sel_firstmp = sel_lastmp + 1
  except:
    ndmp = 10
    sel_firstmp = 1
  #endtry:

  if mode == 'selected' or iupdatesel == 1:

    if NMagPolSel < 0: return

    if mode == 'selected':
      sel_lastmp = sel_firstmp + ndmp - 1
      sel_firstmp = 1
      sel_lastmp = min(ndmp,NMagPolSel)
    else:
      if sel_lastmp > NMagPolSel - 1:
        sel_lastmp = NMagPolSel -1
        sel_firstmp = sel_lastmp - ndmp
      #endif sel_lastmp > NMagPolSel - 1
      mode == 'selected'
    #endif mode == 'selected'

    WselListMags = Toplevel()
    WselListMags.title("List of Selected Magnetic Items")
    WselListMags.attributes('-topmost', 1)

    sel_butts = []
    sel_frames = []

    sel_fmagmoth = Frame(WselListMags)
    sel_fmoth = Frame(sel_fmagmoth)
    sel_fmag = Frame(sel_fmagmoth)
    sel_fxyz = Frame(sel_fmagmoth)
    sel_fb = Frame(sel_fmagmoth)
    sel_fedi = Frame(sel_fmagmoth)
    sel_fdel = Frame(sel_fmagmoth)
    sel_fcop = Frame(sel_fmagmoth)
    sel_fplot = Frame(sel_fmagmoth)
    sel_fbott = Frame(WselListMags)
    sel_fpn = Frame(WselListMags)

    sel_fmoth.pack(side=LEFT)

    sel_width_ini = WselListMags.winfo_reqwidth()
    sel_width = sel_width_ini

    for isel in range(sel_lastmp):

      cmag = MagPolsSel[isel]
      imp = DictMagPolsTot[cmag]
      mp = MagPolsTot[imp]
      cmoth = mp[0][1]

      buttmoth = Button(sel_fmoth,text=cmoth, bg='white',
                        command= lambda moth=cmoth: _selectMoth(moth))
      buttmoth.pack(side=TOP,fill=X)
      buttmag = Button(sel_fmag,text=cmag, bg='white',
                       command= lambda mag = cmag: _selectMag(mag))
      buttmag.pack(side=TOP,fill=X)
      txyz = str(mp[-1])
      buttxyz = Button(sel_fxyz,text=txyz, bg='white')
      buttxyz.pack(side=TOP,fill=X)
      vmat = mp[5]
      bc = calc_var(vmat[0])
      bxn = calc_var(vmat[1])
      byn = calc_var(vmat[2])
      bzn = calc_var(vmat[3])
      mat = vmat[4]
      if mat in Variables and Variables[mat] == 1 or mat == '1':
        sxyz = ""
        if bxn > 0: sxyz += "   +X"
        if bxn < 0: sxyz += "   -X"
        if byn > 0: sxyz += "   +Y"
        if byn < 0: sxyz += "   -Y"
        if bzn > 0: sxyz += "   +Z"
        if bzn < 0: sxyz += "   -Z"
        tb = str(bc) + sxyz
      else:
        tb = " P "
      #endif Variables[mat] == 1

      buttb = Button(sel_fb,text=tb, bg='white')
      buttb.pack(side=TOP,fill=X)

      buttdel = Button(sel_fdel,text='Delete', bg='white',
                       command= lambda mag = imp: _delmagpol(mag))
      buttdel.pack(side=TOP,fill=X)

      buttedi = Button(sel_fedi,text='Edit', bg='white',
                       command= lambda mag = imp: _editMag(mag))
      buttedi.pack(side=TOP,fill=X)

      buttcop = Button(sel_fcop,text='Copy', bg='white',
                       command= lambda mag = imp: _copyMag(mag))
      buttcop.pack(side=TOP,fill=X)

      buttplot = Button(sel_fplot,text='Plot', bg='white',
                       command= lambda mag = imp: _plotMag(mag))
      buttplot.pack(side=TOP,fill=X)

      sel_butts.append([buttmoth,buttmag,buttxyz,buttb,buttedi,buttcop,buttplot])
    #endfor imp in range( NMagPolSel)

    WselListMags.update()

    sel_width_ini = WselListMags.winfo_width()
    sel_width = sel_width_ini

    if NMagPolSel > ndmp:
      bPrev = Button(sel_fpn,text='Previous',command= lambda key='sel_prev': _listMags(key))
      bPrev.pack(expand=TRUE,side=LEFT,fill=X)
      bCont = Button(sel_fpn,text='Next',command= lambda key='sel_next': _listMags(key))
      bCont.pack(expand=TRUE,side=RIGHT,fill=X)
    #endif NMagPolSel > 0

    bClose = Button(sel_fbott,text='Ok',command=_clWselListMags)
    bClose.pack(side=BOTTOM,fill=BOTH)

    sel_fmag.pack(side=LEFT)
    sel_fmoth.pack(side=LEFT)
    sel_fxyz.pack(side=LEFT)
    sel_fb.pack(side=LEFT)
    sel_fedi.pack(side=LEFT)
    sel_fcop.pack(side=LEFT)
    sel_fdel.pack(side=LEFT)
    sel_fplot.pack(side=LEFT)

    sel_fmagmoth.pack(side=TOP)
    sel_fpn.pack(side=TOP,fill=X)
    sel_fbott.pack(side=TOP,fill=X)

    if iupdatesel == 1:
      sgeo = WselGeo.split('+')
      sgeo = '+' + sgeo[1] + '+' + sgeo[2]
      WselListMags.geometry(sgeo)
    #endif mode == 'update'
    #x,y = Umaster.winfo_pointerxy()
    #sgeo = '+' + str(x) + '+' + str(y)
    #WselListMags.geometry(sgeo)

    WselListMags.update()
    sel_width = WselListMags.winfo_width()
    #sel_width = sel_fmagmoth.winfo_width()
    sel_width_old = sel_width

  elif mode == 'sel_prev':

    sel_lastmp = sel_firstmp + ndmp - 1

    sel_lastmp = max(sel_lastmp-2*ndmp, ndmp)
    sel_firstmp = max(sel_firstmp-2*ndmp,1)

    ibut = ndmp
    for isel in range(sel_lastmp-1,sel_firstmp-2,-1):

      cmag = MagPolsSel[isel]
      imp = DictMagPolsTot[cmag]
      mp = MagPolsTot[imp]
      cmoth = mp[0][1]

      sel_butts[ibut-1][0].config(text=cmoth, bg='white', command= lambda moth = MyMoth[cmag]: _selectMoth(cmoth))
      sel_butts[ibut-1][1].config(text=cmag, bg='white',command= lambda mag = imp: _selectMag(cmag))
      txyz = str(MagPolsSel[imp][-1])
      sel_butts[ibut-1][2].configure(text=txyz)
      vmat = mp[5]
      bc = calc_var(vmat[0])
      bxn = calc_var(vmat[1])
      byn = calc_var(vmat[2])
      bzn = calc_var(vmat[3])
      mat = vmat[4]
      if mat in Variables and Variables[mat] == 1 or mat == '1':
        sxyz = ""
        if bxn > 0: sxyz += "+X"
        if bxn < 0: sxyz += "-X"
        if byn > 0: sxyz += "+Y"
        if byn < 0: sxyz += "-Y"
        if bzn > 0: sxyz += "+Z"
        if bzn < 0: sxyz += "-Z"
        tb = str(bc) + "   " + sxyz
      else:
        tb = " P "
      #endif Variables[mat] == 1
      sel_butts[ibut-1][3].configure(text=tb)
      sel_butts[ibut-1][4].config(text=cmag, bg='white',command= lambda mag = imp: _editMag(mag))
      sel_butts[ibut-1][5].config(text=cmag, bg='white',command= lambda mag = imp: _plotMag(mag))
      ibut -= 1
    #endfor imp in range(sel_lastmp,sel_firstmp,-1)

  elif mode == 'sel_next':

    sel_lastmp = sel_firstmp + ndmp - 1

    if sel_lastmp > NMagPolSel - 1:
      sel_lastmp = NMagPolSel -1
      sel_firstmp = sel_lastmp - ndmp
    #if sel_lastmp > NMagPolSel - 1

    ibut = ndmp
    for isel in range(sel_lastmp-1,sel_firstmp-2,-1):

      cmag = MagPolsSel[isel]
      imp = DictMagPolsTot[cmag]
      mp = MagPolsTot[imp]
      cmoth = mp[0][1]

      sel_butts[ibut-1][0].config(text=cmoth, bg='white', command= lambda moth = MyMoth[cmag]: _selectMoth(cmoth))
      sel_butts[ibut-1][1].config(text=cmag, bg='white',command= lambda mag = imp: _selectMag(cmag))
      txyz = str(MagPolsSel[imp][-1])
      sel_butts[ibut-1][2].configure(text=txyz)
      vmat = mp[5]
      bc = calc_var(vmat[0])
      bxn = calc_var(vmat[1])
      byn = calc_var(vmat[2])
      bzn = calc_var(vmat[3])
      mat = vmat[4]
      if mat in Variables and Variables[mat] == 1 or mat == '1':
        sxyz = ""
        if bxn > 0: sxyz += "+X"
        if bxn < 0: sxyz += "-X"
        if byn > 0: sxyz += "+Y"
        if byn < 0: sxyz += "-Y"
        if bzn > 0: sxyz += "+Z"
        if bzn < 0: sxyz += "-Z"
        tb = str(bc) + "   " + sxyz
      else:
        tb = " P "
      #endif Variables[mat] == 1
      sel_butts[ibut-1][3].configure(text=tb)
      sel_butts[ibut-1][4].config(text=cmag, bg='white',command= lambda mag = imp: _editMag(mag))
      sel_butts[ibut-1][5].config(text=cmag, bg='white',command= lambda mag = imp: _plotMag(mag))
      ibut -= 1
    #endfor imp in range(sel_lastmp,sel_firstmp,-1)

  #endif mode == 'sel'

  # counter, i.e. indices + 1
  try:
    del_firstmp = del_lastmp + 1
  except:
    ndmp = 10
    del_firstmp = 1
  #endtry:

  if mode == 'deleted' or iupdatedel == 1:

    if NMagPolDel < 0: return

    if mode == 'deleted':
      del_lastmp = del_firstmp + ndmp - 1
      del_firstmp = 1
      del_lastmp = min(ndmp,NMagPolDel)
    else:
      if del_lastmp > NMagPolDel - 1:
        del_lastmp = NMagPolDel -1
        del_firstmp = del_lastmp - ndmp
      #endif del_lastmp > NMagPolDel - 1
      mode == 'delected'
    #endif mode == 'delected'

    WdelListMags = Toplevel()
    WdelListMags.title("List of Delected Magnetic Items")
    WdelListMags.attributes('-topmost', 1)

    del_butts = []
    del_frames = []

    del_fmagmoth = Frame(WdelListMags)
    del_fmoth = Frame(del_fmagmoth)
    del_fmag = Frame(del_fmagmoth)
    del_fxyz = Frame(del_fmagmoth)
    del_fb = Frame(del_fmagmoth)
    del_fedi = Frame(del_fmagmoth)
    del_fdel = Frame(del_fmagmoth)
    del_fcop = Frame(del_fmagmoth)
    del_fplot = Frame(del_fmagmoth)
    del_fbott = Frame(WdelListMags)
    del_fpn = Frame(WdelListMags)

    del_fmoth.pack(side=LEFT)

    del_width_ini = WdelListMags.winfo_reqwidth()
    del_width = del_width_ini

    for idel in range(del_lastmp):

      mp = MagPolsDel[idel]
      cmag = mp[0][0]
      cmoth = mp[0][1]

      buttmoth = Button(del_fmoth,text=cmoth, bg='white',
                        command= lambda moth=cmoth: _delectMoth(moth))
      buttmoth.pack(side=TOP,fill=X)
      buttmag = Button(del_fmag,text=cmag, bg='white',
                       command= lambda mag = cmag: _delectMag(mag))
      buttmag.pack(side=TOP,fill=X)
      txyz = str(mp[-1])
      buttxyz = Button(del_fxyz,text=txyz, bg='white')
      buttxyz.pack(side=TOP,fill=X)
      vmat = mp[5]
      bc = calc_var(vmat[0])
      bxn = calc_var(vmat[1])
      byn = calc_var(vmat[2])
      bzn = calc_var(vmat[3])
      mat = vmat[4]
      if mat in Variables and Variables[mat] == 1 or mat == '1':
        sxyz = ""
        if bxn > 0: sxyz += "   +X"
        if bxn < 0: sxyz += "   -X"
        if byn > 0: sxyz += "   +Y"
        if byn < 0: sxyz += "   -Y"
        if bzn > 0: sxyz += "   +Z"
        if bzn < 0: sxyz += "   -Z"
        tb = str(bc) + sxyz
      else:
        tb = " P "
      #endif Variables[mat] == 1

      buttb = Button(del_fb,text=tb, bg='white')
      buttb.pack(side=TOP,fill=X)

      buttdel = Button(del_fdel,text='Restore', bg='white',
                       command= lambda mag = idel: _resmagpol(mag))
      buttdel.pack(side=TOP,fill=X)

      buttedi = Button(del_fedi,text='Edit', bg='white',
                       command= lambda mag = idel: _editMag(mag))
      buttedi.pack(side=TOP,fill=X)

      buttcop = Button(del_fcop,text='Copy', bg='white',
                       command= lambda mag = idel: _copyMag(mag))
      buttcop.pack(side=TOP,fill=X)

      buttplot = Button(del_fplot,text='Plot', bg='white',
                       command= lambda mag = idel: _plotMag(mag))
      buttplot.pack(side=TOP,fill=X)

      del_butts.append([buttmoth,buttmag,buttxyz,buttb,buttedi,buttcop,buttplot])
    #endfor idel in range( NMagPolDel)

    WdelListMags.update()

    del_width_ini = WdelListMags.winfo_width()
    del_width = del_width_ini

    if NMagPolDel > ndmp:
      bPrev = Button(del_fpn,text='Previous',command= lambda key='del_prev': _listMags(key))
      bPrev.pack(expand=TRUE,side=LEFT,fill=X)
      bCont = Button(del_fpn,text='Next',command= lambda key='del_next': _listMags(key))
      bCont.pack(expand=TRUE,side=RIGHT,fill=X)
    #endif NMagPolDel > 0

    bClose = Button(del_fbott,text='Ok',command=_clWdelListMags)
    bClose.pack(side=BOTTOM,fill=BOTH)

    del_fmag.pack(side=LEFT)
    del_fmoth.pack(side=LEFT)
    del_fxyz.pack(side=LEFT)
    del_fb.pack(side=LEFT)
    del_fedi.pack(side=LEFT)
    del_fcop.pack(side=LEFT)
    del_fdel.pack(side=LEFT)
    del_fplot.pack(side=LEFT)

    del_fmagmoth.pack(side=TOP)
    del_fpn.pack(side=TOP,fill=X)
    del_fbott.pack(side=TOP,fill=X)

    if iupdatedel == 1:
      sgeo = WdelGeo.split('+')
      sgeo = '+' + sgeo[1] + '+' + sgeo[2]
      WdelListMags.geometry(sgeo)
    #endif mode == 'update'
    #x,y = Umaster.winfo_pointerxy()
    #sgeo = '+' + str(x) + '+' + str(y)
    #WdelListMags.geometry(sgeo)

    WdelListMags.update()
    del_width = WdelListMags.winfo_width()
    #del_width = del_fmagmoth.winfo_width()
    del_width_old = del_width

  elif mode == 'del_prev':

    del_lastmp = del_firstmp + ndmp - 1

    del_lastmp = max(del_lastmp-2*ndmp, ndmp)
    del_firstmp = max(del_firstmp-2*ndmp,1)

    ibut = ndmp
    for idel in range(del_lastmp-1,del_firstmp-2,-1):

      mp = MagPolsDel[idel]
      cmag = mp[0][0]
      cmoth = mp[0][1]

      del_butts[ibut-1][0].config(text=cmoth, bg='white', command= lambda moth = MyMoth[cmag]: _delectMoth(cmoth))
      del_butts[ibut-1][1].config(text=cmag, bg='white',command= lambda mag = idel: _delectMag(cmag))
      txyz = str(MagPolsDel[idel][-1])
      del_butts[ibut-1][2].configure(text=txyz)
      vmat = mp[5]
      bc = calc_var(vmat[0])
      bxn = calc_var(vmat[1])
      byn = calc_var(vmat[2])
      bzn = calc_var(vmat[3])
      mat = vmat[4]
      if mat in Variables and Variables[mat] == 1 or mat == '1':
        sxyz = ""
        if bxn > 0: sxyz += "+X"
        if bxn < 0: sxyz += "-X"
        if byn > 0: sxyz += "+Y"
        if byn < 0: sxyz += "-Y"
        if bzn > 0: sxyz += "+Z"
        if bzn < 0: sxyz += "-Z"
        tb = str(bc) + "   " + sxyz
      else:
        tb = " P "
      #endif Variables[mat] == 1
      del_butts[ibut-1][3].configure(text=tb)
      del_butts[ibut-1][4].config(text=cmag, bg='white',command= lambda mag = idel: _editMag(mag))
      del_butts[ibut-1][5].config(text=cmag, bg='white',command= lambda mag = idel: _plotMag(mag))
      ibut -= 1
    #endfor idel in range(del_lastmp,del_firstmp,-1)

  elif mode == 'del_next':

    del_lastmp = del_firstmp + ndmp - 1

    if del_lastmp > NMagPolDel - 1:
      del_lastmp = NMagPolDel -1
      del_firstmp = del_lastmp - ndmp
    #if del_lastmp > NMagPolDel - 1

    ibut = ndmp
    for idel in range(del_lastmp-1,del_firstmp-2,-1):

      mp = MagPolsDel[idel]
      cmag = mp[0][0]
      cmoth = mp[0][1]

      del_butts[ibut-1][0].config(text=cmoth, bg='white', command= lambda moth = MyMoth[cmag]: _delectMoth(cmoth))
      del_butts[ibut-1][1].config(text=cmag, bg='white',command= lambda mag = idel: _delectMag(cmag))
      txyz = str(MagPolsDel[idel][-1])
      del_butts[ibut-1][2].configure(text=txyz)
      vmat = mp[5]
      bc = calc_var(vmat[0])
      bxn = calc_var(vmat[1])
      byn = calc_var(vmat[2])
      bzn = calc_var(vmat[3])
      mat = vmat[4]

      if mat in Variables and Variables[mat] == 1 or mat == '1':
        sxyz = ""
        if bxn > 0: sxyz += "+X"
        if bxn < 0: sxyz += "-X"
        if byn > 0: sxyz += "+Y"
        if byn < 0: sxyz += "-Y"
        if bzn > 0: sxyz += "+Z"
        if bzn < 0: sxyz += "-Z"
        tb = str(bc) + "   " + sxyz
      else:
        tb = " P "
      #endif Variables[mat] == 1
      del_butts[ibut-1][3].configure(text=tb)
      del_butts[ibut-1][4].config(text=cmag, bg='white',command= lambda mag = idel: _editMag(mag))
      del_butts[ibut-1][5].config(text=cmag, bg='white',command= lambda mag = idel: _plotMag(mag))
      ibut -= 1
    #endfor idel in range(del_lastmp,del_firstmp,-1)

  #endif mode == 'del'

#enddef _listMags()

# +KEEP,listmags,T=PYTHON.}
+KEEP,unduplgeo,T=PYTHON.
*CMZ :  2.04/10 21/08/2023  15.45.12  by  Michael Scheer
*CMZ :  2.04/09 17/08/2023  15.19.59  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  13.14.39  by  Michael Scheer
*CMZ :  2.04/00 24/12/2022  11.49.32  by  Michael Scheer
*CMZ :  2.03/00 14/07/2022  12.03.10  by  Michael Scheer
*CMZ :  2.02/02 04/07/2022  14.31.24  by  Michael Scheer
*CMZ :  2.02/01 26/01/2022  12.39.30  by  Michael Scheer
*CMZ :  2.02/00 24/03/2021  15.14.49  by  Michael Scheer
*-- Author :    Michael Scheer   26/10/2020

+seq,UnduColors.
+seq,ureadclc.

def undu_coil(ntup='ncoil', fcoil='undumag.fil'):
  if fexist(fcoil):
    ncoil = ncread(ntup,"itype:curr:x1:y1:z1:x2:y2:z2:icol:num:ncoil",fcoil)
    if Nlines > 0: ninfo(ncoil)
  else:
    ncoil = ncre(ntup,"itype:curr:x1:y1:z1:x2:y2:z2:icol:num:ncoil")
  #endif
  return ncoil
#enddef undu_coil

def undu_plot_coil_4x4(ntup='!', fcoil='!'):
  zone(2,2)
  undu_plot_coil('!','!','3d',0)
  nextzone()
  undu_plot_coil('!','!','top',0)
  nextzone()
  undu_plot_coil('!','!','side',0)
  nextzone()
  undu_plot_coil('!','!','beam',0)
#enddef

def undu_plot_coil_top(ntup='!', fcoil='!',isame=0):
  undu_plot_coil('!','!','top',isame)
def undu_plot_coil_side(ntup='!', fcoil='!',isame=0):
  undu_plot_coil('!','!','side',isame)
def undu_plot_coil_beam(ntup='!', fcoil='!',isame=0):
  undu_plot_coil('!','!','beam',isame)

def undu_plot_coil(ntup='!', fcoil='!', mode='3d', isame=0):

  if ntup == '!': ntup = 'ncoil'
  if fcoil == '!': fcoil = 'undumag.fil'
  if not nexist(ntup): ncoil = undu_coil(ntup,fcoil)
  else: ncoil = nget("ncoil")

  if not len(ncoil): return

  #print(ntup,fcoil,mode)

  xmin = min(ncoil.x1.min(),ncoil.x2.min())
  xmax = max(ncoil.x1.max(),ncoil.x2.max())
  ymin = min(ncoil.y1.min(),ncoil.y2.min())
  ymax = max(ncoil.y1.max(),ncoil.y2.max())
  zmin = min(ncoil.z1.min(),ncoil.z2.min())
  zmax = max(ncoil.z1.max(),ncoil.z2.max())

  d = (xmax-xmin)*0.1
  xmin -= d
  xmax += d
  if xmin == xmax:
    xmin = xmin - 1.0
    xmax = xmax + 1.0
  #endif

  d = (ymax-ymin)*0.1
  ymin -= d
  ymax += d
  if ymin == ymax:
    ymin = ymin - 1.0
    ymax = ymax + 1.0
  #endif

  d = (zmax-zmin)*0.1
  zmin -= d
  zmax += d
  if zmin == zmax:
    zmin = zmin - 1.0
    zmax = zmax + 1.0
  #endif

  yzmin = min(ymin,zmin)
  yzmax = max(ymax,zmax)

  if mode.lower() == 'xz' or mode.lower() == 'top':

    if not isame:
      null(xmin,xmax,zmin,zmax)
      txyz("Coil","x/mm","z/mm")
    #endif

    # Exterm langsam!!     for w in ncoil.itertuples():
    #        Ax.plot([w.x1,w.x2],[w.z1,w.z2],UnduColors[w.icol])
    #for w in ncoil.itertuples()

    for icoil in range(ncoil.ncoil.max()):
      coil = ncoil.query("ncoil=="+str(icoil+1))
      for w in coil.itertuples():
        Ax.plot([w.x1,w.x2],[w.z1,w.z2],UnduColors[w.icol])
    #endfor icoil in range(ncoil.num.max()+1)

  elif mode.lower() == 'xy' or mode.lower() == 'side':

    if not isame:
      null(xmin,xmax,ymin,ymax)
      txyz("Coil","x/mm","y/mm")
    #endif

    for icoil in range(ncoil.ncoil.max()):
      coil = ncoil.query("ncoil=="+str(icoil+1))
      for w in coil.itertuples():
        Ax.plot([w.x1,w.x2],[w.y1,w.y2],UnduColors[w.icol])
    #endfor icoil in range(ncoil.num.max()+1)

  elif mode.lower() == 'yz' or mode.lower() == 'beam':

    if not isame:
      null(yzmin,yzmax,yzmin,yzmax)
      txyz("Coil","z/mm","y/mm")
    #endif

    #    Elegant, aber extrem langsam!!
    #    for w in ncoil.itertuples(): Ax.plot([w.z1,w.z2],[w.y1,w.y2],color='blue')

    for icoil in range(ncoil.ncoil.max()):
      coil = ncoil.query("ncoil=="+str(icoil+1))
      for w in coil.itertuples():
        Ax.plot([w.z1,w.z2],[w.y1,w.y2],UnduColors[w.icol])
    #endfor icoil in range(ncoil.num.max()+1)

  else:

    if not isame:
      null3d(xmin,xmax,yzmin,yzmax,yzmin,yzmax)
      txyz("Coil","x/mm","z/mm","y/mm")
    #endif

    for icoil in range(ncoil.ncoil.max()):
      coil = ncoil.query("ncoil=="+str(icoil+1))
      for w in coil.itertuples():
        Ax.plot([w.x1,w.x2],[w.z1,w.z2],[w.y1,w.y2],UnduColors[w.icol])
    #endfor icoil in range(ncoil.num.max()+1)

  #endif mode.lower() == '3d'

#enddef undu_plot_coil(...)

def undu_geo(plopt='sameline'):

+seq,argumentsind.
+seq,mhbglobind.
+seq,UnduColorsind.

  kdump = Kdump
  kpdf = Kpdf
  kecho = Kecho

  Kdump = False
  Kpdf = False
  Kecho = False

  if nargs > 2: ugeomode = int(args[2])
  else: ugeomode = 0

  if plopt == '!': plopt = 'sameline'

  if not nexist("ngeo"):
    ngeo = ncread("ngeo","mag:ityp:xc:yc:zc:moth:ix:iy:iz:mat:icol:mx:my:mz:bc:iplan:icorn:x:y:z:cmag:cmoth","undumag.geo")
  #endif

  if Nlines <= 0:
    undu_plot_coil()
    return
  #endif

  ninfo(ngeo)

  xmin = ngeo.x.min()
  ymin = ngeo.y.min()
  zmin = ngeo.z.min()

  xmax = ngeo.x.max()
  ymax = ngeo.y.max()
  zmax = ngeo.z.max()

  dx = (xmax-xmin)/20.
  dy = (ymax-ymin)/20.
  dz = (zmax-zmin)/20.

  xyzmax = xmax + dx
  if ymax+dy > xyzmax: xyzmax=ymax+dy
  if zmax+dz > xyzmax: xyzmax=zmax+dz
  xyzmin=xmin-dx

  if ymin-dy < xyzmin: xyzmin=ymin-dy
  if zmin-dz < xyzmin: xyzmin=zmin-dz

  yzmin=min(ymin,zmin)
  yzmax=max(ymax,zmax)

  null3d(xmin-dx,xmax+dx,yzmin,yzmax,yzmin,yzmax)

  txyz("geo","x","z","y")
  if len(ngeo) == 0: return

  if ugeomode < 0:
    return
  #endif ugeomode < 0

  ssel = "cmag != 'wire'"
  nmag = ngeo.query(ssel)

  isame = 0

  if len(nmag):

    if ugeomode > 0: # convex hull of items

      mmin = int(ngeo.mag.min())
      mmax = int(ngeo.mag.max())

      for mag in range(mmin,mmax+1):

        ssel = "mag == " + str(mag)
        icmin,icmax = nminmax(nmag,"icol",ssel)

        icmin = int(icmin)
        icmax = int(icmax)

        setmarkercolor(UnduColors[icmin])
        #setlinecolor(UnduColors[icmin])
        nhull = nhull3d(nmag,"x:z:y",ssel,'sameline',
                        facecolor=UnduColors[icmin],edgecolor=UnduColors[icmin],
                        alpha=0,ishow=0)

      #endfor mag in range(mmin,mmax)

      txyz("geo","x","z","y")

    else: # convex hull of mothers

      mmin = int(ngeo.moth.min())
      mmax = int(ngeo.moth.max())

      for moth in range(mmin,mmax+1):

        ssel = "moth==" + str(moth)

        icmin,icmax = nminmax(ngeo,"icol",ssel)
        try: icmin = int(icmin)
        except: continue

        setmarkercolor(UnduColors[icmin])
        #setlinecolor(UnduColors[icmin])

        nhull = nhull3d(ngeo,"x:z:y",ssel,'sameline')
        nhull = nhull3d(ngeo,"x:z:y",ssel,'sameline',
                        facecolor=UnduColors[icmin],edgecolor=UnduColors[icmin],
                        alpha=0,ishow=0)

      #endfor mag in range(mmin,mmax)

      txyz("geo","x","z","y")

    #endif ugeomode

  #endif

  undu_plot_coil(isame=isame)

  Kdump = kdump
  Kpdf = kpdf
  Kecho = kecho

#enddef undu_geo()

def undu_plot_mag(select='yc<0 and zc<0',plopt='sameline'):

+seq,mhbglobind.
+seq,UnduColorsind.

  kdump = Kdump
  kpdf = Kpdf
  kecho = Kecho

  Kdump = False
  Kpdf = False
  Kecho = False

  if plopt == '!': plopt = 'sameline'

  if not nexist("ngeo"):
    print('\nReading undumag.geo...')
    ngeo = ncread("ngeo","mag:ityp:xc:yc:zc:moth:ix:iy:iz:mat:icol:mx:my:mz:bc:iplan:icorn:x:y:z:cmag:cmoth","undumag.geo")
    print('done\n')
  #endif

  print('\nSelection for ',select)

  if len(select) > 0:
    nt = ngeo.query(select)
  else:
    nt = ngeo
  #endif

  print('\nStart plotting')

  if len(nt) == 0:
    print("\n*** Nothing to plot for",select)
    return
  #endif

  xmin = nt.x.min()
  ymin = nt.y.min()
  zmin = nt.z.min()

  xmax = nt.x.max()
  ymax = nt.y.max()
  zmax = nt.z.max()

  dx = (xmax-xmin)/20.
  dy = (ymax-ymin)/20.
  dz = (zmax-zmin)/20.

  xyzmax = xmax + dx
  if ymax+dy > xyzmax: xyzmax=ymax+dy
  if zmax+dz > xyzmax: xyzmax=zmax+dz
  xyzmin=xmin-dx

  if ymin-dy < xyzmin: xyzmin=ymin-dy
  if zmin-dz < xyzmin: xyzmin=zmin-dz

  yzmin=min(ymin,zmin)
  yzmax=max(ymax,zmax)

  null3d(xmin-dx,xmax+dx,yzmin,yzmax,yzmin,yzmax)

  nhull = nhull3d(nt,"x:z:y",'',plopt,edgecolor='black',ishow=0)
  plt.show(block=False)

  mmin = nt.mag.min()
  mmax = nt.mag.max()

  for m in range(mmin,mmax+1):
    selma = "mag==" + str(m)
    nm = nt.query(selma)
    icol = nm.icol.max()
    if len(nm) > 0:
      nhull = nhull3d(nm,"x:z:y",'',plopt,edgecolor=UnduColors[icol],ishow=0)
  #endfor

  plt.show(block=False)
  #txyz(select,"x","z","y")

  Kdump = kdump
  Kpdf = kpdf
  Kecho = kecho

#enddef undu_plot_mag()

def undu_mags(plopt='sameline'):

+seq,argumentsind.
+seq,mhbglobind.
+seq,UnduColorsind.

  #reakpoint()
  kdump = Kdump
  kpdf = Kpdf
  kecho = Kecho

  Kdump = False
  Kpdf = False
  Kecho = False


  if nargs > 2: ugeomode = int(args[2])
  else: ugeomode = 0

  if plopt == '!': plopt = 'sameline'

  if not nexist("nmags"):
    nmags = ncread("nmags","imoth:mag:icol:iplan:icorn:x:y:z:bx:by:bz:imat:cmag:cmoth:ispole","undumag.mag")
  else:
    nmags = nget("nmags")
  #endif

  if not nexist("nvox"):
    nvox = ncread("nvox","cnam:cmoth:icol:modu:kmag:lmag:ivox:icop:x:y:z:bxi:byi:bzi:bxe:bye:bze:ispole","undumag_voxel.lis")
  else:
    nvox = nget("nvox")
  #endif

  xmin = nmags.x.min()
  ymin = nmags.y.min()
  zmin = nmags.z.min()

  xmax = nmags.x.max()
  ymax = nmags.y.max()
  zmax = nmags.z.max()

  dx = (xmax-xmin)/20.
  dy = (ymax-ymin)/20.
  dz = (zmax-zmin)/20.

  xyzmax = xmax + dx
  if ymax+dy > xyzmax: xyzmax=ymax+dy
  if zmax+dz > xyzmax: xyzmax=zmax+dz
  xyzmin=xmin-dx

  if ymin-dy < xyzmin: xyzmin=ymin-dy
  if zmin-dz < xyzmin: xyzmin=zmin-dz

#  getzone('3d')
  null3d(xyzmin,xyzmax,xyzmin,xyzmax,xyzmin,xyzmax)

#  print("Returning");return
  txyz("Magnets","x","z","y")

  if ugeomode < 0:
    ninfo(nmags)
    return
  #endif ugeomode < 0

  mmin = int(nmags.mag.min())
  mmax = int(nmags.mag.max())

  if ugeomode == 0: # convex hull of items

    for mag in range(mmin,mmax+1):

      ssel = "mag==" + str(mag)
      icmin,icmax = nminmax(nmags,"icol",ssel)
      icmin = int(icmin)
      icmax = int(icmax)
      setmarkercolor(UnduColors[icmin])
      setlinecolor(UnduColors[icmin])
      if mag > 1:
        nhull = nhull3d(nmags,"x:z:y",ssel,'sameline',ishow=0)
      else:
        nhull = nhull3d(nmags,"x:z:y",ssel,plopt,ishow=0)
      #endif mag > 0
    #endfor mag in range(mmin,mmax)

    txyz("Magnets","x","z","y")

  #endif ugeomode

  Kdump = kdump
  Kpdf = kpdf
  Kecho = kecho

#enddef undu_mags()
+KEEP,showgeo,T=PYTHON.
*CMZ :  2.04/10 21/08/2023  13.18.56  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  19.12.52  by  Michael Scheer
*CMZ :  2.04/06 09/07/2023  12.23.11  by  Michael Scheer
*CMZ :  2.03/00 01/09/2022  08.28.07  by  Michael Scheer
*CMZ :  2.02/02 08/03/2022  11.43.34  by  Michael Scheer
*CMZ :  2.02/01 21/10/2021  12.11.52  by  Michael Scheer
*CMZ :  2.02/00 30/03/2021  11.36.44  by  Michael Scheer
*-- Author :    Michael Scheer   13/10/2020
+seq,unduplgeo.

def _ucoilplot(view='3d', mode='same', item=-1,callkey=''):

  global Coils, Filaments, UnduColors, CurrLoops, NMagPolTot

+self,if=trace.
  print(NL,"trace:: _ucoilplot:",view,mode,item,callkey)
+self.

  if NMagPolTot >= 0 and len(Filaments) == 0:
+self,if=trace.
    print(NL,"trace:: Leaving _ucoilplot, no coils...")
+self.
    return
  #endif

  xmin = 1.e30
  xmax = -1.e30
  ymin = 1.e30
  ymax = -1.e30
  zmin = 1.e30
  zmax = -1.e30

  coiltit = "Coils"
  icoil = -1
  ifound = 0

  for coil in Filaments:

    icoil += 1
    if item > -1 and icoil != item: continue
    coiltit = Coils[icoil][0][1]
    ifound = 1
    for wire in coil:
      xmin = min(xmin,wire[2],wire[5])
      xmax = max(xmax,wire[2],wire[5])
      ymin = min(ymin,wire[3],wire[6])
      ymax = max(ymax,wire[3],wire[6])
      zmin = min(zmin,wire[4],wire[7])
      zmax = max(zmax,wire[4],wire[7])
    #endfor wire in coil

  #endfor coil in Filaments

  dx = (xmax-xmin)*0.1
  dy = (ymax-ymin)*0.1
  dz = (zmax-zmin)*0.1

  if dx == 0.0: dx = 1.
  if dy == 0.0: dy = 1.
  if dz == 0.0: dz = 1.

  if ifound == 0:
    wError("No coils to plot")
+self,if=trace.
    print(NL,"trace:: Leaving _ucoilplot due to error")
+self.
    return
  #endif

  if view.lower() == 'xz' or view.lower() == 'top':

    if not mode == 'same':
      null(xmin-dx,xmax+dx,zmin-dz,zmax+dz)
      txyz(coiltit,"x/mm","z/mm")
    #endif

    icoil = -1
    for coil in Filaments:
      icoil += 1
      if item > -1 and icoil != item: continue
      color = UnduColors[coil[0][8]]
      for w in coil:
        Ax.plot([w[2],w[5]],[w[4],w[7]],color)
      #endfor
    #endfor

  elif view.lower() == 'xy' or view.lower() == 'side':

    if not mode == 'same':
      null(xmin-dx,xmax+dx,ymin-dy,ymax+dy)
      txyz(coiltit,"x/mm","y/mm")
    #endif

    icoil = -1
    for coil in Filaments:
      icoil += 1
      if item > -1 and icoil != item: continue
      color = UnduColors[coil[0][8]]
      for w in coil:
        Ax.plot([w[2],w[5]],[w[3],w[6]],color)
      #endfor
    #endfor

  elif view.lower() == 'yz' or view.lower() == 'beam':

    if not mode == 'same':
      null(zmin-dz,zmax+dz,ymin-dy,ymax+dy)
      txyz(coiltit,"z/mm","y/mm")
    #endif

    icoil = -1
    for coil in Filaments:
      icoil += 1
      if item > -1 and icoil != item: continue
      color = UnduColors[coil[0][8]]
      for w in coil:
        Ax.plot([w[3],w[6]],[w[4],w[7]],color)
      #endfor
    #endfor

  else:

    if not mode == 'same':
      null3d(xmin-dx,xmax+dx,zmin-dx,zmax+dz,ymin-dy,ymax+dy)
      txyz(coiltit,"x/mm","z/mm","y/mm")
    #endif

    icoil = -1

    for coil in Filaments:
      icoil += 1
      if item > -1 and icoil != item: continue
      color = UnduColors[coil[0][8]]
      for w in coil:
        Ax.plot([w[2],w[5]],[w[4],w[7]],[w[3],w[6]],color)
      #endfor
#      Ax.plot(
#              [coil[-1][5],coil[0][2]],
#              [coil[-1][7],coil[0][4]],
#              [coil[-1][6],coil[0][3]],
#              color)
    #endfor

  #endif mode

+self,if=trace.
  print(NL,"trace:: Leaving _ucoilplot")
+self.

#enddef _ucoilplot(view='3d', mode='same')

def _h3d(h3d,sx,sy,sz):
  global Hull3D
  Hull3D = []
  for plan in h3d:
    pl = []
    for p in plan:
      xzy = [sx*p[0],sy*p[2],sz*p[1]]
      pl.append(xzy)
    #endfor p in plan
    Hull3D.append(pl)
  #endfor p in plan
#enddef _h3d(h3d,sx,sy,sz)

def plothull3dxzy(isame=0,facecolor='blue',alpha=0.5,edgecolor='black', ishow=1,mode='line'):
+seq,uguiglobind.

  h3d =deepcopy(Hull3D)

  if cIxSym == 'yes' and cIySym == 'yes' and cIzSym == 'yes':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,-1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,-1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,-1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,-1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,-1.,-1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
  elif cIxSym == 'no' and cIySym == 'yes' and cIzSym == 'yes':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,-1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
  elif cIxSym == 'yes' and cIySym == 'no' and cIzSym == 'yes':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,-1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,-1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
  elif cIxSym == 'yes' and cIySym == 'yes' and cIzSym == 'no':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,-1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,-1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
  elif cIxSym == 'no' and cIySym == 'no' and cIzSym == 'yes':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,1.,-1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
  elif cIxSym == 'no' and cIySym == 'yes' and cIzSym == 'no':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,1.,-1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
  elif cIxSym == 'yes' and cIySym == 'no' and cIzSym == 'no':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
    _h3d(h3d,-1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
  elif cIxSym == 'no' and cIySym == 'no' and cIzSym == 'no':
    _h3d(h3d,1.,1.,1.); plothull3d(isame,facecolor,alpha,edgecolor,ishow,mode)
  #endif cIxSym == 'yes' and cIySym == 'yes' and if cIzSym == 'yes'

#enddef plothull3dxzy(isame=0,facecolor='blue',alpha=0.5,edgecolor='black', ishow=1)

def _plotMag(imp,key='3d'):

  if imp>=0:
    cmag = MagPolsTot[imp][0][0]
    if not cmag in DictMagPolsSel: _selectMag(cmag)
  #endif

  #print('plotMag()?\n',imp,key,'\nDictMothsSel:\n',DictMothsSel,\
  #'\nDictMagPolsSel:\n',DictMagPolsSel)

  if len(DictMagPolsSel) == 0:
    print('_plotMag: Nothing selected')
    return
  #endif

  setisame(0)

  if key == '3d' or key == '3dseleted':
    _showGeoPython(mode='3dselected',item=-2,callkey='plotMoth')
  else:
    for cmag in DictMagPolsSel:
      imag = DictMagPolsSel[cmag]
      cmoth = MagPolsTot[imag][0][1]
      imoth = DictMoths[cmoth]
      sel = "imoth==" + str(imoth)
      xyz =  MothsXYZ.query(sel)
      xmin = xyz.xmin[0]
      xmax = xyz.xmax[0]
      ymin = xyz.ymin[0]
      ymax = xyz.ymax[0]
      zmin = xyz.zmin[0]
      zmax = xyz.zmax[0]
      dx = (xmax - xmin) / 10.
      dy = (ymax - ymin) / 10.
      dz = (zmax - zmin) / 10.
      if key == 'xy':
        null(xmin-dx,xmax+dx,ymin-dy,ymax+dy)
        txyz(cmoth,"x [mm]","y [mm]")
      elif key == 'xz':
        null(xmin-dx,xmax+dx,zmin-dz,zmax+dz)
        txyz(cmoth,"x [mm]","z [mm]")
      elif key == 'zy':
        null(zmin-dz,zmax+dz,ymin-dy,ymax+dy)
        txyz(cmoth,"z [mm]","y [mm]")
      #endif
    #endfor

    for cmag in DictMagPolsSel:
      i = DictMagPolsSel[cmag]
      _plotSingleMag(imp,key=key,imoth=1)
      #endfor
  #endif

#enddef _plotMag(imp,key='3d'):

def _plotSingleMag(imp,key='3d',imoth=0):

  global MagPolsTot,WallListMags,Isame
  WallListMags.attributes('-topmost', 0)

  if imoth == 0:
    plopt = ''
    zone(1,1)
  else:
    plopt = 'same'
  #endif

  mp = MagPolsTot[imp]
  cmag = MagPolsTot[imp][0][0]
  col = mp[5][5]
  if not col in DictUnduColors:
    kcol = int(ugui_calc_line(col))
    col = UnduColors[kcol]
  #endif col not in UnduColors
  points = []
  cen = mp[4]

  if imoth <= 0:
    store_kdump_kpdf(); optdump(False); optpdf(False)
  #endif

  if imoth == 0:
    ms = getmarkersize()
    setmarkersize(0)
  #endif

  if key == 'xy':
    xc = ugui_calc_line(cen[0])
    yc = ugui_calc_line(cen[1])
    if mp[3].find('Block') > -1:
      corns = blockcorners(mp)
      for c in corns: points.append([xc+c[0],yc+c[1]])
    elif mp[3] == 'File' or mp[3] == 'Corners':
      for ic in range(len(mp[7])):
        c1 = xc + calc_var(mp[7][ic][0])
        c2 = yc + calc_var(mp[7][ic][1])
        points.append([c1,c2])
      #endfor ic in range(len(mp[7]))
    else:
      print('\n*** ', mp[3], 'noch in  _plotSingleMag einfuegen\n')
    #endif
    hull = ConvexHull(points)
    nhull2d = ncre("Nhull2d","Nhull2d","ipoi:iedge:x:y",ioverwrite=1)
    nedge=0
    fill = []
    for s in hull.simplices:
      nedge += 1
      i1 = s[0]
      i2 = s[1]
      x1 = points[i1][0]
      y1 = points[i1][1]
      x2 = points[i2][0]
      y2 = points[i2][1]
      fill.append([i1,nedge,x1,y1])
      fill.append([i2,nedge,x2,y2])
    #endfor s in hull.simplices
    fill = np.array(fill)
    nhull2d = nfill(nhull2d,fill)
    nplot(nhull2d,"x:y",plopt=plopt,color=col)
    for ied in range(nedge):
      sel = '"iedge==' + str(ied+1) + '"'
      eval('nplot("Nhull2d","x:y",' + sel + ',"","sameline", color="' + col + '")')
    #endfor
    txyz(cmag,"x[mm]","y[mm]")
  elif key == 'xz':
    xc = ugui_calc_line(cen[0])
    zc = ugui_calc_line(cen[2])
    if mp[3].find('Block') > -1:
      corns = blockcorners(mp)
      for c in corns: points.append([xc+c[0],zc+c[2]])
    elif mp[3] == 'File' or mp[3] == 'Corners':
      for ic in range(len(mp[7])):
        c1 = xc + calc_var(mp[7][ic][0])
        c3 = zc + calc_var(mp[7][ic][2])
        points.append([c1,c2])
      #endfor ic in range(len(mp[7]))
    else:
      print('\n*** ', mp[3], 'noch in  _plotSingleMag einfuegen\n')
    #endif
    hull = ConvexHull(points)
    nhull2d = ncre("Nhull2d","Nhull2d","ipoi:iedge:x:z",ioverwrite=1)
    nedge=0
    fill = []
    for s in hull.simplices:
      nedge += 1
      i1 = s[0]
      i2 = s[1]
      x1 = points[i1][0]
      z1 = points[i1][1]
      x2 = points[i2][0]
      z2 = points[i2][1]
      fill.append([i1,nedge,x1,z1])
      fill.append([i2,nedge,x2,z2])
    #endfor s in hull.simplices
    fill = np.array(fill)
    nhull2d = nfill(nhull2d,fill)

    nplot(nhull2d,"x:z",plopt=plopt,color=col)
    for ied in range(nedge):
      sel = '"iedge==' + str(ied+1) + '"'
      eval('nplot("Nhull2d","x:z",' + sel + ',"","sameline", color="' + col + '")')
    #endfor
    txyz(cmag,"x[mm]","z[mm]")
  elif key == 'zy':
    zc = ugui_calc_line(cen[2])
    yc = ugui_calc_line(cen[1])
    if mp[3].find('Block') > -1:
      corns = blockcorners(mp)
      for c in corns: points.append([zc+c[2],yc+c[1]])
    elif mp[3] == 'File' or mp[3] == 'Corners':
      for ic in range(len(mp[7])):
        c1 = zc + calc_var(mp[7][ic][2])
        c2 = yc + calc_var(mp[7][ic][1])
        points.append([c1,c2])
      #endfor ic in range(len(mp[7]))
    else:
      print('\n*** ', mp[3], 'noch in  _plotSingleMag einfuegen\n')
    #endif
    hull = ConvexHull(points)
    nhull2d = ncre("Nhull2d","Nhull2d","ipoi:iedge:z:y",ioverwrite=1)
    nedge=0
    fill = []
    for s in hull.simplices:
      nedge += 1
      i1 = s[0]
      i2 = s[1]
      x1 = points[i1][0]
      y1 = points[i1][1]
      x2 = points[i2][0]
      y2 = points[i2][1]
      fill.append([i1,nedge,x1,y1])
      fill.append([i2,nedge,x2,y2])
    #endfor s in hull.simplices
    fill = np.array(fill)
    nhull2d = nfill(nhull2d,fill)
    nplot(nhull2d,"z:y",plopt=plopt,color=col)
    for ied in range(nedge):
      sel = '"iedge==' + str(ied+1) + '"'
      eval('nplot("Nhull2d","z:y",' + sel + ',"","sameline", color="' + col + '")')
    #endfor
    txyz(cmag,"z[mm]","y[mm]")
  else:
    _showGeoPython(mode='3d',item=imp,callkey='plotMag')
    txyz(cmag,"x[mm]", "z[mm]","y[mm]")
  #endif

  if imoth == 0:
    setmarkersize(ms)
  if imoth <= 0:
    restore_kdump_kpdf()

#enddef _plotSingleMag(imp)

def _showGeo(mode='3d',item=-1,kseg=0,callkey=''):
+self,if=trace.
  print(NL,"trace:: _showGeo:",mode,item,kseg,callkey)
+self.
  if mode == 'undu3d' or mode == 'eps':
    _showGeoUndu(mode,item,kseg,callkey='showGeo')
  else:
    _showGeoPython(mode,item,callkey='showGeo')
+self,if=trace.
    print(NL,"trace:: Leaving _showGeo")
+self.
#enddef _showGeo(mode='3d',item=-1,kseg=0)

def _showGeoPython(mode='3d',item=-1,callkey=''):
+seq,uguiglobind.
+seq,UnduColorsind.

+self,if=trace.
  print(NL,"trace:: _showGeoPython:",mode,item,callkey)
+self.

  isameo = getisame()

  if not isameo: zone(1,1)

  if NMagPolTot == 0 and len(Filaments) == 0:
    print("Nothing to plot!")
+self,if=trace.
    print(NL,"trace:: Leaving _showGeoPython")
+self.
    return
  #endif NMagPolTot == 0

  xmin = 1.0e30
  xmax = -1.0e30
  ymin = 1.0e30
  ymax = -1.0e30
  zmin = 1.0e30
  zmax = -1.0e30

  xMinCoil = 1.0e30
  xMaxCoil = -1.0e30
  yMinCoil = 1.0e30
  yMaxCoil = -1.0e30
  zMinCoil = 1.0e30
  zMaxCoil = -1.0e30

  if len(Filaments):
    for f in Filaments:
      for w in f:
        x1 = float(w[0])
        y1 = float(w[1])
        z1 = float(w[2])
        x2 = float(w[3])
        y2 = float(w[4])
        z2 = float(w[5])
        if x2 < xMinCoil: xMinCoil = x2
        if x2 > xMaxCoil: xMaxCoil = x2
        if y2 < yMinCoil: yMinCoil = y2
        if y2 > yMaxCoil: yMaxCoil = y2
        if z2 < zMinCoil: zMinCoil = z2
        if z2 > zMaxCoil: zMaxCoil = z2
        if x1 < xMinCoil: xMinCoil = x1
        if x1 > xMaxCoil: xMaxCoil = x1
        if y1 < yMinCoil: yMinCoil = y1
        if y1 > yMaxCoil: yMaxCoil = y1
        if z1 < zMinCoil: zMinCoil = z1
        if z1 > zMaxCoil: zMaxCoil = z1
      #endfor w in f
    #endfor f in Filaments
  #endif len(Filaments)

  if not NMagPolTot:
    _ucoilplot('3d','notsame',callkey='ShowGeoPython')
+self,if=trace.
    print(NL,"trace:: Leaving _showGeoPython after _ucoilplot(...)")
+self.
  #endif not NMagPolTot

  xmin = min(xmin,xMinCoil)
  xmax = max(xmax,xMaxCoil)
  ymin = min(ymin,yMinCoil)
  ymax = max(ymax,yMaxCoil)
  zmin = min(zmin,zMinCoil)
  zmax = max(zmax,zMaxCoil)
+self,if=trace.
  print(NL,"trace:: showGeo")
  imp = 0
  for mp in MagPolsTot:
    imp += 1
    print(imp,mp[0:4])
  #endfor
+self.

  if NMagPolTot > NspecMagPol:

    tranMaxX = -1.0e30
    tranMaxY = -1.0e30
    tranMaxZ = -1.0e30

    for mm in range(Nmodul):

      mo = Modules[mm]
      mo2 = mo[1]

      nper = ugui_calc_line(mo2)
      w = mo[2].split()
      perlen = ugui_calc_line(w[0])

      tx = ugui_calc_line(w[1]) * (nper-1) * perlen
      ty = ugui_calc_line(w[2]) * (nper-1) * perlen
      tz = ugui_calc_line(w[3]) * (nper-1) * perlen

      if tx > tranMaxX: tranMaxX = tx
      if ty > tranMaxY: tranMaxY = ty
      if tz > tranMaxZ: tranMaxZ = tz

    #endfor mm in range(Nmodul)

  else:

    tranMaxX = 0.0
    tranMaxY = 0.0
    tranMaxZ = 0.0

  #endif NMagPolTot > NspecMagPol

  Ysym = 0.0
  Zsym = 0.0
  ical = 0

  if item < 0:

    if item == -2 and len(DictMagPolsSel) == 0:
      wError(" Nothing selected! ")
      return
    #endif

    plopt = ''

    Kpdf = False
    Kdump = False
    Kecho = False

    dot()
    getzone('3d')

    if mode == '3d' or mode == '3dselected':

      if item == -1:
        if NspecMagPol > 0:
          xmin = min(MothsXYZ.xmin.min()+tranMaxX,SpecXYZ[0])
          xmax = max(MothsXYZ.xmax.max()+tranMaxX,SpecXYZ[1])
          ymin = min(MothsXYZ.ymin.min()+tranMaxY,SpecXYZ[2])
          ymax = max(MothsXYZ.ymax.max()+tranMaxY,SpecXYZ[3])
          zmin = min(MothsXYZ.zmin.min()+tranMaxZ,SpecXYZ[4])
          zmax = max(MothsXYZ.zmax.max()+tranMaxZ,SpecXYZ[5])
        else:
          xmin = MothsXYZ.xmin.min()+tranMaxX
          xmax = MothsXYZ.xmax.max()+tranMaxX
          ymin = MothsXYZ.ymin.min()+tranMaxY
          ymax = MothsXYZ.ymax.max()+tranMaxY
          zmin = MothsXYZ.zmin.min()+tranMaxZ
          zmax = MothsXYZ.zmax.max()+tranMaxZ
        #endif NspecMagPol > 0

      else:

        for mpnam in MagPolsSel:
          mp = MagPolsTot[DictMagPolsSel[mpnam]]
          mothnam = mp[0][1]
          imoth = DictMoths[mothnam]
          sel = 'index==' + str(imoth)
          mxyz = MothsXYZ.query(sel)
          if mxyz.xmin[0] < xmin: xmin = mxyz.xmin[0]
          if mxyz.xmax[0] > xmax: xmax = mxyz.xmax[0]
          if mxyz.ymin[0] < ymin: ymin = mxyz.ymin[0]
          if mxyz.ymax[0] > ymax: ymax = mxyz.ymax[0]
          if mxyz.zmin[0] < zmin: zmin = mxyz.zmin[0]
          if mxyz.zmax[0] > zmax: zmax = mxyz.zmax[0]
        #endfor

        xmin += tranMaxX
        xmax += tranMaxX
        ymin += tranMaxY
        ymax += tranMaxY
        zmin += tranMaxZ
        zmax += tranMaxZ

      #endif item

      xmn = xmin
      xmx = xmax
      ymn = ymin
      ymx = ymax
      zmn = zmin
      zmx = zmax

      if cIzSym == 'yes':
        dzsym = max(abs(Zsym-zmin),abs(Zsym-zmax))
        zmn = Zsym - dzsym
        zmx = Zsym + dzsym
      #endif

      if cIySym == 'yes':
        dysym = max(abs(Ysym-ymin),abs(Ysym-ymax))
        ymn = Ysym - dysym
        ymx = Ysym + dysym
      #endif

      if cIxSym == 'yes':
        dxsym = max(abs(Xsym-xmin),abs(Xsym-xmax))
        xmn = Xsym - dxsym
        xmx = Xsym + dxsym
      #endif

      xmin = min(xmn,xmx)
      xmax = max(xmn,xmx)
      ymin = min(ymn,ymx)
      ymax = max(ymn,ymx)
      zmin = min(zmn,zmx)
      zmax = max(zmn,zmx)

      xmin = min(xmin,xMinCoil)
      xmax = max(xmax,xMaxCoil)
      ymin = min(ymin,yMinCoil)
      ymax = max(ymax,yMaxCoil)
      zmin = min(zmin,zMinCoil)
      zmax = max(zmax,zMaxCoil)

#      print(tranMaxX,tranMaxY)
#      print(xmin,xmax,ymin,ymax,zmin,zmax)

    elif mode == '3dperiodic':

      xmin = MothsXYZ.xmin.min()+tranMaxX - tx
      xmax = MothsXYZ.xmax.max()+tranMaxX - tx
      ymin = MothsXYZ.ymin.min()+tranMaxY - ty
      ymax = MothsXYZ.ymax.max()+tranMaxY - ty
      zmin = MothsXYZ.zmin.min()+tranMaxZ - tz
      zmax = MothsXYZ.zmax.max()+tranMaxZ - tz

      if cIxSym == 'yes':
        xmn = Xsym + (Xsym - xmin)
        xmx = Xsym + (Xsym - xmax)
      #endif

      if cIySym == 'yes':
        ymn = Ysym + (Ysym - ymin)
        ymx = Ysym + (Ysym - ymax)
      #endif

      if cIzSym == 'yes':
        zmn = Zsym + (Zsym - zmin)
        zmx = Zsym + (Zsym - zmax)
      #endif

      xmin = min(xmn,xmx)
      xmax = max(xmn,xmx)
      ymin = min(ymn,ymx)
      ymax = max(ymn,ymx)
      zmin = min(zmn,zmx)
      zmax = max(zmn,zmx)

    elif mode == '3dnoper':

      if NspecMagPol > 0:
        xmin = min(MothsXYZ.xmin.min()+tranMaxX,SpecXYZ[0])
        xmax = max(MothsXYZ.xmax.max()+tranMaxX,SpecXYZ[1])
        ymin = min(MothsXYZ.ymin.min()+tranMaxY,SpecXYZ[2])
        ymax = max(MothsXYZ.ymax.max()+tranMaxY,SpecXYZ[3])
        zmin = min(MothsXYZ.zmin.min()+tranMaxZ,SpecXYZ[4])
        zmax = max(MothsXYZ.zmax.max()+tranMaxZ,SpecXYZ[5])
      #endif NspecMagPol > 0

      if cIxSym == 'yes':
        xmn = Xsym + (Xsym - xmin)
        xmx = Xsym + (Xsym - xmax)
      #endif

      if cIySym == 'yes':
        ymn = Ysym + (Ysym - ymin)
        ymx = Ysym + (Ysym - ymax)
      #endif

      if cIzSym == 'yes':
        zmn = Zsym + (Zsym - zmin)
        zmx = Zsym + (Zsym - zmax)
      #endif

      xmin = min(xmn,xmx)
      xmax = max(xmn,xmx)
      ymin = min(ymn,ymx)
      ymax = max(ymn,ymx)
      zmin = min(zmn,zmx)
      zmax = max(zmn,zmx)

      xmin = min(xmin,xMinCoil)
      xmax = max(xmax,xMaxCoil)
      ymin = min(ymin,yMinCoil)
      ymax = max(ymax,yMaxCoil)
      zmin = min(zmin,zMinCoil)
      zmax = max(zmax,zMaxCoil)

    else:
      print("_showGeoPython: ",mode, " not yet implemented!")
      return
    #endif mode == '3d'

    dx = (xmax - xmin) / 10.
    dy = (ymax - ymin) / 10.
    dz = (zmax - zmin) / 10.

    null3d(xmin-dx,xmax+dx,zmin-dz,zmax+dz,ymin-dy,ymax+dy)
    txyz(Ucomment,"x [mm]","z [mm]", "y [mm]")

    if mode == '3d' or mode == '3dperiodic' or mode == '3dselected':

      if len(Filaments) and mode == '3d': _ucoilplot(callkey='ShowGeoPython')

      for mm in range(Nmodul):

        mo = Modules[mm]

        lcen = mo[0]
        w = lcen.split()

        offx = ugui_calc_line(w[0])
        offy = ugui_calc_line(w[1])
        offz = ugui_calc_line(w[2])

        nper = ugui_calc_line(mo[1])
        s = mo[2].split()

        perlen = ugui_calc_line(s[0])

        vspace = [float(s[1]),float(s[2]),float(s[3])]
        ang = float(s[4])

        cen = [0.0,0.0,0.0]
        vin = [1.0,0.0,0.0]
        istat, vdum, rm = util_rotate(cen,vspace,ang,vin)

        rot11 = rm[0][0]; rot12 = rm[0][1]; rot13 = rm[0][2]
        rot21 = rm[1][0]; rot22 = rm[1][1]; rot23 = rm[1][2]
        rot31 = rm[2][0]; rot32 = rm[2][1]; rot33 = rm[2][2]

        tx = vspace[0] * perlen
        ty = vspace[1] * perlen
        tz = vspace[2] * perlen

        w = mo[3].split()
        bsx = ugui_calc_line(w[0])
        bsy = ugui_calc_line(w[1])
        bsz = ugui_calc_line(w[2])

        nmp = NMagPolTot
        if item == -2: nmp = NMagPolSel

        #print("nmp:",nmp)

        for imp in range(nmp):

          if item == -1:
            mp = MagPolsTot[imp]
            cmag = mp[0][0]
          elif item == -2:
            cmag = MagPolsSel[imp]
            mp = MagPolsTot[DictMagPolsSel[cmag]]
          #endif

          #print("cmag:",cmag,':\n',mp)

          ispec = mp[2]
#          if ispec == 'yes' or str(ispec) == '1': continue
+self,if=trace.
          print(mp[:4])
+self.
          if item == -2 and cmag not in DictMagPolsSel: continue

          col = mp[5][5]
          if not col in DictUnduColors:
            kcol = int(ugui_calc_line(col))
            col = UnduColors[kcol]
          #endif col not in UnduColors

          points = []
          iscyl = 0

          cen = mp[4]

          xc = ugui_calc_line(cen[0]) + tx
          yc = ugui_calc_line(cen[1]) + ty
          zc = ugui_calc_line(cen[2]) + tz

          if mp[3].find('Block') > -1:

            corns = blockcorners(mp)

            for corn in corns:
              xx = corn[0]; yy = corn[1]; zz = corn[2]
              x = xc + rot11*xx + rot12*yy + rot13*zz
              y = yc + rot21*xx + rot22*yy + rot23*zz
              z = zc + rot31*xx + rot32*yy + rot33*zz
              points.append([x,y,z])
            #endfor corn in corns

          elif mp[3] == 'File' or mp[3] == 'Corners':

            for ic in range(len(mp[7])):
              c1 = xc + calc_var(mp[7][ic][0])
              c2 = yc + calc_var(mp[7][ic][1])
              c3 = zc + calc_var(mp[7][ic][2])
              points.append([c1,c2,c3])
            #endfor ic in range(len(mp[7]))

          elif mp[3] == 'Cylinder':
            iscyl = 1
          else:
            Quit("_showGeoPython: " + mp[3] + " hier einfgen")
          #endif mp[3] == 'Block'

          dtx = -tx; dty = -ty; dtz = -tz

          if mode == '3d' or mode == '3dperiodic': mper = nper
          else: mper = 1

          for iper in range(mper):
            pp = []
            if not iscyl:
              for p in points:
                pp.append([p[0]+dtx,p[1]+dty,p[2]+dtz])
              #endfor p in points
              verts,ifaces,faces = hull3d(pp)
              if type(verts) != Tdf:
                corns = pd.DataFrame(verts)
              else:
                corns = verts
              #endif
              plothull3dxzy(isame=1,edgecolor=col,ishow=0,mode='line')
            else:
              for ntc in Ntcyls:
                poly = plotncylinder(ntc[2],1,col,0)
              #endfor
            #endif not iscyl

            dtx += tx; dty += ty; dtz += tz
          #enddofor iper in range(1,nper+1):

        #endfor mag in range(nmag)

      #endfor mm in range(Nmodul)

    #endif mode == '3d' or mode == '3dperiodic'

    if mode == '3d' or mode == '3dnoper' or mode == '3dselected':

      if mode != '3dselected': _ucoilplot(callkey='showGeoPython')
      return
      nmp = NMagPolTot
      if item == -2: nmp = NMagPolSel

      for imp in range(nmp):

        if item == -1:
          mp = MagPolsTot[imp]
          cmag = mp[0][0]
        elif item == -2:
          cmag = MagPolsSel[imp]
          mp = MagPolsTot[DictMagPolsSel[cmag]]
        #endif

        cmag = mp[0][0]
        ispec = mp[2]
        print(cmag,ispec)
        if ispec == 'no' or str(ispec) == '0': continue

        if item == -2 and cmag not in DictMagPolsSel: continue

        col = mp[5][5]
        if not col in DictUnduColors:
          kcol = int(ugui_calc_line(col))
          col = UnduColors[kcol]
        #endif col not in UnduColors

        points = []

        cen = mp[4]

        xc = ugui_calc_line(cen[0])
        yc = ugui_calc_line(cen[1])
        zc = ugui_calc_line(cen[2])

        if mp[3].find('Block') > -1:

          corns = blockcorners(mp)
          for c in corns: points.append([xc+c[0],yc+c[1],zc+c[2]])

        elif mp[3] == 'File' or mp[3] == 'Corners':

          for ic in range(len(mp[7])):
            c1 = xc + calc_var(mp[7][ic][0])
            c2 = yc + calc_var(mp[7][ic][1])
            c3 = zc + calc_var(mp[7][ic][2])
            points.append([c1,c2,c3])
          #endfor ic in range(len(mp[7]))

        elif mp[3] == 'Cylinder':
          ntc = Ntclys[DictCyls[cmag]]
          poly = plotncylinder(ntc[2],1,col,0)
        else:
          Quit("_showGeoPython: " + mp[3] + " hier einfgen")
          #Quit(mp[3] + " hier einfgen")
        #endif mp[3] == 'Block'

        #verts,ifaces,faces = hull3d(points)

        #if type(verts) != Tdf:
        #  corns = pd.DataFrame(verts)
        #else:
         # corns = verts
        #endif

        if len(points) > 0:
          plothull3dxzy(isame=1,edgecolor=col,ishow=0,mode='line')

      #endfor mag in range(nmag)

    #endif mode == '3d'

  else: # item=imp{

    mp = MagPolsTot[item]

    cmag = mp[0][0]
    ispec = mp[2]

    col = mp[5][5]
    if not col in DictUnduColors:
      kcol = int(ugui_calc_line(col))
      col = UnduColors[kcol]
    #endif col not in UnduColors

    points = []

    cen = mp[4]

    xc = ugui_calc_line(cen[0])
    yc = ugui_calc_line(cen[1])
    zc = ugui_calc_line(cen[2])

    if mp[3].find('Block') > -1:

      corns = blockcorners(mp)
      for c in corns: points.append([xc+c[0],yc+c[1],zc+c[2]])

    elif mp[3] == 'File' or mp[3] == 'Corners':

      for ic in range(len(mp[7])):
        c1 = xc + calc_var(mp[7][ic][0])
        c2 = yc + calc_var(mp[7][ic][1])
        c3 = zc + calc_var(mp[7][ic][2])
        points.append([c1,c2,c3])
      #endfor ic in range(len(mp[7]))

    else:
      Quit("_showGeoPython: " + mp[3] + " hier einfgen")
      #Quit(mp[3] + " hier einfgen")
    #endif mp[3] == 'Block'

+self,if=-oldhull3d.
    verts,ifaces,faces = hull3d(points)
    if type(verts) != Tdf:
      corns = pd.DataFrame(verts)
    else:
      corns = verts
    #endif
+self,if=oldhull3d.
    corns = hull3d(points)
+self.
    plothull3dxzy(isame=0,edgecolor=col,ishow=0,mode='line')

  #endif item < 0

  Isame = isameo

+self,if=trace.
  print(NL,"trace:: Leaving _showGeoPython")
+self.

#enddef _showGeoPython(mode='3d',item=-1)

def _showGeoUndu(mode='3d',item=-1,kseg=0,callkey=''):
+seq,uguiglobind.
+seq,UnduColorsind.

  isameo = get_isame()

  Rmode = 'SEGMENTATION STDOUT=undumag.lun6'

  if NMagPolTot == 0:
    print("Nothing to plot!")
    return
  #endif NMagPolTot == 0

  if MustUpdate:
+self,if=debpy.
    Quit("*** _undumag in showgeo wegen MustUpdate ***")
+self.
    _undumag("showGeoUndu")  #run undumag
    if nexist("Ngeo"): Ngeo = ndelete("Ngeo")
    Ngeo = ncread("Ngeo","mag:ityp:xc:yc:zc:moth:ix:iy:iz:mat:icol:mx:my:mz:bc:iplan:icorn:x:y:z:cmag:cmoth","undumag.geo")
    MustUpdate = 0
  #endif MustUpdate

  if mode == 'undu3d':

    if item < 0:

      if not nexist("Ngeo"):
        Ngeo = ncread("Ngeo","mag:ityp:xc:yc:zc:moth:ix:iy:iz:mat:icol:mx:my:mz:bc:iplan:icorn:x:y:z:cmag:cmoth","undumag.geo")
      #endif not nexist("Ngeo")

      plopt = ''

      Kpdf = False
      Kdump = False
      Kecho = False

      dot()
      getzone('3d')
      #nplot("Ngeo","x:z:y","mag<10")
      nmag = int(Ngeo.mag.max())

      xmin = Ngeo.x.min()
      xmax = Ngeo.x.max()
      ymin = Ngeo.y.min()
      ymax = Ngeo.y.max()
      zmin = Ngeo.z.min()
      zmax = Ngeo.z.max()

      dx = (xmax - xmin) / 10.
      dy = (ymax - ymin) / 10.
      dz = (zmax - zmin) / 10.

      null3d(xmin-dx,xmax+dx,zmin-dz,zmax+dz,ymin-dy,ymax+dy)
      txyz(Ucomment,"x [mm]","z [mm]", "y [mm]")

      for mag in range(nmag):
        selmag = 'mag==' + str(mag+1)
        kcol = Ngeo.query(selmag + ' and iplan==1 and icorn==1').icol.max()
        col = UnduColors[kcol]
        mhull3d(Ngeo,"x:z:y",selmag,edgecolor=col,isame=1)
#        nplan = Ngeo.query(selmag + ' and icorn==1').iplan.max()
#        kcol = Ngeo.query(selmag + ' and iplan==1 and icorn==1').icol.max()
#        col = UnduColors[kcol]
#        for ipl in range(nplan):
#          sel = selmag + " and iplan==" + str(ipl+1)
#          nplot(Ngeo,"x:z:y",sel,"","sameline",color=col)
#        #endfor ipl in range(nplan)
      #endfor mag in range(nmag)

      #undu_geo('line')

    #endif item < 0

  elif mode == 'eps':
    eps = image.open('undumag.eps')
    eps.show()
  #endif mode == '3d'

  Isame = isameo

+self,if=trace.
  print(NL,"trace:: Leaving _showGeoUndu",NL)
+self.

#enddef _showGeoUndu(mode)
+KEEP,ureadclc,T=PYTHON.
*CMZ :  2.04/10 21/08/2023  12.18.59  by  Michael Scheer
*CMZ :  2.04/09 16/08/2023  22.49.41  by  Michael Scheer
*CMZ :  2.04/06 09/07/2023  10.46.00  by  Michael Scheer
*CMZ :  2.04/00 07/09/2022  09.21.13  by  Michael Scheer
*CMZ :  2.03/00 01/09/2022  06.51.21  by  Michael Scheer
*CMZ :  2.02/02 08/03/2022  12.16.54  by  Michael Scheer
*CMZ :  2.02/01 21/10/2021  12.11.52  by  Michael Scheer
*CMZ :  2.02/00 17/03/2021  12.15.56  by  Michael Scheer
*-- Author :    Michael Scheer   14/10/2020
+seq,utransrotcop.
+seq,chtransrotcop.

def undumag_wind_to_fila(coilin):
  global Filaments, Coils, CurrLoops, DictUnduColors,UnduColors

  if coilin[0][0].upper() != 'RECTWINDINGS':
    wError("Unknown coil type " + coilin[0] + " in undumag_wind_to_fila")
    return
  #if coil[0].upper() != 'RECTWINDINGS'

  print("wind_to_fila:",NL,coilin)
  debug("debug: Wind")

  coil = []
  for v in coilin[1]:
    try:
      val = calc_var(v)
      coil.append(val)
    except:
      wError("  Error in undumag_wind_to_fila: Could not resolve " + str(v) + "   ")
      return
  #endfor v in coil

  kcolor = int(coil[18])

  x0 = float(coil[3])
  y0 = float(coil[4])
  z0 = float(coil[5])

  vx = float(coil[6])
  vy = float(coil[7])
  vz = float(coil[8])

  vn = np.sqrt(vx**2+vy**2+vz**2)
  if vn == 0.0:
    wError("*** Error in undumag_wind_to_fila: Zero normal vector for coil")
    return
  #endif vn == 0.0

  alpha = float(coil[9])

  xo = float(coil[10]/2.0)
  zi = float(coil[11]/2.0)
  zo = float(coil[12]/2.0)
  ri = float(coil[13])
  h = float(coil[14])

  ny = int(coil[15])
  nz = int(coil[16])
  nphi = int(coil[17])

  kolor = int(coil[18])

  w=zo-zi
  xi=xo-w
  ro=ri+w

  yc=0.0

  if xi < ri:
    wError("*** Error in undumag_wind_to_fila: The inner length is smaller than twice the inner radius ***")
    return
  #endif xi < ri

  dphi=pi/2.0/nphi
  dy=h/ny
  dz=w/nz

  z = []
  for iz in range(nz):
    z.append(zi+(iz+0.5)*dz)
  #endfor

  y = []
  for iy in range(ny):
    y.append(yc-h/2.0+(iy+0.5)*dy)
  #endfor

  fila = []

  ielem = 0
  for iy in range(ny):
    for iz in range(nz):

      # first x bar
      wire = []
      wire.append(xi-ri)
      wire.append(+y[iy])
      wire.append(-z[iz])
      wire.append(-xi+ri)
      wire.append(+y[iy])
      wire.append(-z[iz])
      wire.append(kolor)
#      wire.append(1)
      wire.append(iy)
      wire.append(iz)

      fila.append(wire)

      # first arc

      xc=-xi+ri
      zc=-zi+ri

      sinphi1=0.0
      cosphi1=1.0

      for iphi in range(nphi):
        sinphi2=np.sin((iphi+1)*dphi)
        cosphi2=np.cos((iphi+1)*dphi)
        wire = []
        r=ri+(iz+0.5)*dz
        wire.append(+xc-r*sinphi1)
        wire.append(+y[iy])
        wire.append(+zc-r*cosphi1)
        wire.append(+xc-r*sinphi2)
        wire.append(+y[iy])
        wire.append(+zc-r*cosphi2)
        wire.append(kolor)
#        wire.append(2)
        wire.append(iy)
        wire.append(iz)
        fila.append(wire)
        sinphi1=sinphi2
        cosphi1=cosphi2
      #endfor iphi in range(nphi)

      # first z bar

      wire = []
      wire.append(-xi-(iz+0.5)*dz)
      wire.append(+y[iy])
      wire.append(-zi+ri)
      wire.append(wire[0])
      wire.append(+y[iy])
      wire.append(+zi-ri)
      wire.append(kolor)
#      wire.append(3)
      wire.append(iy)
      wire.append(iz)

      fila.append(wire)

      # second arc

      xc=-xi+ri
      zc=zi-ri
      sinphi1=0.0
      cosphi1=1.0

      for iphi in range(nphi):
        sinphi2=np.sin((iphi+1)*dphi)
        cosphi2=np.cos((iphi+1)*dphi)
        wire = []
        r=ri+(iz+0.5)*dz
        wire.append(+xc-r*cosphi1)
        wire.append(+y[iy])
        wire.append(+zc+r*sinphi1)
        wire.append(+xc-r*cosphi2)
        wire.append(+y[iy])
        wire.append(zc+r*sinphi2)
        wire.append(kolor)
#        wire.append(4)
        wire.append(iy)
        wire.append(iz)

        fila.append(wire)

        sinphi1=sinphi2
        cosphi1=cosphi2
      #endfor iphi in range(nphi)

      # second x bar

      wire = []
      wire.append(-xi+ri)
      wire.append(+y[iy])
      wire.append(z[iz])
      wire.append(+xi-ri)
      wire.append(+y[iy])
      wire.append(z[iz])
      wire.append(kolor)
#      wire.append(5)
      wire.append(iy)
      wire.append(iz)

      fila.append(wire)

      # third arc

      xc=xi-ri
      zc=zi-ri

      sinphi1=0.0
      cosphi1=1.0

      for iphi in range(nphi):
        sinphi2=np.sin((iphi+1)*dphi)
        cosphi2=np.cos((iphi+1)*dphi)
        wire = []
        r=ri+(iz+0.5)*dz
        wire.append(+xc+r*sinphi1)
        wire.append(+y[iy])
        wire.append(+zc+r*cosphi1)
        wire.append(+xc+r*sinphi2)
        wire.append(+y[iy])
        wire.append(+zc+r*cosphi2)
        wire.append(kolor)
#        wire.append(6)
        wire.append(iy)
        wire.append(iz)

        fila.append(wire)

        sinphi1=sinphi2
        cosphi1=cosphi2
      #endfor iphi in range(nphi)

      # second z bar
      wire = []
      wire.append(+xi+(iz+0.5)*dz)
      wire.append(+y[iy])
      wire.append(+zi-ri)
      wire.append(wire[0])
      wire.append(+y[iy])
      wire.append(-zi+ri)
      wire.append(kolor)
      wire.append(iy)
      wire.append(iz)

      fila.append(wire)

      # fourth arc
      xc=xi-ri
      zc=-zi+ri
      sinphi1=0.0
      cosphi1=1.0

      for iphi in range(nphi):
        sinphi2=np.sin((iphi+1)*dphi)
        cosphi2=np.cos((iphi+1)*dphi)
        wire = []
        r=ri+(iz+0.5)*dz
        wire.append(+xc+r*cosphi1)
        wire.append(+y[iy])
        wire.append(+zc-r*sinphi1)
        wire.append(+xc+r*cosphi2)
        wire.append(+y[iy])
        wire.append(+zc-r*sinphi2)
        wire.append(kolor)
#        wire.append(2)
        wire.append(iy)
        wire.append(iz)

        fila.append(wire)
        sinphi1=sinphi2
        cosphi1=cosphi2
      #endfor iphi in range(nphi)
    #endfor iz
  #endfor iy

  #rotate and translate coil

  vx = vx/vn
  vy = vy/vn
  vz = vz/vn

  istat, rotmat =  util_rotate_vector_to_y_axis([vx,vy,vz])

  rmat = deepcopy(rotmat)
  for i in range(3):
    for j in range(3):
      rmat[i][j]=rotmat[j][i]
    #endfor j in range(3)
  #endfor i in range(3)

  cosa=np.cos(alpha/180.0*pi)
  sina=np.sin(alpha/180.0*pi)

  currloopx = []
  currloopy = []
  currloopz = []

  iw = -1
  for wire in fila:

    iw += 1

    wx=cosa*wire[0]+sina*wire[2]
    wy=wire[1]
    wz=-sina*wire[0]+cosa*wire[2]

    fila[iw][0]=rmat[0][0]*wx+rmat[0][1]*wy+rmat[0][2]*wz+x0
    fila[iw][1]=rmat[1][0]*wx+rmat[1][1]*wy+rmat[1][2]*wz+y0
    fila[iw][2]=rmat[2][0]*wx+rmat[2][1]*wy+rmat[2][2]*wz+z0

    wx=cosa*wire[3]+sina*wire[5]
    wy=wire[4]
    wz=-sina*wire[3]+cosa*wire[5]

    fila[iw][3]=rmat[0][0]*wx+rmat[0][1]*wy+rmat[0][2]*wz+x0
    fila[iw][4]=rmat[1][0]*wx+rmat[1][1]*wy+rmat[1][2]*wz+y0
    fila[iw][5]=rmat[2][0]*wx+rmat[2][1]*wy+rmat[2][2]*wz+z0

    currloopx.append(fila[iw][0])
    currloopy.append(fila[iw][1])
    currloopz.append(fila[iw][2])

  #endfor w in fila

  currloopx.append(currloopx[0])
  currloopy.append(currloopy[0])
  currloopz.append(currloopz[0])

  CurrLoops.append([kcolor,currloopx,currloopy,currloopz])

  Filaments.append(fila)

#enddef undumag_wind_to_fila(coil)

def util_rotate_vector_to_y_axis(vin):

  istat=0
  vn=np.sqrt(vin[0]**2+vin[1]**2+vin[2]**2)

  rotmat=[[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]]

  if vn == 0.0:
    istat=-1
    return istat, rotmat
  #endif

  vx=vin[0]/vn
  vy=vin[1]/vn
  vz=vin[2]/vn

  if vx**2+vz**2 > 1.0e-9:
    cosphi=vx/np.sqrt(vx**2+vz**2)
    sinphi=vz/np.sqrt(vx**2+vz**2)
  else:
    cosphi=1.0e0
    sinphi=0.0e0
  #endif

  wx=cosphi*vx+sinphi*vz
  wy=vy
  wz=-sinphi*vx+cosphi*vz

  if wx**2+wy**2 > 1.0e-9:
    costhe=wy/np.sqrt(wx**2+wy**2)
    sinthe=wx/np.sqrt(wx**2+wy**2)
  else:
    costhe=1.0e0
    sinthe=0.0e0
  #endif

  rotphi = deepcopy(rotmat)
  rotthe = deepcopy(rotmat)

  rotphi[0][0]=cosphi
  rotphi[0][1]=0.0e0
  rotphi[0][2]=sinphi

  rotphi[1][0]=0.0e0
  rotphi[1][1]=1.0e0
  rotphi[1][2]=0.0e0

  rotphi[2][0]=-sinphi
  rotphi[2][1]=0.0e0
  rotphi[2][2]=cosphi

  rotthe[0][0]=costhe
  rotthe[0][1]=-sinthe
  rotthe[0][2]=0.0e0

  rotthe[1][0]=sinthe
  rotthe[1][1]=costhe
  rotthe[1][2]=0.0e0

  rotthe[2][0]=0.0e0
  rotthe[2][1]=0.0e0
  rotthe[2][2]=1.0e0

  rotmat[0][0] = \
  rotthe[0][0]*rotphi[0][0]+rotthe[0][1]*rotphi[1][0]+rotthe[0][2]*rotphi[2][0]
  rotmat[0][1] = \
  rotthe[0][0]*rotphi[0][1]+rotthe[0][1]*rotphi[1][1]+rotthe[0][2]*rotphi[2][1]
  rotmat[0][2] = \
  rotthe[0][0]*rotphi[0][2]+rotthe[0][1]*rotphi[1][2]+rotthe[0][2]*rotphi[2][2]

  rotmat[1][0] = \
  rotthe[1][0]*rotphi[0][0]+rotthe[1][1]*rotphi[1][0]+rotthe[1][2]*rotphi[2][0]
  rotmat[1][1] = \
  rotthe[1][0]*rotphi[0][1]+rotthe[1][1]*rotphi[1][1]+rotthe[1][2]*rotphi[2][1]
  rotmat[1][2] = \
  rotthe[1][0]*rotphi[0][2]+rotthe[1][1]*rotphi[1][2]+rotthe[1][2]*rotphi[2][2]

  rotmat[2][0] = \
  rotthe[2][0]*rotphi[0][0]+rotthe[2][1]*rotphi[1][0]+rotthe[2][2]*rotphi[2][0]
  rotmat[2][1] = \
  rotthe[2][0]*rotphi[0][1]+rotthe[2][1]*rotphi[1][1]+rotthe[2][2]*rotphi[2][1]
  rotmat[2][2] = \
  rotthe[2][0]*rotphi[0][2]+rotthe[2][1]*rotphi[1][2]+rotthe[2][2]*rotphi[2][2]

  return istat,rotmat
#enddef util_rotate_vector_to_y_axis(vin,rotmat,istat)

def undu_coils_to_filaments(kcoil=-1,callkey=''):
+seq,uguiglobind.

+self,if=trace.
  print(NL,"trace:: undu_coils_to_filaments",kcoil,callkey,NL)
+self.

  if len(Coils) == 0:
    Filaments = []
    return
  #endif

  Fclc = open("filaments.clc","w")
  Fclc.write("& User_Comment\nCoils to Filaments\n\n")

  fil = []
  if kcoil > -1:
    filo = deepcopy(Filaments)
  #endif

  write_variables(Fclc)
  write_coils(Coils,Fclc,kcoil)

  Fclc.close()

  Rmode = 'FILAMENTS STDOUT=undumag.lun6'
  _undumag("Filaments")

  #Quit("Ende nach undumag")

+self,if=trace.
  print(NL,"trace:: Leaving undu_coils_to_filaments",NL)
+self.
#enddef undu_coils_to_filaments()

def blockcorners(mp):

  cen = mp[4]
  siz = mp[6]
  #print(NL,NL,mp)

  xcen = cen[0]
  ycen = cen[1]
  zcen = cen[2]

  xcen = calc_var(xcen)
  ycen = calc_var(ycen)
  zcen = calc_var(zcen)

  typ = mp[3]

  if typ.find('Block') > -1:
    siz = mp[6]
    xcen = calc_var(xcen)
    ycen = calc_var(ycen)
    zcen = calc_var(zcen)
    x = calc_var(siz[0]) / 2.
    y = calc_var(siz[1]) / 2.
    z = calc_var(siz[2]) / 2.
    chamf = calc_var(siz[3])
  #endif typ.find('Block') > -1

  if typ == 'Block':
    corns = [
             [-x,-y,-z],[-x,+y,-z],[+x,-y,-z],[+x,+y,-z],
             [-x,-y,+z],[-x,+y,+z],[+x,-y,+z],[+x,+y,+z]
            ]
  elif typ == 'BlockChamf':

    if chamf >= 0:
      c = chamf; xc = x-c; yc = y-c; zc = z-c
    else:
      c = -chamf; xc = x-c; yc = - (y-c); zc = z-c; y = -y
    #endif

    corns = [
             [-x,-yc,-z],[x,-yc,-z],[x,-yc,z],[-x,-yc,z],
             [-x,+yc,-z],[x,+yc,-z],[x,+yc,z],[-x,+yc,z],
             [-xc,+y,-z],[xc,+y,-z],[xc,+y,z],[-xc,+y,z]
            ]

  elif typ == 'BlockDsChamf':

    chamf = calc_var(siz[3])

    if chamf >= 0:
      c = chamf; xc = x-c; yc = y-c; zc = z-c
    else:
      c = -chamf; xc = x-c; yc = - (y-c); zc = z-c; y = -y
    #endif

    corns = [
             [-x,-yc,-z],[x,-yc,-z],[x,-yc,z],[-x,-yc,z],
             [-x,+y,-z],[x,+yc,-z],[x,+yc,z],[-x,+y,z],
             [-xc,+y,-z],[xc,+y,-z],[xc,+y,z],[-xc,+y,z]
            ]

  elif typ == 'BlockUsChamf':

    chamf = calc_var(siz[3])
    if chamf >= 0:
      c = chamf; xc = x-c; yc = y-c; zc = z-c
    else:
      c = -chamf; xc = x-c; yc = - (y-c); zc = z-c; y = -y
    #endif

    corns = [
             [-x,-yc,-z],[x,-yc,-z],[x,-yc,z],[-x,-yc,z],
             [-x,+y,-z],[x,+yc,-z],[x,+yc,z],[-x,+y,z],
             [-xc,+y,-z],[xc,+y,-z],[xc,+y,z],[-xc,+y,z]
            ]

  else:
    Quit("Error in blockcorners(mp): Unknown type '" + typ + "'")
  #endif typ == 'Block'

  return corns

#enddef blockcorners(mp)

def ureadclc(callkey=''):
+seq,uguiglobind.

  NL = "\n"

+self,if=trace.
  debug("trace: ureadclc:callkey:",callkey)
+self.

  undugui_clean(callkey)

  if not os.path.exists(FileCLC):
    if os.path.exists("FileCLC" + ".clc"):
      FileCLC = FileCLC + ".clc"
      print("\nReading " + FileCLC)
    elif os.path.exists("../input/" + FileCLC):
      print(FileCLC + " not found in current directory, but in ../input")
      FileCLC = "../input/" + FileCLC
    elif os.path.exists("../input/" + FileCLC + ".clc"):
      FileCLC = "../input/" + FileCLC + ".clc"
      print(FileCLC + " not found in current directory, but in ../input")
    else:
      wError(FileCLC + " not found!")
      return
    #endif
  #endif not os.path.exists(FileCLC)

  Fclc = open(FileCLC,"r")

  LastCLC = FileCLC

  Flast = open("unduclc.lst","w")
  Flast.write(FileCLC+NL)
  Flast.close()

  Uclcorig = Fclc.readlines()
  IclcRead = 1

  Fclc.close()

  iline = -1
  nlines = len(Uclcorig)
  icomm = 0

  #print(NL,NL)

  AppleII_Mode = 0
  Hybrid_Mode = 0

  if EchoCLC: print("\nundumag.clc:\n")

  while iline < nlines - 1:

    iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
    if not len(cline): break

    #if EchoCLC: print(cline)

    words = cline.split()
    w1 = words[0]
    c1 = cline[0]

    if words[0] == 'Mode':
      if words[1] == 'AppleII':
        AppleII_Mode = 1
      elif words[1] == 'Hybrid':
        Hybrid_Mode = 1
      elif words[1] == 'Mirror':
        Hybrid_Mode = 2
      #endif
    #endif

    if w1 == '&':

      ckey =  words[1]

      if ckey.upper() == "USER_COMMENT":
        iline += 1
        Ucomment =  Uclcorig[iline].strip()
        print(NL,NL,"User comment:",NL,Ucomment,NL,NL)
      #endif

      elif ckey.upper() == "MAGNET" \
      or ckey.upper() == "SPECIAL_MAGNET" \
      or ckey.upper() == "SPECIAL_POLE" \
      or ckey.upper() == "POLE":

        if ckey.upper() == "SPECIAL_MAGNET" or ckey.upper() == "SPECIAL_POLE":
          ispec = 1
        else:
          ispec = 0
        #endif

        if ckey.upper() == "SPECIAL_POLE" or ckey.upper() == "POLE":
          ispole = 1
        else:
          ispole = 0
        #endif

        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        if not len(cline): break

        try:
          words = cline.split()
          key = words[0]
          cnam = words[1]
          cmoth = words[2]
          col = words[3]
        except:
          Quit("*** Error in ureadclc: Bad line:\n" + cline)
        #endtry
        cname = [cnam,cmoth]

        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        if not len(cline): break

        try:
          words = cline.split()
          xcen = words[0]
          ycen = words[1]
          zcen = words[2]
          cen = [xcen,ycen,zcen]
        except:
          Quit("*** Error in ureadclc: Bad line:\n" + cline)
        #endtry

        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        if not len(cline): break

        try:
          words = cline.split()
          if not ispole:
            bc = words[0]
            xm = words[1]
            ym = words[2]
            zm = words[3]
            mat = words[4]
          else:
            bc = '0.0'
            xm = '0.0'
            ym = '0.0'
            zm = '0.0'
            mat = words[0]
          #endif
          vmat = [bc,xm,ym,zm,mat,col]
        except:
          Quit("*** Error in ureadclc: Bad line:\n" + cline)
        #endtry

        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        if not len(cline): break

        if key.upper() != 'FILE' and key.upper() != 'CORNERS':
          try:
            words = cline.split()
            size = ['0.0','0.0','0.0','0.0','0.0','0.0','0.0']
            for i in range(len(words)):
              size[i] = words[i]
            #endfor
          except:
            Quit("*** Error in ureadclc: Bad line:\n" + cline)
          #endtry
        else:
          iline -= 1
        #endif

        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        if not len(cline): break

        try:
          words = cline.split()
          nxdiv = words[0]
          nydiv = words[1]
          nzdiv = words[2]
          yfracdiv = words[3]
          zfracdiv = words[4]
        except:
          Quit("*** Error in ureadclc: Bad line:\n" + cline)
        #endtry

        div = [nxdiv,nydiv,nzdiv,yfracdiv,zfracdiv]

        corns = []
+self,if=debugureadclc.
        print("cnam,key,ispec,ispole:",cnam,key,ispec,ispole)
+self.

        if key.upper() == 'CORNERS':

          iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
          if not len(cline): break
          sncorn = cline
          ncorn = eval(sncorn)

          for i in range(ncorn):
            iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
            words = cline.split()
#            x = calc_var(words[0])
#            y = calc_var(words[1])
#            z = calc_var(words[2])
#            corns.append([x,y,z])
            corns.append([words[0],words[1],words[2]])
          #endfor i in range(ncorn))

          for mpt in MagPols:
            if mpt[0][0] == cnam:
              print("\n*** Error in ureadclc: Duplicate magnet name:",
                    NL,mpt[0],"< - >",cname)
              Quit()
          #endfor

          for mpt in SpecMagPols:
            if mpt[0][0] == cnam:
              print("\n*** Error in ureadclc: Duplicate magnet name:",
                    NL,mpt[0],"< - >",cname)
              Quit()
          #endfor

          if ispec:
            SpecMagPols.append([cname,None,ispec,key,cen,vmat,sncorn,corns,div])
          else:
            MagPols.append([cname,None,ispec,key,cen,vmat,sncorn,corns,div])
          #endif

        elif key.upper() == 'FILE':

          iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
          if not len(cline): break
          fname = cline
          Fcorn = open(fname,'r')
          cornlines = Fcorn.readlines()
          Fcorn.close()
          for cline in cornlines:
            words = cline.split()
            if cline[0] == '*' or len(words) < 3: continue
            words = cline.split()
#            x = calc_var(words[0])
#            y = calc_var(words[1])
#            z = calc_var(words[2])
#            corns.append([x,y,z])
            corns.append([words[0],words[1],words[2]])
          #endfor cline in cornlines
          sncorn = str(len(corns))
          DictCornFiles[cname[0]] = fname

          for mpt in MagPols:
            if mpt[0][0] == cnam:
              print("\n*** Error in ureadclc: Duplicate magnet name:",
                    NL,mpt[0],"< - >",cname)
              Quit()
          #endfor

          for mpt in SpecMagPols:
            if mpt[0][0] == cnam:
              print("\n*** Error in ureadclc: Duplicate magnet name:",
                    NL,mpt[0],"< - >",cname)
              Quit()
          #endfor

          if ispec:
            SpecMagPols.append([cname,None,ispec,key,cen,vmat,sncorn,corns,div])
          else:
            MagPols.append([cname,None,ispec,key,cen,vmat,sncorn,corns,div])
          #endif

        else:
+self,if=debugureadclc.
          #debug(cnam)
+self.
          for mpt in MagPols:
            if mpt[0][0] == cnam:
              print("\n*** Error in ureadclc: Duplicate magnet name:",
                    NL,mpt[0],"< - >",cname)
              Quit()
          #endfor

          for mpt in SpecMagPols:
            if mpt[0][0] == cnam:
              print("\n*** Error in ureadclc: Duplicate magnet name:",
                    NL,mpt[0],"< - >",cname)
              Quit()
          #endfor

          if ispec:
            SpecMagPols.append([cname,None,ispec,key,cen,vmat,size,div])
          else:
            MagPols.append([cname,None,ispec,key,cen,vmat,size,div])
          #endif

        #endif  'CORNERS'

      elif ckey.upper() == "COIL":

        #debug("debug: Coil")
        coil = []

        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        words = cline.split()

        key = words[0]
        idxcoil = len(Coils)

        if len(words) > 1:
          cnam = words[1]
        else:
          cnam = 'coil_' + str(idxcoil+1)
        #endif

        if not key in DictCoils: DictCoils[key] = []
        DictCoils[key].append(idxcoil)

#        debug(key + " " + cnam)

        coil.append([key,cnam])

#        for w in words: coil.append(w)

        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        words = cline.split()

        if key == 'Filaments':
          coil.append(words[0])
          fil = []
          for i in range(int(coil[1])):
            iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
            words = cline.split()
            fi = []
            for f in words: fi.append(f)
            fil.append(fi)
          #endfor
          coil.append(fil)
          Coils.append(coil)
        elif key == 'File':
          if words[0][0] == '"' or  words[0][0] == "'":
            coil.append(words[0][1:-1])
          else:
            coil.append(words[0])
          #endif
          Coils.append(coil)
        elif key == 'RectWindings' or key == 'Rectangular' or key == 'RectangCirc':
          wl = []
          for w in words: wl.append(w)
          #debug("wl")
          coil.append(wl)
          Coils.append(coil)
        elif key == 'RectArc' or key == 'RectBar' \
        or key == 'ThickWire' or key == 'CircArc':
          #debug("debug: RectBar")
          ww = []
          wl = []
          for w in words: wl.append(w)
          ww.append(wl)
          iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
          words = cline.split()
          wl = []
          for w in words: wl.append(w)
          ww.append(wl)
          coil.append(ww)
          Coils.append(coil)
        else:
          print("*** Error in ureadclc: Unknown coil key: " + key + NL)
        #endif

      elif ckey == "Translate":
        trc = [ckey]
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        trc.append(cline)
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        trc.append(cline)
        TransRotCop.append(trc)
      elif ckey == "Remanence":
        trc = [ckey]
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        trc.append(cline)
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        trc.append(cline)
        TransRotCop.append(trc)
      elif ckey == "Copy":
        trc = [ckey]
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        trc.append(cline)
        TransRotCop.append(trc)
      elif ckey == "Rotate" or ckey == "Rotate_Shape":
        trc = [ckey]
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        trc.append(cline)
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        trc.append(cline)
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        trc.append(cline)
        TransRotCop.append(trc)

      elif ckey == "Module":

        Nmodul += 1

        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        trans = cline
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        nper = cline
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        space = cline
        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        scale = cline

        modu = [trans,nper,space,scale]
        Modules.append(modu)

      elif ckey == "Materials":

        iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
        Nmat = int(cline)

        for i in range(Nmat):
          iline, cline, icomm, com = ugui_get_clc_line_com(iline,nlines,icomm)
          words = cline.split()
          if words[1] == '1': words[1] = 'REC'
          if words[1] == '2': words[1] = 'Iron'
          if words[1] == '3':
            words[1] = 'Mirror'
            Quit("Spiegel")
          Fmat = open(words[3],'r')
          flines = Fmat.readlines()
          Fmat.close()
          words.append(flines)
          Materials.append(words)
        #endfor i in range(Nmat)

      else:
        print("*** Error in ureadclc: Unknown key: " + ckey + NL)
      #endif ckey

    elif c1 == '$':

      words = cline.split('=')
      if len(words) == 1: continue

      vnam = words[0].strip()
      CalcLines.append([vnam,words[1].strip(),com])
      DictVcomments[vnam] = com

    elif w1.lower() == 'p':

      words = cline.split("=")
      pnam = '$' + words[0].split()[1].strip()
      pval = words[1].strip()

      if pnam == '$PerLen':
        if Parameters[0][0] == '$PerLen':
          Parameters[0][1] = pval
          Pars[pnam] = float(pval)
        else:
          Quit("Reserved Parameter $PerLen not found in Parameters[0]")
        #endif
        DictPcomments[pnam] = com
        continue
      #endif

      if pnam == '$Mcoating':
        if Parameters[1][0] == '$Mcoating':
          Parameters[1][1] = pval
          Pars[pnam] = float(pval)
        else:
          Quit("Reserved Parameter $Mcoating not found in Parameters[1]")
        #endif
        DictPcomments[pnam] = com
        continue
      #endif
      DictPcomments[pnam] = com
      Parameters.append([pnam,pval])
    #endif

  #endwhile iline < nlines - 1

  Npar = len(Parameters)

  NMagPol = len(MagPols)
  NspecMagPol = len(SpecMagPols)

  ugui_calc()

  imag = 0
  for imp in range(NMagPol):

    # MagPols.append([cname,mag,ispec,key,cen,vmat,siz,div])
    # MagPols.append([cname,mag,ispec,key,cen,vmat,sncorn,corns,div])

    imag += 1
+self,if=debugureadclc.
    #debug("debug ureadclc imag")
+self.
    mp = MagPols[imp]

    cname = mp[0]
    DictMagPolsTot[cname[0]] = imp

    #vmat = [bc,xm,ym,zm,mat,col]

    vmat = mp[5]
    mat = vmat[4]

    if mat[0] == '$':
      mat = int(Variables[mat])
    #endif mat[0] == '$'

    tmat = Materials[int(mat)-1][1]

+self,if=debugureadclc.
    print("tmat:",tmat)
+self.

    if tmat == 'REC':
      mp[1] = 'REC'
      Magnets.append(cname)
    elif tmat == 'Iron':
      mp[1] = 'Iron'
      Pols.append(cname)
    #endif

    MagPolsTot.append(mp)

  #endfor imp in range(NMagPol)

  ispec = 0

  for imp in range(NspecMagPol):

    # MagPols.append([cname,mag,ispec,key,cen,vmat,siz,div])
    # MagPols.append([cname,mag,ispec,key,cen,vmat,sncorn,corns,div])

    imag += 1
    ispec += 1
    mp = SpecMagPols[imp]

    cname = mp[0]
    DictMagPolsTot[cname[0]] = NMagPol + imp

    #vmat = [bc,xm,ym,zm,mat,col]

    vmat = mp[5]
    mat = vmat[4]
    if mat[0] == '$':
      mat = Variables[mat]
    #endif mat[0] == '$'
+self,if=debugureadclc.
    print("mat:",mat)
+self.
    if int(mat) < 1 or int(mat) > Nmat:
+self,if=debugureadclc.
      debug()
+self.
      print("*** Error in ureadclc: Bad Material index for",mp[0])
      Quit()
    #endif

    tmat = Materials[int(mat)-1][1]

+self,if=debugureadclc.
    print("tmat:",tmat)
+self.

    if tmat == 'REC':
      mp[1] = 'REC'
      SpecMags.append(cname)
    elif tmat == 'Iron':
      mp[1] = 'Iron'
      SpecPols.append(cname)
    #endif

    MagPolsTot.append(mp)

  #endfor imp in range(NSpecMagPol)

  Nmag = len(Magnets)
  Npol = len(Pols)

  NspecMag = len(SpecMags)
  NspecPol = len(SpecPols)

  NMagPolTot = len(MagPolsTot)

+self,if=DEBUGUREADCLC.
  if callkey == 'clWhyrid':
    print('*******************************************')
    print(Nmag,Npol)
    print(NspecMag,NspecPol)
    for m in range(NMagPolTot):
      mp = MagPolsTot[m]
      cnam = mp[0][0]
      cmoth = mp[0][1]
      typ = mp[3]
      print(cnam,cmoth)
    #endif
    print('*******************************************')
    print("DictMoths",DictMoths)
    print("Moths",Moths)
  #endif
  debug("debug: ureadclc 1")
+self.

  for m in range(NMagPolTot):

    mp = MagPolsTot[m]
    cnam = mp[0][0]
    cmoth = mp[0][1]
    typ = mp[3]

    if cmoth in DictMoths:
      moth = DictMoths[cmoth]
      Moths[moth-1].append(cnam)
    else:
      Nmoth += 1
      Moths.append([])
      Moths[Nmoth-1].append(cnam)
      DictMoths[cmoth] = Nmoth - 1
    #endif cmoth in DictMothHulls

    cen = mp[4]

    xcen = cen[0]
    ycen = cen[1]
    zcen = cen[2]

    xcen = calc_var(xcen)
    ycen = calc_var(ycen)
    zcen = calc_var(zcen)

+self,if=debugrspec.
    print("debugrspec:",m,NL,mp)
+self.
    if typ.upper().find('BLOCK') > -1:
      corns = blockcorners(mp)
    elif typ.upper() == 'CYLINDER':
      DictCyls[cnam] = Ncylinder
      size = mp[6]
      rin = float(size[0])
      rout = float(size[1])
      h = float(size[2])
      dphi = float(size[3])
      nphi = int(mp[7][2])
      if nphi < int(dphi/45.)+3: nphi = int(dphi/45.)+3
      Ncylinder += 1
      ccyl = 'ncyl_' + str(Ncylinder)
      ncyl = ncylinder(ccyl,
                       xcen,ycen,zcen,rout-rin,rin,rin,h,0.0,90.,dphi,nphi,1)
      poly = cylinderpoly(ccyl)
      Ntcyls.append([imp,mp,ccyl,poly])
    elif typ.upper() == 'FILE' or typ.upper() == 'CORNERS':
      corns = []
      for ic in range(len(mp[7])):
        c1 = calc_var(mp[7][ic][0])
        c2 = calc_var(mp[7][ic][1])
        c3 = calc_var(mp[7][ic][2])
        corns.append([c1,c2,c3])
      #endfor ic in range(len(corns))
    else:
      print("*** Bad key " + typ + " in ureadclc ***")
    #endif typ == 'Block'

    if typ.upper() == 'CYLINDER':
      MagPolsTot[m].append(mp[4])
      continue
    #endif

    xmin = 1.e30
    xmax = -1.e30
    ymin = 1.e30
    ymax = -1.e30
    zmin = 1.e30
    zmax = -1.e30

    for corn in corns:
      x = corn[0] + xcen
      y = corn[1] + ycen
      z = corn[2] + zcen
      if x < xmin: xmin = x
      if x > xmax: xmax = x
      if y < ymin: ymin = y
      if y > ymax: ymax = y
      if z < zmin: zmin = z
      if z > zmax: zmax = z
    #endfor corn in corns

    x = (xmin+xmax)/2.
    y = (ymin+ymax)/2.
    z = (zmin+zmax)/2.

    MagPolsTot[m].append([x,y,z])

    verts,ifaces,faces = hull3d(corns)
    if type(verts) != Tdf:
      hull = pd.DataFrame(verts)
    else:
      hull=verts
    #endif
    hull.columns = ['xr','yr','zr']

    hull['x'] = hull.xr+xcen
    hull['y'] = hull.yr+ycen
    hull['z'] = hull.zr+zcen

    DictHulls[cnam] = len(Hulls)
    Hulls.append(hull)

  #endfor m in range(NMagPolTot)

+self,if=DEBUGUREADCLC.
  for mp in MagPolsTot: print(NL,mp)
  debug("debug: ureadclc 2")
+self.

  if NMagPolTot:

    # sort mothers by x

    moli = []

    xmins = 1.e30
    xmaxs = -1.e30
    ymins = 1.e30
    ymaxs = -1.e30
    zmins = 1.e30
    zmaxs = -1.e30

    ispec = 0

    for mo in range(len(Moths)):

      moth = Moths[mo]

      xmin = 1.e30
      xmax = -1.e30
      ymin = 1.e30
      ymax = -1.e30
      zmin = 1.e30
      zmax = -1.e30

      for cmag in moth:
        mag = DictMagPolsTot[cmag]
        mp = MagPolsTot[mag]
        typ = mp[3]
        if typ == 'Cylinder':
          cyl = Ntcyls[DictCyls[cmag]]
          nc = nget(cyl[2])
          nh = Nhead[Ind]
          xmn = nh[6][1]
          xmx = nh[6][2]
          zmn = nh[5][1]
          zmx = nh[7][2]
          ymn = nh[8][1]
          ymx = nh[9][2]
        else:
          nhu = DictHulls[cmag]
          xmn = Hulls[nhu].x.min()
          xmx = Hulls[nhu].x.max()
          ymn = Hulls[nhu].y.min()
          ymx = Hulls[nhu].y.max()
          zmn = Hulls[nhu].z.min()
          zmx = Hulls[nhu].z.max()
        #endif Cyl

        if xmn < xmin: xmin = xmn
        if xmx > xmax: xmax = xmx
        if ymn < ymin: ymin = ymn
        if ymx > ymax: ymax = ymx
        if zmn < zmin: zmin = zmn
        if zmx > zmax: zmax = zmx
        if MagPolsTot[mag][2] == 'yes':
          if xmn < xmins: xmins = xmn
          if xmx > xmaxs: xmaxs = xmx
          if ymn < ymins: ymins = ymn
          if ymx > ymaxs: ymaxs = ymx
          if zmn < zmins: zmins = zmn
          if zmx > zmaxs: zmaxs = zmx
        #endif MagPolsTot[mag][2] == 'yes'

      #endfor mag in moth

      moli.append([mo,
                   xmin,xmax,(xmin+xmax)/2.,
                   ymin,ymax,(ymin+ymax)/2.,
                   zmin,zmax,(zmin+zmax)/2.])
    #endfor mo in range(len(Moths))

+self,if=DEBUGUREADCLC.
    debug("debug: ureadclc 3")
+self.
    MothsXYZ = pd.DataFrame(moli)
    MothsXYZ.columns = ['imoth',
                        'xmin','xmax','x',
                        'ymin','ymax','y',
                        'zmin','zmax','z']
    MothsXYZ = MothsXYZ.sort_values(by=['x','y','z']).reset_index()

    if not ispec:
      xmins = MothsXYZ.xmin.min()
      xmaxs = MothsXYZ.xmax.max()
      ymins = MothsXYZ.ymin.min()
      ymaxs = MothsXYZ.ymax.max()
      zmins = MothsXYZ.zmin.min()
      zmaxs = MothsXYZ.zmax.max()
    #endif not ispec

    SpecXYZ = [xmins,xmaxs,ymins,ymaxs,zmins,zmaxs]

    mocop = deepcopy(Moths)
    Moths = []

    for mo in range(len(mocop)):
      Moths.append(mocop[MothsXYZ.imoth[mo]])
    #endfor mo in range(len(mocop))

    # sort by mothers

    mpcop = MagPolsTot
    MagPolsTot = []
    MagPolsSelected = []

    for mo in range(len(Moths)):
      moth = Moths[mo]
      for mag in moth:
        MyMoth[mag] = mo
        mag = DictMagPolsTot[mag]
        MagPolsTot.append(mpcop[mag])
      #endfor mag in moth
    #endfor mo in range(len(Moths))

  #endif NMagPolTot

+self,if=DEBUGUREADCLC.
  imp = 0
  for mp in MagPolsTot:
    imp += 1
    print(imp,mp[0:4])
  #endfor
  debug("debug: ureadclc 4")
+self.

  for imp in range(NMagPolTot):
    cnam = MagPolsTot[imp][0][0]
    DictMagPolsTot[cnam] = imp
  #endfor mo in range(len(Moths))

  NCalc = len(Calcs)
  DictCalcs = {}
  for ic in range(NCalc):
    cnam = Calcs[ic][0]
    DictCalcs[cnam] = [ic,Calcs[ic][1]]
  #endfor mo in range(len(Moths))

  if Nmag + Npol + NspecMag + NspecPol != NMagPolTot:
    Quit("*** Error in ureadclc: Bad sum of magnets and poles ***")
  #endif Nmag + Npol + NspecMag + NspecPol != NMagPolTot

  NCoil = len(Coils)
  if NCoil: undu_coils_to_filaments()

  #if len(TransRotCop): utransrotcop()
  if len(TransRotCop): checktransrotcop()

  #debug("debug: Ende von ureadclc")

#enddef ureadclc()

+KEEP,mgeometry,T=PYTHON.
*CMZ :  2.04/10 19/08/2023  20.51.51  by  Michael Scheer
*CMZ :  2.04/09 18/08/2023  08.47.17  by  Michael Scheer
*CMZ :  2.04/06 08/07/2023  11.41.00  by  Michael Scheer
*CMZ :  2.03/00 01/09/2022  10.11.28  by  Michael Scheer
*CMZ :  2.02/02 04/03/2022  08.58.13  by  Michael Scheer
*CMZ :  2.02/01 30/04/2021  08.25.40  by  Michael Scheer
*CMZ :  2.02/00 27/03/2021  13.54.39  by  Michael Scheer
*-- Author :    Michael Scheer   13/10/2020

# +KEEP,mgeometry,T=PYTHON.

def framelabentry(win,text,var,stvar,font,widlab,wident):
  stvar.set(var)
  f = Frame(win)
  l = Label(f,text=text,font=font, width=widlab)
  l.pack(side=LEFT)
  e = Entry(f,text=stvar,width=wident,justify=CENTER,font=font)
  e.pack(side=LEFT)
  f.pack(fill='x')
#enddef framelabentry():

def framelabentrycomment(win,text,var,stvar,com,stcom,font,widlab,wident,widcom):
  stvar.set(var)
  stcom.set(com)
  f = Frame(win)
  l = Label(f,text=text,font=font, width=widlab)
  l.pack(side=LEFT)
  e = Entry(f,text=stvar,width=wident,justify=CENTER,font=font)
  e.pack(side=LEFT)
  c = Entry(f,text=stcom,width=widcom,justify=CENTER,font=font)
  c.pack(side=LEFT)
  f.pack(fill='x')
  return l,e,c
#enddef framelabentry():

+seq,showgeo.

+seq,hybridvars.

def _GetMirror(key=''):
+seq,uguiglobind.
+seq,hybridvarsind.

  if key == 'menu' and fexist("mirror.lst"):
    print(NL,"--- Initializing quasi infinite undulator, reading default values from mirror.lst ---")
    Mirror = {}
    flst = open("mirror.lst","r")
    lines =  flst.readlines()
    flst.close()
    for line in lines:
      mir = line.strip().split()
      print(mir)
      Mirror[mir[0]] = mir[1]
    #endfor
    return
  #endif

  Mirror["PerLen_Mirror"] = _EntryVarGet(S_PerLen_Mirror)
  Mirror["FullGap_Mirror"] = _EntryVarGet(S_FullGap_Mirror)

  Mirror["Br_Mirror"] = _EntryVarGet(S_Br_Mirror)
  Mirror["mu_Mirror"] = _EntryVarGet(S_mu_Mirror)
  Mirror["KsiPerp_Mirror"] = _EntryVarGet(S_KsiPerp_Mirror)

  Mirror["LyMag_Mirror"] = _EntryVarGet(S_LyMag_Mirror)
  Mirror["LzMagFull_Mirror"] = _EntryVarGet(S_LzMagFull_Mirror)
  Mirror["ChamfMag_Mirror"] = _EntryVarGet(S_ChamfMag_Mirror)

  Mirror["Mcoating_Mirror"] = _EntryVarGet(S_Mcoating_Mirror)

  Mirror["nDivX_Mag_Mirror"] = _EntryVarGet(S_nDivX_Mag_Mirror)
  Mirror["nDivY_Mag_Mirror"] = _EntryVarGet(S_nDivY_Mag_Mirror)
  Mirror["nDivZ_MagHalf_Mirror"] = _EntryVarGet(S_nDivZ_MagHalf_Mirror)
  Mirror["FracDivY_Mag_Mirror"] = _EntryVarGet(S_FracDivY_Mag_Mirror)
  Mirror["FracDivZ_Mag_Mirror"] = _EntryVarGet(S_FracDivZ_Mag_Mirror)

  Mirror["MatPol_Mirror"] = _EntryVarGet(S_MatPol_Mirror)

  Mirror["LxPol_Mirror"] = _EntryVarGet(S_LxPol_Mirror)
  Mirror["LyPol_Mirror"] = _EntryVarGet(S_LyPol_Mirror)
  Mirror["LzPolFull_Mirror"] = _EntryVarGet(S_LzPolFull_Mirror)
  Mirror["ChamfPol_Mirror"] = _EntryVarGet(S_ChamfPol_Mirror)

  Mirror["nDivX_Pol_Mirror"] = _EntryVarGet(S_nDivX_Pol_Mirror)
  Mirror["nDivY_Pol_Mirror"] = _EntryVarGet(S_nDivY_Pol_Mirror)
  Mirror["nDivZ_PolHalf_Mirror"] = _EntryVarGet(S_nDivZ_PolHalf_Mirror)
  Mirror["FracDivY_Pol_Mirror"] = _EntryVarGet(S_FracDivY_Pol_Mirror)
  Mirror["FracDivZ_Pol_Mirror"] = _EntryVarGet(S_FracDivZ_Pol_Mirror)
  Mirror["Space_Mag_Pol_Mirror"] = _EntryVarGet(S_Space_Mag_Pol_Mirror)

  Mirror["LxMirror"] = _EntryVarGet(S_LxMirror)
  Mirror["LyMirror"] = _EntryVarGet(S_LyMirror)
  Mirror["LzMirror"] = _EntryVarGet(S_LzMirror)

  Mirror["nMirDivX"] = _EntryVarGet(S_nMirDivX)
  Mirror["nMirDivY"] = _EntryVarGet(S_nMirDivY)
  Mirror["nMirDivZ"] = _EntryVarGet(S_nMirDivZ)

  Mirror["FracDivMirY"] = _EntryVarGet(S_FracDivMirY)
  Mirror["FracDivMirZ"] = _EntryVarGet(S_FracDivMirZ)

  Mirror["Mat_Mirror"] = _EntryVarGet(S_Mat_Mirror)

  if int(Mirror["RECIndex_Mirror"])  < 0:
    Nmat += 1
    Mirror["RECIndex_Mirror"] = Nmat
    Materials.append([str(Nmat),"1","1","undugui_Hybrid_mu.dat", \
    [str(Mirror["mu_Mirror"]) + " " + str(Mirror["KsiPerp_Mirror"]) + "! mu_Par and ksi_Perp_Mirror"]])
  #endif

  if int(Mirror["IronIndex_Hybrid"]) < 0:
    Nmat += 1
    Mirror["IronIndex_Hybrid"] = Nmat
    Materials.append([str(Nmat),"2","3",Mirror["MatPol_Mirror"],""])
  #endif

  Mirror["Mat_Mirror"] = _EntryVarGet(S_Mat_Mirror)

  if int(Mirror["IronIndex_Mirror"]) < 0:
    Nmat += 1
    Mirror["IronIndex_Mirror"] = Nmat
    Materials.append([str(Nmat),"2","0",Mirror["Mat_Mirror"],""])
    #print("MatMir:",Nmat,Materials[len(Materials)-1])
  #endif

  Fsav = open("mirror.lst","w")
  for par in Mirror: Fsav.write(par + " " + str(Mirror[par]) + "\n" )
  Fsav.close()

#enddef _GetMirror()

def _GetHybrid():
+seq,uguiglobind.
+seq,hybridvarsind.

  Hybrid["nPeriods_Hybrid"] = _EntryVarGet(S_nPer_Hybrid)
  Hybrid["PerLen_Hybrid"] = _EntryVarGet(S_PerLen_Hybrid)
  Hybrid["FullGap_Hybrid"] = _EntryVarGet(S_FullGap_Hybrid)

  Hybrid["Br_Hybrid"] = _EntryVarGet(S_Br_Hybrid)
  Hybrid["mu_Hybrid"] = _EntryVarGet(S_mu_Hybrid)
  Hybrid["KsiPerp_Hybrid"] = _EntryVarGet(S_KsiPerp_Hybrid)

  #Hybrid["LxMag_Hybrid"] = _EntryVarGet(S_LxMag_Hybrid)
  Hybrid["LyMag_Hybrid"] = _EntryVarGet(S_LyMag_Hybrid)
  Hybrid["LzMagFull_Hybrid"] = _EntryVarGet(S_LzMagFull_Hybrid)
  Hybrid["ChamfMag_Hybrid"] = _EntryVarGet(S_ChamfMag_Hybrid)

  Hybrid["Mcoating_Hybrid"] = _EntryVarGet(S_Mcoating_Hybrid)

  Hybrid["nDivX_Mag_Hybrid"] = _EntryVarGet(S_nDivX_Mag_Hybrid)
  Hybrid["nDivY_Mag_Hybrid"] = _EntryVarGet(S_nDivY_Mag_Hybrid)
  Hybrid["nDivZ_MagHalf_Hybrid"] = _EntryVarGet(S_nDivZ_MagHalf_Hybrid)
  Hybrid["FracDivY_Mag_Hybrid"] = _EntryVarGet(S_FracDivY_Mag_Hybrid)
  Hybrid["FracDivZ_Mag_Hybrid"] = _EntryVarGet(S_FracDivZ_Mag_Hybrid)

  Hybrid["Space_Mag_Pol_Hybrid"] = _EntryVarGet(S_Space_Mag_Pol_Hybrid)

  Hybrid["MatPol_Hybrid"] = _EntryVarGet(S_MatPol_Hybrid)

  Hybrid["LxPol_Hybrid"] = _EntryVarGet(S_LxPol_Hybrid)
  Hybrid["LyPol_Hybrid"] = _EntryVarGet(S_LyPol_Hybrid)
  Hybrid["LzPolFull_Hybrid"] = _EntryVarGet(S_LzPolFull_Hybrid)
  Hybrid["ChamfPol_Hybrid"] = _EntryVarGet(S_ChamfPol_Hybrid)
  Hybrid["OffPol_Hybrid"] = _EntryVarGet(S_OffPol_Hybrid)

  Hybrid["nDivX_Pol_Hybrid"] = _EntryVarGet(S_nDivX_Pol_Hybrid)
  Hybrid["nDivY_Pol_Hybrid"] = _EntryVarGet(S_nDivY_Pol_Hybrid)
  Hybrid["nDivZ_PolHalf_Hybrid"] = _EntryVarGet(S_nDivZ_PolHalf_Hybrid)
  Hybrid["FracDivY_Pol_Hybrid"] = _EntryVarGet(S_FracDivY_Pol_Hybrid)
  Hybrid["FracDivZ_Pol_Hybrid"] = _EntryVarGet(S_FracDivZ_Pol_Hybrid)
  Hybrid["Space_Pol_Mag_Hybrid"] = _EntryVarGet(S_Space_Pol_Mag_Hybrid)

  if Hybrid["RECIndex_Hybrid"]  < 0:
    Nmat += 1
    Hybrid["RECIndex_Hybrid"] = Nmat
    Materials.append([str(Nmat),"1","1","undugui_Hybrid_mu.dat", \
    [str(Hybrid["mu_Hybrid"]) + " " + str(Hybrid["KsiPerp_Hybrid"]) + "! mu_Par and ksi_Perp_Hybrid"]])
  #endif

  if Hybrid["IronIndex_Hybrid"] < 0:
    Nmat += 1
    Hybrid["IronIndex_Hybrid"] = Nmat
    Materials.append([str(Nmat),"2","3",Hybrid["MatPol_Hybrid"],""])
  #endif

#enddef _GetHybrid()

def _clWsetMirror():
  global WsetMirror

  _GetMirror("clWset")

  MustWriteCLC = 1

  WsetMirror.destroy()
#enddef _clsetmirror()

def _clWmirror():

  global Hybrid_Mode,Wmirror, FileCLCO, FileCLC, Mirror

  _GetMirror('clWmirror')
  Hybrid_Mode = 2

  uwritenam('clWmirror')
  uwriteclc('_clWmirror')

  MustWriteCLC = 0

  ureadclc('clWmirror')
  _showGeoPython(callkey='clWmirror')

  FileCLCO = FileCLC

#  _showGeoPython()

#  FileCLCO = FileCLC

  Wmirror.destroy()
#enddef _clmirror()

def _clWhybrid():
  global Hybrid_Mode,Whybrid, FileCLCO, FileCLC

  _GetHybrid()
  Hybrid_Mode = 1

  uwritenam('_clWhybrid')
  uwriteclc('_clWhybrid')

  MustWriteCLC = 0

  ureadclc('clWhyrid')
+self,if=trace.
  global NMagPolTot,MagPolsTot
  print("\ntrace:: List of magnets in _clWhybrid")
  imp = 0
  for mp in MagPolsTot:
    imp += 1
    print(imp,mp[0:4])
  #endfor
+self.

  _showGeoPython(callkey='clWhybrid')

  FileCLCO = FileCLC

  Whybrid.destroy()
#enddef _clhybrid()

def _cnWhyEnd():
  global WhyEnd
  WhyEnd.destroy()
#enddef _cnhybrid()

def GetHybridEnd():
+seq,uguiglobind.
+seq,hybridvarsind.

  Hybrid["LyEndMag1_Hybrid"] = _EntryVarGet(S_LyEndMag1_Hybrid)
  Hybrid["SpaceEndMag1_Hybrid"] = _EntryVarGet(S_SpaceEndMag1_Hybrid)
  Hybrid["OffEndMag1_Hybrid"] = _EntryVarGet(S_OffEndMag1_Hybrid)

  Hybrid["LyEndMag2_Hybrid"] = _EntryVarGet(S_LyEndMag2_Hybrid)
  Hybrid["SpaceEndMag2_Hybrid"] = _EntryVarGet(S_SpaceEndMag2_Hybrid)
  Hybrid["OffEndMag2_Hybrid"] = _EntryVarGet(S_OffEndMag2_Hybrid)

  Hybrid["LyEndMag3_Hybrid"] = _EntryVarGet(S_LyEndMag3_Hybrid)
  Hybrid["SpaceEndMag3_Hybrid"] = _EntryVarGet(S_SpaceEndMag3_Hybrid)
  Hybrid["OffEndMag3_Hybrid"] = _EntryVarGet(S_OffEndMag3_Hybrid)

  Hybrid["LyEndPol1_Hybrid"] = _EntryVarGet(S_LyEndPol1_Hybrid)
  Hybrid["SpaceEndPol1_Hybrid"] = _EntryVarGet(S_SpaceEndPol1_Hybrid)
  Hybrid["OffEndPol1_Hybrid"] = _EntryVarGet(S_OffEndPol1_Hybrid)

  Hybrid["LyEndPol2_Hybrid"] = _EntryVarGet(S_LyEndPol2_Hybrid)
  Hybrid["SpaceEndPol2_Hybrid"] = _EntryVarGet(S_SpaceEndPol2_Hybrid)
  Hybrid["OffEndPol2_Hybrid"] = _EntryVarGet(S_OffEndPol2_Hybrid)

#enddef GetHybridEnd()

def _clWhyEnd():
  global WhyEnd
  GetHybridEnd()
  WhyEnd.destroy()
#enddef _clhybrid()

def _cnWhybrid():
  global Whybrid
  Whybrid.destroy()
#enddef _cnhybrid()

def _setMirror():

  global WsetMirror, Mirror

  WsetMirror = Toplevel()
  WsetMirror.title("Mirror Plate")
  WsetMirror.attributes('-topmost', 1)

  widlab = 25
  wident = 30

  #_GetMirror('menu')

  framelabentry(WsetMirror,'length of mirror',Mirror["LxMirror"],S_LxMirror,MyFont,widlab,wident)
  framelabentry(WsetMirror,'height of mirror',Mirror["LyMirror"],S_LyMirror,MyFont,widlab,wident)
  framelabentry(WsetMirror,'width of mirror',Mirror["LzMirror"],S_LzMirror,MyFont,widlab,wident)

  framelabentry(WsetMirror,'number of segments in x',Mirror["nMirDivX"],S_nMirDivX,MyFont,widlab,wident)
  framelabentry(WsetMirror,'number of segments in y',Mirror["nMirDivY"],S_nMirDivY,MyFont,widlab,wident)
  framelabentry(WsetMirror,'number of segments in z',Mirror["nMirDivZ"],S_nMirDivZ,MyFont,widlab,wident)
  framelabentry(WsetMirror,'fraction of  y-seg.',Mirror["FracDivMirY"],S_FracDivMirY,MyFont,widlab,wident)
  framelabentry(WsetMirror,'fraction of  z-seg.',Mirror["FracDivMirZ"],S_FracDivMirZ,MyFont,widlab,wident)

  framelabentry(WsetMirror,'MH-Curve',Mirror["Mat_Mirror"],S_Mat_Mirror,MyFont,widlab,wident)

  fbot = Frame(WsetMirror)

  bCancel = Button(fbot,text='Cancel',command=_cnWsetMirror)
  bCancel.pack(side=LEFT,expand=TRUE,fill=X)

  bClose = Button(fbot,text='Ok',command=_clWsetMirror)
  bClose.pack(side=LEFT,expand=TRUE,fill=X)

  fbot.pack(expand=TRUE,fill=X)

  x,y = Umaster.winfo_pointerxy()
  sgeo = '+' + str(x) + '+' + str(y)
  WsetMirror.geometry(sgeo)

  Umaster.wait_window(WsetMirror)

#enddef

def _cnWsetMirror():
  global WsetMirror
  WsetMirror.destroy()
#enddef

def _cnWmirror():
  global Wmirror
  Wmirror.destroy()
#enddef _cnhybrid()

def _EndPoles_Whybrid():
+seq,uguiglobind.
+seq,hybridvarsind.

  WhyEnd = Toplevel()
  WhyEnd.title("Endpoles of Hybrid Undulator")
  WhyEnd.attributes('-topmost', 1)

  widlab = 25
  wident = 30

  framelabentry(WhyEnd,'Height of 1st endmagnet',Hybrid["LyEndMag1_Hybrid"],S_LyEndMag1_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Vert. offset of 1st endmagnet',Hybrid["OffEndMag1_Hybrid"],S_OffEndMag1_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Spacer of 1st endmagnet',Hybrid["SpaceEndMag1_Hybrid"],S_SpaceEndMag1_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Height of 1st endpole',Hybrid["LyEndPol1_Hybrid"],S_LyEndPol1_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Vert. offset of 1st endpole',Hybrid["OffEndPol1_Hybrid"],S_OffEndPol1_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Spacer of 1st endpole',Hybrid["SpaceEndPol1_Hybrid"],S_SpaceEndPol1_Hybrid,MyFont,widlab,wident)

  framelabentry(WhyEnd,'Height of 2nd endmagnet',Hybrid["LyEndMag2_Hybrid"],S_LyEndMag2_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Vert. offset of 2nd endmagnet',Hybrid["OffEndMag2_Hybrid"],S_OffEndMag2_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Spacer of 2nd endmagnet',Hybrid["SpaceEndMag2_Hybrid"],S_SpaceEndMag2_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Height of 2nd endpole',Hybrid["LyEndPol2_Hybrid"],S_LyEndPol2_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Vert. offset of 2nd endpole',Hybrid["OffEndPol2_Hybrid"],S_OffEndPol2_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Spacer of 2nd endpole',Hybrid["SpaceEndPol2_Hybrid"],S_SpaceEndPol2_Hybrid,MyFont,widlab,wident)

  framelabentry(WhyEnd,'Height of 3rd endmagnet',Hybrid["LyEndMag3_Hybrid"],S_LyEndMag3_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Vert. offset of 3rd endmagnet',Hybrid["OffEndMag3_Hybrid"],S_OffEndMag3_Hybrid,MyFont,widlab,wident)
  framelabentry(WhyEnd,'Spacer of 3rd endmagnet',Hybrid["SpaceEndMag3_Hybrid"],S_SpaceEndMag3_Hybrid,MyFont,widlab,wident)

  fbot = Frame(WhyEnd)
  bCancel = Button(fbot,text='Cancel',command=_cnWhyEnd)
  bCancel.pack(side=LEFT,expand=TRUE,fill=X)
  bClose = Button(fbot,text='Ok',command=_clWhyEnd)
  bClose.pack(side=LEFT,expand=TRUE,fill=X)
  fbot.pack(expand=TRUE,fill=X)

  x,y = Umaster.winfo_pointerxy()
  sgeo = '+' + str(x-200) + '+' + str(y-500)
  WhyEnd.geometry(sgeo)

  Umaster.wait_window(WhyEnd)

#enddef _EndPoles_Whybrid()

def _mirror():

+seq,uguiglobind.
+seq,hybridvarsind.

  undugui_clean('mirror')
  ugui_ini_mirror('mirror')

  Wmirror = Toplevel()
  Wmirror.title("Infinite Hybrid Undulator")
  Wmirror.attributes('-topmost', 1)

  widlab = 25
  wident = 30

  framelabentry(Wmirror,'period-length',Mirror["PerLen_Mirror"],S_PerLen_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'full gap',Mirror["FullGap_Mirror"],S_FullGap_Mirror,MyFont,widlab,wident)

  framelabentry(Wmirror,'remanence',Mirror["Br_Mirror"],S_Br_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'mu linear',Mirror["mu_Mirror"],S_mu_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'ksi perpendicular',Mirror["KsiPerp_Mirror"],S_KsiPerp_Mirror,MyFont,widlab,wident)

  framelabentry(Wmirror,'height of magnets',Mirror["LyMag_Mirror"],S_LyMag_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'width of magnets',Mirror["LzMagFull_Mirror"],S_LzMagFull_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'chamfer of magnets',Mirror["ChamfMag_Mirror"],S_ChamfMag_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'Coating',Mirror["Mcoating_Mirror"],S_Mcoating_Mirror,MyFont,widlab,wident)

  framelabentry(Wmirror,'x-segmentation of magnets',Mirror["nDivX_Mag_Mirror"],S_nDivX_Mag_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'y-segmentation of magnets',Mirror["nDivY_Mag_Mirror"],S_nDivY_Mag_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'z-segmentation of magnets',Mirror["nDivZ_MagHalf_Mirror"],S_nDivZ_MagHalf_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'fraction of  y-seg. of magnets',Mirror["FracDivY_Mag_Mirror"],S_FracDivY_Mag_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'fraction of  z-seg. of magnets',Mirror["FracDivZ_Mag_Mirror"],S_FracDivZ_Mag_Mirror,MyFont,widlab,wident)
  #framelabentry(Wmirror,'spacer  magnet to pole',Mirror["Space_Mag_Pol_Mirror"],S_Space_Mag_Pol_Mirror,MyFont,widlab,wident)

  framelabentry(Wmirror,'MH-curve of poles',Mirror["MatPol_Mirror"],S_MatPol_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'length of poles',Mirror["LxPol_Mirror"],S_LxPol_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'width of poles',Mirror["LzPolFull_Mirror"],S_LzPolFull_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'height of poles',Mirror["LyPol_Mirror"],S_LyPol_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'chamfer of poles',Mirror["ChamfPol_Mirror"],S_ChamfPol_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'x-segmentation of poles',Mirror["nDivX_Pol_Mirror"],S_nDivX_Pol_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'y-segmentation of poles',Mirror["nDivY_Pol_Mirror"],S_nDivY_Pol_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'z-segmentation of poles',Mirror["nDivZ_PolHalf_Mirror"],S_nDivZ_PolHalf_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'fraction of  y-seg. of poles',Mirror["FracDivY_Pol_Mirror"],S_FracDivY_Pol_Mirror,MyFont,widlab,wident)
  framelabentry(Wmirror,'fraction of  z-seg. of poles',Mirror["FracDivZ_Pol_Mirror"],S_FracDivZ_Pol_Mirror,MyFont,widlab,wident)

  framelabentry(Wmirror,'spacer between pole and mag.',Mirror["Space_Mag_Pol_Mirror"],S_Space_Mag_Pol_Mirror,MyFont,widlab,wident)

  fbot = Frame(Wmirror)

  bCancel = Button(fbot,text='Cancel',command=_cnWmirror)
  bCancel.pack(side=LEFT,expand=TRUE,fill=X)

  bMirror = Button(fbot,text='Mirror',command=_setMirror)
  bMirror.pack(side=LEFT,expand=TRUE,fill=X)

  bClose = Button(fbot,text='Ok',command=_clWmirror)
  bClose.pack(side=LEFT,expand=TRUE,fill=X)

  fbot.pack(expand=TRUE,fill=X)

  x,y = Umaster.winfo_pointerxy()
  sgeo = '+' + str(x) + '+' + str(y)
  Wmirror.geometry(sgeo)

  Umaster.wait_window(Wmirror)
#enddef _mirror()

def _hybrid():

+seq,uguiglobind.
+seq,hybridvarsind.

  undugui_clean('hybrid')
  ugui_ini_hybrid()

  Whybrid = Toplevel()
  Whybrid.title("Hybrid Undulator")
  Whybrid.attributes('-topmost', 1)

  widlab = 25
  wident = 30

  framelabentry(Whybrid,'number of periods',Hybrid["nPeriods_Hybrid"],S_nPer_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'period-length',Hybrid["PerLen_Hybrid"],S_PerLen_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'full gap',Hybrid["FullGap_Hybrid"],S_FullGap_Hybrid,MyFont,widlab,wident)

  framelabentry(Whybrid,'remanence',Hybrid["Br_Hybrid"],S_Br_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'mu linear',Hybrid["mu_Hybrid"],S_mu_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'ksi perpendicular',Hybrid["KsiPerp_Hybrid"],S_KsiPerp_Hybrid,MyFont,widlab,wident)

  framelabentry(Whybrid,'height of magnets',Hybrid["LyMag_Hybrid"],S_LyMag_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'width of magnets',Hybrid["LzMagFull_Hybrid"],S_LzMagFull_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'chamfer of magnets',Hybrid["ChamfMag_Hybrid"],S_ChamfMag_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'Coating',Hybrid["Mcoating_Hybrid"],S_Mcoating_Hybrid,MyFont,widlab,wident)

  framelabentry(Whybrid,'x-segmentation of magnets',Hybrid["nDivX_Mag_Hybrid"],S_nDivX_Mag_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'y-segmentation of magnets',Hybrid["nDivY_Mag_Hybrid"],S_nDivY_Mag_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'z-segmentation of magnets',Hybrid["nDivZ_MagHalf_Hybrid"],S_nDivZ_MagHalf_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'fraction of  y-seg. of magnets',Hybrid["FracDivY_Mag_Hybrid"],S_FracDivY_Mag_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'fraction of  z-seg. of magnets',Hybrid["FracDivZ_Mag_Hybrid"],S_FracDivZ_Mag_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'spacer from magnet to pole',Hybrid["Space_Mag_Pol_Hybrid"],S_Space_Mag_Pol_Hybrid,MyFont,widlab,wident)

  framelabentry(Whybrid,'MH-curve of poles',Hybrid["MatPol_Hybrid"],S_MatPol_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'length of poles',Hybrid["LxPol_Hybrid"],S_LxPol_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'width of poles',Hybrid["LzPolFull_Hybrid"],S_LzPolFull_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'height of poles',Hybrid["LyPol_Hybrid"],S_LyPol_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'vert. offset of poles',Hybrid["OffPol_Hybrid"],S_OffPol_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'chamfer of poles',Hybrid["ChamfPol_Hybrid"],S_ChamfPol_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'x-segmentation of poles',Hybrid["nDivX_Pol_Hybrid"],S_nDivX_Pol_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'y-segmentation of poles',Hybrid["nDivY_Pol_Hybrid"],S_nDivY_Pol_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'z-segmentation of poles',Hybrid["nDivZ_PolHalf_Hybrid"],S_nDivZ_PolHalf_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'fraction of  y-seg. of poles',Hybrid["FracDivY_Pol_Hybrid"],S_FracDivY_Pol_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'fraction of  z-seg. of poles',Hybrid["FracDivZ_Pol_Hybrid"],S_FracDivZ_Pol_Hybrid,MyFont,widlab,wident)
  framelabentry(Whybrid,'spacer from pole to magnet',Hybrid["Space_Mag_Pol_Hybrid"],S_Space_Mag_Pol_Hybrid,MyFont,widlab,wident)

  fbot = Frame(Whybrid)
  bCancel = Button(fbot,text='Cancel',command=_cnWhybrid)
  bCancel.pack(side=LEFT,expand=TRUE,fill=X)
  bEndPol = Button(fbot,text='End poles',command=_EndPoles_Whybrid)
  bEndPol.pack(side=LEFT,expand=TRUE,fill=X)
  bClose = Button(fbot,text='Ok',command=_clWhybrid)
  bClose.pack(side=LEFT,expand=TRUE,fill=X)
  fbot.pack(expand=TRUE,fill=X)

  x,y = Umaster.winfo_pointerxy()
  sgeo = '+' + str(x) + '+' + str(y)
  Whybrid.geometry(sgeo)

  Umaster.wait_window(Whybrid)

#enddef _hybrid()

def _updateMenu(menu):
+seq,uguiglobind.
  pass
#def _updateMenu(ev,menu)

def _enterMenu(ev,menu):
+seq,uguiglobind.
  ew = ev.widget
  key=ev.keysym
  _updateMenu(menu)
#def _enterMenu(ev,menu)

def _keypressMenu(ev,menu):
+seq,uguiglobind.
  ew = ev.widget
  key=ev.keysym
  _updateMenu(menu)
#def _keypressMenu(ev,menu)

def _leaveMenu(ev,menu):
+seq,uguiglobind.
  ew = ev.widget
  key=ev.keysym
  _updateMenu(menu)
#def _leaveMenu(ev,menu)

def _ccWfclc():
  global WFileCLC
  WFileCLC.destroy()
#enddef _ccWfclc()

def _clWfclc(key):
+seq,uguiglobind.

  FileCLC = S_FileCLC.get()
  Ucomment = S_Ucomment.get()

+self,if=debugread.
  ureadclc('debugread')
+self,if=debugread,if=debugshow.
  print("Nach Test von ureadclc!")
  _showGeo('3d')
+self,if=debugread.
  Quit("Ende nach Test!")
+self.

  if key == 'LoadCLC':

    ureadclc('clWfclc')

    try:

      MustUpdate = 1

      try:
        keyclc = Uclcorig[1].strip().split('!')[1].strip()
      except:
        keyclc = ""
      #endtry

      if keyclc == 'Obsolete AppleII':

        for a in AppleII:
          AppleII[a] = Pars[a]
          del Pars[a]
        #endfor a in AppleII

        Npar = len(Pars)

        fmat = Materials[0][3]
        AppleII["MatIndex"] = Materials[0]

        if os.path.exists(fmat):
          Fmat = open(fmat,"r")
          cline = Fmat.readline()
          words = cline.split()
          Fmat.close()
        else:
         print("Could not find " + fmat)
         return
        #endif os.path.exists(fmat)

        AppleII["Mu"] = eval(words[0])
        AppleII["KsiPerp"] = eval(words[1])

        S_nPer_AppleII.set(AppleII["nPeriods"])
        S_FullGap_AppleII.set(AppleII["FullGap"])

        S_Xlen_AppleII.set(AppleII["LxMag"])
        S_Ylen_AppleII.set(AppleII["LyMag"])
        S_Zlen_AppleII.set(AppleII["LzMag"])

        S_HorSlit_AppleII.set(AppleII["zSlit"])
        S_AirGap_AppleII.set(AppleII["AirGap"])
        S_DeadCoat_AppleII.set(Pars["$Mcoating"])

        S_S2Shift_AppleII.set(AppleII["S2Shift"])
        S_S3Shift_AppleII.set(AppleII["S3Shift"])

        S_Br_AppleII.set(AppleII["Br"])
        S_Mu_AppleII.set(AppleII["Mu"])
        S_KsiPerp_AppleII.set(AppleII["KsiPerp"])

        S_NdivX_AppleII.set(AppleII["nMagDivX"])
        S_NdivXHalf_AppleII.set(AppleII["nHalfMagDivX"])
        S_NdivY_AppleII.set(AppleII["nMagDivY"])
        S_NdivZ_AppleII.set(AppleII["nMagDivZ"])

        AppleIIOld = AppleII

      #endif keyclc == 'AppleII':

      WFileCLC.destroy()
      _showGeo('3d')

    except:

      if len(FileCLC) > 0:
        print("*** Reading of geometry file " + FileCLC + " failed ***")
      else:
        print("*** Reading of geometry file (e.g. undumag.clc) failed ***")
      #endif len(FileCLC) > 0

    #endtry: ureadclc(

  elif key == 'WriteCLC':

+self,if=debuguwriteclc.
    uwriteclc('debug')
    Quit("Debug: Ende nach uwriteclc")
+self.
    try:
      uwriteclc('_clWfclc')
      LastCLC = FileCLC
      MustUpdate = 0
      MustWriteCLC = 0
      WFileCLC.destroy()
    except:
      if len(FileCLC) > 0:
        print("*** Writing of geometry file " + FileCLC + " failed ***")
      else:
        print("*** Writing of geometry file (e.g. undumag.clc) failed ***")
    #endtry: ureadclc

  #endif key == 'LoadCLC':

#enddef _clWfclc()

S_FileCLC = StringVar()
S_FileCLC.set(FileCLC)
S_Ucomment = StringVar()

def _uclc(key):
+seq,uguiglobind.

  WFileCLC = Toplevel()
  WFileCLC.attributes('-topmost', 1)
  WFileCLC.title('Load Geometry')

  if key == 'WriteCLC':
    WFileCLC.title('Save Geometry')
    S_Ucomment.set(Ucomment)
    ffucom = Frame(WFileCLC)
    tfucom = 'User comment'
    lfucom = Label(ffucom,text=tfucom,font=MyFont)
    lfucom.pack(side=LEFT)
    efucom = Entry(ffucom,text=S_Ucomment,justify=CENTER,font=MyFont)
    efucom.pack(side=RIGHT)
    ffucom.pack(fill='x')
  #endif key == 'WriteCLC'

  if int(AppleII_Mode) > 0: FileCLC = "undumag.clc"
  S_FileCLC.set(FileCLC)

  ffclc = Frame(WFileCLC)
  tfclc = 'Filename'
  lfclc = Label(ffclc,text=tfclc,font=MyFont)
  lfclc.pack(side=LEFT)
  efclc = Entry(ffclc,text=S_FileCLC,justify=CENTER,font=MyFont)
  efclc.pack(side=RIGHT)
  ffclc.pack(fill='x')

  fcc = Frame(WFileCLC)
  fcc.pack(fill=X)

  bCancel = Button(fcc,text='Cancel',command=_ccWfclc)
  bCancel.bind('<Return>',lambda event, mode=key: _clWfclc(mode))
  bCancel.pack(expand=TRUE,side=LEFT,fill=X)

  bClose = Button(fcc,text='Ok',command= lambda mode=key:_clWfclc(mode))
  bClose.bind('<Return>',lambda event, mode=key: _clWfclc(mode))
  bClose.pack(expand=TRUE,side=LEFT,fill=X)

  x,y = Umaster.winfo_pointerxy()
  sgeo = '+' + str(x) + '+' + str(y)
  WFileCLC.geometry(sgeo)

  WFileCLC.bind('<Enter>',lambda event, menu = key: _enterMenu(event,menu))
  WFileCLC.bind('<Leave>',lambda event, menu = key: _leaveMenu(event,menu))
  WFileCLC.bind('<KeyPress>',lambda event, menu = key: _keypressMenu(event,menu))

  Umaster.wait_window(WFileCLC)

#enddef _uclc()

def ugui_ini_mirror(mode=''):
+seq,uguiglobind.
+seq,hybridvarsind.

  if mode != 'force' and fexist("mirror.lst"):
    try:
      print(NL,"--- Initializing quasi infinite undulator, reading default values from mirror.lst ---")
      Mirror = {}
      flst = open("mirror.lst","r")
      lines =  flst.readlines()
      flst.close()
      for line in lines:
        mir = line.strip().split()
        Mirror[mir[0]] = mir[1]
      #endfor
      Mirror["IronIndex_Mirror"] = -1
      Mirror["RECIndex_Mirror"] = -1
      Mirror["IronIndex_Hybrid"] = -1
      print("--- Suceeded ---")
    except:
      Mirror = {}
      Mirror["IronIndex_Mirror"] = -1
      Mirror["RECIndex_Mirror"] = -1
      Mirror["IronIndex_Hybrid"] = -1
      print("--- Failed ---")
  #endif

  if len(Mirror)  <= 3 or mode == 'force':

    Mirror = {}

    Mirror["FullGap_Mirror"] = '5.5'
    Mirror["PerLen_Mirror"] = '17.'
    Mirror["LyMag_Mirror"] = '35.'
    Mirror["LzMagFull_Mirror"] = '50.'
    Mirror["LxPol_Mirror"] = '3.'
    Mirror["LyPol_Mirror"] = '30.'
    Mirror["LzPolFull_Mirror"] = '40.'
    Mirror["Mcoating_Mirror"] = '0.014'
    Mirror["ChamfPol_Mirror"] = '0.1'
    Mirror["ChamfMag_Mirror"] = '0.3'
    Mirror["Space_Mag_Pol_Mirror"] = '0.1'
    Mirror["Br_Mirror"] = '1.62'
    Mirror["mu_Mirror"] = '1.03'
    Mirror["KsiPerp_Mirror"] = '0.17'
    Mirror["Space_Pol_Mag_Mirror"] = '0.1'

    Mirror["RECIndex_Mirror"] = -1
    Mirror["IronIndex_Hybrid"] = -1
    Mirror["MatPol_Mirror"] = 'Vanadium_Permendur_Radia.dat'

    Mirror["nDivX_Mag_Mirror"] = '3'
    Mirror["nDivY_Mag_Mirror"] = '3'
    Mirror["nDivZ_MagHalf_Mirror"] = '3'
    Mirror["FracDivY_Mag_Mirror"] = '1.0'
    Mirror["FracDivZ_Mag_Mirror"] = '1.0'

    Mirror["nDivX_Pol_Mirror"] = '5'
    Mirror["nDivY_Pol_Mirror"] = '5'
    Mirror["nDivZ_PolHalf_Mirror"] = '7'
    Mirror["FracDivY_Pol_Mirror"] = '1.0'
    Mirror["FracDivZ_Pol_Mirror"] = '1.0'

    Mirror["LxMirror"] = '1.0'
    Mirror["LyMirror"] = '100.0'
    Mirror["LzMirror"] = '100.0'
    Mirror["Mat_Mirror"] = 'iron_muinf_sat-2.34.dat'
    Mirror["IronIndex_Mirror"] = -1
    Mirror["nMirDivX"] = '1'
    Mirror["nMirDivY"] = '51'
    Mirror["nMirDivZ"] = '51'
    Mirror["FracDivMirY"] = '1.0'
    Mirror["FracDivMirZ"] = '1.0'

  #endif len(Mirror)

  VMirror = {}

  VMirror['$LxPolHalf'] = '$LxPol_Mirror / 2.'
  VMirror['$LyPol'] = '$LyPol_Mirror'
  VMirror['$LzPolHalf'] = '$LzPolFull_Mirror / 2.'

  VMirror['$xPolHalf'] = '- $LxPolHalf / 2.'
  VMirror['$yPol'] = '- ( $LyPol_Mirror + $FullGap_Mirror ) / 2.'
  VMirror['$zPolHalf'] = '- $LzPolHalf / 2.'

  VMirror['$nDivX_PolHalf'] = 'int[ $nDivX_Pol_Mirror / 2. + 0.5 ]'

  VMirror['$LxMag'] = '$PerLen_Mirror / 2. - ( $LxPol_Mirror + 2.0 * $Space_Mag_Pol_Mirror)'
  VMirror['$LxMagHalf'] = '$LxMag / 2.'
  VMirror['$LzMagHalf'] = '$LzMagFull_Mirror / 2.'

  VMirror['$xMagHalf'] = '$xPolHalf - $LxPolHalf / 2. - $Space_Mag_Pol_Mirror - $LxMagHalf / 2.'
  VMirror['$yMag'] = '- ( $LyMag_Mirror + $FullGap_Mirror ) / 2.'
  VMirror['$zMagHalf'] = '- $LzMagHalf / 2.'

  VMirror['$nDivX_MagHalf'] = 'int[ $nDivX_Mag_Mirror / 2. + 0.5 ]'

  VMirror['$ColorMag'] = '$red'
  VMirror['$ColorPol'] = '$blue'
  VMirror['$ColorMir'] = '$cyan'

  VMirror['$LyMirrorHalf'] = '$LyMirror / 2.'
  VMirror['$LzMirrorHalf'] = '$LzMirror / 2.'

  VMirror['$eps'] = '1.23e-6'
  VMirror['$xMirror'] = '$xMagHalf - $LxMagHalf / 2. - $LxMirror / 2.'
  VMirror['$yMirrorHalf'] = '- $LyMirrorHalf / 2. - $eps'
  VMirror['$zMirrorHalf'] = '- $LzMirrorHalf / 2. - $eps'

  S_FullGap_Mirror = StringVar()
  S_LyMag_Mirror = StringVar()
  S_LzMagFull_Mirror = StringVar()
  S_PerLen_Mirror = StringVar()
  S_LxPol_Mirror = StringVar()
  S_LyPol_Mirror = StringVar()
  S_LzPolFull_Mirror = StringVar()
  S_MatPol_Mirror = StringVar()
  S_Mat_Mirror = StringVar()
  S_ChamfPol_Mirror = StringVar()
  S_ChamfMag_Mirror = StringVar()
  S_Space_Mag_Pol_Mirror = StringVar()
  S_Space_Pol_Mag_Mirror = StringVar()
  S_Mcoating_Mirror = StringVar()
  S_Br_Mirror = StringVar()
  S_mu_Mirror = StringVar()
  S_KsiPerp_Mirror = StringVar()

  S_LxMirror = StringVar()
  S_LyMirror = StringVar()
  S_LzMirror = StringVar()

  S_nMirDivX = StringVar()
  S_nMirDivY = StringVar()
  S_nMirDivZ = StringVar()
  S_FracDivMirY = StringVar()
  S_FracDivMirZ = StringVar()

  S_nDivX_Mag_Mirror = StringVar()
  S_nDivY_Mag_Mirror = StringVar()
  S_nDivZ_MagHalf_Mirror = StringVar()
  S_FracDivY_Mag_Mirror = StringVar()
  S_FracDivZ_Mag_Mirror = StringVar()

  S_nDivX_Pol_Mirror = StringVar()
  S_nDivY_Pol_Mirror = StringVar()
  S_nDivZ_PolHalf_Mirror = StringVar()
  S_FracDivY_Pol_Mirror = StringVar()
  S_FracDivZ_Pol_Mirror = StringVar()

  S_FullGap_Mirror.set(Mirror["FullGap_Mirror"])
  S_PerLen_Mirror.set(Mirror["PerLen_Mirror"])
  S_LyMag_Mirror.set(Mirror["LyMag_Mirror"])
  S_LzMagFull_Mirror.set(Mirror["LzMagFull_Mirror"])
  S_LxPol_Mirror.set(Mirror["LxPol_Mirror"])
  S_LyPol_Mirror.set(Mirror["LyPol_Mirror"])
  S_LzPolFull_Mirror.set(Mirror["LzPolFull_Mirror"])
  S_Mcoating_Mirror.set(Mirror["Mcoating_Mirror"])
  S_MatPol_Mirror.set("Vanadium_Permendur_Radia.dat")
  S_Mat_Mirror.set("iron_muinf_sat-2.34.dat")
  S_ChamfPol_Mirror.set(Mirror["ChamfPol_Mirror"])
  S_ChamfMag_Mirror.set(Mirror["ChamfMag_Mirror"])
  S_Space_Mag_Pol_Mirror.set(Mirror["Space_Mag_Pol_Mirror"])
  S_Space_Pol_Mag_Mirror.set(Mirror["Space_Pol_Mag_Mirror"])
  S_Br_Mirror.set(Mirror["Br_Mirror"])
  S_mu_Mirror.set(Mirror["mu_Mirror"])
  S_KsiPerp_Mirror.set(Mirror["KsiPerp_Mirror"])

  S_nDivX_Pol_Mirror.set(Mirror["nDivX_Pol_Mirror"])
  S_nDivY_Pol_Mirror.set(Mirror["nDivY_Pol_Mirror"])
  S_nDivZ_PolHalf_Mirror.set(Mirror["nDivZ_PolHalf_Mirror"])
  S_FracDivY_Pol_Mirror.set(Mirror["FracDivY_Pol_Mirror"])
  S_FracDivZ_Pol_Mirror.set(Mirror["FracDivZ_Pol_Mirror"])

  S_nDivX_Mag_Mirror.set(Mirror["nDivX_Mag_Mirror"])
  S_nDivY_Mag_Mirror.set(Mirror["nDivY_Mag_Mirror"])
  S_nDivZ_MagHalf_Mirror.set(Mirror["nDivZ_MagHalf_Mirror"])
  S_FracDivY_Mag_Mirror.set(Mirror["FracDivY_Mag_Mirror"])
  S_FracDivZ_Mag_Mirror.set(Mirror["FracDivZ_Mag_Mirror"])

  S_LxMirror.set(Mirror["LxMirror"])
  S_LyMirror.set(Mirror["LyMirror"])
  S_LzMirror.set(Mirror["LzMirror"])

  S_nMirDivX.set(Mirror["nMirDivX"])
  S_nMirDivY.set(Mirror["nMirDivY"])
  S_nMirDivZ.set(Mirror["nMirDivZ"])

  S_FracDivMirY.set(Mirror["FracDivMirY"])
  S_FracDivMirZ.set(Mirror["FracDivMirZ"])

  S_Mat_Mirror.set(Mirror["Mat_Mirror"])

  MirrorOld = Mirror

#enddef ugui_ini_mirror()

def ugui_ini_hybrid(mode=''):
+seq,uguiglobind.
+seq,hybridvarsind.

  if mode != 'force' and fexist("hybrid.lst"):
    try:
      Hybrid = {}
      print(NL,"--- Initializing hybrid undulator, reading default values from hybrid.lst ---")
      flst = open("hybrid.lst","r")
      lines =  flst.readlines()
      flst.close()
      for line in lines:
        hyb = line.strip().split()
        Hybrid[hyb[0]] = hyb[1]
      #endfor
      Hybrid["RECIndex_Hybrid"] = -1
      Hybrid["IronIndex_Hybrid"] = -1
      print("--- Succeeded ---",NL)
      #endfor
    except:
      print("--- Failed ---",NL)
      Hybrid = {}
      Hybrid["RECIndex_Hybrid"] = -1
      Hybrid["IronIndex_Hybrid"] = -1
  #endif

  if len(Hybrid) <= 2 or mode == 'force':

    Hybrid["FullGap_Hybrid"] = '5.5'
    Hybrid["nPeriods_Hybrid"] = '3'
    Hybrid["PerLen_Hybrid"] = '17.'
    #Hybrid["LxMag_Hybrid"] = '10.'
    Hybrid["LyMag_Hybrid"] = '35.'
    Hybrid["LzMagFull_Hybrid"] = '50.'
    Hybrid["LxPol_Hybrid"] = '3.0'
    Hybrid["LyPol_Hybrid"] = '30.'
    Hybrid["LzPolFull_Hybrid"] = '40.'
    Hybrid["Mcoating_Hybrid"] = '0.014'
    Hybrid["ChamfPol_Hybrid"] = '0.1'
    Hybrid["OffPol_Hybrid"] = '0.05'
    Hybrid["ChamfMag_Hybrid"] = '0.3'
    Hybrid["Space_Mag_Pol_Hybrid"] = '0.1'
    Hybrid["Space_Pol_Mag_Hybrid"] = '0.1'
    Hybrid["Br_Hybrid"] = '1.62'
    Hybrid["mu_Hybrid"] = '1.03'
    Hybrid["KsiPerp_Hybrid"] = '0.17'

    Hybrid["RECIndex_Hybrid"] = -1
    Hybrid["IronIndex_Hybrid"] = -1
    Hybrid["MatPol_Hybrid"] = 'Vanadium_Permendur_Radia.dat'

    Hybrid["nDivX_Mag_Hybrid"] = '3'
    Hybrid["nDivY_Mag_Hybrid"] = '3'
    Hybrid["nDivZ_MagHalf_Hybrid"] = '3'
    Hybrid["FracDivY_Mag_Hybrid"] = '1.0'
    Hybrid["FracDivZ_Mag_Hybrid"] = '1.0'

    Hybrid["nDivX_Pol_Hybrid"] = '5'
    Hybrid["nDivY_Pol_Hybrid"] = '5'
    Hybrid["nDivZ_PolHalf_Hybrid"] = '7'
    Hybrid["FracDivY_Pol_Hybrid"] = '1.0'
    Hybrid["FracDivZ_Pol_Hybrid"] = '1.0'

    Hybrid["LyEndMag1_Hybrid"] = Hybrid["LyMag_Hybrid"]
    Hybrid["LyEndMag2_Hybrid"] = "32.2"
    Hybrid["LyEndMag3_Hybrid"] = "12.5"

    Hybrid["OffEndMag1_Hybrid"] = '0.0'
    Hybrid["OffEndMag2_Hybrid"] = '1.81'
    Hybrid["OffEndMag3_Hybrid"] = '6.47'

    Hybrid["SpaceEndMag1_Hybrid"] = Hybrid["Space_Mag_Pol_Hybrid"]
    Hybrid["SpaceEndMag2_Hybrid"] = Hybrid["Space_Mag_Pol_Hybrid"]
    Hybrid["SpaceEndMag3_Hybrid"] = Hybrid["Space_Mag_Pol_Hybrid"]

    Hybrid["LyEndPol1_Hybrid"] = Hybrid["LyPol_Hybrid"]
    Hybrid["LyEndPol2_Hybrid"] = Hybrid["LyPol_Hybrid"]

    Hybrid["OffEndPol1_Hybrid"] = Hybrid["OffPol_Hybrid"] = '0.05'
    Hybrid["OffEndPol2_Hybrid"] = Hybrid["OffPol_Hybrid"] = '0.05'
    Hybrid["OffEndPol3_Hybrid"] = Hybrid["OffPol_Hybrid"] = '0.05'

    Hybrid["SpaceEndPol1_Hybrid"] = Hybrid["Space_Pol_Mag_Hybrid"]
    Hybrid["SpaceEndPol2_Hybrid"] = Hybrid["Space_Pol_Mag_Hybrid"]
    Hybrid["SpaceEndPol3_Hybrid"] = Hybrid["Space_Pol_Mag_Hybrid"]

  #endif len(Hybrid)

  VHybrid = {}

  VHybrid['$xCen_Hybrid'] = '- ( $nPeriods_Hybrid - 1 ) * $PerLen_Hybrid'

  VHybrid['$LxMag_Hybrid'] = '$PerLen_Hybrid / 2. - ( $LxPol_Hybrid + $Space_Mag_Pol_Hybrid + $Space_Pol_Mag_Hybrid)'
  #    VHybrid['$LxPol_Hybrid'] = '$PerLen_Hybrid / 2. - ( $LxMag_Hybrid + $Space_Mag_Pol_Hybrid + $Space_Pol_Mag_Hybrid)'
  VHybrid['$LxPolHalf_Hybrid'] = '$LxPol_Hybrid / 2.'
  VHybrid['$LzPolHalf_Hybrid'] = '$LzPolFull_Hybrid / 2.'

  VHybrid['$xHalfPol3_Hybrid'] = '$xCen_Hybrid - $PerLen_Hybrid + $LxPol_Hybrid / 4.'
  VHybrid['$xMag2_Hybrid'] = '$xHalfPol3_Hybrid + $LxPolHalf_Hybrid / 2. + $Space_Pol_Mag_Hybrid + $LxMag_Hybrid / 2.'
  VHybrid['$xPol2_Hybrid'] = '$xCen_Hybrid - $PerLen_Hybrid / 2.'
  VHybrid['$xMag1_Hybrid'] = '$xMag2_Hybrid + $PerLen_Hybrid / 2.'
  VHybrid['$xHalfPol1_Hybrid'] = '$xCen_Hybrid - $LxPol_Hybrid / 4.'

  VHybrid['$yMag_Hybrid'] = '- ( $LyMag_Hybrid + $FullGap_Hybrid ) / 2.'
  VHybrid['$yPol_Hybrid'] = '- ( $LyPol_Hybrid + $FullGap_Hybrid ) / 2. - $OffPol_Hybrid'

  VHybrid['$LzMagHalf_Hybrid'] = '$LzMagFull_Hybrid / 2.'
  VHybrid['$zMag_Hybrid'] = '- $LzMagHalf_Hybrid / 2.'
  VHybrid['$LzPolHalf_Hybrid'] = '$LzPolFull_Hybrid / 2.'
  VHybrid['$zPol_Hybrid'] = '- $LzPolHalf_Hybrid / 2.'

  VHybrid['$xEndPolHalf_Hybrid'] = '$xHalfPol3_Hybrid - $LxPolHalf_Hybrid'
  VHybrid['$nDivX_PolHalf_Hybrid'] = 'int[ $nDivX_Pol_Hybrid / 2. + 0.5 ]'

  VHybrid['$xEndMag1_Hybrid'] = '$xEndPolHalf_Hybrid - $LxPolHalf_Hybrid / 2. - $SpaceEndMag2_Hybrid - $LxMag_Hybrid / 2.'
  VHybrid['$yEndMag1_Hybrid'] = '- ( $LyEndMag1_Hybrid + $FullGap_Hybrid ) / 2. - $OffEndMag1_Hybrid'

  VHybrid['$xEndPol1_Hybrid'] = '$xEndMag1_Hybrid - $LxMag_Hybrid / 2. - $SpaceEndPol1_Hybrid - $LxPol_Hybrid / 2.'
  VHybrid['$yEndPol1_Hybrid'] = '- ( $LyEndPol1_Hybrid + $FullGap_Hybrid ) / 2. - $OffEndPol1_Hybrid'

  VHybrid['$xEndMag2_Hybrid'] = '$xEndPol1_Hybrid - $LxPol_Hybrid / 2. - $SpaceEndMag2_Hybrid - $LxMag_Hybrid / 2.'
  VHybrid['$yEndMag2_Hybrid'] = '- ( $LyEndMag2_Hybrid + $FullGap_Hybrid ) / 2. - $OffEndMag2_Hybrid'

  VHybrid['$xEndPol2_Hybrid'] = '$xEndMag2_Hybrid - $LxMag_Hybrid / 2. - $SpaceEndPol2_Hybrid - $LxPol_Hybrid / 2.'
  VHybrid['$yEndPol2_Hybrid'] = '- ( $LyEndPol2_Hybrid + $FullGap_Hybrid ) / 2. - $OffEndPol2_Hybrid'

  VHybrid['$ColorMag_Hybrid'] = '$red'
  VHybrid['$ColorPol_Hybrid'] = '$blue'

  VHybrid['$xEndMag3_Hybrid'] = '$xEndPol2_Hybrid - $LxPol_Hybrid / 2. - $SpaceEndMag3_Hybrid - $LxMag_Hybrid / 2.'
  VHybrid['$yEndMag3_Hybrid'] = '- ( $LyEndMag3_Hybrid + $FullGap_Hybrid ) / 2. - $OffEndMag3_Hybrid'

  S_nPer_Hybrid = StringVar()
  S_FullGap_Hybrid = StringVar()
  #S_LxMag_Hybrid = StringVar()
  S_LyMag_Hybrid = StringVar()
  S_LzMagFull_Hybrid = StringVar()
  S_PerLen_Hybrid = StringVar()
  S_LxPol_Hybrid = StringVar()
  S_LyPol_Hybrid = StringVar()
  S_LzPolFull_Hybrid = StringVar()
  S_MatPol_Hybrid = StringVar()
  S_ChamfPol_Hybrid = StringVar()
  S_OffPol_Hybrid = StringVar()
  S_ChamfMag_Hybrid = StringVar()
  S_Space_Mag_Pol_Hybrid = StringVar()
  S_Space_Pol_Mag_Hybrid = StringVar()
  S_Mcoating_Hybrid = StringVar()
  S_Br_Hybrid = StringVar()
  S_mu_Hybrid = StringVar()
  S_KsiPerp_Hybrid = StringVar()

  S_nDivX_Mag_Hybrid = StringVar()
  S_nDivY_Mag_Hybrid = StringVar()
  S_nDivZ_MagHalf_Hybrid = StringVar()
  S_FracDivY_Mag_Hybrid = StringVar()
  S_FracDivZ_Mag_Hybrid = StringVar()

  S_nDivX_Pol_Hybrid = StringVar()
  S_nDivY_Pol_Hybrid = StringVar()
  S_nDivZ_PolHalf_Hybrid = StringVar()
  S_FracDivY_Pol_Hybrid = StringVar()
  S_FracDivZ_Pol_Hybrid = StringVar()

  S_LyEndMag1_Hybrid = StringVar()
  S_SpaceEndMag1_Hybrid = StringVar()
  S_OffEndMag1_Hybrid = StringVar()

  S_LyEndMag2_Hybrid = StringVar()
  S_SpaceEndMag2_Hybrid = StringVar()
  S_OffEndMag2_Hybrid = StringVar()

  S_LyEndMag3_Hybrid = StringVar()
  S_SpaceEndMag3_Hybrid = StringVar()
  S_OffEndMag3_Hybrid = StringVar()

  S_LyEndPol1_Hybrid = StringVar()
  S_SpaceEndPol1_Hybrid = StringVar()
  S_OffEndPol1_Hybrid = StringVar()

  S_LyEndPol2_Hybrid = StringVar()
  S_SpaceEndPol2_Hybrid = StringVar()
  S_OffEndPol2_Hybrid = StringVar()

  S_FullGap_Hybrid.set(Hybrid["FullGap_Hybrid"])
  S_nPer_Hybrid.set(Hybrid["nPeriods_Hybrid"])
  S_PerLen_Hybrid.set(Hybrid["PerLen_Hybrid"])
  #S_LxMag_Hybrid.set(Hybrid["LxMag_Hybrid"])
  S_LyMag_Hybrid.set(Hybrid["LyMag_Hybrid"])
  S_LzMagFull_Hybrid.set(Hybrid["LzMagFull_Hybrid"])
  S_LxPol_Hybrid.set(Hybrid["LxPol_Hybrid"])
  S_LyPol_Hybrid.set(Hybrid["LyPol_Hybrid"])
  S_LzPolFull_Hybrid.set(Hybrid["LzPolFull_Hybrid"])
  S_Mcoating_Hybrid.set(Hybrid["Mcoating_Hybrid"])
  S_MatPol_Hybrid.set("Vanadium_Permendur_Radia.dat")
  S_ChamfPol_Hybrid.set(Hybrid["ChamfPol_Hybrid"])
  S_OffPol_Hybrid.set(Hybrid["OffPol_Hybrid"])
  S_ChamfMag_Hybrid.set(Hybrid["ChamfMag_Hybrid"])
  S_Space_Mag_Pol_Hybrid.set(Hybrid["Space_Mag_Pol_Hybrid"])
  S_Space_Pol_Mag_Hybrid.set(Hybrid["Space_Pol_Mag_Hybrid"])
  S_Br_Hybrid.set(Hybrid["Br_Hybrid"])
  S_mu_Hybrid.set(Hybrid["mu_Hybrid"])
  S_KsiPerp_Hybrid.set(Hybrid["KsiPerp_Hybrid"])

  S_nDivX_Pol_Hybrid.set(Hybrid["nDivX_Pol_Hybrid"])
  S_nDivY_Pol_Hybrid.set(Hybrid["nDivY_Pol_Hybrid"])
  S_nDivZ_PolHalf_Hybrid.set(Hybrid["nDivZ_PolHalf_Hybrid"])
  S_FracDivY_Pol_Hybrid.set(Hybrid["FracDivY_Pol_Hybrid"])
  S_FracDivZ_Pol_Hybrid.set(Hybrid["FracDivZ_Pol_Hybrid"])

  S_nDivX_Mag_Hybrid.set(Hybrid["nDivX_Mag_Hybrid"])
  S_nDivY_Mag_Hybrid.set(Hybrid["nDivY_Mag_Hybrid"])
  S_nDivZ_MagHalf_Hybrid.set(Hybrid["nDivZ_MagHalf_Hybrid"])
  S_FracDivY_Mag_Hybrid.set(Hybrid["FracDivY_Mag_Hybrid"])
  S_FracDivZ_Mag_Hybrid.set(Hybrid["FracDivZ_Mag_Hybrid"])

  S_LyEndMag1_Hybrid.set(Hybrid["LyMag_Hybrid"])
  S_SpaceEndMag1_Hybrid.set(Hybrid["SpaceEndMag1_Hybrid"])
  S_OffEndMag1_Hybrid.set(Hybrid["OffEndMag1_Hybrid"])

  S_LyEndMag2_Hybrid.set(Hybrid["LyMag_Hybrid"])
  S_SpaceEndMag2_Hybrid.set(Hybrid["SpaceEndMag2_Hybrid"])
  S_OffEndMag2_Hybrid.set(Hybrid["OffEndMag2_Hybrid"])

  S_LyEndMag3_Hybrid.set(Hybrid["LyMag_Hybrid"])
  S_SpaceEndMag3_Hybrid.set(Hybrid["SpaceEndMag3_Hybrid"])
  S_OffEndMag3_Hybrid.set(Hybrid["OffEndMag3_Hybrid"])

  S_LyEndPol1_Hybrid.set(Hybrid["LyPol_Hybrid"])
  S_SpaceEndPol1_Hybrid.set(Hybrid["SpaceEndPol1_Hybrid"])
  S_OffEndPol1_Hybrid.set(Hybrid["OffEndPol1_Hybrid"])

  S_LyEndPol2_Hybrid.set(Hybrid["LyPol_Hybrid"])
  S_SpaceEndPol2_Hybrid.set(Hybrid["SpaceEndPol2_Hybrid"])
  S_OffEndPol2_Hybrid.set(Hybrid["OffEndPol2_Hybrid"])

#enddef ugui_ini_hybrid()

def ugui_ini_appleII(mode=''):
+seq,uguiglobind.

+self,if=debugappii.
  print(NL,"ugui_ini_appleII::mode:",mode)
  print("ugui_ini_appleII::AppleII:",len(AppleII),AppleII,NL)
+self.

  if mode != 'force' and fexist("appleii.lst"):
    AppleII = {}
    try:
      print(NL,"--- Initializing AppleII undulator, reading default values from appleii.lst ---")
      flst = open("appleii.lst","r")
      lines =  flst.readlines()
      flst.close()
      for line in lines:
        app = line.strip().split()
        AppleII[app[0]] = app[1]
      #endfor
      print("--- Succeeded ---",NL)
    except:
      print("--- Failed ---",NL)
  #endif

  if len(AppleII) < 3 or mode == 'force':

    AppleII["nPeriods"] = 3
    AppleII["LxMag"] = 14.0
    AppleII["LyMag"] = 40.0
    AppleII["LzMag"] = 40.0
    AppleII["AirGap"] = 0.1
    AppleII["Mcoating"] = 0.014
    Pars["$Mcoating"] = 0.014
    AppleII["FullGap"] = 5.0

    AppleII["Br"] = -1.38
    AppleII["Mu"] = 1.06
    AppleII["KsiPerp"] = 0.17
    AppleII["MatIndex"] = -1

    AppleII["S2Shift"] = 0.0
    AppleII["S3Shift"] = 10.0
    AppleII["xMagCen"] = 0.0
    AppleII["zSlit"] = 0.5
    AppleII["xMagCen"] = 0.0
    AppleII["nMagDivX"] = 4
    AppleII["nHalfMagDivX"] = 2
    AppleII["nMagDivY"] = 4
    AppleII["nMagDivZ"] = 3

    VAppleII = {}

    VAppleII['$E1Br'] = '$Br / 4.'
    VAppleII['$E2Br'] = '- $Br * 3. / 4.'
    VAppleII['$PerLen'] = '4. * $LxMag'
    VAppleII['$HalfGap'] = '$FullGap / 2.'
    VAppleII['$HalfPerLen'] = '$PerLen / 2.'
    VAppleII['$LxHalfMag'] = '$LxMag / 2.'
    VAppleII['$yMagCen'] = '- $HalfGap - $LyMag / 2.'
    VAppleII['$zMagCen'] = '- $LzMag / 2. - $zSlit / 2.'
    VAppleII['$hS3Shift'] = '$S3Shift / 2.'
    VAppleII['$hS2Shift'] = '$S2Shift / 2.'
    VAppleII['$x1LRMagCen'] = '$xMagCen + $LxHalfMag / 2. - $hS3Shift - $hS2Shift'
    VAppleII['$x2LRMagCen'] = '$x1LRMagCen + $LxHalfMag / 2. + $LxMag / 2.'
    VAppleII['$x3LRMagCen'] = '$x1LRMagCen + $LxMag + $LxHalfMag'
    VAppleII['$x4LRMagCen'] = '$x3LRMagCen + $LxHalfMag'
    VAppleII['$x5LRMagCen'] = '$x4LRMagCen + $LxHalfMag / 2. + $LxMag / 2.'
    VAppleII['$x6LRMagCen'] = '$x5LRMagCen + $LxMag / 2. + $LxHalfMag / 2.'
    VAppleII['$x1LLMagCen'] = ' $x1LRMagCen + $S3Shift + $S2Shift'
    VAppleII['$x2LLMagCen'] = ' $x2LRMagCen + $S3Shift + $S2Shift'
    VAppleII['$x3LLMagCen'] = ' $x3LRMagCen + $S3Shift + $S2Shift'
    VAppleII['$x4LLMagCen'] = ' $x4LRMagCen + $S3Shift + $S2Shift'
    VAppleII['$x5LLMagCen'] = ' $x5LRMagCen + $S3Shift + $S2Shift'
    VAppleII['$x6LLMagCen'] = ' $x6LRMagCen + $S3Shift + $S2Shift'

    VAppleII['$x1ULMagCen'] = ' $x1LRMagCen'
    VAppleII['$x2ULMagCen'] = ' $x2LRMagCen'
    VAppleII['$x3ULMagCen'] = ' $x3LRMagCen'
    VAppleII['$x4ULMagCen'] = ' $x4LRMagCen'
    VAppleII['$x5ULMagCen'] = ' $x5LRMagCen'
    VAppleII['$x6ULMagCen'] = ' $x6LRMagCen'

    VAppleII['$x1URMagCen'] = '$x1LLMagCen - $S2Shift * 2.'
    VAppleII['$x2URMagCen'] = '$x2LLMagCen - $S2Shift * 2.'
    VAppleII['$x3URMagCen'] = '$x3LLMagCen - $S2Shift * 2.'
    VAppleII['$x4URMagCen'] = '$x4LLMagCen - $S2Shift * 2.'
    VAppleII['$x5URMagCen'] = '$x5LLMagCen - $S2Shift * 2.'
    VAppleII['$x6URMagCen'] = '$x6LLMagCen - $S2Shift * 2.'

    VAppleII['$yUMagCen'] = '- $yMagCen'

    VAppleII['$zLLMagCen'] = '- $zMagCen'
    VAppleII['$zULMagCen'] = '- $zMagCen'

    VAppleII['$yModCen'] = '- 2. * $yMagCen'
    VAppleII['$zModCen'] = '- 2. * $zMagCen'

    VAppleII['$x1E1LLMagCen'] = '$x1LLMagCen - $PerLen'
    VAppleII['$x2E1LLMagCen'] = '$x2LLMagCen - $PerLen'
    VAppleII['$x3E1LLMagCen'] = '$x3LLMagCen - $PerLen'

    VAppleII['$x1E1ULMagCen'] = '$x1ULMagCen - $PerLen'
    VAppleII['$x2E1ULMagCen'] = '$x2ULMagCen - $PerLen'
    VAppleII['$x3E1ULMagCen'] = '$x3ULMagCen - $PerLen'

    VAppleII['$x1E1LRMagCen'] = '$x1LRMagCen - $PerLen'
    VAppleII['$x2E1LRMagCen'] = '$x2LRMagCen - $PerLen'
    VAppleII['$x3E1LRMagCen'] = '$x3LRMagCen - $PerLen'

    VAppleII['$x1E1URMagCen'] = '$x1URMagCen - $PerLen'
    VAppleII['$x2E1URMagCen'] = '$x2URMagCen - $PerLen'
    VAppleII['$x3E1URMagCen'] = '$x3URMagCen - $PerLen'

    VAppleII['$x1E2LLMagCen'] = '$x1LLMagCen - $HalfPerLen'
    VAppleII['$x2E2LLMagCen'] = '$x2LLMagCen - $HalfPerLen'
    VAppleII['$x3E2LLMagCen'] = '$x3LLMagCen - $HalfPerLen'

    VAppleII['$x1E2ULMagCen'] = '$x1ULMagCen - $HalfPerLen'
    VAppleII['$x2E2ULMagCen'] = '$x2ULMagCen - $HalfPerLen'
    VAppleII['$x3E2ULMagCen'] = '$x3ULMagCen - $HalfPerLen'

    VAppleII['$x1E2LRMagCen'] = '$x1LRMagCen - $HalfPerLen'
    VAppleII['$x2E2LRMagCen'] = '$x2LRMagCen - $HalfPerLen'
    VAppleII['$x3E2LRMagCen'] = '$x3LRMagCen - $HalfPerLen'

    VAppleII['$x1E2URMagCen'] = '$x1URMagCen - $HalfPerLen'
    VAppleII['$x2E2URMagCen'] = '$x2URMagCen - $HalfPerLen'
    VAppleII['$x3E2URMagCen'] = '$x3URMagCen - $HalfPerLen'

    VAppleII['$dxED0'] = '( $nPeriods + 1.0 ) * $PerLen'
    VAppleII['$dxED1'] = '( $nPeriods + 2.0 ) * $PerLen'
    VAppleII['$dxED2'] = '( $nPeriods + 1.5 ) * $PerLen'

    VAppleII['$x1D0LLMagCen'] = '$x1E1LLMagCen + $dxED0'
    VAppleII['$x2D0LLMagCen'] = '$x2E1LLMagCen + $dxED0'
    VAppleII['$x3D0LLMagCen'] = '$x3E1LLMagCen + $dxED0'

    VAppleII['$x1D0LRMagCen'] = '$x1E1LRMagCen + $dxED0'
    VAppleII['$x2D0LRMagCen'] = '$x2E1LRMagCen + $dxED0'
    VAppleII['$x3D0LRMagCen'] = '$x3E1LRMagCen + $dxED0'

    VAppleII['$x1D0ULMagCen'] = '$x1E1ULMagCen + $dxED0'
    VAppleII['$x2D0ULMagCen'] = '$x2E1ULMagCen + $dxED0'
    VAppleII['$x3D0ULMagCen'] = '$x3E1ULMagCen + $dxED0'

    VAppleII['$x1D0URMagCen'] = '$x1E1URMagCen + $dxED0'
    VAppleII['$x2D0URMagCen'] = '$x2E1URMagCen + $dxED0'
    VAppleII['$x3D0URMagCen'] = '$x3E1URMagCen + $dxED0'

    VAppleII['$x1D1LLMagCen'] = '$x1E1LLMagCen + $dxED1'
    VAppleII['$x2D1LLMagCen'] = '$x2E1LLMagCen + $dxED1'
    VAppleII['$x3D1LLMagCen'] = '$x3E1LLMagCen + $dxED1'

    VAppleII['$x1D1LRMagCen'] = '$x1E1LRMagCen + $dxED1'
    VAppleII['$x2D1LRMagCen'] = '$x2E1LRMagCen + $dxED1'
    VAppleII['$x3D1LRMagCen'] = '$x3E1LRMagCen + $dxED1'

    VAppleII['$x1D1ULMagCen'] = '$x1E1ULMagCen + $dxED1'
    VAppleII['$x2D1ULMagCen'] = '$x2E1ULMagCen + $dxED1'
    VAppleII['$x3D1ULMagCen'] = '$x3E1ULMagCen + $dxED1'

    VAppleII['$x1D1URMagCen'] = '$x1E1URMagCen + $dxED1'
    VAppleII['$x2D1URMagCen'] = '$x2E1URMagCen + $dxED1'
    VAppleII['$x3D1URMagCen'] = '$x3E1URMagCen + $dxED1'

    VAppleII['$x1D2LLMagCen'] = '$x1E1LLMagCen + $dxED2'
    VAppleII['$x2D2LLMagCen'] = '$x2E1LLMagCen + $dxED2'
    VAppleII['$x3D2LLMagCen'] = '$x3E1LLMagCen + $dxED2'

    VAppleII['$x1D2LRMagCen'] = '$x1E1LRMagCen + $dxED2'
    VAppleII['$x2D2LRMagCen'] = '$x2E1LRMagCen + $dxED2'
    VAppleII['$x3D2LRMagCen'] = '$x3E1LRMagCen + $dxED2'

    VAppleII['$x1D2ULMagCen'] = '$x1E1ULMagCen + $dxED2'
    VAppleII['$x2D2ULMagCen'] = '$x2E1ULMagCen + $dxED2'
    VAppleII['$x3D2ULMagCen'] = '$x3E1ULMagCen + $dxED2'

    VAppleII['$x1D2URMagCen'] = '$x1E1URMagCen + $dxED2'
    VAppleII['$x2D2URMagCen'] = '$x2E1URMagCen + $dxED2'
    VAppleII['$x3D2URMagCen'] = '$x3E1URMagCen + $dxED2'

    VAppleII['$colormag'] = '$red'
    VAppleII['$e1colormag'] = '$magenta'
    VAppleII['$e2colormag'] = '$green'

  #endif len(AppleII)

  S_nPer_AppleII = StringVar()
  S_FullGap_AppleII = StringVar()

  S_Xlen_AppleII = StringVar()
  S_Ylen_AppleII = StringVar()
  S_Zlen_AppleII = StringVar()

  S_HorSlit_AppleII = StringVar()
  S_AirGap_AppleII = StringVar()
  S_DeadCoat_AppleII = StringVar()

  S_S2Shift_AppleII = StringVar()
  S_S3Shift_AppleII = StringVar()

  S_Br_AppleII = StringVar()
  S_Mu_AppleII = StringVar()
  S_KsiPerp_AppleII = StringVar()

  S_NdivX_AppleII = StringVar()
  S_NdivXHalf_AppleII = StringVar()
  S_NdivY_AppleII = StringVar()
  S_NdivZ_AppleII = StringVar()

  S_nPer_AppleII.set(AppleII["nPeriods"])
  S_FullGap_AppleII.set(AppleII["FullGap"])

  S_Xlen_AppleII.set(AppleII["LxMag"])
  S_Ylen_AppleII.set(AppleII["LyMag"])
  S_Zlen_AppleII.set(AppleII["LzMag"])

  S_HorSlit_AppleII.set(AppleII["zSlit"])
  S_AirGap_AppleII.set(AppleII["AirGap"])
  S_DeadCoat_AppleII.set(Pars["$Mcoating"])

  S_S2Shift_AppleII.set(AppleII["S2Shift"])
  S_S3Shift_AppleII.set(AppleII["S3Shift"])

  S_Br_AppleII.set(AppleII["Br"])
  S_Mu_AppleII.set(AppleII["Mu"])
  S_KsiPerp_AppleII.set(AppleII["KsiPerp"])

  S_NdivX_AppleII.set(AppleII["nMagDivX"])
  S_NdivXHalf_AppleII.set(AppleII["nHalfMagDivX"])
  S_NdivY_AppleII.set(AppleII["nMagDivY"])
  S_NdivZ_AppleII.set(AppleII["nMagDivZ"])

  AppleIIOld = AppleII

#enddef ugui_ini_appleII()

def _cnWappleII():
+seq,uguiglobind.
  WappleII.destroy()
#enddef _cnappleII()

def _clWappleII(callkey=''):
+seq,uguiglobind.

+self,if=trace.
  print(NL,"trace:: _clWappleII")
+self.

  FileCLCO = FileCLC
  FileCLC = 'undumag.clc'
  AppleII_Mode = 1

  if int(AppleII["MatIndex"]) < 0:
    Nmat += 1
    AppleII["MatIndex"] = Nmat
    Materials.append([str(Nmat),"1","1","undugui_AppleII_mu.dat", \
    [str(AppleII["Mu"]) + " " + str(AppleII["KsiPerp"]) + "! mu_Par and ksi_Perp"]])
  #endif

  uwritenam('clWappleII')
  uwriteclc('clWappleII')

  MustWriteCLC = 0

  ureadclc('clWappleII')

  AppleOld = AppleII

  #AppleII_Mode = 1

  _showGeoPython(callkey='clWappleII')

  FileCLCO = FileCLC
  WappleII.destroy()

+self,if=trace.
  print(NL,"trace:: Leaving _clWappleII")
+self.

#enddef _clappleII()

def _appleII(callkey=''):
+seq,uguiglobind.

+self,if=trace.
  print(NL,"trace:: _appleII('",callkey,"')")
+self.

  undugui_clean('AppleII')
  ugui_ini_appleII('_appleII')

  WappleII = Toplevel()
  WappleII.title("APPLE-II Undulator")
  WappleII.attributes('-topmost', 1)

  widlab = 30

  fNper = Frame(WappleII)
  tNper = 'number of periods'
  lNper = Label(fNper,text=tNper,font=MyFont, width=widlab)
  lNper.pack(side=LEFT)
  eNper = Entry(fNper,text=S_nPer_AppleII,justify=CENTER,font=MyFont)
  eNper.pack(side=RIGHT)
  fNper.pack(fill='x')

  fFullGap = Frame(WappleII)
  tFullGap = 'full gap [mm]'
  lFullGap = Label(fFullGap,text=tFullGap,font=MyFont, width=widlab)
  lFullGap.pack(side=LEFT)
  eFullGap = Entry(fFullGap,text=S_FullGap_AppleII,justify=CENTER,font=MyFont)
  eFullGap.pack(side=RIGHT)
  fFullGap.pack(fill='x')

  fxlen = Frame(WappleII)
  txlen = 'length of magnets [mm]'
  lxlen = Label(fxlen,text=txlen,font=MyFont, width=widlab)
  lxlen.pack(side=LEFT)
  exlen = Entry(fxlen,text=S_Xlen_AppleII,justify=CENTER,font=MyFont)
  exlen.pack(side=RIGHT)
  fxlen.pack(fill='x')

  fAirGap = Frame(WappleII)
  tAirGap = 'AirGap in x between magnets [mm]'
  lAirGap = Label(fAirGap,text=tAirGap,font=MyFont, width=widlab)
  lAirGap.pack(side=LEFT)
  eAirGap = Entry(fAirGap,text=S_AirGap_AppleII,justify=CENTER,font=MyFont)
  eAirGap.pack(side=RIGHT)
  fAirGap.pack(fill='x')

  fylen = Frame(WappleII)
  tylen = 'height of magnets [mm]'
  lylen = Label(fylen,text=tylen,font=MyFont, width=widlab)
  lylen.pack(side=LEFT)
  eylen = Entry(fylen,text=S_Ylen_AppleII,justify=CENTER,font=MyFont)
  eylen.pack(side=RIGHT)
  fylen.pack(fill='x')

  fzlen = Frame(WappleII)
  tzlen = 'width of magnets [mm]'
  lzlen = Label(fzlen,text=tzlen,font=MyFont, width=widlab)
  lzlen.pack(side=LEFT)
  ezlen = Entry(fzlen,text=S_Zlen_AppleII,justify=CENTER,font=MyFont)
  ezlen.pack(side=RIGHT)
  fzlen.pack(fill='x')

  fS2Shift = Frame(WappleII)
  tS2Shift = 'S2 shift [mm]'
  lS2Shift = Label(fS2Shift,text=tS2Shift,font=MyFont, width=widlab)
  lS2Shift.pack(side=LEFT)
  eS2Shift = Entry(fS2Shift,text=S_S2Shift_AppleII,justify=CENTER,font=MyFont)
  eS2Shift.pack(side=RIGHT)
  fS2Shift.pack(fill='x')

  fS3Shift = Frame(WappleII)
  tS3Shift = 'S3 shift [mm]'
  lS3Shift = Label(fS3Shift,text=tS3Shift,font=MyFont, width=widlab)
  lS3Shift.pack(side=LEFT)
  eS3Shift = Entry(fS3Shift,text=S_S3Shift_AppleII,justify=CENTER,font=MyFont)
  eS3Shift.pack(side=RIGHT)
  fS3Shift.pack(fill='x')

  fHorSlit = Frame(WappleII)
  tHorSlit = 'Slit between rows [mm]'
  lHorSlit = Label(fHorSlit,text=tHorSlit,font=MyFont, width=widlab)
  lHorSlit.pack(side=LEFT)
  eHorSlit = Entry(fHorSlit,text=S_HorSlit_AppleII,justify=CENTER,font=MyFont)
  eHorSlit.pack(side=RIGHT)
  fHorSlit.pack(fill='x')

  fNdivX = Frame(WappleII)
  tNdivX = 'number of segments in x'
  lNdivX = Label(fNdivX,text=tNdivX,font=MyFont, width=widlab)
  lNdivX.pack(side=LEFT)
  eNdivX = Entry(fNdivX,text=S_NdivX_AppleII,justify=CENTER,font=MyFont)
  eNdivX.pack(side=RIGHT)
  fNdivX.pack(fill='x')

  fNdivXHalf = Frame(WappleII)
  tNdivXHalf = 'number of seg. in x for half mag.'
  lNdivXHalf = Label(fNdivXHalf,text=tNdivXHalf,font=MyFont, width=widlab)
  lNdivXHalf.pack(side=LEFT)
  eNdivXHalf = Entry(fNdivXHalf,text=S_NdivXHalf_AppleII,justify=CENTER,font=MyFont)
  eNdivXHalf.pack(side=RIGHT)
  fNdivXHalf.pack(fill='x')

  fNdivY = Frame(WappleII)
  tNdivY = 'number of segments in y'
  lNdivY = Label(fNdivY,text=tNdivY,font=MyFont, width=widlab)
  lNdivY.pack(side=LEFT)
  eNdivY = Entry(fNdivY,text=S_NdivY_AppleII,justify=CENTER,font=MyFont)
  eNdivY.pack(side=RIGHT)
  fNdivY.pack(fill='x')

  fNdivZ = Frame(WappleII)
  tNdivZ = 'number of segments in z'
  lNdivZ = Label(fNdivZ,text=tNdivZ,font=MyFont, width=widlab)
  lNdivZ.pack(side=LEFT)
  eNdivZ = Entry(fNdivZ,text=S_NdivZ_AppleII,justify=CENTER,font=MyFont)
  eNdivZ.pack(side=RIGHT)
  fNdivZ.pack(fill='x')

  fDeadCoat = Frame(WappleII)
  tDeadCoat = 'coating and dead layer [mm]'
  lDeadCoat = Label(fDeadCoat,text=tDeadCoat,font=MyFont, width=widlab)
  lDeadCoat.pack(side=LEFT)
  eDeadCoat = Entry(fDeadCoat,text=S_DeadCoat_AppleII,justify=CENTER,font=MyFont)
  eDeadCoat.pack(side=RIGHT)
  fDeadCoat.pack(fill='x')

  fBr = Frame(WappleII)
  tBr = 'remanence [T]'
  lBr = Label(fBr,text=tBr,font=MyFont, width=widlab)
  lBr.pack(side=LEFT)
  eBr = Entry(fBr,text=S_Br_AppleII,justify=CENTER,font=MyFont)
  eBr.pack(side=RIGHT)
  fBr.pack(fill='x')

  fMu = Frame(WappleII)
  tMu = 'mu'
  lMu = Label(fMu,text=tMu,font=MyFont, width=widlab)
  lMu.pack(side=LEFT)
  eMu = Entry(fMu,text=S_Mu_AppleII,justify=CENTER,font=MyFont)
  eMu.pack(side=RIGHT)
  fMu.pack(fill='x')

  fKsiPerp = Frame(WappleII)
  tKsiPerp = 'ksi (perpendicular)'
  lKsiPerp = Label(fKsiPerp,text=tKsiPerp,font=MyFont, width=widlab)
  lKsiPerp.pack(side=LEFT)
  eKsiPerp = Entry(fKsiPerp,text=S_KsiPerp_AppleII,justify=CENTER,font=MyFont)
  eKsiPerp.pack(side=RIGHT)
  fKsiPerp.pack(fill='x')

  fbottom = Frame(WappleII)

  bCancel = Button(fbottom,text='Cancel',width=widlab,command = _cnWappleII)
  bCancel.bind('<Return>',lambda event: _cnWappleII())
  bCancel.pack(side=LEFT)

  bClose = Button(fbottom,text='Ok',command = lambda ck='_appleII' :_clWappleII(ck))
  bClose.bind('<Return>',lambda event, ck='_appleII': _clWappleII(ck))
  bClose.pack(side=LEFT,expand=TRUE,fill=X)

  fbottom.pack(expand=TRUE,fill=X)

  x,y = Umaster.winfo_pointerxy()
  sgeo = '+' + str(x) + '+' + str(y)
  WappleII.geometry(sgeo)

  WappleII.bind('<Enter>',lambda event, menu = 'AppleII': _enterMenu(event,menu))
  WappleII.bind('<Leave>',lambda event, menu = 'AppleII': _leaveMenu(event,menu))
  WappleII.bind('<KeyPress>',lambda event, menu = 'AppleII': _keypressMenu(event,menu))

  Umaster.wait_window(WappleII)

+self,if=trace.
  print(NL,"trace:: Leaving _appleII")
+self.
#enddef _appleII()

ugui_ini_appleII('main')
ugui_ini_hybrid()

MpreDefs = Menu(Mgeo,tearoff=1,font=MyFont)

MShowGeo = Menu(Mgeo,tearoff=1,font=MyFont)
MShowGeo.add_command(label='3D view', command= lambda mode='3d', item=-1: _showGeo(mode,item),font=MyFont)
MShowGeo.add_command(label='3D periodic', command= lambda mode='3dperiodic', item=-1: _showGeo(mode,item),font=MyFont)
MShowGeo.add_command(label='3D specials', command= lambda mode='3dnoper', item=-1: _showGeo(mode,item),font=MyFont)
MShowGeo.add_command(label='3D view, selected', command= lambda mode='3dselected', item=-2: _showGeo(mode,item),font=MyFont)
MShowGeo.add_command(label='3D periodic, selected', command= lambda mode='3dpersel', item=-2: _showGeo(mode,item),font=MyFont)
MShowGeo.add_command(label='3D specials, selected', command= lambda mode='3dnopersel', item=-2: _showGeo(mode,item),font=MyFont)
MShowGeo.add_command(label='3D UNDUMAG', command= lambda mode='undu3d', item=-1: _showGeo(mode,item),font=MyFont)
MShowGeo.add_command(label='eps', command= lambda mode='eps', item=-1: _showGeo(mode,item),font=MyFont)

MVariables = Menu(Mgeo,tearoff=1,font=MyFont)
MenuMagPols = Menu(Mgeo,tearoff=1,font=MyFont)
MenuTRC = Menu(Mgeo,tearoff=1,font=MyFont)
MenuCoils = Menu(Mgeo,tearoff=1,font=MyFont)
MenuModules = Menu(Mgeo,tearoff=1,font=MyFont)
MaddMag = Menu(MenuMagPols,tearoff=1,font=MyFont)
MaddCoil = Menu(MenuCoils,tearoff=1,font=MyFont)

MpreDefs.add_command(label='Apple II',command=_appleII,font=MyFont)
MpreDefs.add_command(label='Hybrid',command=_hybrid,font=MyFont)
MpreDefs.add_command(label='Infinited Hybrid',command=_mirror,font=MyFont)

Mgeo.add_command(label='Load file', command= lambda mode='LoadCLC': _uclc(mode),font=MyFont)
Mgeo.add_cascade(label='Predefined settings',  menu=MpreDefs,font=MyFont)
Mgeo.add_cascade(label='Variables', menu=MVariables,font=MyFont)
Mgeo.add_cascade(label='Magnets and poles', menu=MenuMagPols,font=MyFont)
Mgeo.add_cascade(label='Operations', menu=MenuTRC,font=MyFont)
Mgeo.add_cascade(label='Coils', menu=MenuCoils,font=MyFont)
Mgeo.add_cascade(label='Modules', menu=MenuModules,font=MyFont)
Mgeo.add_cascade(label='Show', menu=MShowGeo,font=MyFont)
Mgeo.add_command(label='Save', command= lambda mode='WriteCLC': _uclc(mode),font=MyFont)

MenuMagPols.add_cascade(label='Add', menu=MaddMag,font=MyFont)
MenuMagPols.add_command(label='List items', command= lambda key='all': _listMags(key),font=MyFont)
#MenuMagPols.add_command(label='List selected items', command= lambda key='selected': _listMags(key),font=MyFont)
MenuMagPols.add_command(label='Deleted items', command= lambda key='deleted': _listMags(key),font=MyFont)

+seq,listcoils.

MenuCoils.add_command(label='Add', command= lambda key='': _addCoils(key),font=MyFont)
MenuCoils.add_command(label='List', command= lambda key='first': _listCoils(key),font=MyFont)
#MenuCoils.add_command(label='List selected items', command= lambda key='selected': _listCoils(key),font=MyFont)
#MenuCoils.add_command(label='Deleted items', command= lambda key='deleted': _listCoils(key),font=MyFont)

+seq,listmods.
MenuModules.add_command(label='Add', command= lambda geo='': _addMod(geo),font=MyFont)
MenuModules.add_command(label='List', command= lambda key='list': _listMods(key),font=MyFont)

+seq,listmags.
+seq,mlistvars.

+seq,listtrc.

+KEEP,uguiglobind,T=PYTHON.
*CMZ :  2.04/10 21/08/2023  10.49.05  by  Michael Scheer
*CMZ :  2.03/00 14/08/2022  15.24.23  by  Michael Scheer
*CMZ :  2.02/02 08/03/2022  11.18.16  by  Michael Scheer
*CMZ :  2.02/00 26/03/2021  10.47.49  by  Michael Scheer
*-- Author :    Michael Scheer   12/10/2020
  global TransRotCop,EchoCLC

  global Ucfg,Uclcorig, Uclc, Nmag, Npol, Nmodul, NspecMag, NspecPol, \
  Magnets, Pols, SpecMags, SpecPols,  NMagPol, MagPols,  NspecMagPol, SpecMagPols, \
  NMagPolTot, MagPolsTot, DictMagPolsTot, DictCoils, DictCoilsHeader, DictCalcs, IclcRead, \
  Nmat, Materials, Br, Rmu, Coating, PerLen, ChamfM, ChamfP, MCol, PCol, \
  AirGap, KeeperGap, MspaceX, MoffY, Parameters, Variables, Npar, Ncalc, Nvar, \
  CalcLines, Calcs, Pars, Ucomment, Modules, MagPolsTotOld, MagPolOld, \
  EditMag_CheckMode,CopyMag_CheckMode, EditMagX, EditMagY,CopyMagX, CopyMagY,WWait, WError, \
  CheckVars, CheckCalcs, CheckDictCalcs, CheckVarNum, VarNum, \
  MagPolsUpdate, MagPolsDel, NMagPolDel,SpecXYZ,DictCornFiles,S_Ucomment,\
  S_ChamfUs, S_ChamfDs, S_Coating,DictVcomments,DictPcomments, IUNDUMAGisRunning

  global Rmode, Debug, Ical, MyFontStyle, MyFontSize,MyFont, RunUndu, \
  MustUpdate, MustWriteCLC, UnduColors, DictUnduColors

  global UMain, Mgeo, Mmat, MpreDefs, MShowGeo, MListVars
  global WaddMag, WappleII, Whybrid, WFileCLC, S_FileCLC, S_FileNAM, FileCLC, FileNAM, LinesNam, FileMu, \
  WallListMags, WlistVars, WAddVars, WlistMat, Wmirror, WsetMirror

  global AppleII_Mode, AppleII, AppleIIOld, VAppleII, \
  S_nPer_AppleII, S_FullGap_AppleII, \
  S_Xlen_AppleII, S_Ylen_AppleII, S_Zlen_AppleII, \
  S_DeadCoat_AppleII, S_AirGap_AppleII, S_Br_AppleII, S_Mu_AppleII, S_KsiPerp_AppleII, \
  S_HorSlit_AppleII, S_S2Shift_AppleII, S_S3Shift_AppleII, \
  S_NdivX_AppleII, S_NdivY_AppleII, S_NdivZ_AppleII, S_NdivXHalf_AppleII

  global V_CmagOld, V_CmothOld, V_XcenOld, V_YcenOld, V_ZcenOld, V_cornsOld, V_NcornOld, V_CornFileOld, \
  V_nXdivOld, V_nYdivOld, V_nZdivOld, \
  V_FracDivYOld,   V_FracDivZOld,  V_XlenOld, V_YlenOld, V_ZlenOld, V_KeyOld, V_MatTypeOld, V_MatOld, \
  V_BcOld, V_BxnOld, V_BynOld, V_BznOld, V_IspecOld

  global WEditMagOld, WCopyMagOld, S_CmagOld, S_CmothOld, S_XcenOld, S_YcenOld, S_ZcenOld, S_cornsOld, S_NcornOld, S_CornFileOld, \
  S_nXdivOld, S_nYdivOld, S_nZdivOld, \
  S_FracDivYOld, S_FracDivZOld, S_XlenOld, S_YlenOld, S_ZlenOld, S_KeyOld, S_MateTypeOld, S_MatOld, \
  S_BcOld, S_BxnOld, S_BynOld, S_BznOld, S_IspecOld

  global S_CylrIn,S_CylrOut,S_CylHeight,S_CyldPhi,DictHulls

  global V_Cmag, V_Cmoth, V_Xcen, V_Ycen, V_Zcen, V_corns, V_Ncorn, V_CornFile, \
  V_nXdiv, V_nYdiv, V_nZdiv, \
  V_FracDivY, V_FracDivZ, V_Xlen, V_Ylen, V_Zlen, V_Key, V_MatType, V_Mat, \
  V_Bc, V_Bxn, V_Byn, V_Bzn, V_Ispec

  global WEditMag,WCopyMag, S_Cmag, S_Cmoth, S_Xcen, S_Ycen, S_Zcen, S_corns, S_Ncorn, S_CornFile, \
  S_nXdiv, S_nYdiv, S_nZdiv, \
  S_FracDivY, S_FracDivZ, S_Xlen, S_Ylen, S_Zlen, S_Key, S_MateType, S_Mat, \
  S_Bc, S_Bxn, S_Byn, S_Bzn, S_Ispec, S_Color, WsearchVar, S_SearchVar

  global S_CylrIn,S_CylrOut,S_CylHeight,S_CyldPhi

  global WaddPol, WEditPol,WCopyPol, S_Iron_Cmag, S_Iron_Cmoth, S_Iron_Xcen, S_Iron_Ycen, S_Iron_Zcen, S_Iron_corns, S_Iron_Ncorn, S_Iron_CornFile, \
  S_Iron_nXdiv, S_Iron_nYdiv, S_Iron_nZdiv, \
  S_Iron_FracDivY,S_Iron_FracDivZ,S_Iron_Xlen, S_Iron_Ylen, S_Iron_Zlen, S_Iron_Key, S_Iron_MatType, S_Iron_Mat, \
  S_Iron_Bc, S_Iron_Bxn, S_Iron_Byn, S_Iron_Bzn, S_Iron_Ispec, S_Iron_Color

  global LastCLC, LastNAM
  global Nmoth, MyMoth, Moths, MothsXYZ, Hulls, DictMoths, DictCoils, DictCoilsHeader, DictCalcs, \
  NMothSel, NMagPolSel,MagPolsSel,DictMagPolsSel, MothsSel,DictMothsSel
  global Ngeo

  global WFileNAM, WSetSym, NamelistVars, DictNamelistVars, \
  S_IxSym, S_IySym, S_IzSym, S_KxCenter, S_xSym, S_xCenter, \
  cIxSym, cIySym, cIzSym, KxCenter, cIxSym, Xcenter, Xsym

  global GeoWaddVars, GeoWlistVars
  global Mirror, VMirror, Hybrid, VHybrid, Hybrid_Mode

  global WSetMap, \
  S_xMapMin,S_yMapMin,S_zMapMin,S_xMapMax,S_yMapMax,S_zMapMax, S_MHmap, \
  S_dxMap,S_NxMap,S_NyMap,S_NzMap,S_dxBeff,S_NxBeff, S_xMinBeff,S_xMaxBeff

  global NCoil, Coils, Filaments, S_Current_Coil, S_Name_Coil, \
  S_nWindings_Coil, S_Filling_Coil, \
  S_Xcen_Coil,S_Ycen_Coil,S_Zcen_Coil,S_VnX_Coil,S_VnY_Coil,S_VnZ_Coil, \
  S_AngRot_Coil,S_xLenOut_Coil,S_zLenIn_Coil,S_zLenOut_Coil,S_RadiusIn_Coil, \
  S_Height_Coil,S_nDivHeight_Coil,S_nDivWidth_Coil,S_nDivArc_Coil,S_Color_Coil, \
  WaddCoil,WaddCoils,Selected_Coil, Stored_Coil, Restore_Coil, CurrLoops, \
  WaddCoilRace,WaddCoilCirc

  global S_CylrIn,S_CylrOut,S_CylHeight,S_CyldPhi,Ntcyls,Ncylinder,DictCyls

+KEEP,uguiglobals,T=PYTHON.
*CMZ :  2.04/10 21/08/2023  10.49.05  by  Michael Scheer
*CMZ :  2.04/09 17/08/2023  11.38.41  by  Michael Scheer
*CMZ :  2.03/00 14/08/2022  15.24.55  by  Michael Scheer
*CMZ :  2.02/02 08/03/2022  11.18.16  by  Michael Scheer
*CMZ :  2.02/00 26/03/2021  10.47.49  by  Michael Scheer
*-- Author :    Michael Scheer   12/10/2020
import m_hbook as m

global TransRotCop, EchoCLC

global Ucfg,Uclcorig, Uclc, Nmag, Npol, Nmodul, NspecMag, NspecPol, \
Magnets, Pols, SpecMags, SpecPols, NMagPol, MagPols,  NspecMagPol, SpecMagPols, \
NMagPolTot, MagPolsTot, DictMagPolsTot, DictCoils, DictCoilsHeader, DictCalcs, IclcRead, \
Nmat, Materials, Br, Rmu, Coating, PerLen, ChamfM, ChamfP, MCol, PCol, \
AirGap, KeeperGap, MspaceX, MoffY, Parameters, Variables, Npar, NCalc, Nvar, \
CalcLines,Calcs,Pars, Ucomment, Modules, MagPolsTotOld, MagPolOld, \
EditMag_CheckMode,CopyMag_CheckMode, EditMagX, EditMagY,CopyMagX, CopyMagY, WWait, WError, \
CheckVars, CheckCalcs, CheckDictCalcs, CheckVarNum, VarNum, \
MagPolsUpdate, MagPolsDel, NMagPolDel, SpecXYZ, DictCornFiles,S_Ucomment,\
S_ChamfUs, S_ChamfDs, S_Coating,DictVcomments,DictPcomments, IUNDUMAGisRunning

global NCoil, Coils, Filaments, S_Current_Coil, S_Name_Coil, \
S_nWindings_Coil,S_Filling_Coil, \
S_Xcen_Coil,S_Ycen_Coil,S_Zcen_Coil,S_VnX_Coil,S_VnY_Coil,S_VnZ_Coil, \
S_AngRot_Coil,S_xLenOut_Coil,S_zLenIn_Coil,S_zLenOut_Coil,S_RadiusIn_Coil, \
S_Height_Coil,S_nDivHeight_Coil,S_nDivWidth_Coil,S_nDivArc_Coil,S_Color_Coil, \
WaddCoil,WaddCoils, Selected_Coil, Stored_Coil, Restore_Coil, CurrLoops, \
WaddCoilRace,WaddCoilCirc

global S_CylrIn,S_CylrOut,S_CylHeight,S_CyldPhi,Ntcyls,Ncylinder,DictCyls

global Rmode, Debug, Ical, MyFontStyle, MyFontSize,MyFont, RunUndu, \
MustUpdate, MustWriteCLC, UnduColors, DictUnduColors
global UMain,  Mgeo, Mmat, MpreDefs, MShowGeo, MListVars
global WaddMag, WappleII, Whybrid, WFileCLC, S_FileCLC, S_FileNAM, FileCLC, FileNAM, LinesNam, FileMu, \
WallListMags, WlistVars, WAddVars, WlistMat,Wmirror, WsetMirror

global Mirror, VMirror, Hybrid, VHybrid, Hybrid_Mode

global AppleII_Mode, AppleII, AppleIIOld, VAppleII, \
S_nPer_AppleII, S_FullGap_AppleII, \
S_Xlen_AppleII, S_Ylen_AppleII, S_Zlen_AppleII, \
S_DeadCoat_AppleII, S_AirGap_AppleII, S_Br_AppleII, S_Mu_AppleII, S_KsiPerp_AppleII, \
S_HorSlit_AppleII, S_S2Shift_AppleII, S_S3Shift_AppleII, \
S_NdivX_AppleII, S_NdivY_AppleII, S_NdivZ_AppleII, S_NdivXHalf_AppleII

global WEditMag,WCopyMag, S_Cmag, S_Cmoth, S_Xcen, S_Ycen, S_Zcen, S_corns, S_Ncorn, S_CornFile, \
S_nXdiv, S_nYdiv, S_nZdiv, S_FracDivY, S_FracDivZ, S_Xlen, S_Ylen, S_Zlen, S_Key, S_MateType, S_Mat, \
S_Bc, S_Bxn, S_Byn, S_Bzn, S_Ispec, S_Color

global S_CylrIn,S_CylrOut,S_CylHeight,S_CyldPhi

global WaddPol, WEditPol,WCopyPol, S_Iron_Cmag, S_Iron_Cmoth, S_Iron_Xcen, S_Iron_Ycen, S_Iron_Zcen, S_Iron_corns, S_Iron_Ncorn, S_Iron_CornFile, \
S_Iron_nXdiv, S_Iron_nYdiv, S_Iron_nZdiv,S_Iron_FracDivY, S_Iron_FracDivZ, S_Iron_Xlen, S_Iron_Ylen, S_Iron_Zlen, S_Iron_Key, S_Iron_MatType, S_Iron_Mat, \
S_Iron_Bc, S_Iron_Bxn, S_Iron_Byn, S_Iron_Bzn, S_Iron_Ispec, S_Iron_Color

global LastCLC, LastNAM
global Nmoth, MyMoth, Moths, MothsXYZ, Hulls, DictMoths, DictCoils, DictCoilsHeader, DictCalcs, \
NMothSel, NMagPolSel,MagPolsSel,DictMagPolsSel, MothsSel,DictMothsSel
global Ngeo

global WFileNAM, WSetSym, NamelistVars, DictNamelistVars, \
S_IxSym, S_IySym, S_IzSym, S_KxCenter, S_xSym, S_xCenter, \
cIxSym, cIySym, cIzSym, KxCenter, cIxSym, Xcenter, Xsym

global V_CmagOld, V_CmothOld, V_XcenOld, V_YcenOld, V_ZcenOld, V_cornsOld, V_NcornOld, V_CornFileOld, \
V_nXdivOld, V_nYdivOld, V_nZdivOld, V_FracDivYOld, V_FracDivZOld, V_XlenOld, V_YlenOld, V_ZlenOld, V_KeyOld, V_MatTypeOld, V_MatOld, \
V_BcOld, V_BxnOld, V_BynOld, V_BznOld, V_IspecOld

global WEditMagOld, WCopyMagOld, S_CmagOld, S_CmothOld, S_XcenOld, S_YcenOld, S_ZcenOld, S_cornsOld, S_NcornOld, S_CornFileOld, \
S_nXdivOld, S_nYdivOld, S_nZdivOld, S_FracDivYOld, S_FracDivZOld, S_XlenOld, S_YlenOld, S_ZlenOld, S_KeyOld, S_MateTypeOld, S_MatOld, \
S_BcOld, S_BxnOld, S_BynOld, S_BznOld, S_IspecOld

global S_CylrIn,S_CylrOut,S_CylHeight,S_CyldPhi, DictHulls

global V_Cmag, V_Cmoth, V_Xcen, V_Ycen, V_Zcen, V_corns, V_Ncorn, V_CornFile, \
V_nXdiv, V_nYdiv, V_nZdiv, V_FracDivY, V_FracDivZ, V_Xlen, V_Ylen, V_Zlen, V_Key, V_MatType, V_Mat, \
V_Bc, V_Bxn, V_Byn, V_Bzn, V_Ispec

global WEditMag,WCopyMag, S_Cmag, S_Cmoth, S_Xcen, S_Ycen, S_Zcen, S_corns, S_Ncorn, S_CornFile, \
S_nXdiv, S_nYdiv, S_nZdiv, S_FracDivY, S_FracDivZ, S_Xlen, S_Ylen, S_Zlen, S_Key, S_MateType, S_Mat, \
S_Bc, S_Bxn, S_Byn, S_Bzn, S_Ispec, WsearchVar, S_SearchVar

global WSetMap, \
S_xMapMin,S_yMapMin,S_zMapMin,S_xMapMax,S_yMapMax,S_zMapMax, S_MHmap, \
S_dxMap,S_NxMap,S_NyMap,S_NzMap,S_dxBeff,S_NxBeff,S_xMinBeff,S_xMaxBeff

+DECK,undugui,T=PYTHON.
*CMZ :  2.04/10 21/08/2023  11.28.16  by  Michael Scheer
*CMZ :  2.04/00 07/09/2022  16.32.24  by  Michael Scheer
*CMZ :  2.03/00 22/08/2022  10.25.22  by  Michael Scheer
*CMZ :  2.02/02 08/03/2022  10.21.28  by  Michael Scheer
*CMZ :  2.02/01 14/04/2021  13.09.46  by  Michael Scheer
*CMZ :  2.02/00 30/03/2021  10.26.36  by  Michael Scheer
*CMZ :  2.01/08 30/07/2020  10.49.14  by  Michael Scheer
*CMZ :  1.32/11 14/04/2020  16.26.11  by  Michael Scheer
*CMZ :  1.32/05 25/10/2019  14.13.42  by  Michael Scheer
*-- Author :    Michael Scheer   09/10/2019

# +PATCH,//UNDUMAG/PYTHON
# +DECK,undugui,T=PYTHON.

global WavesMode
WavesMode = 'UNDUMAG'

global idebug
idebug = 0
def debug(arg=''):
  global idebug
  idebug += 1
  print("idebug:",idebug)
  if arg: print("\n",arg,"\n")
#enddef debug(arg)

+seq,uguiimports.
+seq,uguiglobals.
+seq,undumagplotglobal.

global Ntcyls, Ncylinder
Ntcyls = []
Ncylinder = 0
DictCyls = {}
DictHulls = {}
#=============================================================================

+self,if=trace.
debug("trace:: Before $uguiini")
+self.
+seq,uguiini.
+self,if=trace.
debug("trace:: After $uguiini, before ureadclc")
+self.
+seq,ureadclc.
+self,if=trace.
debug("trace:: After ureadclc")
+self.

def start():
  pass
#enddef

def _nTopLevel(title='TopLevel',att='-topmost',attn=1):
  tl = Toplevel()
  tl.title(title)
  tl.attributes(att,attn)
  return tl
#enddef _nTopLevel

def _MbLeave(ev):
+seq,uguiglobind.
  Mgeo.unpost()
  Mmat.unpost()
#enddef _MbLeave(ev)

def _MenuBar(ev):
+seq,uguiglobind.

  item = Umaster.call(ev.widget, "index", "active")
  #print("Index:",type(item), item)

  x,y = Umaster.winfo_pointerxy()
  ww, wh, wx, wy = getgeo()

  rx = (x-wx) / ww
  #print(item,rx)

  rxgeoi = 0.
  rxgeoe = 0.093
  rxmati = 0.09
  rxmate = 0.179

  xgeoi = wx + rxgeoi * ww
  xgeoe = wx + rxgeoe * ww
  ixgeo = int(xgeoi)

  xmati = wx + rxmati * ww
  xmate = wx + rxmate * ww
  ixmat = int(xmati)

  iytb = int(wy + 0.1 * wh)

  if item == 1:
    Mgeo.post(ixgeo,iytb)
    Mmat.unpost()
  elif item == 2:
    Mmat.post(ixmat,iytb)
    Mgeo.unpost()
  elif rx >= rxmate:
    Mgeo.unpost()
    Mmat.unpost()
  #endif index

#enddef _MenuBar(ev)

def _exit():
  #print("Entered _exit")
  Quit("\n\n --- End of undugui.py --- \n")
#enddef _exit()

def _canvas_key(ev):
  if ev.key in ['q', 'Q']:
      Quit()
#enddef canvas_key(ev)

+self,if=trace.
debug("trace:: Before uwriteclc")
+self.
+seq,uwriteclc.
+self,if=trace.
debug("trace:: After uwriteclc")
+self.

def ureadfil(callkey=''):

+seq,uguiglobind.

  #debug("debug: Filaments")

+self,if=trace.
  print(NL,"trace::ureadfil:",callkey)
+self.

  IUNDUMAGisRunning = 1
  os.system(RunUndu + " " + Rmode)
  IUNDUMAGisRunning = 0

  undu_get_runnumber()

  try:
    Fsta = open("undumag.sta","r")
    cline = Fsta.readline().strip()
    cline = Fsta.readline().strip()
    if cline != 'Calculation of coil filaments finished':
      wError("\n*** UNDUMAG run for filaments failed ***")
    #endif trim(cline) != ' Segmentation finished'
  except:
    wError("\n*** UNDUMAG run for filaments failed ***")
  #endtry

  #Filaments = []
  if not fexist("undumag.fil"):
+self,if=trace.
    print(NL,"trace:: Leaving ureadfil: No file undumag.fil")
+self.
    return
  #endif

  Ffil = open("undumag.fil","r")
  fils = Ffil.readlines()
  Ffil.close()
  fs = fils[1].split()
  icoilo = fs[-1]
  icoil = icoilo
  l = len(fils)
  i = 0
  fil = []
  while i < l:
    i += 1
    fs = fils[i].split()
    icoil = fs[-1]
    if icoil != icoilo:
      Filaments.append(fil)
      fil = []
    elif i == l - 1:
      for k in range(len(fs)): fs[k] = float(fs[k])
      fs[0] = int(fs[0])
      for k in range(1,8): fs[k] = float(fs[k])
      for k in range(8,11): fs[k] = int(fs[k])
      fil.append(fs)
      Filaments.append(fil)
      break
    #endif
    for k in range(len(fs)): fs[k] = float(fs[k])
    fs[0] = int(fs[0])
    for k in range(1,8): fs[k] = float(fs[k])
    for k in range(8,11): fs[k] = int(fs[k])
    fil.append(fs)
    icoilo = icoil
  #endwhile

  if len(Filaments) != len(Coils): Quit("*** Error in ureadfil(): Number of coils does not match ***")

  #debug("debug: Ende Filaments")
+self,if=trace.
  print(NL,"trace:: Leaving ureadfil")
+self.
#enddef

+self,if=trace.
debug("trace:: Before ureadclc")
+self.
+seq,undumag.
+self,if=trace.
debug("trace:: After $undumag")
+self.

#=============================================================================

if platform.system() == 'Linux': RunUndu = "bash $UNDUMAG/shell/undumag_run.sh"
elif platform.system() == 'Windows': RunUndu = '..\\bin\\undumag.exe '
else: Quit("*** Error: Unknown platform: ",platform.system())

iLoad = 0
EchoCLC = 0

#debug()
if os.path.exists("undugui.cfg"):
  Fcfg = open("undugui.cfg","r")
  Ucfg = Fcfg.readlines()
  for line in Ucfg:
    line = line.split('!')
    line = line[0].strip()
    words = line.split(':')
    w0 = words[0].strip().upper()
    w1 = 'FALSE'
    if len(words) > 1:
      w1 = words[1].strip().upper()
    if w1 == '1': w1 == 'TRUE'
    if w0 == 'RUNUNDU': RunUndu = words[1]
    if w0 == 'ECHOCLC' and w1 == 'TRUE': EchoCLC = 1
    if w0 == 'LOADLAST' and w1 == 'TRUE': iLoad += 1
    if w0 == 'SHOWLAST' and w1 == 'TRUE': iLoad += 10
  #endfor
  Fcfg.close()
#endtry

+self,if=debugureadclc.
ugui_ini()
ureadclc('debugureadclc')
Quit("Stop after test call to ureadclc")
+self.

NL = "\n"
Rmode = ''

AppleII = {}

+self,if=trace.
debug("trace:: Before mshwelcome")
+self.
mshwelcome(program='UNDUMAG',year='2022')
+self,if=trace.
debug("trace:: After mshwelcome, before undu_get_runnumber")
+self.

undu_get_runnumber()
+self,if=trace.
debug("trace:: Before ugui_ini")
+self.
ugui_ini()
+self,if=trace.
debug("trace:: After ugui_ini, before $ugui")
+self.

+seq,ugui.
+self,if=trace.
debug("trace:: After $ugui, before ntupini")
+self.
start()

ntupini()
+self,if=trace.
debug("trace:: After ntupini(), before startup")
+self.
startup("undugui_start.py")
+self,if=trace.
debug("trace:: After startup")
+self.

WaveFilePrefix = 'undugui_'

#debug("Vor iLoad")
if iLoad:
+self,if=trace.
  debug("trace:: Before ureadclc")
+self.
  ureadclc("Load")
+self,if=trace.
  debug("trace:: After ureadclc")
+self.
  if iLoad > 1:
+self,if=trace.
    debug("trace:: Before _showGeo")
+self.
    _showGeo("3d")
+self,if=trace.
    debug("trace:: After _showGeo")
+self.
  #endif
#endif
#uwriteclc()
#Quit("Ende nach uwriteclc")

#_WaddCoils()
#_WaddCoilRace()
#_listCoils()

#Quit("\n\n --- End of undugui.py --- \n")
+PATCH,MODULES.
*CMZ :  2.04/05 14/03/2023  12.19.23  by  Michael Scheer
+DECK,UNDUMAGf90m,T=F77.
*CMZ :  2.04/10 22/08/2023  08.57.29  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  19.31.25  by  Michael Scheer
*CMZ :  2.04/03 05/03/2023  15.03.22  by  Michael Scheer
*CMZ :  2.03/00 22/08/2022  12.27.43  by  Michael Scheer
*CMZ :  2.02/02 03/03/2022  11.56.47  by  Michael Scheer
*CMZ :  2.02/01 26/04/2021  07.33.54  by  Michael Scheer
*CMZ :  2.02/00 16/02/2021  14.20.30  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.30.15  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  14.58.35  by  Michael Scheer
*CMZ :  2.01/04 16/07/2019  14.49.37  by  Michael Scheer
*CMZ :  2.01/03 15/07/2019  15.06.29  by  Michael Scheer
*CMZ :  2.01/02 26/04/2018  12.28.16  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  13.52.25  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  15.53.14  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  10.11.25  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  13.49.06  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  13.28.25  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  09.19.11  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  08.36.08  by  Michael Scheer
*CMZ :  1.23/05 05/10/2017  16.45.51  by  Michael Scheer
*CMZ :  1.23/04 28/09/2017  13.54.36  by  Michael Scheer
*CMZ :  1.23/03 21/09/2017  14.46.49  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  14.00.28  by  Michael Scheer
*CMZ :  1.22/02 27/07/2017  09.16.11  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  12.02.40  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  10.53.36  by  Michael Scheer
*CMZ :  1.20/00 20/06/2017  17.32.50  by  Michael Scheer
*CMZ :  1.19/00 19/06/2017  18.04.00  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.16.03  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  12.18.33  by  Michael Scheer
*CMZ :  1.17/07 21/05/2017  18.28.26  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.01.23  by  Michael Scheer
*CMZ :  1.17/05 18/05/2017  09.20.21  by  Michael Scheer
*CMZ :  1.17/04 10/05/2017  11.17.06  by  Michael Scheer
*CMZ :  1.17/00 08/05/2017  13.25.33  by  Michael Scheer
*CMZ :  1.16/00 06/05/2017  12.55.04  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  15.51.52  by  Michael Scheer
*CMZ :  1.15/11 23/04/2017  10.38.05  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.19.13  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  09.03.14  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.28.20  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  11.21.37  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.38.33  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  16.23.04  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  09.37.22  by  Michael Scheer
*CMZ :  1.13/01 06/03/2017  10.14.22  by  Michael Scheer
*CMZ :  1.13/00 01/03/2017  09.19.24  by  Michael Scheer
*CMZ :  1.11/05 27/01/2017  09.42.57  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.52.23  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.07  by  Michael Scheer
*CMZ :  1.11/01 05/01/2017  14.35.46  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.38.34  by  Michael Scheer
*CMZ :  1.10/03 01/12/2016  14.58.46  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.20.40  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.05.14  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.44.47  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.38.45  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.27.14  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  11.55.19  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.46  by  Michael Scheer
*CMZ :  1.02/00 22/08/2016  17.13.11  by  Michael Scheer
*CMZ :  0.00/13 28/07/2016  09.47.14  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.35  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  11.39.48  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.56.05  by  Michael Scheer
*CMZ :  0.00/09 05/07/2016  16.04.35  by  Michael Scheer
*CMZ :  0.00/07 22/06/2016  14.09.40  by  Michael Scheer
*CMZ :  0.00/04 10/05/2016  09.06.41  by  Michael Scheer
*CMZ :  0.00/02 27/04/2016  09.26.25  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.57.22  by  Michael Scheer
*CMZ :  1.17/13 07/04/2016  14.37.11  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  12.17.38  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  13.37.17  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.08.54  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  13.18.15  by  Michael Scheer
*CMZ :  1.17/06 31/03/2016  09.17.56  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  09.00.04  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  16.12.04  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  09.38.56  by  Michael Scheer
*CMZ :  1.17/02 11/03/2016  16.56.25  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      module undumagf90m

c +PATCH,//UNDUMAG/SEQ
c +DECK,UNDUMAGf90m,T=F77.

      implicit none

      integer nthreadp,nwitems
      parameter (nthreadp=1000,nwitems=11)

!      double precision, dimension (:,:,:,:), allocatable :: wwmatrix

      double precision, dimension (:,:,:), allocatable :: bcmat
      double precision, dimension (:,:), allocatable :: bc0,bc00,bpm,
     &  bpebc0,wire,race,wind,arc,carc,crace,rectbar,thickwire,brnmat

      double precision, dimension (:), allocatable ::
     &  feh1,feh2,feh3,fem1,fem2,fem3,ufespl1,
     &  fespl1,fewspl1,fewspl2,fewspl3,fewspl4,
     &  bxconvw,byconvw,bzconvw

      double precision, dimension (:,:), allocatable :: dipoles
      double precision, dimension (:,:,:), allocatable :: cornpoles

      real*4, dimension (:,:,:,:), allocatable :: wwmatrix4,convmat
c      real*4, dimension (:,:,:), allocatable :: wwmatrix

      integer, dimension (:), allocatable :: kspecmag,idamp8,ncornpoles
      integer, dimension(:,:), allocatable :: magcyl

      double precision
     &  unduplot_phi,unduplot_theta,traxyz_theta,traxyz_phi,permu,parmu,perksi,parksi,
     &  xmapmin,xmapmax,ymapmin,ymapmax,zmapmin,zmapmax,dxmap,
     &  xminpl,xmaxpl,yminpl,ymaxpl,zminpl,zmaxpl,
     &  xconvmin,xconvmax,dxconv,xconv(100),yconv,zconv,hconv,hconva,uwindow,xsym,
     &  xbeff,xbeffy,xbeffz,perlen,
     &  ebeam,zslit,xcenter,xmaxinf,xcentershift,xelec,yelec,zelec,
     &  vxelec,vyelec,vzelec,
     &  ds,xf,yf,zf,efx,efy,efz,xobsv,yobsv,zobsv,phelow,phehig,dampiron,dampi,
     &  ubfcenx,ubfceny,ubfcenz,ubflenx,ubfleny,ubflenz,
     &  utorqcenx,utorqceny,utorqcenz,
     &  fxdip,fydip,fzdip,
     &  txdip,tydip,tzdip,
     &  uservar(100),corrtiny,cuttiny,hulltiny,randos,randox,randoy,randoz
     &  ,dampfac,hconvbase,hconvexp,chicut,damp8,rcvthron,angmaprotx,
     &  cenmaprotxy,cenmaprotxz,zminprof,zmaxprof,
     &  bxex,byex,bzex,hresidiron,resiron,halt,dedgefb,coating

      real randoxa,randoya,randoza,randox10,randoy10,randoz10,
     &  randomx,randomy,randomz

      integer
     &  maxiter,maxiterrec,maxiteriron,nchiiron,ibulk,nchimax,kesti,
     &  ktetmesh,
     &  kiter,iterrectot,iterirontot,
     &  iunduplot,kcomment,krunnum,kdate,kplsym,nrec,niron,nxmap,intmaglis,noduplis,nymap,nzmap
     &  ,mode,ncornmax,nplanmax,ncornadd,nplanadd,niterrec,niteriron,niter,
     &  kconvrec,kconviron,kconv,lunconv,kdumpconv,nmatfiles,
     &  matmaps(4,1000),kpreset,matrix,
     &  magmatrix,nuthreads,
     &  ixsym,iysym,izsym,nspecmag,nxbeff,kbeffmode,
     &  ixsymo,iysymo,izsymo,
     &  ieneloss,ivelofield,nphener,nstep,kxcenter,kudebug,kcalcvars,isimpson,
     &  nxconv,kdisplace,kechocalc,knomagmap,knopolmap,isplinefm,
     &  iforce,ivrml,iundugeo,idipoles,iforcedip,iplforce,itorque,mbforcex,mbforcey,mbforcez,mfcolor,
     &  kmapmode,kmapnohead,knointmap,konv,iwarnsum,maxpoints,nmagpols,kallodip,
     &  nwarnbound, iwarnin,iwarn2pi,iwarnbound,ndipoles,killbadmag,irecrepl,kwarncom,irandmag,kshuffle,
     &  kforcemag,kurad,kbextern,kresiron,kprint,ndivfboxy,
     &  ncwires,nrace,nwind,ncrace,ncfila,narc,ncarc,nwcarc,nwrace,nwwind,
     &  nwcrace,nwarc,ncoil,newclc,iunduplot_mode,
     &  nrbar,nwrbar,nthwir,nwthwir,nmagcyl,kwave,iforcegrid,modegui,nbrnmat

      character(256) unducomment
      character(512) cundutit
      character(16) chuvers

      character, dimension (:,:), allocatable :: chmags, chmoths,
     &  chmagsm,chmothsm,chmagsi,chmothsi,chmagpols,chmothso

      character(32) chmag,chmoth,chforcemag

      namelist/undumagn/
     &  maxiter,maxiterrec,maxiteriron,nchiiron,ibulk,iunduplot,kcomment,
     &  krunnum,kdate,ktetmesh,kesti,
     &  kplsym,nxmap,intmaglis,noduplis,nymap,nzmap
     &  ,mode,kdumpconv,dxmap,iunduplot_mode,
     &  unduplot_phi,unduplot_theta,traxyz_theta,traxyz_phi,
     &  xmapmin,xmapmax,ymapmin,ymapmax,zmapmin,zmapmax,
     &  xconvmin,xconvmax,dxconv,nxconv,yconv,zconv,hconv,kpreset,uwindow,matrix,nuthreads,
     &  xminpl,xmaxpl,yminpl,ymaxpl,zminpl,zmaxpl,
     &  ixsym,iysym,izsym,xsym,
     &  xbeff,xbeffy,xbeffz,perlen,nxbeff,kbeffmode,kurad,ebeam,zslit,xcenter,
     &  xelec,yelec,zelec,vxelec,vyelec,vzelec,
     &  ds,xf,yf,zf,efx,efy,efz,xobsv,yobsv,zobsv,phelow,phehig,
     &  ieneloss,ivelofield,nphener,nstep,kxcenter,kcalcvars,
     &  dampiron,isimpson,isplinefm,kdisplace,kechocalc,knomagmap,knopolmap,
     &  kmapmode,kmapnohead,knointmap,
     &  iforce,ivrml,iundugeo,idipoles,iforcedip,iplforce,itorque,mbforcex,mbforcey,mbforcez,mfcolor,
     &  ubfcenx,ubfceny,ubfcenz,ubflenx,ubfleny,ubflenz,
     &  utorqcenx,utorqceny,utorqcenz,chforcemag,nwarnbound, iwarnin,iwarn2pi,
     &  killbadmag,corrtiny,cuttiny,hulltiny,randos,randox,randoy,randoz,irecrepl
     &  ,dampfac,hconvbase,hconvexp,chicut,irandmag,kshuffle,
     &  randomx,randomy,randomz,rcvthron,angmaprotx,cenmaprotxy,cenmaprotxz,
     &  bxex,byex,bzex,kbextern,kresiron,resiron,kprint,ndivfboxy,dedgefb,
     &  iforcegrid,kudebug,newclc

      end module undumagf90m
+DECK,magnet_struct,T=F77.
*CMZ :  2.04/10 23/08/2023  08.17.05  by  Michael Scheer
*CMZ :  2.04/05 14/03/2023  19.31.25  by  Michael Scheer
*CMZ :  2.04/03 03/03/2023  16.41.34  by  Michael Scheer
*CMZ :  2.04/02 27/02/2023  16.37.47  by  Michael Scheer
*CMZ :  2.04/01 23/01/2023  09.51.15  by  Michael Scheer
*CMZ :  2.04/00 13/01/2023  10.56.20  by  Michael Scheer
*CMZ :  2.02/02 16/02/2022  15.17.02  by  Michael Scheer
*CMZ :  2.02/01 06/02/2022  11.20.01  by  Michael Scheer
*-- Author :    Michael Scheer   25/04/2021
      module magnets_structure

      double precision ::
     &  xcwmin=1.0d30,xcwmax=-1.0d30,
     &  ycwmin=1.0d30,ycwmax=-1.0d30,
     &  zcwmin=1.0d30,zcwmax=-1.0d30,
     &  xmin_t=1.0d30,xmax_t=-1.0d30,
     &  ymin_t=1.0d30,ymax_t=-1.0d30,
     &  zmin_t=1.0d30,zmax_t=-1.0d30,
     &  xsymmm_t

      integer nclcbuff,nclcspec,nclcmag,nclccoil,nclcvar,nclcmod,nclcmat,
     &  kunduplot_mode

      integer :: nvar_t=0,nmag_t=0,nvox_t=0,niron_t=0,kvox=0,kfirstiron_t=0,
     &  nspecmag_t=0,kfirstiron_spec_t=0,ncoils_t=0,ncwires_t=0,nmagtot_t=0,
     &  ncornmax_t=8,nplanmax_t=16, nmodule_t=0, nmagcopy_t=0,nvoxcopy_t=0,
     &  nclccop_t=0,nmoth_t=0,nmothtot_t=0,nmagsym_t=0,ninhom_t=0,nmaginhom_t=0

      integer, dimension (:), allocatable :: ksort_t,kmaglist_t,maginhom_t

      character(512), dimension (:), allocatable :: clcbuff,clcmag,clccoil,
     &  clcvar,clcmod,clcmat,clctrarot,clccop,clcspec,clcinhom

      type T_variable
        character(128) cname
        double precision val
      end type T_variable

      type(T_variable), dimension(:), allocatable :: t_variables

      type T_Voxel

      double precision, dimension (:), allocatable :: xhull,yhull,zhull
      double precision, dimension (:,:), allocatable :: plan, vnorm

      integer, dimension (:,:), allocatable :: kedge
      integer, dimension (:), allocatable :: kface,khull

      double precision xyz(3),size(3),trans(3),rot(3,3),Br(3),
     &  gcen(3),volume,xmin,xmax,ymin,ymax,zmin,zmax

      integer nhull,ixdiv,iydiv,izdiv,nedge,nface,kfacelast,
     &  IsPole,IsBlock,mxdiv,mydiv,mzdiv

      end type T_Voxel

      type T_Voxel_Copy
        integer kmagnet,kmodule,kcopy,kvoxel,kproto,ispole
        double precision Br(3),gcen(3)
      end type T_Voxel_Copy

      type T_Magnet_Copy
        integer kproto,kmodule,kcopy,IsPole,IsSpecial
        double precision gcen(3),Br(3),BrN,xmin,xmax,ymin,ymax,zmin,zmax,
     &    size(3),volume
        character(32) ctype,cnam,cmoth
      end type T_Magnet_Copy

      type T_Magnet_Sym
        integer kproto,kmodule,kcopy,IsPole,IsSpecial
        double precision gcen(3),Br(3),BrN,xmin,xmax,ymin,ymax,zmin,zmax
        character(32) ctype,cnam,cmoth
      end type T_Magnet_Sym

      type T_Magnet

        double precision, dimension (:,:), allocatable :: plan
        double precision, dimension (:), allocatable :: xhull0,yhull0,zhull0,
     &    xhull,yhull,zhull,ydivs,zdivs

        integer, dimension (:,:,:), allocatable :: kvoxels
        integer, dimension (:,:), allocatable :: kedge
        integer, dimension (:), allocatable :: kface,khull,kcopy

        character(512), dimension (:), allocatable :: cinhom

        double precision xyz(3),size(3),trans(3),rot(3,3),Br(3),yfracdiv,
     &    xmin,ymin,zmin,xmax,ymax,zmax,volume,gcen(3),dxdiv,dydiv,dzdiv,yfrac,
     &    zfracdiv,zfrac,uschamf,dschamf,cylphi,BrN,xyzinh(4),xvolume,yvolume,
     &    zvolume

        integer :: nface,nhull,icol,imat,nxdiv,nydiv,nzdiv,matindex,mattype,
     &    kfacelast,nedge,nvoxels,IsPole,IsSpecial,IsBlock,nhull0,IsPart,
     &    ncopy=0,kmodule=0,IsInhom=0,mxdiv,mydiv,mzdiv,IsRotated

        character(32) ctype,cnam,cmoth
        character(1024) cfile

        type(T_Voxel), dimension(:), allocatable ::  t_voxels, t_xcuts
        type(T_Voxel), dimension(:,:), allocatable :: t_xycuts
        type(T_Voxel), dimension(:,:,:), allocatable :: t_xyzcuts

      end type T_Magnet

      type T_Mother

        double precision, dimension (:), allocatable :: xhull,yhull,zhull

        integer, dimension (:,:), allocatable :: kedge
        integer, dimension (:), allocatable :: kface,khull,magnets

        double precision xyz(3),xmin,ymin,zmin,xmax,ymax,zmax,gcen(3)

        integer :: nmagnets=0,nhull,kfacelast

        character(32) :: cmoth=''

      end type T_Mother

      type T_Filament
        double precision curr,x1,y1,z1,x2,y2,z2
        integer icolor
      end type T_Filament

      type T_Coil
        integer ncwireI,ncwireE,iibuff,iebuff
        character(128) ctype,cnam
        character(1024) cparams
        double precision params(100)
      endtype T_Coil

      type(T_Magnet), dimension(:), allocatable ::  t_magnets, t_magnets_copy
      type(T_Coil), dimension(:), allocatable ::  t_coils

      type T_Module
        integer ncopy
        double precision offset(3),phi,vspace(3), scalmag(3),rotmat(3,3)
      end type T_Module

      character(32), dimension(:), allocatable :: chmutts

      integer, dimension (:), allocatable :: magmodule
      integer, parameter :: ntransrotcop_p=1000, nmat_p=1000

      integer :: ntransrotcop=0, nmat_t=0, t_matrec(3,nmat_p), nowarnugv=0
      double precision transrotcop(8,ntransrotcop_p)
      character(128) ctransrotcop(ntransrotcop_p)

      type(T_Mother), dimension(:), allocatable ::  t_mothers
      type(T_Module), dimension(:), allocatable ::  t_modules
      type(T_Magnet_Copy), dimension(:), allocatable ::  t_magcopy
      type(T_Magnet_Sym), dimension(:), allocatable ::  t_magsym
      type(T_Voxel_Copy), dimension(:), allocatable ::  t_voxcopy

      double precision, dimension (:), allocatable ::
     &  xpuffer1,ypuffer1,zpuffer1,
     &  xpuffer2,ypuffer2,zpuffer2,
     &  xpuffer3,ypuffer3,zpuffer3

      end module magnets_structure
