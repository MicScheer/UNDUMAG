+PATCH,FOR.
*CMZ :  0.00/00 20/04/2016  13.00.13  by  Michael Scheer
+DECK,undumag_end.
*CMZ :          26/10/2024  17.27.20  by  Michael Scheer
*CMZ :  2.05/05 30/06/2024  16.08.56  by  Michael Scheer
*CMZ :  2.05/04 06/02/2024  15.02.28  by  Michael Scheer
*CMZ :  2.05/02 02/11/2023  14.05.20  by  Michael Scheer
*CMZ :  2.05/01 22/10/2023  14.47.55  by  Michael Scheer
*CMZ :  2.04/12 30/08/2023  11.37.07  by  Michael Scheer
*CMZ :  2.04/06 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  16.57.37  by  Michael Scheer
*CMZ :  2.04/01 20/01/2023  13.43.13  by  Michael Scheer
*CMZ :  2.04/00 16/01/2023  14.39.15  by  Michael Scheer
*CMZ :  2.03/00 01/09/2022  10.41.39  by  Michael Scheer
*CMZ :  2.02/02 26/02/2022  12.52.35  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 29/03/2021  09.45.50  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.14.56  by  Michael Scheer
*CMZ :  2.01/05 05/06/2020  17.09.33  by  Michael Scheer
*CMZ :  2.01/04 29/07/2019  12.05.13  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.25.31  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  16.20.58  by  Michael Scheer
*CMZ :  2.00/03 19/04/2018  11.05.57  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  13.46.37  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  16.46.42  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  11.15.27  by  Michael Scheer
*CMZ :  1.25/03 03/04/2018  08.01.24  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.03.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.17.42  by  Michael Scheer
*CMZ :  1.25/00 14/03/2018  12.58.50  by  Michael Scheer
*CMZ :  1.24/01 13/10/2017  11.37.28  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  14.05.37  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.07.37  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  15.55.08  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.18.42  by  Michael Scheer
*CMZ :  1.22/02 04/08/2017  07.56.26  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.55.33  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.09.09  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  15.38.45  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.35.35  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  16.39.29  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.15.48  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.22.03  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  16.12.25  by  Michael Scheer
*CMZ :  1.18/00 02/06/2017  09.38.06  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  15.20.49  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  08.36.20  by  Michael Scheer
*CMZ :  1.17/06 18/05/2017  22.30.31  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  15.55.38  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  17.57.38  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.15.17  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  09.01.37  by  Michael Scheer
*CMZ :  1.15/07 04/04/2017  13.49.11  by  Michael Scheer
*CMZ :  1.15/05 03/04/2017  13.40.53  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.57.38  by  Michael Scheer
*CMZ :  1.15/03 02/04/2017  15.45.35  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.38.56  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  15.25.06  by  Michael Scheer
*CMZ :  1.15/00 27/03/2017  15.13.40  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  14.39.06  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.16.46  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.26.29  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.53.52  by  Michael Scheer
*CMZ :  1.11/04 23/01/2017  17.22.15  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.28  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.48.13  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.22.30  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.52.38  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.18.26  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.45.21  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.30.02  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.49.21  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.57.45  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.31.52  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  14.13.49  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  15.30.08  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  12.45.07  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.03.06  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.37.39  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  11.57.51  by  Michael Scheer
*CMZ :  0.00/11 18/07/2016  09.18.11  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.57.35  by  Michael Scheer
*CMZ :  0.00/09 28/06/2016  15.42.08  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/05 13/06/2016  12.45.02  by  Michael Scheer
*CMZ :  0.00/02 30/04/2016  13.12.13  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.02.34  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  15.51.06  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.38.32  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.40.54  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  15.11.21  by  Michael Scheer
*CMZ :  1.17/03 22/03/2016  07.59.20  by  Michael Scheer
*CMZ :  1.17/02 07/03/2016  16.32.54  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_end

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

+seq,debugutil.
+seq,random.

      double precision, dimension (:,:,:,:), allocatable :: bmap
      double precision, dimension (:,:), allocatable :: hmvoxel,hmagvox
      double precision, dimension (:), allocatable ::
     &  xint,bxa,bya,bza,
     &  byint,bzint,byint2,bzint2,
     &  xinti,byai,bzai,
     &  byinti,bzinti,byint2i,bzint2i,
     &  xintnor,bxanor,byanor,bzanor,
     &  byintnor,bzintnor,byint2nor,bzint2nor,
     &  xintd,bxad,byad,bzad,
     &  byintd,bzintd,byint2d,bzint2d,
     &  ws1,ws2,ws3,ws4,coef

      double precision :: retval,undumag_variable_getval,br

      integer, dimension (:), allocatable :: kfailbyeff,kfailbzeff,kfailon

      double precision x,y,z,bx,by,bz,hx,hy,hz,bcx,bcy,bcz,b,bprog,h,
     &  bc,dx,dy,dz,vmaglab(3),a(3),xopt,yopt,yint,zint,
     &  xminbeff,xmaxbeff,dkeffzd,
     &  bymaxbeff,bzmaxbeff,xbymax,xbzmax,xbeffo,
     &  beffd,beffzd,dkeffd,xmaxbeffnor,xminbeffnor,
     &  yp(3),bp(3),dum,bmaxp,
     &  bmaxbeffd,bmnbeffd,bmxbeffd,bmnbeffzd,bmxbeffzd,
     &  y2z2,py,pz,pryz,zr,yr,cosa,sina,
     &  xx,yy,zz,quadperlen,halfperlen,dxkbmode,bdx,bdy,bdz,x3(3),b3(3),a3(3),
     &  zmin,
     &  byif,bzif,bcrecmax,bcrecmin,bcironmax,bcironmin,bn,
     &  hcon,easy(3),easyn

      double precision :: bxexint=0.0d0, byexint=0.0d0, bzexint=0.0d0

      real g(3),xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &  dxpl,dypl,dzpl,xpl(2),ypl(2),zpl(2),
     &  bzplmin,bzplmax,bziplmin,bziplmax,bziiplmin,bziiplmax,
     &  byplmin,byplmax,byiplmin,byiplmax,byiiplmin,byiiplmax,
     &  s0min,s1min,s2min,s3min,s0,s1,s2,s3,
     &  s0max,s1max,s2max,s3max,xlaboff,ylaboff,brn,
     &  zppl(1000),bypl(1000),bzpl(1000),hbmatmin,hbmatmax,
     &  bcmaxrec,bcminrec,hmaxrec,hminrec,hmaxiron

      integer luninf,luni,lun,kfail,ifail77,ifail,imoth,iron,kmag,ix,iy,iz,
     &  matmap2,matmap3,n,lunmag,lunst,lunmat,lmag,
     &  lunpost,idis,mat,mtyp,imat,
     &  iplan,nplan,i,ibmax,ixon,ixonnor,
     &  itry,ixbeff,ixbeffnor,nfirst,nlast,lunkill,irecover,
     &  lunw,icorn,ncorn,nper,ibrn,kbrn,kx,kproto

      integer :: jcharge=-1,nthstep=1

      integer nstepp,nphp,npawp
      parameter (nstepp=1000000,nphp=10001,npawp=10000)

      double precision
     &  gammai,dgamtot,powden,xexit,yexit,zexit,
     &  traxyz(14,nstepp),
     &  phener(nphp),stokes(4,nphp),vnxex,vnyex,vnzex,texit,
     &  byint1f,bzint1f,byint2f,bzint2f,
     &  byint1fnor,bzint1fnor,byint2fnor,bzint2fnor,
     &  byint1fd,bzint1fd,byint2fd,bzint2fd,
     &  bxint1inf,byint1inf,bzint1inf,byi,bzi,byint1infd,bzint1infd

      complex*16 aradx(nphp),arady(nphp),aradz(nphp)

      integer :: idebug=0

      integer ndim,istatus,ifreq,istep,lunz,nz
      real hpaw(npawp)
      common/pawc/hpaw

+seq,mshplt.
+seq,phyconparam.

      character(64) ctitle,chtime,chrun
      character(32) cmag,cmoth,cmodule,cmagnet,ccopy
      character(24) cbint

      save

      call  util_random_get_seed(irnsize,irnseed)

      hcon=9999.0d0
      if (halt.ne.0.0d0) then
        call undumag_bconv(hcon)
        hcon=(hcon-halt)/halt
      endif

      open(newunit=lunst,file="undumag.sta")
      write(lunst,*)kundurun,konv,iwarnsum, kiter,iterrectot,iterirontot,hresidiron,hcon
      if (konv.eq.1) then
        write(lunst,*)"Convergence reached"
      else if (konv.eq.0) then
        if (maxiter.eq.0) then
          write(lunst,*)"No iterations done due to maxiter=0"
        else
          write(lunst,*)"Maximum number of iterations reached"
        endif
      else
        write(lunst,*)"Terminated with problems"
      endif

      write(lunst,*)"undumag_end"

      flush(lunst)
      close(lunst)

      if (idebug.eq.1) then
        i_debug=1
        !all util_break
      endif

      if (krunnum.ne.0) then
        write(chrun,*)kundurun
        if (usercom.ne.'') then
          ctitle=trim(usercom)//", Run: "//trim(chrun)
        else
          ctitle=", Run: "//trim(chrun)
        endif
      else
        ctitle=trim(usercom)
      endif

      nowarnugv=1
      retval=undumag_variable_getval("nPeriods")
      if (retval.ne.-9999.0d29) then
        nper=nint(retval)
      else
        nper=-1
      endif
      nowarnugv=0

      call util_zeit_kommentar(lun6,"Writing undumag.mh")

      open(newunit=lunmag,file="undumag.mh")
      write(lunmag,'(a)') '* ' // ctitle

      if (maxiter.eq.0.and.kpreset.eq.0) goto 9999

      if (nmag.eq.0.and.kbextern.eq.0.and.ncwires.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_end: Returning, since there are no magnetic items ***"
        write(lun6,*)
        goto 9999
      endif

      if (maxiter.gt.1) then

        call util_zeit_kommentar(lun6,"Writing undumag.pst")

        open(newunit=lunpost,file='undumag.pst')

        bcrecmax=-1.0d30
        bcrecmin=+1.0d30
        bcironmax=-1.0d30
        bcironmin=1.0d30

        if (nrec.eq.0) then
          bcrecmax=+0.0d0
          bcrecmin=-0.0d0
        endif
        if (niron.eq.0) then
          bcironmax=+0.0d0
          bcironmin=-0.0d0
        endif

        do kmag=1,nmag

          bn=sqrt(bpebc(4,kmag)**2+bpebc(5,kmag)**2+bpebc(6,kmag)**2)

          if (kmag.le.nrec) then
            if (bn.gt.bcrecmax) bcrecmax=bn
            if (bn.lt.bcrecmin) bcrecmin=bn
          else
            if (bn.gt.bcironmax) bcironmax=bn
            if (bn.lt.bcironmin) bcironmin=bn
          endif

          nplan=ibpeplan(kmag)
          write(lunpost,*)nplan,bpebc(1:17,kmag)
          do iplan=1,nplan
            write(lunpost,*)bpemag(1:3,1,iplan,kmag),
     &        bpetm(1:3,8,iplan,kmag)
          enddo !iplan

        enddo
        flush(lunpost)
        close(lunpost)

      endif !(maxiter.gt.0) then

      if (idebug.eq.1) then
        i_debug=2
        !all util_break
      endif

      if (maxiter.gt.0.and.maxiteriron.gt.0) call undumag_residuals_iron

      write(lun6,*)
      write(lun6,*)"File undumag.pst written."
      write(lun6,*)

      write(lun6,*)
      write(lun6,*)"Minimum and maximum magnetization of magnets:",
     &  sngl(bcrecmin),sngl(bcrecmax)
      write(lun6,*)"Minimum and maximum magnetization of iron:",
     &  sngl(bcironmin),sngl(bcironmax)
      write(lun6,*)
      write(lun6,*)"RMS of iron magnetization residuals:",
     &  sngl(hresidiron)
      write(lun6,*)

      if (nxbeff.lt.5) nxbeff=5

      allocate (
     &  kfailbyeff(nxbeff),kfailbzeff(nxbeff),kfailon(nxmap),
     &  xintnor(nxmap),
     &  byintnor(nxmap),bzintnor(nxmap),
     &  byint2nor(nxmap),bzint2nor(nxmap),
     &  xint(nxmap),
     &  byint(nxmap),bzint(nxmap),
     &  byint2(nxmap),bzint2(nxmap),
     &  xintd(nxmap),
     &  byintd(nxmap),bzintd(nxmap),
     &  byint2d(nxmap),bzint2d(nxmap),
     &  bxa(nxmap),bya(nxmap),bza(nxmap),
     &  bxanor(nxmap),byanor(nxmap),bzanor(nxmap),
     &  bxad(nxmap),byad(nxmap),bzad(nxmap),
     &  ws1(nxmap),ws2(nxmap),ws3(nxmap),ws4(nxmap),coef(nxmap))

      if (nmag.eq.0.and.ncwires+nrace.eq.0.and.kbextern.eq.0) then
        xmapmin=0.1
        xmapmax=0.1
      endif

      if (nxmap.gt.1) then
        dx=(xmapmax-xmapmin)/(nxmap-1)
        x=xmapmin-dx
      else
        xmapmin=(xmapmax+xmapmin)/2.0d0
        dx=0.0d0
      endif

      if (nymap.gt.1) then
        dy=(ymapmax-ymapmin)/(nymap-1)
        y=ymapmin-dy
      else
        ymapmin=(ymapmax+ymapmin)/2.0d0
        dy=0.0d0
      endif

      if (nzmap.gt.1) then
        dz=(zmapmax-zmapmin)/(nzmap-1)
        z=zmapmin-dz
      else
        zmapmin=(zmapmax+zmapmin)/2.0d0
        dz=0.0d0
      endif

      if (kbextern.ne.0) then
        bxexint=bxex*(xmapmax-xmapmin)
        byexint=byex*(xmapmax-xmapmin)
        bzexint=bzex*(xmapmax-xmapmin)
      endif

      if (idipoles.ne.0) then
        call util_zeit_kommentar(lun6,"Calculating dipole map")
        do ix=1,nxmap
          x=xmapmin+(ix-1)*dx
          xintd(ix)=x
          call undumag_dipoles_field(x/1000.0d0,0.0d0,0.0d0,
     &      bxad(ix),byad(ix),bzad(ix),ifail)
          if (ifail.gt.0) then
            write(lun6,*)"Undumag_dipoles_field returned failure for on-axis field at point ",
     &        ix,x,y,z
          endif
        enddo
      endif !(idipoles.ne.0) then

      if (intmaglis.ne.0) then

        if (idipoles.ne.0) then
          do kmag=1,ndipoles
            if (dipoles(8,kmag).ne.0.0d0) then
              if (dipoles(8,kmag).eq.2.0d0) then
                dipoles(4,kmag)=-dipoles(4,kmag)
              endif
            else
              dipoles(8,kmag)=-1.0d0
            endif
          enddo
        endif !(idipoles.ne.0) then

        do kmag=1,nmag
          if (bpebc(17,kmag).ne.0.0d0) then
            if (bpebc(17,kmag).eq.2.0d0) then
              bpebc(4:6,kmag)=-bpebc(4:6,kmag)
              if(bpebc(8,kmag).eq.1) then !not rectangular nor cylindrical magnet
                vmaglab(1:3)=bpebc(4:6,kmag)
                nplan=iabs(ibpeplan(kmag))
                do iplan=1,nplan
                  bpetm(1,7,iplan,kmag)=
     &              vmaglab(1)*bpetm(1,8,iplan,kmag)+
     &              vmaglab(2)*bpetm(2,8,iplan,kmag)+
     &              vmaglab(3)*bpetm(3,8,iplan,kmag)
                enddo
              endif
            endif
          else
            bpebc(17,kmag)=-1.0d0
          endif
        enddo
      endif

      x=xmapmin-dx
      ixon=0
      ixonnor=0
      irecover=0
      itry=0

      call util_zeit_kommentar(lun6,"Calculating on-axis field")

      do ix=1,nxmap
        i_debug=ix
        idis=0
11      x=xmapmin+(ix-1)*dx
        ! to avoid boundary effects:
        call util_random(3,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif

        if (itry.eq.0.and.randoz.gt.0.0d0) g=0.

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        xint(ix)=x

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif

        if (randoz.ge.0.0d0) then
          z=g(3)*randoza
        else
          z=randoza
        endif

        ifail=0
        kkfail=0

        if (itry.eq.0) ifail=-1

        call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &    bxa(ix),bya(ix),bza(ix),ifail)

        if (itry.eq.0.and.ifail.eq.-1) then
          ifail=0
        endif

        if (ifail.ne.0) kkfail=ifail

        b=sqrt(bxa(ix)**2+bya(ix)**2+bza(ix)**2)

        ifail77=0

        if (ix.gt.2) then
          call util_parabel(xint(ix-2),bxa(ix-2),
     &      a,yp,xopt,yopt,kfail)
          if (kfail.eq.0) then
            bx=a(1)+a(2)*x+a(3)*x*x
          else
            ifail77=77
          endif
          if (ifail.ne.0) kkfail=ifail
          call util_parabel(xint(ix-2),bya(ix-2),
     &      a,yp,xopt,yopt,kfail)
          if (kfail.eq.0) then
            by=a(1)+a(2)*x+a(3)*x*x
          else
            ifail77=77
          endif
          if (ifail.ne.0) kkfail=ifail
          call util_parabel(xint(ix-2),bza(ix-2),
     &      a,yp,xopt,yopt,kfail)
          if (kfail.eq.0) then
            bz=a(1)+a(2)*x+a(3)*x*x
          else
            ifail77=77
          endif
          if (ifail.ne.0) kkfail=ifail
          bprog=sqrt(bx*bx+by*by+bz*bz)
          if (bprog.gt.1.0d-9.and.abs((b-bprog)/(b+bprog)).gt.rcvthron) then
            ifail77=77
          endif
        endif

        if (bprog.gt.1.0d-9.and.ifail77.eq.77.and.idis.eq.0) then
          write(lun6,*)"Discontinuity or numerical problems for on-axis field discovered, check rcvthron, x, dB, randox etc."
          write(lun6,*)"x, B, Bexpected, dB:",x,b,bprog,abs((b-bprog)/(b+bprog))
          idis=1
        endif

        if (ifail.ne.0.and.itry.lt.10) then
          itry=itry+1
          goto 11
        endif
        itry=0

        if (ifail.gt.0) then
          write(lun6,*)"Undumag_field returned failure for on-axis field at point ",
     &      ix,x,y,z
        else
          if (ifail.lt.0) then
            irecover=irecover+1
          endif
          ixon=ixon+1
          kfailon(ixon)=ifail
          if (ifail.eq.0) then
            ixonnor=ixonnor+1
            xintnor(ixonnor)=xint(ix)
            bxanor(ixonnor)=bxa(ix)
            byanor(ixonnor)=bya(ix)
            bzanor(ixonnor)=bza(ix)
          endif
          xint(ixon)=xint(ix)
          bxa(ixon)=bxa(ix)
          bya(ixon)=bya(ix)
          bza(ixon)=bza(ix)
        endif
      enddo !ix

      if (idebug.eq.1) then
        i_debug=-1
        !all util_break
      endif

      if (irecover.ne.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_end:  On-axis field calculations with ",irecover, " recovered errors ***"
        write(lun6,*)
c        do ix=1,ixon
c          if (kfailon(ix).ne.0) then
c            write(lun6,*)ix,xint(ix),bya(ix),bza(ix)
c          endif
c        enddo
c        write(lun6,*)
      endif
      if (ixon.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_end: No field data on-axis calculated ***"
        write(lun6,*)
      endif

      if (ixonnor.gt.1) then

        if (isimpson.eq.0) then
          call util_spline_running_integral(xintnor,byanor,ixonnor,byintnor,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xintnor,bzanor,ixonnor,bzintnor,coef,
     &      ws1,ws2,ws3,ws4)

          call util_spline_running_integral(xintnor,byintnor,ixonnor,
     &      byint2nor,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xintnor,bzintnor,ixonnor,
     &      bzint2nor,coef,
     &      ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixonnor,xintnor,byanor,byintnor)
          call util_simpson_running_integral(ixonnor,xintnor,bzanor,bzintnor)
          call util_simpson_running_integral(ixonnor,xintnor,byintnor,byint2nor)
          call util_simpson_running_integral(ixonnor,xintnor,bzintnor,bzint2nor)
        endif

      endif

      if (ixon.gt.1) then

        if (isimpson.eq.0) then
          call util_spline_running_integral(xint,bya,ixon,byint,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xint,bza,ixon,bzint,coef,
     &      ws1,ws2,ws3,ws4)

          call util_spline_running_integral(xint,byint,ixon,byint2,coef,
     &      ws1,ws2,ws3,ws4)
          call util_spline_running_integral(xint,bzint,ixon,bzint2,coef,
     &      ws1,ws2,ws3,ws4)
        else
          call util_simpson_running_integral(ixon,xint,bya,byint)
          call util_simpson_running_integral(ixon,xint,bza,bzint)
          call util_simpson_running_integral(ixon,xint,byint,byint2)
          call util_simpson_running_integral(ixon,xint,bzint,bzint2)
        endif

      endif !ixon

      if (idipoles.ne.0) then
        if (nxmap.gt.0.and.maxiter.gt.0) then
          if (isimpson.eq.0) then
            call util_spline_running_integral(xintd,byad,nxmap,byintd,coef,
     &        ws1,ws2,ws3,ws4)
            call util_spline_running_integral(xintd,bzad,nxmap,bzintd,coef,
     &        ws1,ws2,ws3,ws4)

            call util_spline_running_integral(xintd,byintd,nxmap,byint2d,coef,
     &        ws1,ws2,ws3,ws4)
            call util_spline_running_integral(xintd,bzintd,nxmap,bzint2d,coef,
     &        ws1,ws2,ws3,ws4)
          else
            call util_simpson_running_integral(nxmap,xintd,byad,byintd)
            call util_simpson_running_integral(nxmap,xintd,bzad,bzintd)
            call util_simpson_running_integral(nxmap,xintd,byintd,byint2d)
            call util_simpson_running_integral(nxmap,xintd,bzintd,bzint2d)
          endif
        endif !nxmap
      endif !(idipoles.ne.0) then

      byplmin=1.0e30
      byplmax=-1.0e30
      byiplmin=1.0e30
      byiplmax=-1.0e30
      byiiplmin=1.0e30
      byiiplmax=-1.0e30
      bzplmin=1.0e30
      bzplmax=-1.0e30
      bziplmin=1.0e30
      bziplmax=-1.0e30
      bziiplmin=1.0e30
      bziiplmax=-1.0e30

c Calculate on-axis field{
      open(newunit=lun,file="undumag_on-axis.dat")

      if (ixon.gt.1) then

        do ix=1,ixon
          if (bza(ix).lt.bzplmin) bzplmin=sngl(bza(ix))
          if (bza(ix).gt.bzplmax) bzplmax=sngl(bza(ix))
          if (bzint(ix).lt.bziplmin) bziplmin=sngl(bzint(ix))
          if (bzint(ix).gt.bziplmax) bziplmax=sngl(bzint(ix))
          if (bzint2(ix).lt.bziiplmin) bziiplmin=sngl(bzint2(ix))
          if (bzint2(ix).gt.bziiplmax) bziiplmax=sngl(bzint2(ix))
          if (bya(ix).lt.byplmin) byplmin=sngl(bya(ix))
          if (bya(ix).gt.byplmax) byplmax=sngl(bya(ix))
          if (byint(ix).lt.byiplmin) byiplmin=sngl(byint(ix))
          if (byint(ix).gt.byiplmax) byiplmax=sngl(byint(ix))
          if (byint2(ix).lt.byiiplmin) byiiplmin=sngl(byint2(ix))
          if (byint2(ix).gt.byiiplmax) byiiplmax=sngl(byint2(ix))
          write(lun,'(7(1pe17.7e3)," ",I10)')xint(ix),
     &      bya(ix),bza(ix),
     &      byint(ix),bzint(ix),
     &      byint2(ix),bzint2(ix),kfailon(ix)
        enddo

      else !ixon
        write(lun,*) "0. 0. 0. 0. 0. 0. 0. 0."
      endif !ixon

      flush(lun)
      close(lun)

      if (idebug.eq.1) then
        i_debug=3
        !all util_break
      endif

c Calculate on-axis field}

      if (idipoles.ne.0) then

        open(newunit=lun,file="undumag_on-axis_dipoles.dat")

        if (nxmap.gt.1) then

          do ix=1,nxmap
            write(lun,'(10(1pe17.7e3))')xintd(ix),
     &        byad(ix),bzad(ix),
     &        byintd(ix),bzintd(ix),
     &        byint2d(ix),bzint2d(ix)
          enddo

        else !ixon
          write(lun,*) "0. 0. 0. 0. 0. 0. 0."
        endif !ixon

        flush(lun)
        close(lun)

      endif !(idipoles.ne.0) then

      if (idebug.eq.1) then
        i_debug=4
        !all util_break
      endif

c Calculate field map{

      call util_zeit_kommentar(lun6,"Calculating field map")

      open(newunit=lun,file="undumag.map")

      if (knointmap.eq.0) then
        open(newunit=luni,file="undumag_integral.map")
        call util_zeit_kommentar(lun6,"Writing undumag.map and undumag_integral.map")
      else
        call util_zeit_kommentar(lun6,"Writing undumag.map")
      endif

      if (kmapnohead.eq.0) then

        call util_time_and_date(chtime)

        if (kmapmode.eq.0) then
          write(lun,'(a)') '* ' // trim(ctitle)
          write(lun,'(a)')"* " // trim(chtime)
          write(lun,'(a)')"* imoth imag mat ityp matmod x/mm y/mm z/mm Bx/T By/T Bz/T B/T Hx/T Hy/T Hz/T H/T Mx/T My/T Mz/T M/T BxDip/T ByDip/T BzDip/T ifail kfail cmag cmoth"
        else
          write(lun,'(a)') '* ' // trim(ctitle)
          write(lun,'(a)')"* " // trim(chtime)
          write(lun,'(a)')"* x/mm y/mm z/mm Bx/T By/T Bz/T ifail kfail"
          write(lun,'(a)')"* scaling = 0.001 0.001 0.001 1.0 1.0 1.0 for WAVE"
        endif

        if (knointmap.eq.0) then
          write(luni,'(a)')"* xi/mm xe/mm y/mm z/mm ByInt1/Tmm BzInt1/Tmm ByInt2/Tmm**2 BzInt2/Tmm**2"
        endif

      endif

      if (nxmap*nymap*nzmap.le.0) then
        x=0.0d0
        y=0.0d0
        z=0.0d0
        bx=0.0d0
        by=0.0d0
        bz=0.0d0
        b=0.0d0
        hx=0.0d0
        hy=0.0d0
        hz=0.0d0
        h=0.0d0
        bcx=0.0d0
        bcy=0.0d0
        bcz=0.0d0
        bc=0.0d0
        if (kmapmode.eq.0) then
          write(lun,*)"0 0 0 0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0 '' '' "
        else
          write(lun,*)"0.0 0.0 0.0 0.0 0.0 0.0"
        endif

      else !(nxmap*nymap*nzmap.le.0) then

        irecover=0
        x=xmapmin-dx
        itry=0
        kkfail=0

        if (knointmap.eq.0) then
          allocate(xinti(nxmap),byai(nxmap),bzai(nxmap),
     &      byinti(nxmap),bzinti(nxmap),
     &      bmap(4,nxmap,nymap,nzmap),
     &      byint2i(nxmap),bzint2i(nxmap)
     &      )
        endif

        kmag=0
        do ix=1,nxmap
          x=x+dx
          y=ymapmin-dy
          do iy=1,nymap
            y=y+dy
            z=zmapmin-dz
            do iz=1,nzmap
c              if(ix.eq.109.and.iy.eq.1.and.iz.eq.82) then
c                i_debug=-7
c                !all util_break
c              endif
              z=z+dz
              if (knomagmap.eq.0.or.knopolmap.eq.0) then
                kinside=-1
              else
                kinside=0
              endif
14            call util_random(3,g)
              g=g-0.5
              if (abs(g(1)).lt.randox10) then
                if (g(1).gt.0.0d0) then
                  g(1)=g(1)+randox10
                else
                  g(1)=g(1)-randox10
                endif
              endif
              if (abs(g(2)).lt.randoy10) then
                if (g(2).gt.0.0d0) then
                  g(2)=g(2)+randoy10
                else
                  g(2)=g(2)-randoy10
                endif
              endif
              if (abs(g(3)).lt.randoz10) then
                if (g(3).gt.0.0d0) then
                  g(3)=g(3)+randoz10
                else
                  g(3)=g(3)-randoz10
                endif
              endif
              if (itry.eq.0.and.randoz.gt.0.0d0) g=0.
              if (randox.ge.0.0d0) then
                xx=x+g(1)*randoxa ! millimeter!
              else
                xx=x+randoxa ! millimeter!
              endif
              if (randoy.ge.0.0d0) then
                yy=y+g(2)*randoya
              else
                yy=y+randoya
              endif
              if (randoz.ge.0.0d0) then
                zz=z+g(3)*randoza
              else
                zz=z+randoza
              endif
              if (angmaprotx.ne.0.0d0) then
                yr=yy-cenmaprotxy
                zr=zz-cenmaprotxz
                cosa=cos(angmaprotx)
                sina=sin(angmaprotx)
                zz=cosa*zr-sina*yr+cenmaprotxz
                yy=sina*zr+cosa*yr+cenmaprotxy
              endif
c              if (ix.eq.70) i_debug=1

              ifail=0
              if (itry.eq.0) ifail=-1

              call undumag_field(xx/1000.0d0,yy/1000.0d0,zz/1000.0d0,
     &          hx,hy,hz,ifail)

c              if (xx.gt.20) print*,ix,x,xx
              if (itry.eq.0.and.ifail.eq.-1) then
                ifail=0
              endif

              if (ifail.ne.0) kkfail=ifail
              if (ifail.eq.-20000) ifail=0 ! inside magnet
              if (ifail.ne.0.and.itry.lt.10) then
                itry=itry+1
                goto 14
              endif
              itry=0
              if (ifail.gt.0) then
                write(lun6,*)"Undumag_field returned failure at point: ",xx,yy,zz
              else if (ifail.lt.0) then
                irecover=irecover+1
              endif
c              write(lun6,*)"field:",ix,iy,iz
              if (idipoles.ne.0) then
                call undumag_dipoles_field(xx/1000.0d0,yy/1000.0d0,zz/1000.0d0,
     &            bdx,bdy,bdz,ifail)
                if (ifail.gt.0) then
                  write(lun6,*)"Undumag_dipoles_field returned failure at point: ",
     &              xx,yy,zz
                endif !(idipoles.ne.0) then
              else if (ifail.lt.0) then
                irecover=irecover+1
              endif

              if (kinside.gt.nmag) then
                write(lun6,*)"*** Error in undumag_end: kInside .gt. nMag ***"
                write(lun6,*)"kInside, nMag:t",kinside,nmag
                write(lun6,*)"x:y:z",xx,yy,zz
                print*,itry,ix,iy,iz
                write(lun6,*)"*** Probably colliding magnets ***"
                stop
              endif

              if (kinside.gt.0.and.kinside.le.nmag) then
                kmag=kinside
                mat=nint(bpebc(9,kmag))
                imoth=nint(bpebc(15,kmag))
                bcx=bpebc(4,kmag)
                bcy=bpebc(5,kmag)
                bcz=bpebc(6,kmag)
                matmap2=matmaps(2,mat)
                matmap3=matmaps(3,mat)
              else !kinside
                imoth=0
                kmag=0
                mat=0
                matmap2=0
                matmap3=0
                bcx=0.0d0
                bcy=0.0d0
                bcz=0.0d0
              endif !kinside

              bx=hx+bcx
              by=hy+bcy
              bz=hz+bcz
              b=sqrt(bx*bx+by*by+bz*bz)
              h=sqrt(hx*hx+hy*hy+hz*hz)
              bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

              if (iforcegrid.ne.0) then
                xx=x
                yy=y
                zz=z
              endif

              cmag='none'
              cmoth='none'

              if (kmapmode.eq.0) then
                if (kmag.gt.0) then
                  if (newclc.eq.0) then
                    write(cmag,'(a)') chmags(:,kmag)
                    write(cmoth,'(a)') chmoths(:,imoth)
                  else
                    cmag=t_magnets(t_voxcopy(kmag)%kmagnet)%cnam
                    cmoth=t_magnets(t_voxcopy(kmag)%kmagnet)%cmoth
                  endif
                endif
                write(lun,*)
     &            imoth,kmag,mat,matmap2,matmap3,
     &            sngl(xx),sngl(yy),sngl(zz),
     &            sngl(bx),sngl(by),sngl(bz),sngl(b),
     &            sngl(hx),sngl(hy),sngl(hz),sngl(h),
     &            sngl(bcx),sngl(bcy),sngl(bcz),sngl(bc),
     &            sngl(bdx),sngl(bdy),sngl(bdz),
     &            ifail,kkfail,trim(cmag),' ',trim(cmoth)
              else
                write(lun,*)
     &            sngl(xx),sngl(yy),sngl(zz),sngl(bx),sngl(by),sngl(bz),ifail,kkfail
              endif
              if (knointmap.eq.0) then
                bmap(1,ix,iy,iz)=x
                bmap(2,ix,iy,iz)=by
                bmap(3,ix,iy,iz)=bz
                bmap(4,ix,iy,iz)=ifail
               endif
            enddo !nzmap
          enddo !nymap
        enddo !nxmap

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif
      endif !(nxmap*nymap*nzmap.le.0) then

      kinside=-1
      if (knomagmap.eq.0) then
        irecover=0
        do kmag=1,nrec

          !x1y1z1
          imoth=nint(bpebc(15,kmag))
          mat=nint(bpebc(9,kmag))
          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          x=bpebc(1,kmag) !mm
          y=bpebc(2,kmag) !mm
          z=bpebc(3,kmag) !mm
          bcx=bpebc(4,kmag)
          bcy=bpebc(5,kmag)
          bcz=bpebc(6,kmag)

          ifail=kinside
          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,hx,hy,hz,ifail)
          if (ifail.gt.0) then
            write(lun6,*)"Undumag_field returned failure at point: ",x,y,z
          else if (ifail.lt.0) then
            irecover=irecover+1
          endif

          bx=hx+bcx
          by=hy+bcy
          bz=hz+bcz
          b=sqrt(bx*bx+by*by+bz*bz)
          h=sqrt(hx*hx+hy*hy+hz*hz)
          bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

          bdx=-9.0d0
          bdy=-9.0d0
          bdz=-9.0d0

          cmag='none'
          cmoth='none'

          if (kmapmode.eq.0) then
            if (kmag.gt.0) then
              if (newclc.eq.0) then
                write(cmag,'(a)') chmags(:,kmag)
                write(cmoth,'(a)') chmoths(:,imoth)
              else
                lmag=t_voxcopy(kmag)%kmagnet
                kproto=t_magcopy(lmag)%kproto
                write(cmagnet,*)t_voxcopy(kmag)%kmagnet
                write(cmodule,*)t_voxcopy(kmag)%kmodule
                write(ccopy,*)t_voxcopy(kmag)%kcopy
                cmag=t_magnets(kproto)%cnam
                cmag=trim(adjustl(cmag)) // '_'
     &            // trim(adjustl(cmodule)) // '_'
     &            // trim(adjustl(cmagnet)) // '_'
     &            // trim(adjustl(ccopy))
                cmoth=t_magcopy(lmag)%cmoth
              endif
            endif
            write(lun,*)
     &        imoth,kmag,mat,matmap2,matmap3,
     &        sngl(x),sngl(y),sngl(z),
     &        sngl(bx),sngl(by),sngl(bz),sngl(b),
     &        sngl(hx),sngl(hy),sngl(hz),sngl(h),
     &        sngl(bcx),sngl(bcy),sngl(bcz),sngl(bc),
     &        sngl(bdx),sngl(bdy),sngl(bdz),
     &        ifail,' 0 ',trim(cmag),' ',trim(cmoth)
          else
            write(lun,*)
     &        sngl(x),sngl(y),sngl(z),sngl(bx),sngl(by),sngl(bz)
          endif
        enddo ! kmag

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations inside magnets with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif

      endif !knomagmap

      if (knomagmap.eq.0) then

        irecover=0
        allocate(hmagvox(2,nrec))

        bcminrec=1.0e30
        bcmaxrec=-1.0e30
        hminrec=1.0e30
        hmaxrec=-1.0e30

        do kmag=1,nrec

          easy=bpebc(11:13,kmag)
          easyn=sqrt(easy(1)**2+easy(2)**2+easy(3)**2)

          imoth=nint(bpebc(15,kmag))

          mat=nint(bpebc(9,kmag))

          if (newclc.ne.0) then

            kbrn=0
            do ibrn=1,nbrnmat
              if (nint(brnmat(1,ibrn)).eq.mat) then
                kbrn=ibrn
                exit
              endif
            enddo

            if (kbrn.eq.0) then
              write(lun6,*)
              write(lun6,*)"*** Warning in undumag_end: Could not find REC material in list of Br ***"
              write(lun6,*)"*** Be careful with plots of magnetisation ***"
            endif

          else
            kbrn=1
          endif !newclc

          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          x=bpebc(1,kmag) !mm
          y=bpebc(2,kmag) !mm
          z=bpebc(3,kmag) !mm

          bcx=bpebc(4,kmag)
          bcy=bpebc(5,kmag)
          bcz=bpebc(6,kmag)
          bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

          ifail=kinside
          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,hx,hy,hz,ifail)

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_field returned failure at point: ",x,y,z
          else if (ifail.lt.0) then
            irecover=irecover+1
          endif

          h=(hx*easy(1)+hy*easy(2)+hz*easy(3))/easyn
          bc=(bcx*easy(1)+bcy*easy(2)+bcz*easy(3))/easyn

          write(lunmag,'(a,I5,1p5e12.4,2I5)')"1 ",matmap3,easy,h,bc,mat,kbrn

          hmagvox(1,kmag)=h
          hmagvox(2,kmag)=bc

          if (bc.lt.bcminrec) bcminrec=sngl(bc)
          if (bc.gt.bcmaxrec) bcmaxrec=sngl(bc)

          if (h.lt.hminrec) hminrec=sngl(h)
          if (h.gt.hmaxrec) hmaxrec=sngl(h)

        enddo ! kmag

        if (hmaxrec-hminrec.lt.1.0e-6) then
          hminrec=-2.0
          hmaxrec=0.0
        endif

        if (bcmaxrec-bcminrec.lt.1.0e-6) then
          bcminrec=0.0
          bcmaxrec=2.
        endif

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations inside magnets with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif

      endif !knomagmap

      hmaxiron=2.5

      if (knopolmap.eq.0) then

        irecover=0
        hmaxiron=0.0

        allocate(hmvoxel(2,niron))
        iron=0

        do kmag=nrec+1,nrec+niron

          iron=iron+1

          !x1y1z1
          imoth=nint(bpebc(15,kmag))

          mat=nint(bpebc(9,kmag))

          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          x=bpebc(1,kmag) !mm
          y=bpebc(2,kmag) !mm
          z=bpebc(3,kmag) !mm

          bcx=bpebc(4,kmag)
          bcy=bpebc(5,kmag)
          bcz=bpebc(6,kmag)

          ifail=kinside
          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,hx,hy,hz,ifail)

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_field returned failure at point: ",x,y,z
          else if (ifail.lt.0) then
            irecover=irecover+1
          endif

          bx=hx+bcx
          by=hy+bcy
          bz=hz+bcz
          b=sqrt(bx*bx+by*by+bz*bz)
          h=sqrt(hx*hx+hy*hy+hz*hz)
          bc=sqrt(bcx*bcx+bcy*bcy+bcz*bcz)

          bdx=-9.0d0
          bdy=-9.0d0
          bdz=-9.0d0

          if (matmap2.eq.2) then
            hmvoxel(1,iron)=h
            hmvoxel(2,iron)=bc
            if (h.gt.hmaxiron) hmaxiron=sngl(h)
          endif

          cmag='none'
          cmoth='none'

          if (kmapmode.eq.0) then

            if (kmag.gt.0) then
              if (newclc.eq.0) then
                write(cmag,'(a)') chmags(:,kmag)
                write(cmoth,'(a)') chmoths(:,imoth)
              else
                lmag=t_voxcopy(kmag)%kmagnet
                kproto=t_magcopy(lmag)%kproto
                write(cmagnet,*)t_voxcopy(kmag)%kmagnet
                write(cmodule,*)t_voxcopy(kmag)%kmodule
                write(ccopy,*)t_voxcopy(kmag)%kcopy
                cmag=t_magnets(kproto)%cnam
                cmag=trim(adjustl(cmag)) // '_'
     &            // trim(adjustl(cmodule)) // '_'
     &            // trim(adjustl(cmagnet)) // '_'
     &            // trim(adjustl(ccopy))
                cmoth=t_magcopy(lmag)%cmoth
              endif
            endif

            write(lun,*)
     &        imoth,kmag,mat,matmap2,matmap3,
     &        sngl(x),sngl(y),sngl(z),
     &        sngl(bx),sngl(by),sngl(bz),sngl(b),
     &        sngl(hx),sngl(hy),sngl(hz),sngl(h),
     &        sngl(bcx),sngl(bcy),sngl(bcz),sngl(bc),
     &        sngl(bdx),sngl(bdy),sngl(bdz),
     &        ifail,' 0 ',trim(cmag),' ',trim(cmoth)
          else
            write(lun,*)
     &        sngl(x),sngl(y),sngl(z),sngl(bx),sngl(by),sngl(bz)
          endif
        enddo ! kmag

        if (irecover.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end:  Field calculations inside iron with ",irecover, " recovered errors ***"
          write(lun6,*)
        endif

      endif !knopolmap

      if (knointmap.eq.0) then

        do iy=1,nymap
          do iz=1,nzmap
            yint=ymapmin+(iy-1)*dy
            zint=zmapmin+(iz-1)*dz
            kx=0
            do ix=1,nxmap
              if (bmap(4,ix,iy,iz).ne.0.0d0) cycle
              kx=kx+1
              xinti(kx)=bmap(1,ix,iy,iz)
              byai(kx)=bmap(2,ix,iy,iz)
              bzai(kx)=bmap(3,ix,iy,iz)
            enddo !ix
            if (kx.gt.1.and.knointmap.eq.0) then
              if (isimpson.eq.0) then
                call util_spline_running_integral(xinti,byai,kx,byinti,coef,
     &            ws1,ws2,ws3,ws4)
                call util_spline_running_integral(xinti,bzai,kx,bzinti,coef,
     &            ws1,ws2,ws3,ws4)
                call util_spline_running_integral(xinti,byinti,kx,byint2i,coef,
     &            ws1,ws2,ws3,ws4)
                call util_spline_running_integral(xinti,bzinti,kx,bzint2i,coef,
     &            ws1,ws2,ws3,ws4)
              else
                call util_simpson_running_integral(kx,xinti,byai,byinti)
                call util_simpson_running_integral(kx,xinti,bzai,bzinti)
                call util_simpson_running_integral(kx,xinti,byinti,byint2i)
                call util_simpson_running_integral(kx,xinti,bzinti,bzint2i)
              endif
              write(luni,'(8(1pe17.7e3))')xinti(1),xinti(kx),yint,zint,
     &          byinti(kx),bzinti(kx),byint2i(kx),bzint2i(kx)
            endif !kx
          enddo !iz
        enddo !iy

        flush(luni)
        close(luni)

        flush(lun)
        close(lun)

      endif !knointmap

c Calculate field map}

      if (idebug.eq.1) then
        i_debug=5
        !all util_break
      endif

      call util_zeit_kommentar(lun6,"Writing undumag_mh_rec.eps")
+self,if=debugend.
      !all util_break
+self.
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_mh_rec.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

c{ Plot Magnetization of magnets

      if (nmag.gt.0) then

        xplmin=hminrec
        xplmax=hmaxrec
        yplmin=bcminrec
        yplmax=bcmaxrec

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        xplmin=xplmin-0.1*dxpl
        xplmax=xplmax+0.1*dxpl
        yplmin=yplmin-0.1*dypl
        yplmax=yplmax+0.1*dypl

        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'H [T]','M [T]',' ')
        call mshplt_set_marker_size(0.25)

        call mgset('PLCI',4.)

        xpl(1)=hminrec
        xpl(2)=hmaxrec

        do ibrn=1,nbrnmat
          mat=nint(brnmat(1,ibrn))
          brn=sngl(abs(brnmat(2,ibrn)))
          matmap2=matmaps(2,mat)
          if (matmap2.eq.1) then
            ypl(1)=brn+sngl(bcmat(2,1,mat))*xpl(1)
            ypl(2)=brn+sngl(bcmat(2,1,mat))*xpl(2)
            call mpl(2,xpl,ypl)
          else if (matmap2.eq.2) then
            ypl(1)=brn+sngl(bcmat(3,1,mat))*xpl(1)
            ypl(2)=brn+sngl(bcmat(3,1,mat))*xpl(2)
            call mpl(2,xpl,ypl)
          endif

        enddo !nbrnmat

        call mgset('PLCI',2.)

        if (knomagmap.eq.0) then
          do kmag=1,nrec
            xpl(1)=sngl(hmagvox(1,kmag))
            ypl(1)=sngl(hmagvox(2,kmag))
            call mpm(1,xpl,ypl)
          enddo
        endif

        call muwk(0,0)
        call mshplt_end

      endif !nmag
c} Plot Magnetization of magnets

      if (niron.gt.0.and.(nmag+ncwires+nrace.gt.0.or.kbextern.gt.0)) then

        call util_zeit_kommentar(lun6,"Writing undumag_mh_iron.eps")
        call mshplt_init(20,15.,15.,25,25,600,600,
     &    'undumag_mh_iron.eps','','',0.)

+self,if=debugend.
      !all util_break
+self.
        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif
        if (krunnum.ne.0) then
          write(ctitle,*)kundurun
          call util_string_trim(ctitle,nfirst,nlast)
          ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
        else
          ctitle=trim(usercom)
        endif

        if (kcomment.ne.0) call mtitle(trim(ctitle))
        call mshplt_hplset('YGTI',-0.5)

c{ Plot Magnetization of iron

        gsiz_ps=0.4

        xplmin=0.0
        xplmax=0.005
        yplmin=0.0
        yplmax=2.5

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mshplt_set_pad(3.5,10.,4.,18.)
        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'H [T]','M [T]',' ')
        call mshplt_set_marker_size(0.25)

        call mgset('PLCI',4.)

        do imat=1,nmatfiles

          if (matmaps(2,imat).eq.1) cycle

          mat=matmaps(1,imat)
          matmap2=matmaps(2,mat)
          matmap3=matmaps(3,mat)

          if (matmap3.eq.0) cycle

          if (matmap3.eq.0) then
            xpl(1)=sngl(xplmin)
            xpl(2)=sngl(xplmax)
            ypl(1:2)=sngl(bcmat(2,1,mat))
            call mpl(2,xpl,ypl)
          else
            do i=1,matmaps(4,mat)-1
              xpl(1:2)=sngl(feh1(i:i+1))
              ypl(1:2)=sngl(fem1(i:i+1))
              call mpl(2,xpl,ypl)
            enddo
          endif

        enddo !imat

        call mgset('PLCI',2.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            easy=0.0
            write(lunmag,'(a,i5,1p5e12.4,2I5)')
     &        "2 ",matmap3,easy,xpl(1),ypl(1),mat, mat*0
            if (matmap3.eq.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
c            if (xpl(1).lt.0.01) then
              call mpm(1,xpl,ypl)
c            else
c              print*,"holla hmvoxel"
c            endif
          enddo
        endif

        call mgset('PLCI',3.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            if (matmap3.ne.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
c            if (xpl(1).lt.0.01) then
              call mpm(1,xpl,ypl)
c            else
c              print*,"holla hmvoxel"
c            endif
            easy=0
            write(lunmag,'(a,i5,1p5e12.4,2I5)')
     &        "2 ",matmap3,easy,xpl(1),ypl(1),mat,mat*0
          enddo
        endif

        call muwk(0,0)

        xplmin=0.0
        xplmax=hmaxiron
        if (hmaxiron.eq.0.0d0) then
          xplmax=sngl(feh1(matmaps(4,2)))
        endif
        yplmin=0.0
        yplmax=2.5

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mshplt_set_pad(12.5,19.,4.,18.)
        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'H [T]','M [T]',' ')

        call mgset('PLCI',4.)
        if (matmap2.eq.0) then
          ypl(1:2)=sngl(bcmat(2,1,2))
          call mpl(2,xpl,ypl)
        else
          do i=1,matmaps(4,2)-1
            xpl(1:2)=sngl(feh1(i:i+1))
            ypl(1:2)=sngl(fem1(i:i+1))
            call mpl(2,xpl,ypl)
          enddo
        endif

        call mgset('PLCI',2.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            if (matmap3.eq.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
            if (xpl(1).lt.0.01) call mpm(1,xpl,ypl)
          enddo
        endif

        call mgset('PLCI',3.)

        if (knopolmap.eq.0) then
          do iron=1,niron
            mat=nint(bpebc(9,nrec+iron))
            matmap2=matmaps(2,mat)
            matmap3=matmaps(3,mat)
            if (matmap3.ne.0) cycle
            xpl(1)=sngl(hmvoxel(1,iron))
            ypl(1)=sngl(hmvoxel(2,iron))
            if (xpl(1).lt.0.01) call mpm(1,xpl,ypl)
          enddo
        endif

        call mgset('PLCI',2.)

        call muwk(0,0)
        call mshplt_end

      endif !(niron.gt.0) then

c} Magnetization of iron

c      write(lun6,*)"matrix:",matrix

      write(lun6,*)"Symmetries:"
      write(lun6,*)"ixsym, iysym, izsym, xsym:",ixsymo,iysymo,izsymo,xsym

      kinside=0
      write(lun6,*)
      write(lun6,*)"Conv. points and field H[T] there:"
c      i_debug=1
      do i=1,nxconv
        call undumag_field(xconv(i),yconv,zconv,hx,hy,hz,ifail)
        if (ifail.gt.0) then
          write(lun6,*)"Undumag_field returned unrecovered failure at convergence point: ",
     &      xconv(i)*1000.0,yconv*1000.0,zconv*1000.0
        endif
        write(lun6,'(a,i6,6g15.5)')" ",i,xconv(i)*1000.,yconv*1000.,zconv*1000.,
     &    hx,hy,hz
      enddo

      byint1fnor=0.0d0
      byint2fnor=0.0d0
      bzint1fnor=0.0d0
      bzint2fnor=0.0d0

      if (ixonnor.gt.1) then
        byint1fnor=byintnor(ixonnor)
        bzint1fnor=bzintnor(ixonnor)
        byint2fnor=byint2nor(ixonnor)
        bzint2fnor=bzint2nor(ixonnor)
      endif

      byint1f=0.0d0
      byint2f=0.0d0
      bzint1f=0.0d0
      bzint2f=0.0d0
      byint1fd=0.0d0
      byint2fd=0.0d0
      bzint1fd=0.0d0
      bzint2fd=0.0d0

      if (ixon.gt.1) then
        byint1f=byint(ixon)
        bzint1f=bzint(ixon)
        byint2f=byint2(ixon)
        bzint2f=bzint2(ixon)
      endif

      if (ixon.gt.1) then
        byint1fd=byintd(ixon)
        bzint1fd=bzintd(ixon)
        byint2fd=byint2d(ixon)
        bzint2fd=bzint2d(ixon)
      endif

      bxint1inf=0.0d0
      byint1inf=0.0d0
      bzint1inf=0.0d0
      byint1infd=0.0d0
      bzint1infd=0.0d0

      x=0.0d0
      y=0.0d0
      z=0.0d0

      if (maxiter.gt.0.and.nxmap.gt.0) then

        !all util_break
        call util_zeit_kommentar(lun6,"Writing undumag_integrals_inf.map")

        open(newunit=luninf,file="undumag_integrals_inf.map")
        write(luninf,'(a)')"* y/mm z/mm ByInt1/Tmm BzInt1/Tmm ByInt1_Dip/Tmm BzInt1_Dip/Tmm"

        y=ymapmin-dy
        do iy=1,nymap

          y=y+dy
          z=zmapmin-dz

          do iz=1,nzmap
            z=z+dz

            y=y/1000.0d0
            z=z/1000.0d0

            bxint1inf=0.0d0
            byint1inf=0.0d0
            bzint1inf=0.0d0

            byint1infd=0.0d0
            bzint1infd=0.0d0

            if (idipoles.ne.0) then
              do kmag=1,nmag
                if (bpebc(17,kmag).lt.0.0d0) cycle
                call undumag_dipoles_int(kmag,y,z,byi,bzi,ifail)
                if (ifail.ne.0) then
                  write(lun6,*)"*** Error in undumag_end: Bad return from undumag_dipoles_int ***"
                endif
                byint1infd=byint1infd+byi
                bzint1infd=bzint1infd+bzi
              enddo !nmag
            endif !(idipoles.ne.0) then

            x=0.0d0

            call undumag_bintinf_sym(0.0d0,y,z,1.0d0,0.0d0,0.0d0,
     &        bxint1inf,byint1inf,bzint1inf,ifail)

            if (ifail.ne.0) then
              write(lun6,*)
              write(lun6,*)"*** Warning in undumag_end: Bad return from undumag_bintinf_sym ***"
              write(lun6,*)"*** y,z:",y,z," ***"
            endif

            y=y*1000.0d0
            z=z*1000.0d0

            write(luninf,'(6(1pe17.7e3))')y,z,
     &        byint1inf*1000.0d0,bzint1inf*1000.0d0,
     &        byint1infd*1000.0d0,bzint1infd*1000.0d0

          enddo !iz
        enddo !iy

        flush(luninf)
        close(luninf)

        if (idebug.eq.1) then
          i_debug=6
          !all util_break
        endif

        bxint1inf=0.0d0
        byint1inf=0.0d0
        bzint1inf=0.0d0

        byint1infd=0.0d0
        bzint1infd=0.0d0

        x=0.0d0 !m
        y=0.0d0 !m
        z=0.0d0 !m

        call undumag_bintinf_sym(x,y,z,1.0d0,0.0d0,0.0d0,
     &    bxint1inf,byint1inf,bzint1inf,ifail)
        if (ifail.ne.0) then
          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end: Bad return from undumag_bintinf_sym ***"
          write(lun6,*)"*** y,z:",y,z," ***"
        endif

        if (idipoles.ne.0) then

          do kmag=1,ndipoles

            y2z2=dipoles(2,kmag)**2+dipoles(3,kmag)**2
            py=dipoles(6,kmag)*dipoles(4,kmag)
            pz=dipoles(7,kmag)*dipoles(4,kmag)
            pryz=py*dipoles(2,kmag)+pz*dipoles(3,kmag)

            if (y2z2.ne.0.0d0) then
              byint1infd=byint1infd
     &          +3.0d0*pryz*dipoles(2,kmag)*2.0d0/3.0d0/y2z2**2*2.0d0
     &          -2.0d0/y2z2*py
              bzint1infd=bzint1infd
     &          +3.0d0*pryz*dipoles(3,kmag)*2.0d0/3.0d0/y2z2**2*2.0d0
     &          -2.0d0/y2z2*pz
            else
              write(lun6,*)"*** Error in undumag_end: Integration of dipole fields fails, since distance to dipole is zero for dipole",
     &          kmag," ***"
            endif
          enddo
        endif !(idipoles.ne.0) then

      endif !(maxiter.gt.1) then

      bxint1inf=bxint1inf*1000.0d0
      byint1inf=byint1inf*1000.0d0
      bzint1inf=bzint1inf*1000.0d0

      write(lun6,*)
      write(lun6,*)"Initial and final damping factors for relaxation of iron:",
     &  sngl(dampi),sngl(damp8)
      write(lun6,*)
      write(lun6,*)"Maximum iteration used for Chi(H) for iron:",nchimax
      write(lun6,*)
      write(lun6,*) "1. Integrals ByI  and BzI  in [Tmm]:  ",
     &  sngl(byint1f),sngl(bzint1f)
      byif=byint1f
      bzif=bzint1f
      write(lun6,*) "1. Integrals ByI  and BzI  in [Tmm], without recovered points:  ",
     &  sngl(byint1fnor),sngl(bzint1fnor)
      write(lun6,*) "1. Integrals ByI and BzI [Tmm], analytically,"
      write(lun6,*) "NOT including external field:  ",
     &  sngl(byint1inf),sngl(bzint1inf)

      if (idipoles.ne.0) then
        write(lun6,*) "1. Integrals ByI  and BzI  in [Tmm] for dipole approx.:  ",
     &    sngl(byint1fd),sngl(bzint1fd)
        write(lun6,*) "1. Integrals ByI and BzI [Tmm], analytically, dipole approx.,"
        write(lun6,*) "NOT including external field:  ",
     &    sngl(byint1infd),sngl(bzint1infd)
      endif !(idipoles.ne.0) then

      write(lun6,*)
      write(lun6,*) "External field [T]:",sngl(bxex),sngl(byex),sngl(bzex)
      write(lun6,*) "1. Integrals ByI and BzI [Tmm] of external field:  ",
     &  sngl(byexint),sngl(bzexint)

      write(lun6,*)
      write(lun6,*) "2. Integrals ByII and BzII in [Tmm**2]: ",
     &  sngl(byint2f),sngl(bzint2f)
      write(lun6,*) "2. Integrals ByII and BzII in [Tmm**2], without recovered points: ",
     &  sngl(byint2fnor),sngl(bzint2fnor)

      if (idipoles.ne.0) then
        write(lun6,*) "2. Integrals ByII and BzII in [Tmm**2] for dipole approx.: ",
     &    sngl(byint2fd),sngl(bzint2fd)
        write(lun6,*)
      endif !(idipoles.ne.0) then

      write(lun6,*)
      dx=xint(nxmap)-xint(1)
      if (nxmap.gt.1) then
        write(lun6,*)"Range of integration and step size:",xint(1),xint(nxmap),dx/(nxmap-1)
      else
        write(lun6,*)"Range of integration and step size:",xint(1),xint(nxmap)," 0.0"
      endif
      write(lun6,*)"By and Bz there:",
     &  sngl(bya(1)),sngl(bza(1)),sngl(bya(nxmap)),sngl(bza(nxmap))
      write(lun6,*)"By*x-range and Bz*x-range there:",
     &  sngl(bya(1)*dx),sngl(bza(1)*dx),sngl(bya(nxmap)*dx),sngl(bza(nxmap)*dx)
      write(lun6,*)

      call util_zeit_kommentar(lun6,"Writing undumag_on-axis_by_bz.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_on-axis_by_bz.eps','','',0.)

      if (ixon.gt.1) then

        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif
        if (krunnum.ne.0) then
          write(ctitle,*)kundurun
          call util_string_trim(ctitle,nfirst,nlast)
          ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
        else
          ctitle=trim(usercom)
        endif

        if (kcomment.ne.0) call mtitle(trim(ctitle))
        call mshplt_hplset('YGTI',-0.5)

c{ Plot By, Bz

        gsiz_ps=0.4

        xplmin=sngl(xmapmin)
        xplmax=sngl(xmapmax)
        yplmin=min(byplmin,bzplmin)
        yplmax=max(byplmax,bzplmax)
        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin

        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bya(ix))
          ypl(2)=sngl(bya(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('PLCI',4.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bza(ix))
          ypl(2)=sngl(bza(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mshplt_set_pad(4.,19.,3.,18.)

        call mshplt_set_text_angle(90.)
        call mshplt_text_ndc(-0.1,0.9,'B [T]')
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.85,-0.1,'x [mm]')

c        call mgset('CHHE',0.4)
c        call mshplt_set_text_angle(0.)
c        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
cc        call mtx(xplmax-dxpl*0.05,yplmin-dypl*0.175,'x [mm]')
c        call mshplt_set_text_angle(90.)
c        if (abs(yplmax).lt.1.0e-3) then
c          call mshplt_text_ndc(-0.1,0.86,'B [T]')
c        else
c          call mshplt_text_ndc(-0.1,0.88,'B [T]')
c        endif
c        call mtx(xplmin-dxpl*0.15,yplmax-dypl*0.05,'B [T]')
        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        call mshplt_text_ndc(0.85,0.9,'By')
        call mshplt_set_text_color(0,0,0,1)
        call mshplt_text_ndc(0.85,0.83,'Bz')
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)

        call muwk(0,0)
        call mshplt_end

      endif !ixon

c} Plot By, Bz

c{ Plot ByInt, BzInt

      call util_zeit_kommentar(lun6,"Writing undumag_on-axis_byint_bzint.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_on-axis_byint_bzint.eps','','',0.)
      if (kcomment.ne.0) call mtitle(trim(ctitle))
      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      call mshplt_hplset('YGTI',-0.5)

      if (ixon.gt.1) then

        call mgset('CHHE',0.3)
        call mshplt_set_text_color(1,0,0,0)
        gsiz_ps=0.4

        xplmin=sngl(xmapmin)
        xplmax=sngl(xmapmax)
        yplmin=min(byiplmin,bziplmin)
        yplmax=max(byiplmax,bziplmax)
        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin
        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(byint(ix))
          ypl(2)=sngl(byint(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('PLCI',4.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bzint(ix))
          ypl(2)=sngl(bzint(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('CHHE',0.4)
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
        call mshplt_set_text_angle(90.)
        call mshplt_text_ndc(-0.1,0.7,'1. Integral of B [Tmm]')
        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        cbint="1. Int By = "
        call mshplt_text_ndc(0.77,0.9,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') byint1f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') byint1f
        cbint(11:14)="Tmm"
        call mshplt_text_ndc(0.77,0.85,cbint)
        call mshplt_set_text_color(0,0,0,1)
        cbint="1. Int Bz = "
        call mshplt_text_ndc(0.77,0.80,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') bzint1f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') bzint1f
        cbint(11:14)="Tmm"
        call mshplt_text_ndc(0.77,0.75,cbint)
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)

      endif !ixon

      call muwk(0,0)
      call mshplt_end

c} Plot ByInt, BzInt

c{ Plot ByInt2, BzInt2

      call util_zeit_kommentar(lun6,"Writing undumag_on-axis_byint2_bzint2.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_on-axis_byint2_bzint2.eps','','',0.)
      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)
      gsiz_ps=0.4

      if (ixon.gt.1) then

        call mgset('CHHE',0.3)
        call mshplt_set_text_color(1,0,0,0)

        xplmin=sngl(xmapmin)
        xplmax=sngl(xmapmax)
        yplmin=min(byiiplmin,bziiplmin)
        yplmax=max(byiiplmax,bziiplmax)
        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin
        if (dxpl.le.1.0e-9) dxpl=1.
        if (dypl.le.1.0e-9) dypl=1.

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(byint2(ix))
          ypl(2)=sngl(byint2(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('PLCI',4.)

        do ix=1,ixon-1
          xpl(1)=sngl(xint(ix))
          xpl(2)=sngl(xint(ix+1))
          ypl(1)=sngl(bzint2(ix))
          ypl(2)=sngl(bzint2(ix+1))
          call mpl(2,xpl,ypl)
        enddo

        call mgset('CHHE',0.4)
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
        call mshplt_set_text_angle(90.)
        call mshplt_text_ndc(-0.1,0.77,'2. Integral of B [Tmm^2]')
        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        cbint="2. Int By = "
        call mshplt_text_ndc(0.73,0.9,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') byint2f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') byint2f
        cbint(9:14)="Tmm^2"
        call mshplt_text_ndc(0.73,0.85,cbint)
        call mshplt_set_text_color(0,0,0,1)
        cbint="2. Int Bz = "
        call mshplt_text_ndc(0.73,0.80,cbint)
        cbint=""
        write(cbint(1:9),'(f9.3)') bzint2f
        if (cbint(1:1).eq.'*') write(cbint(1:9),'(e9.3)') bzint2f
        cbint(9:14)="Tmm^2"
        call mshplt_text_ndc(0.73,0.75,cbint)
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)
      endif !ixon

      call muwk(0,0)
      call mshplt_end
c} Plot ByInt2, BzInt2

c Calculate beff{

      deallocate (xintnor)
      deallocate (bxanor)
      deallocate (byanor)
      deallocate (bzanor)
      deallocate (byintnor)
      deallocate (bzintnor)
      deallocate (byint2nor)
      deallocate (bzint2nor)
      deallocate (xint)
      deallocate (bxa)
      deallocate (bya)
      deallocate (bza)
      deallocate (byint)
      deallocate (bzint)
      deallocate (byint2)
      deallocate (bzint2)
      deallocate (ws1)
      deallocate (ws2)
      deallocate (ws3)
      deallocate (ws4)
      deallocate (coef)

      allocate (
     &  xintnor(nxbeff),
     &  byintnor(nxbeff),bzintnor(nxbeff),
     &  byint2nor(nxbeff),bzint2nor(nxbeff),
     &  bxanor(nxbeff),byanor(nxbeff),bzanor(nxbeff),
     &  xint(nxbeff),
     &  byint(nxbeff),bzint(nxbeff),
     &  byint2(nxbeff),bzint2(nxbeff),
     &  bxa(nxbeff),bya(nxbeff),bza(nxbeff),
     &  ws1(nxbeff),ws2(nxbeff),ws3(nxbeff),ws4(nxbeff),coef(nxbeff))

c      if (xbeff.eq.9999.0d0) xbeff=xconv(nxconv/2+1)
      if (xbeff.eq.9999.0d0) xbeff=xcenter
      if (xbeff.eq.-9999.0d0) xbeff=(xmapmin+xmapmax)/2.0d0

      xbeffo=xbeff

      halfperlen=perlen/2.0d0
      quadperlen=perlen/4.0d0
+self,if=oldbeff.
      bymaxbeff=-1.0d30
      bzmaxbeff=-1.0d30

      if (kbeffmode.eq.9999) then
        if (nper.gt.0) then
          kbeffmode=0
        else
          kbeffmode=1
        endif
      endif

      if (kbeffmode.eq.0) then
        xminbeff=xbeff-perlen*0.51
        xmaxbeff=xbeff+perlen*0.51
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
        dxkbmode=abs(kbeffmode)*dx
      else
        xminbeff=xbeff-quadperlen
        xmaxbeff=xbeff+quadperlen
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        dxkbmode=abs(kbeffmode)*dx
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
      endif

      xbymax=xbeff
      xbzmax=xbeff

      do ix=1,nxbeff

        x=xminbeff+(ix-1)*dx
        xx=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          cycle
        endif

        call util_random(3,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        xint(ix)=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          if (x.lt.xbeff) then
            x=xx+abs(xx-x)
          else
            x=xx-abs(xx-x)
          endif
        endif

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif
        if (randoz.ge.0.0d0) then
          z=g(3)*randoza
        else
          z=randoza
        endif

        if (kbeffmode.eq.0) then
          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &      bx,by,bz,ifail)
        else
          if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
            cycle
          endif
          if (abs(x-xbeff).le.quadperlen) then
            call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
          else if (x.lt.xbeff) then
            call undumag_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          else
            call undumag_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          endif
        endif !kbeffmode

        if (ifail.ne.0) cycle

        if (abs(by).gt.bymaxbeff) then
          bymaxbeff=abs(by)
          xbymax=xminbeff+(ix-1)*dx
        endif

        if (abs(bz).gt.bzmaxbeff) then
          bzmaxbeff=abs(bz)
          xbzmax=xminbeff+(ix-1)*dx
        endif

      enddo !ix

      if (bymaxbeff.lt.1.0d-4*bzmaxbeff) xbymax=xbzmax
      if (bzmaxbeff.lt.1.0d-4*bymaxbeff) xbzmax=xbymax
+self. if=oldbeff.
      call undumag_beffy_beffz(
     &  byint1f,bzint1f,
     &  byint2f,bzint2f,
     &  byint1inf,bzint1inf,
     &  byint1fnor,bzint1fnor,
     &  byint2fnor,bzint2fnor,
     &  byexint,bzexint)

      if (idipoles.ne.0) then

        call util_zeit_kommentar(lun6,"Writing undumag_bzeff_dipoles.dat")
        open(newunit=lun,file="undumag_bzeff_dipoles.dat")

        xbeff=xbzmax
        xminbeff=xbeff-perlen/2.0d0
        xmaxbeff=xbeff+perlen/2.0d0

        halfperlen=perlen/2.0d0
        quadperlen=perlen/4.0d0

        if (abs(xbeffo-xminbeff).le.quadperlen) then
          xminbeff=xminbeff-halfperlen
          xmaxbeff=xmaxbeff-halfperlen
        else if (xbeffo-xminbeff.gt.halfperlen*1.001) then
          xminbeff=xminbeff+halfperlen
          xmaxbeff=xmaxbeff+halfperlen
        endif

        if (xbeffz.ne.-9999.0d0) then
          xbeff=xbeffz
          xminbeff=xbeff-perlen/2.0d0
          xmaxbeff=xbeff+perlen/2.0d0
        endif

        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff

        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        x=xminbeff-dx
        dxkbmode=abs(kbeffmode)*dx

        ixbeff=0
        ixbeffnor=0
        irecover=0

        do ix=1,nxbeff

          x=xminbeff+(ix-1)*dx
          xint(ix)=x
          if (kbeffmode.eq.0) then
            call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bxa(ix),bya(ix),bza(ix),ifail)
          else
            if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
              cycle
            endif
            if (abs(x-xbeff).le.quadperlen) then
              call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
            else if (x.lt.xbeff) then
              call undumag_dipoles_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            else
              call undumag_dipoles_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            endif
          endif !kbeffmode

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_dipoles_field returned failure for Bzeff calculation at point ",ix,xint(ix)
          else
            ixbeff=ixbeff+1
            xint(ixbeff)=xint(ix)
            bxa(ixbeff)=bxa(ix)
            bya(ixbeff)=bya(ix)
            bza(ixbeff)=bza(ix)
          endif

        enddo

        if (ixbeff.gt.0) then

          x3=xint(1:3)
          b3=bya(1:3)
          call parabel_short(x3,b3,a3)
          xint(1)=xminbeff
          bya(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2
          b3=bza(1:3)
          call parabel_short(x3,b3,a3)
          bza(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2

          x3=xint(ixbeff-2:ixbeff)
          b3=bya(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          xint(ixbeff)=xmaxbeff
          bya(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2
          b3=bza(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          bza(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2

          do i=1,ixbeff
            write(lun,*)i,xint(i),bya(i),bza(i)
          enddo

          call util_spline_running_integral(xint,bza,ixbeff,bzint,coef,
     &      ws1,ws2,ws3,ws4)

          bmnbeffd=1.0d30
          bmxbeffd=-1.0d30
          bmaxbeffd=-1.0d30
          do i=1,ixbeff
            if (bza(i).gt.bmxbeffd) then
              bmxbeffd=bza(i)
            endif
            if (bza(i).lt.bmnbeffd) then
              bmnbeffd=bza(i)
            endif
            if (abs(bza(i)).gt.bmaxbeffd) then
              bmaxbeffd=abs(bza(i))
              ibmax=i
            endif
            bzint(i)=bzint(i)**2
          enddo

          if (ibmax.eq.1) ibmax=2
          if (ibmax.eq.ixbeff) ibmax=ixbeff-1

          yp(1)=1.0d0
          yp(2)=2.0d0
          yp(3)=3.0d0
          bp(1)=abs(bza(ibmax-1))
          bp(2)=abs(bza(ibmax))
          bp(3)=abs(bza(ibmax+1))

          call util_max_parabel(3,yp,bp,dum,bmaxp,ws1,ws2,ifail)
          if (ifail.eq.0) bmaxbeffd=bmaxp

          call util_spline_running_integral(xint,bzint,ixbeff,bzint2,coef,
     &      ws1,ws2,ws3,ws4)

          beffd= sqrt(bzint2(ixbeff)/(xint(ixbeff)-xint(1)))
c Correct for endpole effects
          if (bmaxbeffd.ne.0.0d0) then
            beffd=beffd*(bmxbeffd-bmnbeffd)/2.0d0/bmaxbeffd
          endif
          bmaxbeffd=(bmxbeffd-bmnbeffd)/2.0d0
          dkeffd = beffd * sqrt(2.0d0)  * 3.0d8 / 0.511d6 / 1000.0d0
          beffd = dkeffd / ((xint(ixbeff)-xint(1))*100.0d0) / 0.934d0 * 1000.0d0

          bmnbeffzd=bmnbeffd
          bmxbeffzd=bmxbeffd
          beffzd=beffd
          dkeffzd=dkeffd

          flush(lun) !undumag_bzeff_dipoles.beff
          close(lun) !undumag_bzeff_dipoles.beff

        else

          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end: No field data for Bzeff calculation ***"
          write(lun6,*)

        endif

        if (idebug.eq.1) then
          i_debug=7
          !all util_break
        endif

        call util_zeit_kommentar(lun6,"Writing undumag_byeff_dipoles.dat")
        open(newunit=lun,file="undumag_byeff_dipoles.dat")

        xbeff=xbymax
        xminbeff=xbeff-perlen/2.0d0
        xmaxbeff=xbeff+perlen/2.0d0

        halfperlen=perlen/2.0d0
        quadperlen=perlen/4.0d0

        if (abs(xbeffo-xminbeff).le.quadperlen) then
          xminbeff=xminbeff-halfperlen
          xmaxbeff=xmaxbeff-halfperlen
        else if (xbeffo-xminbeff.gt.halfperlen*1.001) then
          xminbeff=xminbeff+halfperlen
          xmaxbeff=xmaxbeff+halfperlen
        endif

        if (xbeffy.ne.-9999.0d0) then
          xbeff=xbeffy
          xminbeff=xbeff-perlen/2.0d0
          xmaxbeff=xbeff+perlen/2.0d0
        endif

        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff

        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        x=xminbeff-dx
        dxkbmode=abs(kbeffmode)*dx

        ixbeff=0
        ixbeffnor=0
        irecover=0
        do ix=1,nxbeff
          x=xminbeff+(ix-1)*dx
          xint(ix)=x
          if (kbeffmode.eq.0) then
            call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bxa(ix),bya(ix),bza(ix),ifail)
          else
            if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
              cycle
            endif
            if (abs(x-xbeff).le.quadperlen) then
              call undumag_dipoles_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
            else if (x.lt.xbeff) then
              call undumag_dipoles_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            else
              call undumag_dipoles_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &          bxa(ix),bya(ix),bza(ix),ifail)
              bxa(ix)=-bxa(ix)
              bya(ix)=-bya(ix)
              bza(ix)=-bza(ix)
            endif
          endif !kbeffmode

          if (ifail.gt.0) then
            write(lun6,*)"Undumag_dipoles_field returned failure for Byeff calculation at point ",ix,xint(ix)
          else
            ixbeff=ixbeff+1
            xint(ixbeff)=xint(ix)
            bxa(ixbeff)=bxa(ix)
            bya(ixbeff)=bya(ix)
            bza(ixbeff)=bza(ix)
          endif
        enddo

        if (ixbeff.gt.0) then

          x3=xint(1:3)
          b3=bya(1:3)
          call parabel_short(x3,b3,a3)
          xint(1)=xminbeff
          bya(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2
          b3=bza(1:3)
          call parabel_short(x3,b3,a3)
          bza(1)=a3(1)+a3(2)*xint(1)+a3(3)*xint(1)**2

          x3=xint(ixbeff-2:ixbeff)
          b3=bya(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          xint(ixbeff)=xmaxbeff
          bya(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2
          b3=bza(ixbeff-2:ixbeff)
          call parabel_short(x3,b3,a3)
          bza(ixbeff)=a3(1)+a3(2)*xint(ixbeff)+a3(3)*xint(ixbeff)**2

          do i=1,ixbeff
            write(lun,*)i,xint(i),bya(i),bza(i)
          enddo

          call util_spline_running_integral(xint,bya,ixbeff,byint,coef,
     &      ws1,ws2,ws3,ws4)

          bmnbeffd=1.0d30
          bmxbeffd=-1.0d30
          bmaxbeffd=-1.0d30
          do i=1,ixbeff
            if (bya(i).gt.bmxbeffd) then
              bmxbeffd=bya(i)
            endif
            if (bya(i).lt.bmnbeffd) then
              bmnbeffd=bya(i)
            endif
            if (abs(bya(i)).gt.bmaxbeffd) then
              bmaxbeffd=abs(bya(i))
              ibmax=i
            endif
            byint(i)=byint(i)**2
          enddo

          if (ibmax.eq.1) ibmax=2
          if (ibmax.eq.ixbeff) ibmax=ixbeff-1

          yp(1)=1.0d0
          yp(2)=2.0d0
          yp(3)=3.0d0
          bp(1)=abs(bya(ibmax-1))
          bp(2)=abs(bya(ibmax))
          bp(3)=abs(bya(ibmax+1))

          call util_max_parabel(3,yp,bp,dum,bmaxp,ws1,ws2,ifail)
          if (ifail.eq.0) bmaxbeffd=bmaxp

          call util_spline_running_integral(xint,byint,ixbeff,byint2,coef,
     &      ws1,ws2,ws3,ws4)

          beffd= sqrt(byint2(ixbeff)/(xint(ixbeff)-xint(1)))
c Correct for endpole effects
          if (bmaxbeffd.ne.0.0d0) then
            beffd=beffd*(bmxbeffd-bmnbeffd)/2.0d0/bmaxbeffd
          endif
          bmaxbeffd=(bmxbeffd-bmnbeffd)/2.0d0
          dkeffd = beffd * sqrt(2.0d0)  * 3.0d8 / 0.511d6 / 1000.0d0
          beffd = dkeffd / ((xint(ixbeff)-xint(1))*100.0d0) / 0.934d0 * 1000.0d0

          flush(lun) !undumag_byeff_dipoles.beff
          close(lun) !undumag_byeff_dipoles.beff

        else

          write(lun6,*)
          write(lun6,*)"*** Warning in undumag_end: No field data for Byeff calculation ***"
          write(lun6,*)

        endif !ixbeff

        if (idebug.eq.1) then
          i_debug=8
          !all util_break
        endif

        write(lun6,*)"XminBeff, XmaxBeff (dipole approx.):",
     &    sngl(xminbeff),sngl(xmaxbeff)

        write(lun6,*)"ByMin, ByMax, (ByMax-ByMin)/2, ByEff (dipoles approx.):",
     &    sngl(bmnbeffd),sngl(bmxbeffd),
     &    sngl((bmxbeffd-bmnbeffd)/2.0d0),sngl(beffd)

        write(lun6,*)"BzMin, BzMax, (BzMax-BzMin)/2, BzEff (dipole approx.):",
     &    sngl(bmnbeffzd),sngl(bmxbeffzd),
     &    sngl((bmxbeffzd-bmnbeffzd)/2.0d0),sngl(beffzd)

        write(lun6,*)
        write(lun6,*)"Beff = Sqrt( ByEff**2 + BzEff**2 ) (dipole approx.):",
     &    sngl(sqrt(beffd**2+beffzd**2))

        dkeffd=sngl(sqrt(dkeffd**2+dkeffzd**2))

        write(lun6,*)

        write(lun6,*)"Keff and first harmonic [eV] (dipole approx):",
     &    sngl(dkeffd),sngl(950.0d0*ebeam**2/(1.0d0+dkeffd**2/2.0d0)/(perlen/10.0d0))
        write(lun6,*)

        call util_zeit_kommentar(lun6,"Writing undumag_dipoles.beff")
        open(newunit=lun,file="undumag_dipoles.beff")
        write(lun,*)"* Run:"
        write(lun,*)kundurun
        write(lun,*)"* XminBeff XmaxBeff:"
        write(lun,*)
     &    sngl(xminbeff),sngl(xmaxbeff)
        write(lun,*)"* ByMin, ByMax, (ByMax-ByMin)/2, ByEff:"
        write(lun,*)
     &    sngl(bmnbeffd),sngl(bmxbeffd),
     &    sngl((bmxbeffd-bmnbeffd)/2.0d0),sngl(beffd)
        write(lun,*)"* BzMin, BzMax, (BzMax-BzMin)/2, BzEff:"
        write(lun,*)
     &    sngl(bmnbeffzd),sngl(bmxbeffzd),
     &    sngl((bmxbeffzd-bmnbeffzd)/2.0d0),sngl(beffzd)
        write(lun,*)"* Beff = Sqrt( ByEff**2 + BzEff**2 ):"
        write(lun,*)
     &    sngl(sqrt(beffd**2+beffzd**2))
        write(lun,*)"* ByInt1, BzInt1, ByInt2, BzInt2:"
        write(lun,*)
     &    sngl(byint1fd),sngl(bzint1fd),
     &    sngl(byint2fd),sngl(bzint2fd)
        write(lun,*)"* ByInt1Inf, BzInt1Inf:"
        write(lun,*)
     &    sngl(byint1infd),sngl(bzint1infd)
        flush(lun)
        close(lun)
!} beff
      endif !(idipoles.ne.0) then

      deallocate (xint)
      deallocate (bxa)
      deallocate (bya)
      deallocate (bza)
      deallocate (byint)
      deallocate (bzint)
      deallocate (byint2)
      deallocate (bzint2)
      deallocate (ws1)
      deallocate (ws2)
      deallocate (ws3)
      deallocate (ws4)
      deallocate (coef)

      if (kurad.ne.0) then

        ndim=nstepp
        gammai=ebeam/emassg1

        if (xelec.eq.9999.0d0) xelec=xmapmin
        if (xf.eq.9999.0d0) xf=xmapmax

        xelec=xelec/1000.0d0
        yelec=yelec/1000.0d0
        zelec=zelec/1000.0d0

        ds=ds/1000.0d0

        xobsv=xobsv/1000.0d0
        yobsv=yobsv/1000.0d0
        zobsv=zobsv/1000.0d0

        xf=xf/1000.0d0
        yf=yf/1000.0d0
        zf=zf/1000.0d0

        call urad(jcharge,
     &    gammai,dgamtot
     &    ,xelec,yelec,zelec,vxelec,vyelec,vzelec
     &    ,xf,yf,zf,efx,efy,efz,
     &    xexit,yexit,zexit,vnxex,vnyex,vnzex,texit,ds
     &    ,nthstep,nstep,ndim,traxyz
     &    ,xobsv,yobsv,zobsv,phelow,phehig,
     &    nphener,phener,aradx,arady,aradz,stokes,powden
     &    ,ieneloss,ivelofield,istatus
     &    )

        write(lun6,*)
        write(lun6,'(a,3g15.5)')"xelec, yelec, zelec for urad [mm]:",
     &    xelec*1000.,yelec*1000.,zelec*1000.
        write(lun6,'(a,3g15.5)')"vxelec, vyelec, vzelec for urad:",
     &    vxelec,vyelec,vzelec
        write(lun6,'(a,2g15.5)')"ebeam [GeV], gamma for urad:",ebeam, gamma
        write(lun6,'(a,3g15.5)')"xexit, yexit, zexit [mm]:",
     &    xexit*1000.0,yexit*1000.0,zexit*1000.0
        write(lun6,'(a,2g15.5)')"hori. and vert. kick at xexit [mrad]:",
     &    vnzex/vnxex*1000., vnyex/vnxex*1000.

        xplmin=1.0e30
        xplmax=-1.0e30
        yplmin=1.0e30
        yplmax=-1.0e30
        zplmin=1.0e30
        zplmax=-1.0e30

        call util_zeit_kommentar(lun6,"Writing urad_traxyz.dat")
        open(newunit=lun,file='urad_traxyz.dat',recl=256)

        do istep=1,nstep
          if (traxyz(1,istep).lt.xplmin) xplmin=sngl(traxyz(1,istep))
          if (traxyz(1,istep).gt.xplmax) xplmax=sngl(traxyz(1,istep))
          if (traxyz(2,istep).lt.yplmin) yplmin=sngl(traxyz(2,istep))
          if (traxyz(2,istep).gt.yplmax) yplmax=sngl(traxyz(2,istep))
          if (traxyz(3,istep).lt.zplmin) zplmin=sngl(traxyz(3,istep))
          if (traxyz(3,istep).gt.zplmax) zplmax=sngl(traxyz(3,istep))
          write(lun,'(14e17.7e3)')traxyz(1:3,istep)*1000.0,traxyz(4:14,istep)
        enddo

        flush(lun)
        close(lun)

c{ Plot x,y,z

        call util_zeit_kommentar(lun6,"Writing undumag_trajectory.eps")
        call mshplt_init(20,15.,15.,25,25,600,600,
     &    'undumag_trajectory.eps','','',0.)

        gsiz_ps=0.4

        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif

        theta_ps=sngl(traxyz_theta)
        phi_ps=sngl(traxyz_phi)

        xplmin=xplmin*1000.
        xplmax=xplmax*1000.
        yplmin=yplmin*1.0e6
        zplmin=zplmin*1.0e6
        yplmax=yplmax*1.0e6
        zplmax=zplmax*1.0e6

        dxpl=xplmax-xplmin
        dypl=yplmax-yplmin
        dzpl=zplmax-zplmin

        if (dypl.lt.1.0e-9) dypl=1.0
        if (dzpl.lt.1.0e-9) dzpl=1.0

        xplmin=xplmin-dxpl*0.05
        xplmax=xplmax+dxpl*0.05
        yplmin=yplmin-dypl*0.05
        yplmax=yplmax+dypl*0.05
        zplmin=zplmin-dzpl*0.05
        zplmax=zplmax+dzpl*0.05

        if (yplmin.le.zplmin) then
          zplmin=yplmin
        else
          yplmin=zplmin
        endif

        if (yplmax.ge.zplmax) then
          zplmax=yplmax
        else
          yplmax=zplmax
        endif

        call mshplt_frame3d_xzy(
     &    xplmin,xplmax,
     &    yplmin,yplmax,
     &    zplmin,zplmax,
     &    'x [mm]','y [mu-m]','z [mu-m]','')

        call mshplt_set_text_color(1,0,0,0)
        gsiz_ps=0.4
        call mgset('CHHE',0.4)
        call mshplt_text_ndc(0.1,1.05,ctitle)

        call mgset('PLCI',2.)

        do istep=1,nstep-1
          xpl(1)=sngl(traxyz(1,istep))*1000.
          xpl(2)=sngl(traxyz(1,istep+1))*1000.
          ypl(1)=sngl(traxyz(2,istep))*1.0e6
          ypl(2)=sngl(traxyz(2,istep+1))*1.0e6
          zpl(1)=zplmax+zplmin-sngl(traxyz(3,istep))*1.0e6
          zpl(2)=zplmax+zplmin-sngl(traxyz(3,istep+1))*1.0e6
          call mpl3(2,xpl,zpl,ypl)
        enddo

        call mshplt_end

c} Plot x,y,z

c{ Plot y,z

      call util_zeit_kommentar(lun6,"Writing undumag_y_z.eps")

      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_y_z.eps','','',0.)

      if (ixon.gt.1) then

        if (kdate.eq.0) then
          call mplopt('NDAT',1)
        else
          call mplopt('DATE',1)
        endif
        if (krunnum.ne.0) then
          write(ctitle,*)kundurun
          call util_string_trim(ctitle,nfirst,nlast)
          ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
        else
          ctitle=trim(usercom)
        endif

        if (kcomment.ne.0) call mtitle(trim(ctitle))
        call mshplt_hplset('YGTI',-0.5)

        call mplfra(
     &    xplmin-dxpl*0.05,
     &    xplmax+dxpl*0.05,
     &    yplmin-dypl*0.05,
     &    yplmax+dypl*0.05,
     &    '')

        call mgset('PLCI',2.)

        do istep=1,nstep-1
          xpl(1)=sngl(traxyz(1,istep))*1000.
          xpl(2)=sngl(traxyz(1,istep+1))*1000.
          zpl(1)=sngl(traxyz(2,istep))*1.0e6
          zpl(2)=sngl(traxyz(2,istep+1))*1.0e6
          call mpl(2,xpl,zpl)
        enddo

        call mgset('PLCI',4.)

        do istep=1,nstep-1
          xpl(1)=sngl(traxyz(1,istep))*1000.
          xpl(2)=sngl(traxyz(1,istep+1))*1000.
          ypl(1)=sngl(traxyz(3,istep))*1.0e6
          ypl(2)=sngl(traxyz(3,istep+1))*1.0e6
          call mpl(2,xpl,ypl)
        enddo

        call mgset('CHHE',0.4)
        call mshplt_set_text_angle(0.)
        call mshplt_text_ndc(0.9,-0.1,'x [mm]')
        call mshplt_set_text_angle(90.)

        call mshplt_text_ndc(-0.1,0.65,'trajectory [mu-m]')

        call mshplt_set_text_angle(0.)
        call mgset('CHHE',0.5)
        call mshplt_set_text_color(0,1,0,0)
        call mshplt_text_ndc(0.85,0.9,'y')
        call mshplt_set_text_color(0,0,0,1)
        call mshplt_text_ndc(0.85,0.83,'z')
        call mshplt_set_text_color(1,0,0,0)
        call mgset('CHHE',0.4)

        call muwk(0,0)
        call mshplt_end

      endif !ixon

c} Plot y,z

        s0min=1.0e30
        s1min=1.0e30
        s2min=1.0e30
        s3min=1.0e30
        s0max=-1.0e30
        s1max=-1.0e30
        s2max=-1.0e30
        s3max=-1.0e30
        call util_zeit_kommentar(lun6,"Writing urad_stokes.dat")
        open(newunit=lun,file='urad_stokes.dat',recl=256)
        do ifreq=1,nphener
          s0=sngl(stokes(1,ifreq))
          s1=sngl(stokes(2,ifreq))
          s2=sngl(stokes(3,ifreq))
          s3=sngl(stokes(4,ifreq))
          write(lun,*)sngl(phener(ifreq)),s0,s1,s2,s3
          if (s0.lt.s0min) s0min=s0
          if (s1.lt.s1min) s1min=s1
          if (s2.lt.s2min) s2min=s2
          if (s3.lt.s3min) s3min=s3
          if (s0.gt.s0max) s0max=s0
          if (s1.gt.s1max) s1max=s1
          if (s2.gt.s2max) s2max=s2
          if (s3.gt.s3max) s3max=s3
        enddo
        flush(lun)
        close(lun)

      endif !kurad

      call util_zeit_kommentar(lun6,"Writing undumag_spectrum.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_spectrum.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (krunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      if (nphener.ne.0) then

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

      gsiz_ps=0.4

      xplmin=sngl(phelow)
      xplmax=sngl(phehig)

! S0
      yplmin=s0min
      yplmax=s0max

      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(4.,10.,12.,18.)

      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S0 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_get_axis_label_offset(xlaboff,ylaboff)
      call mshplt_set_axis_label_offset(xlaboff,ylaboff*0.75)
      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  yplmin,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      call mshplt_set_text_angle(0.)

      call mgset('PLCI',2.)

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(1,ifreq))
        ypl(2)=sngl(stokes(1,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

! S1
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(13.,19.,12.,18.)
      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S1 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  -yplmax-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      call mgset('PLCI',2.)

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(2,ifreq))
        ypl(2)=sngl(stokes(2,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

      call mgset('PLCI',4.)

! S2
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(4.,10.,4.,10.)
      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S2 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  -yplmax-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      call mgset('PLCI',2.)

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(3,ifreq))
        ypl(2)=sngl(stokes(3,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

! S3
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(13.,19.,4.,10.)
      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.15,0.0,'S3 [1/s/mm^2/0.1%BW,100mA]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.25,'Eph [eV]')

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  -yplmax-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  ' ',' ',' ')

      do ifreq=1,nphener-1
        xpl(1)=sngl(phener(ifreq))
        xpl(2)=sngl(phener(ifreq+1))
        ypl(1)=sngl(stokes(4,ifreq))
        ypl(2)=sngl(stokes(4,ifreq+1))
        call mpl(2,xpl,ypl)
      enddo

      call muwk(0,0)
      call mshplt_end

+self,if=-nowarnings.
      flush(lunwarn)
      close(lunwarn)
+self.,if=-nowarnings.

      endif !(nphener.ne.0) then

      if (kdumpconv.ne.0) then
        flush(lunconv)
        close(lunconv)
      endif

      if (killbadmag.lt.0.and.killbadmag.ne.-9999) then
        i=0
        call util_zeit_kommentar(lun6,"Writing undumag.bad")
        open(newunit=lunkill,file="undumag.bad")
        do kmag=1,nmag
          if (bpebc(16,kmag).ne.0.0d0) then
            write(lunkill,*)kmag,nint(bpebc(16,kmag)),bpebc(1:6,kmag)
            i=i+1
          endif
        enddo
        flush(lunkill)
        close(lunkill)
        write(lun6,*)
        write(lun6,*)"File undumag.bad written, number of bad voxel:",i
      endif

      if (idipoles.ne.0) then
        call util_zeit_kommentar(lun6,"Writing undumag_map.dip")
        open(newunit=lun,file="undumag_map.dip")
        do kmag=1,ndipoles
          write(lun,'(14e17.7e3)')dipoles(1:3,kmag),
     &      dipoles(4,kmag)*dipoles(5:7,kmag),dipoles(9:16,kmag)
        enddo
        flush(lun)
        close(lun)
      endif

      if (intmaglis.ne.0) then
        write(lun6,*)
        write(lun6,*)" --- Due to flag intmaglis, only magnets on file undumag_magmap.lis do contribute to field map ---"
        write(lun6,*)
      endif

c      call muwk(0,0)
c      call mshplt_end

+self,if=debugb.
      yint=0.0d0
      zint=0.0d0
      call undumag_bintinf_sym(0.0d0,yint,zint,1.0d0,0.0d0,0.0d0,
     &  bxintinf,byintinf,bzintinf,ifail)

      call undumag_field_int(1,
     &  1.0d0,yint,zint,
     &  1.0d0,0.0d0,0.0d0,
     &  bxi,byi,bzi,ifail)
      write(lun6,*)"---------------------------------------------"
      write(lun6,*)

      write(lun6,*)"Wahrheit a:",bxi*twopi*1000.0d0,byi*1000.0d0,bzi*1000.0d0
      write(lun6,*)"Wahrheit n:","           Null           ",byif,bzif
      write(lun6,*)"Wahrheit a:",bxi*twopi*1000.0d0,byi*twopi*1000.0d0,bzi*twopi*1000.0d0
      write(lun6,*)"Wahrheit n:","           Null           ",byif*twopi,bzif*twopi

+self.
+self,if=debuge.
      yint=0.0d0
      zint=0.0d0
      call undumag_bintinf_sym(0.0d0,yint,zint,1.0d0,0.0d0,0.0d0,
     &  bxintinf,byintinf,bzintinf,ifail)
      write(lun6,*)"Wahrheit a:",bxi*1000.0d0,byi*1000.0d0,bzi*1000.0d0
      write(lun6,*)"Wahrheit n:","           Null           ",byif,bzif
      write(lun6,*)"Näherung:  ","           Null          ",byint1infd,bzint1infd
      write(lun6,*)"Glaube:     ",
     &  bxintinf*1000.0d0,byintinf*1000.0d0,bzintinf*1000.0d0
+self.
      byplmin=1.0e30
      bzplmin=1.0e30
      byplmax=-1.0e30
      bzplmax=-1.0e30
      call util_zeit_kommentar(lun6,"Writing undumag_field_profile.dat")
      open(newunit=lunz,file='undumag_field_profile.dat')
      nz=(nint(zmaxprof-zminprof))+1
      zmin=dble(nint(zminprof))-1.0d0
      i=0
      do iz=1,nz
22      z=zmin+dble(iz)
        x=(xminbeff+xmaxbeff)/2.0d0
        y=0.0d0
        ! to avoid boundary effects:
        call util_random(3,g)
        g=g-0.5
c+self,if=rando10.
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif
c+self.,if=rando10.

        if (itry.eq.0.and.randoz.gt.0.0d0) g=0.

        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif

        if (randoz.ge.0.0d0) then
          z=z+g(3)*randoza
        else
          z=z+randoza
        endif

        ifail=0

        if (itry.eq.0) ifail=-1

        call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,bx,by,bz,ifail)

        if (itry.eq.0.and.ifail.eq.-1) then
          ifail=0
        endif

        if (ifail.ne.0.and.itry.lt.10) then
          itry=itry+1
          goto 22
        endif
        itry=0

        if (ifail.le.0) then
          i=i+1
          write(lunz,*)x,y,z,bx,by,bz
          zppl(i)=sngl(z)
          bypl(i)=sngl(by)
          bzpl(i)=sngl(bz)
          if (by.lt.byplmin) byplmin=sngl(by)
          if (by.gt.byplmax) byplmax=sngl(by)
          if (bz.lt.bzplmin) bzplmin=sngl(bz)
          if (bz.gt.bzplmax) bzplmax=sngl(bz)
        endif

      enddo
      flush(lunz)
      close(lunz)

      nz=i

      call util_zeit_kommentar(lun6,"Writing undumag_field_profile.eps")
      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_field_profile.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (krunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

c{ Plot By, Bz

      gsiz_ps=0.4

      xplmin=sngl(zminprof)
      xplmax=sngl(zmaxprof)
      yplmin=min(byplmin,bzplmin)
      yplmax=max(byplmax,bzplmax)
      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mplfra(
     &  xplmin-dxpl*0.05,
     &  xplmax+dxpl*0.05,
     &  yplmin-dypl*0.05,
     &  yplmax+dypl*0.05,
     &  '')

      call mgset('PLCI',2.)
      call mshplt_set_marker_size(0.5)

      do i=1,nz-1
        xpl(1)=sngl(zppl(i))
        xpl(2)=sngl(zppl(i+1))
        ypl(1)=sngl(bypl(i))
        ypl(2)=sngl(bypl(i+1))
        call mpl(2,xpl,ypl)
      enddo

      call mgset('PLCI',4.)

      do i=1,nz-1
        xpl(1)=sngl(zppl(i))
        xpl(2)=sngl(zppl(i+1))
        ypl(1)=sngl(bzpl(i))
        ypl(2)=sngl(bzpl(i+1))
        call mpl(2,xpl,ypl)
      enddo

      call mgset('CHHE',0.4)
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.9,-0.1,'z [mm]')
      call mshplt_set_text_angle(90.)
      if (abs(yplmax).lt.1.0e-3) then
        call mshplt_text_ndc(-0.1,0.86,'B [T]')
      else
        call mshplt_text_ndc(-0.1,0.88,'B [T]')
      endif
      call mshplt_set_text_angle(0.)
      call mgset('CHHE',0.5)
      call mshplt_set_text_color(0,1,0,0)
      call mshplt_text_ndc(0.85,0.9,'By')
      call mshplt_set_text_color(0,0,0,1)
      call mshplt_text_ndc(0.85,0.83,'Bz')
      call mshplt_set_text_color(1,0,0,0)
      call mgset('CHHE',0.4)

      call muwk(0,0)
      call mshplt_end

      call util_zeit_kommentar(lun6,"Writing undumag.wav")
      open(newunit=lunw,file='undumag.wav')

      write(lunw,'(a)')cundutit
      write(lunw,*)ncwires,nrec,nmag,nplanmax,ncornmax,' 20',' 3',' 8',
     &  " ! ncwires, nrec, nmag, nplanmax, ncornmax, 1_dim_bpebc, 1_dim_bperot, 2_dim_bpetm"
      write(lunw,*)ixsym,iysym,izsym,kxcenter,xsym,xcenter
      write(lunw,*)perlen,xmapmin,xmapmax,nper
      write(lunw,*)kurad,ebeam
      write(lunw,*)xelec,yelec,zelec
      write(lunw,*)vxelec,vyelec,vzelec
      write(lunw,*)xf,yf,zf
      write(lunw,*)efx,efy,efz
      write(lunw,*)tiny,window

      do kmag=1,nmag
        write(lunw,*)kmag
        write(lunw,*)bpebc(:,kmag)
        nplan=ibpeplan(kmag)
        write(lunw,*)nplan,ibpecol(kmag)
        do iplan=1,nplan
          ncorn=ibpecorn(iplan,kmag)
          write(lunw,*)ncorn
          do icorn=1,ncorn
            write(lunw,*)bpemag(1:3,icorn,iplan,kmag)
            write(lunw,*)bperot(1:3,icorn,iplan,kmag)
          enddo
          do i=1,8
            write(lunw,*)bpetm(1:3,i,iplan,kmag)
          enddo
        enddo
      enddo

      do i=1,ncwires
        write(lunw,*)wire(:,i)
      enddo

      flush(lunw)
      close(lunw)

      call undumag_uout

      call util_zeit_kommentar(lun6,"Writing undumag.mat")
+self,if=debugend.
      !all util_break
+self.

      open(newunit=lunmat,file="undumag.mat")

      write(lunmat,'(a)') '* ' // ctitle

      do mat=1,nmatfiles
        n=matmaps(4,mat)
        mtyp=matmaps(2,mat)
        if (mtyp.eq.1.and.nrec.gt.0) then
          if (n.eq.0) then
            if (newclc.ne.0) then
              br=0.0d0
              do ibrn=1,nbrnmat
                if (abs(brnmat(2,ibrn)).gt.br) br=abs(brnmat(2,ibrn))
              enddo
              kbrn=0
              do ibrn=1,nbrnmat
                if (nint(brnmat(1,ibrn)).eq.mat) then
                  kbrn=ibrn
                  exit
                endif
              enddo
              if (kbrn.eq.0) then
                write(lun6,*)
                write(lun6,*)"*** Warning in undumag_end: Could not find REC material in list of Br ***"
                write(lun6,*)"*** Be careful with plots of magnetisation ***"
              endif
              brn=sngl(abs(brnmat(2,ibrn)))
              hbmatmin=sngl(brn-bcmat(2,1,mat)*br)
              hbmatmax=sngl(brn+bcmat(2,1,mat)*br)
            endif !newclc
            write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(-br),hbmatmin,sngl(bcmat(3,1,mat))
            write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(br),hbmatmax,sngl(bcmat(3,1,mat))
          else
            do i=1,n
              write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(bcmat(1:3,i,mat))
            enddo
          endif
        else if (mtyp.eq.2) then
          do i=1,n
            write(lunmat,*) mat,mtyp,matmaps(3,mat),sngl(bcmat(1:3,i,mat))
          enddo
        endif !mtyp
      enddo

      flush(lunmat)
      close(lunmat)

      open(newunit=lunmat,file="undumag.brn")

      write(lunmat,'(a)') '* ' // ctitle

      do mat=1,nbrnmat
        write(lunmat,*) brnmat(1:2,mat)
      enddo

      flush(lunmat)
      close(lunmat)

      call clcmag_voxels_list(1)

      open(newunit=lunst,file="undumag.stat")
      write(lunst,*)"0"
      flush(lunst)
      close(lunst)

      flush(lunmag)
      close(lunmag)

9999  continue

      call  util_random_get_seed(irnsize,irnseed)

      call util_get_free_lun(lun)
      call util_zeit_kommentar(lun6,"Writing undumag.seeds")

      open(newunit=lun,file='undumag.seeds',status='unknown')

      write(lun,*)irnsize, kundurun
      do i=1,irnsize
        write(lun,*)i,irnseed(i)
      enddo

      flush(lun)
      close(lun)

      open(newunit=lun,file='undumag.gmd',status='unknown')
      write(lun,*)kundurun,modegui
      flush(lun)
      close(lun)

      return
      end
+DECK,undumag_bpolyeder.
*CMZ :  2.05/05 30/06/2024  16.06.24  by  Michael Scheer
*CMZ :  2.05/02 02/11/2023  14.14.41  by  Michael Scheer
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/00 26/10/2020  14.56.48  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  12.32.35  by  Michael Scheer
*CMZ :  2.01/03 15/07/2019  15.03.51  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  16.29.19  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  14.11.34  by  Michael Scheer
*CMZ :  1.23/03 19/09/2017  19.25.01  by  Michael Scheer
*CMZ :  1.23/02 30/08/2017  13.27.12  by  Michael Scheer
*CMZ :  1.22/02 31/07/2017  10.32.51  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.46.06  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  09.55.55  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  09.17.17  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.26.26  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  11.26.04  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  16.58.30  by  Michael Scheer
*CMZ :  1.15/10 12/04/2017  14.53.10  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.30.25  by  Michael Scheer
*CMZ :  1.15/03 03/04/2017  10.59.22  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  07.35.42  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  13.53.21  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.31.38  by  Michael Scheer
*CMZ :  1.11/03 16/01/2017  12.22.22  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  09.47.59  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.07/00 23/09/2016  09.19.06  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.10.51  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.27.23  by  Michael Scheer
*CMZ :  0.00/13 28/07/2016  16.09.29  by  Michael Scheer
*CMZ :  0.00/09 06/07/2016  08.42.18  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  13.18.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.13  by  Michael Scheer
*CMZ :  0.00/01 25/04/2016  16.03.15  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.41.34  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  09.46.51  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  13.27.16  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.31.31  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  13.53.25  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  10.43.50  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  18.38.48  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bpolyeder(xin,yin,zin,bxout,byout,bzout,ifail)
c
c      Calculation of magnetic field of polyhedron according to
c      Oleb Chubar, Pascal Elleaume and Joel Chavanne
c      J. Synchrotron Rad. (1998) 5, 481-484
c
c Paper contains an error: The rotation matrix is wrong, since for nz=-1 the
c                          determinant is -1, which yields to errors??.
c Private notice:
c Einige Terme sind unklar, Notizen finden sich im Ordner RADIA/POLYMAG
c Siehe auch Notebooks: rec_int.nb, qx_rect.nb etc.
c oder Reduce olegqz.red, qxqyqz.red, rec_int.red etc.

+self,if=omp.
      use omp_lib
+self.
      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none
+seq,debugutil.
+seq,seqdebug.

      double precision xin,yin,zin,bxout,byout,bzout
      double precision r1(3),r2(3),dlab(3),blab(3)
      double precision ts(3,3),tsinv(3,3),bplan(3),bcvn,vnormlab(3)
      double precision xx,yy,zz,xxrot,yyrot,zzrot
      double precision a,b,z,qx,qy,qz,
     &  pi4inv,reverse,tiny2,
     &  bxm,bym,bzm,bxp,byp,bzp
      double precision q(3,3),vmagrot(3),vmaglab(3),h(3),
     &  xr(2),yr(2),zr(2),dum,dume,bo(3,nthreadp)

c      double precision xmin,xmax,ymin,ymax,zmin,zmax,bx,by,bz

      parameter (pi4inv=0.0795774715459477d0)

      integer ical,ifound
      integer itiny,iwtiny,jtiny
      integer imag,iplan,ncorn,icorn,i,j,k,ip2,kwarn,kwarni,ic,moth
      integer ifailin,ifail,ifailm,ifailp,iout,linside,
     &  kfail(nthreadp),kinsidelocal(nthreadp)

      integer nmaxth,ith

      save bo,nmaxth,ith,ical,kinsidelocal

      data ical/0/

      kwarncom=0

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      tiny2=tiny*tiny

      ifailin=ifail
c      if (ifailin.eq.-1) then
c        print*,"undumag_bpolyeder: ifailin:",ifailin
c      endif
c      if (ifailin.ne.0) then
c        print*,"undumag_bpolyeder: kinside:",kinside
c      endif
      ifail=0
      ifailm=0
      ifailp=0

c calculate field at (xin,yin,zin)

      if (magmag.lt.0) then
        return
      endif !magmag.le.0

c      if (xin.eq.0.0d0) return
      xx=xin*1000.0d0
c      if (abs(xx+15.6).lt.0.05) then
c        iseqdebug=1
c      else
c        iseqdebug=0
c      endif
      yy=yin*1000.0d0
      zz=zin*1000.0d0

      itiny=0
      jtiny=0
      iwtiny=0

      if (ical.eq.0) then
        nmaxth=1
        ith=1
+self,if=omp.
        nmaxth=nthreads
        nmaxth=OMP_GET_MAX_THREADS()
        if (nthreads.gt.0) nmaxth=min(nmaxth,nthreads,nthreadp)
c        write(lun6,*)"Number of CPU cores used:",nmaxth
+self.
        bo=0.0d0
        ical=1
      endif

      bo=0.0d0
      kinsidelocal=kinside
      kwarni=0
      kwarn=0
      kfail=0

      iseqdebug=0

+self,if=omp.
!$OMP PARALLEL NUM_THREADS(nmaxth) DEFAULT(PRIVATE)
!$OMP& SHARED(i_debug,kfail,iseqdebug,kinsidelocal,ical,bpetm,window,bpebc,bpemag,ibpeplan,ibpecorn,bperot,bo,iwarnbound,nwarnbound)
!$OMP& FIRSTPRIVATE(nmag,itiny,jtiny,iwtiny,tiny,xin,yin,zin,xx,yy,zz,kwarni,kwarn,lun6)
      ith=OMP_GET_THREAD_NUM()+1
      bo(1:3,ith)=0.0d0
!$OMP DO
+self.
      do imag=1,nmag

        if (bpebc(17,imag).lt.0.0d0) then
          cycle
        endif

        moth=nint(bpebc(15,imag))

        bcvn=0.0d0
c        if(iseqdebug.eq.-8) print*,"1:",ith,imag,kinsidelocal(ith)

        if (abs(xx-bpebc(1,imag)).le.window) then

          !non-zero magnetization and no virgin shim
          if (bpebc(7,imag).ne.0.0d0.and.bpebc(7,imag).ne.9999.) then

            if(bpebc(8,imag).eq.1) then !not rectangular nor cylindrical magnet

c check, if we are inside of magnet; we assume convex shape
              if (kinsidelocal(ith).ne.-1) then

                iout=-1

                do iplan=1,ibpeplan(imag)

                  dlab(1)=xx-bpemag(1,1,iplan,imag)
                  dlab(2)=yy-bpemag(2,1,iplan,imag)
                  dlab(3)=zz-bpemag(3,1,iplan,imag)

                  vnormlab(1)=bpetm(1,8,iplan,imag)
                  vnormlab(2)=bpetm(2,8,iplan,imag)
                  vnormlab(3)=bpetm(3,8,iplan,imag)

                  if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &                dlab(3)*vnormlab(3).gt.0.0d0) then
                    iout=1
                    goto 97
                  endif

                enddo !iplan

97              continue
              endif !inside?

              do iplan=1,ibpeplan(imag)

                bcvn=-bpetm(1,7,iplan,imag)*pi4inv

                bplan(1)=0.d0
                bplan(2)=0.d0
                bplan(3)=0.d0

c transform everything to the nz=(0,0,1) system

c                if (iseqdebug.ne.0) dum=bcvn
                if (bcvn.eq.0.0d0) cycle

                if (ibpecorn(iplan,imag).gt.0) then

                  ts(1:3,1:3)=bpetm(1:3,1:3,iplan,imag)
                  tsinv(1:3,1:3)=bpetm(1:3,4:6,iplan,imag)

                  xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
                  yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
                  zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

                  ncorn=ibpecorn(iplan,imag)-1
                  do icorn=1,ncorn

                    ip2=icorn+1

                    r1(1)=bperot(1,icorn,iplan,imag)-xxrot
                    r1(2)=bperot(2,icorn,iplan,imag)-yyrot
                    r1(3)=bperot(3,icorn,iplan,imag)-zzrot

                    r2(1)=bperot(1,ip2,iplan,imag)-xxrot
                    r2(2)=bperot(2,ip2,iplan,imag)-yyrot
                    r2(3)=bperot(3,ip2,iplan,imag)-zzrot

                    if (abs(r1(1)-r2(1)).gt.tiny) then

                      a=(r2(2)-r1(2))/(r2(1)-r1(1))
                      b=r1(2)-a*r1(1)

                      if (abs(a).lt.tiny2) then
                        a=0.0d0
                        b=r1(2)
                      endif

                      z=r1(3)
                      kwarn=0

c                      if (iseqdebug.ne.0) iseqdebug=1
                      call undumag_bpeq(r1(1),r2(1),a,b,z,qx,qy,qz,
     &                  tiny,reverse,kwarn)
c                      if (iseqdebug.eq.2) then
c                        write(lun6,*)imag,iplan,icorn,kwarn
c                      endif

                      if (kwarn.ne.0) then
                        bpebc(16,imag)=kwarn
c                        write(lun6,*)"eder: kwarn,imag,xx,yy,zz",kwarn,imag,xx,yy,zz
                      endif
c                      if (kwarn.eq.1.or.kwarn.eq.6) kwarn=0
                      if (kwarn.eq.1.or.kwarn.eq.6.and.iwarn2pi.eq.0) kwarn=0
                      if (kwarn.eq.6) kwarni=6

c                      if (bcvn.ne.0.0d0) then
                      if (qx.ne.qx.or.qy.ne.qy.or.qz.ne.qz
     &                    .or.
     &                    (kwarn.ne.0)) then
                        kfail(ith)=imag
c                        if(iseqdebug.eq.-8) print*,"3:",ith,imag
c                        goto 799
                      endif !qx,qy,qz, kwarn

                      bplan(1)=bplan(1)-qx*bcvn
                      bplan(2)=bplan(2)-qy*bcvn
                      bplan(3)=bplan(3)-qz*bcvn
c                      endif !bcvn

c                      if (iseqdebug.ne.0) write(lun6,*)xin,iplan,icorn,bplan,kwarn
                    endif !r1(1)-r2(1)

                  enddo !icorn=1,ncorn

                  blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
                  blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
                  blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

                  if (
     &                blab(1).ne.blab(1)
     &                .or.
     &                blab(2).ne.blab(2)
     &                .or.
     &                blab(3).ne.blab(3)
     &                ) then
                    if (kudebug.eq.2) then
                      write(lun6,*)"*** Error 3 in undumag_bpolyeder: blab is not a number (NaN) ***"
                      write(lun6,*)
     &                  "imag,iplan,xin,yin,zin:",imag,iplan,xin,yin,zin,iseqdebug
c                    write(lun6,*)"blab",blab
c                    write(lun6,*)"tsinv",tsinv
                    endif
                    kfail(ith)=imag
c                    if(iseqdebug.eq.-8) print*,"4:",ith,imag
c                    stop
                  endif

                  bo(1,ith)=bo(1,ith)+blab(1)
                  bo(2,ith)=bo(2,ith)+blab(2)
                  bo(3,ith)=bo(3,ith)+blab(3)

                endif !ncorn

              enddo ! iplan=1,nplan

              if (iout.eq.-1) then
                if (kinsidelocal(ith).gt.0.) then
                  write(lun6,*)"*** Warning in subroutine undumag_bpolyeder: Inside Magnet or colliding Magnets: ",imag,kinsidelocal(ith)
c                  print*,i_debug
c                  stop
                endif
                kinsidelocal(ith)=moth
              endif !iout

            else !bpebc(8,imag) .eq. 1

              if (kinsidelocal(ith).ne.-1) then

                iout=-1

                do iplan=1,ibpeplan(imag)

                  dlab(1)=xx-bpemag(1,1,iplan,imag)
                  dlab(2)=yy-bpemag(2,1,iplan,imag)
                  dlab(3)=zz-bpemag(3,1,iplan,imag)

                  vnormlab(1)=bpetm(1,8,iplan,imag)
                  vnormlab(2)=bpetm(2,8,iplan,imag)
                  vnormlab(3)=bpetm(3,8,iplan,imag)

                  if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &                dlab(3)*vnormlab(3).gt.0.d0) then
                    iout=1
                    goto 911
                  endif

                enddo !iplan

                if (iout.eq.-1) then
                  if (kinsidelocal(ith).gt.0) then
                    write(lun6,*)"*** Error 2 in subroutine undumag_bpolyeder: Colliding Magnets: ",imag,kinsidelocal(ith)
c                    stop
                  endif
                  kinsidelocal(ith)=moth
                endif !iout

911             continue
              endif !inside?

c rectangular or cylindrical magnet
              vmaglab(1:3)=bpebc(4:6,imag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

              ts(1:3,1:3)=bpetm(1:3,1:3,1,imag)
              tsinv(1:3,1:3)=bpetm(1:3,4:6,1,imag)

              xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
              yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
              zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

              vmagrot(1)=
     &          ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
              vmagrot(2)=
     &          ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
              vmagrot(3)=
     &          ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

              xr(1)=bperot(1,1,1,imag)-xxrot
              xr(2)=bperot(1,2,1,imag)-xxrot
              yr(1)=bperot(2,1,1,imag)-yyrot
              yr(2)=bperot(2,3,1,imag)-yyrot
              zr(1)=bperot(3,1,1,imag)-zzrot
              zr(2)=bperot(3,1,3,imag)-zzrot

              if (xr(1).eq.0.0d0) xr(1)=1.0d-15
              if (xr(2).eq.0.0d0) xr(2)=1.0d-15
              if (yr(1).eq.0.0d0) yr(1)=1.0d-15
              if (yr(2).eq.0.0d0) yr(2)=1.0d-15
              if (zr(1).eq.0.0d0) zr(1)=1.0d-15
              if (zr(2).eq.0.0d0) zr(2)=1.0d-15

              q=0.0d0

              q(1,2)=1.0d0
              q(1,3)=1.0d0
              q(2,3)=1.0d0

              do i=1,2
                do j=1,2
                  do k=1,2
                    q(1,1)=q(1,1)+
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                yr(j)/xr(i)*zr(k)/
     &                sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
     &                )

                    q(2,2)=q(2,2)+
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                xr(j)/yr(i)*zr(k)/
     &                sqrt(yr(i)**2+xr(j)**2+zr(k)**2)
     &                )

                     dum=
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                yr(j)/zr(i)*xr(k)/
     &                sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
     &                )
                    q(3,3)=q(3,3)+dum
c                    write(lun6,*)"--- imag,zzrot",imag,zzrot
c                    write(lun6,*)"i,j,k",i,j,k,xr(k),yr(j),zr(i)
c                    write(lun6,*)"xx,dum,q33",xx,dum,q(3,3)

                    dum=zr(k)+sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
                    dume=(-1.0d0)**(i+j+k)

                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(1,2)=q(1,2)*dum
                      else
                        q(1,2)=q(1,2)/dum
                      endif
                    endif

                    dum=yr(k)+sqrt(xr(i)**2+zr(j)**2+yr(k)**2)
                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(1,3)=q(1,3)*dum
                      else
                        q(1,3)=q(1,3)/dum
                      endif
                    endif

                    dum=xr(k)+sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(2,3)=q(2,3)*dum
                      else
                        q(2,3)=q(2,3)/dum
                      endif
                    endif

                  enddo !k
                enddo !j
              enddo !i

              q(1,2)=log(q(1,2))
              q(1,3)=log(q(1,3))
              q(2,3)=log(q(2,3))

              q(2,1)=q(1,2)
              q(3,1)=q(1,3)
              q(3,2)=q(2,3)

              h(1)=
     &          -(q(1,1)*vmagrot(1)+q(1,2)*vmagrot(2)+q(1,3)*vmagrot(3))*
     &          pi4inv
              h(2)=
     &          -(q(2,1)*vmagrot(1)+q(2,2)*vmagrot(2)+q(2,3)*vmagrot(3))*
     &          pi4inv
              h(3)=
     &          -(q(3,1)*vmagrot(1)+q(3,2)*vmagrot(2)+q(3,3)*vmagrot(3))*
     &          pi4inv

              bplan(1)=h(1)
              bplan(2)=h(2)
              bplan(3)=h(3)

c              write(lun6,*)"h============================:",h

              blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
              blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
              blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

              bo(1,ith)=bo(1,ith)+blab(1)
              bo(2,ith)=bo(2,ith)+blab(2)
              bo(3,ith)=bo(3,ith)+blab(3)

            endif !(bpebc(8,imag).eq.1)

          endif !non-zero magnetization

c        write(lun6,'(3g15.5)'),xin,imag,imag,bo(2,ith)

        endif !window
c799     continue
      enddo !imag=1,nmag
+self,if=omp.
!$OMP END DO
!$OMP END PARALLEL
+self.

      do ic=1,nmaxth
        ifail=ifail+kfail(ic)
        bxout=bxout+bo(1,ic)
        byout=byout+bo(2,ic)
        bzout=bzout+bo(3,ic)
      enddo

      if (kinside.ne.-1) then
        kinside=0
        ifound=0
        do ic=1,nmaxth
          kinside=kinside+kinsidelocal(ic)
          if (kinsidelocal(ic).gt.0) ifound=ifound+1
          if (ifound.gt.0.and.i_debug.eq.0) then
            print*,ical,kinsidelocal(1:nmaxth)
            i_debug=1
          endif
          if (ifound.gt.1) then
            write(lun6,*)"*** Error 3 in subroutine undumag_bpolyeder: Colliding Magnet: ",kinsidelocal(ic)
c            stop
          endif
        enddo
      endif

      if (bxout.ne.bxout.or.byout.ne.byout.or.bzout.ne.bzout
     &  .or.bxout.gt.1.0d30
     &  .or.byout.gt.1.0d30
     &    .or.bzout.gt.1.0d30) then
        bxout=0.0d0
        byout=0.0d0
        bzout=0.0d0
        ifail=11
      endif

      if (abs(bxout).le.1.0d-15) bxout=0.0d0
      if (abs(byout).le.1.0d-15) byout=0.0d0
      if (abs(bzout).le.1.0d-15) bzout=0.0d0

c      if (iseqdebug.ne.0) write(lun6,*)"ifail:",ifail
      if (ifail.ne.0) goto 7799

      goto 7979

7799  continue

      if (corrtiny.eq.0.0) then
        ifail=-4
        goto 7979
      endif

      if (kudebug.eq.2) then
        write(lun6,*)"*** ifail,xin,yin,zin"
      endif

      kwarncom=1
      ifail=-3

C Not working for unknown reasons for OMP ?? still true 20.4.2017??

      if (kinside.ne.-1) then
        kinside=0
      endif

      call undumag_bpolyeder_corr(xin-corrtiny,yin-corrtiny,zin-corrtiny,
     &  bxm,bym,bzm,ifailm)

      if (kinside.ne.-1) then
        linside=kinside
        kinside=0
      endif

      call undumag_bpolyeder_corr(xin+corrtiny,yin+corrtiny,zin+corrtiny,
     &  bxp,byp,bzp,ifailp)

      if (kinside.ne.-1) then
        kinside=max(linside,kinside)
      endif

      if (ifailm.eq.0.and.ifailp.eq.0) then
        bxout=(bxm+bxp)/2.0d0
        byout=(bym+byp)/2.0d0
        bzout=(bzm+bzp)/2.0d0
        ifail=-1
        kwarncom=1
      else if (ifailm.eq.0) then
        bxout=bxm
        byout=bym
        bzout=bzm
        kwarncom=2
        ifail=2
      else if (ifailp.eq.0) then
        bxout=bxp
        byout=byp
        bzout=bzp
        kwarncom=2
        ifail=2
      else
        if (ifailin.ge.0) then
          write(lun6,*) "*** Warning in undumag_bpolyeder: Could not recover for x,y,z:",
     &      sngl(xin*1000.),sngl(yin*1000.0),sngl(zin*1000.)
          write(lun6,*)"Differences in Bx,By,Bz, abs. and. rel.:",
     &      sngl(abs(bxp-bxm)),sngl(abs(byp-bym)),sngl(abs(bzp-bzm))
        endif
        bxout=(bxm+bxp)/2.0d0
        byout=(bym+byp)/2.0d0
        bzout=(bzm+bzp)/2.0d0
        if (ifailin.ge.0) then
          print '(6e15.4)',
     &      abs((bxp-bxm)/(bxout+1.0d-15)),abs((byp-bym)/(byout+1.0d-15)),
     &      abs((bzp-bzm)/(bzout+1.0d-15))
        endif
        kwarncom=3
        ifail=3
      endif

7979  continue

c      if (ncwires+nrace.gt.0) then
c        call undumag_bcoils(xin,yin,zin,bx,by,bz,istat)
c        bxout=bxout+bx
c        byout=byout+by
c        bzout=bzout+bz
c        if (istat.ne.0) ifail=ifail+1000
c      endif

      return
      end
+DECK,undumag_field.
*CMZ :  2.05/05 30/06/2024  16.17.15  by  Michael Scheer
*CMZ :  2.05/02 02/11/2023  11.04.17  by  Michael Scheer
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 12/04/2021  14.05.35  by  Michael Scheer
*CMZ :  2.02/00 21/01/2021  13.24.48  by  Michael Scheer
*CMZ :  2.01/08 14/08/2020  10.40.03  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.26.49  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  12.45.27  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  14.15.52  by  Michael Scheer
*CMZ :  1.23/03 19/09/2017  19.32.15  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  14.10.42  by  Michael Scheer
*CMZ :  1.15/11 19/04/2017  14.47.22  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  15.43.17  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  14.43.16  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  13.43.20  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.20.28  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  15.33.12  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  16.02.08  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  09.46.04  by  Michael Scheer
*CMZ :  1.17/13 07/04/2016  17.38.21  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.53.04  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.28.51  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.49.46  by  Michael Scheer
*-- Author :    Michael Scheer   03/04/2016
      subroutine undumag_field(x,y,z,bxout,byout,bzout,ifail)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

+seq,debugutil.

      double precision x,y,z,hx,hy,hz,bxout,byout,bzout,xcut,bx,by,bz
      integer ifail,ifailin,kfail,linside

      integer :: ical=0
      save ical

c      kfail=iwarnbound
      ifailin=ifail
      ifail=0
c      kinside=0 ! use as flag, see undmag_end

      if (knomagmap.eq.0.and.knopolmap.eq.0.and.ifailin.eq.0) then
        kinside=0
      else
        kinside=-1
      endif

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      if (nrec.eq.0.and.kbextern.eq.0.and.ncwires.eq.0) then
        bxout=0.0d0
        byout=0.0d0
        bzout=0.0d0
        return
      endif

      linside=kinside

c      if (i_debug.le.-7) then
c        call util_break
c      endif

      if (nmag.ne.0) then

+self,if=msingle.
        if (ical.eq.0) then
          write(lun6,*)"*** Using undmag_bpolyeder_single(...) due to CMZ selection msingle ***"
          write(lun6,*)"*** CHECK TREATMENT OF COILS"
          stop
          ical=1
        endif
        linside=kinside
        call undumag_bpolyeder_single(x,y,z,bxout,byout,bzout,ifail)
        goto 111
+self.

        !x1y1z1
        kfail=ifailin
        call undumag_bpolyeder(x,y,z,bxout,byout,bzout,kfail)

        if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail

        if (kinside.gt.0) then
          linside=kinside
          kinside=0
        endif

        if (ixsym.eq.0) then

          if (iysym.ne.0) then
            kfail=ifailin
            call undumag_bpolyeder(x,-y,z,hx,hy,hz,kfail)
            if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout-hz
          endif

          if (izsym.ne.0) then
            kfail=ifailin
            call undumag_bpolyeder(x,y,-z,hx,hy,hz,kfail)
            if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout+hx
            byout=byout+hy
            bzout=bzout-hz
          endif

          if (iysym.ne.0.and.izsym.ne.0) then
            kfail=ifailin
            call undumag_bpolyeder(x,-y,-z,hx,hy,hz,kfail)
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout+hz
          endif

        else !ixsym

          xcut=2.0d0*xsym-x

          !x2y1z1
          kfail=ifailin
          call undumag_bpolyeder(xcut,y,z,hx,hy,hz,kfail)
          if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
          if (kinside.gt.0) then
            linside=kinside
            kinside=0
          endif
          bxout=bxout-hx
          byout=byout+hy
          bzout=bzout+hz

          if (iysym.ne.0) then
            !x1y2z1
            kfail=ifailin
            call undumag_bpolyeder(x,-y,z,hx,hy,hz,kfail)
            if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout-hz
            !x2y1z1
            kfail=ifailin
            call undumag_bpolyeder(xcut,-y,z,hx,hy,hz,kfail)
            if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout+hx
            byout=byout+hy
            bzout=bzout-hz
          endif

          if (izsym.ne.0) then
            !x1y1z2
            kfail=ifailin
            call undumag_bpolyeder(x,y,-z,hx,hy,hz,kfail)
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
            bxout=bxout+hx
            byout=byout+hy
            bzout=bzout-hz
            !x2y1z2
            kfail=ifailin
            call undumag_bpolyeder(xcut,y,-z,hx,hy,hz,kfail)
            if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout-hz
          endif

          if (iysym.ne.0.and.izsym.ne.0) then
            !x2y2z2
            kfail=ifailin
            call undumag_bpolyeder(xcut,-y,-z,hx,hy,hz,kfail)
            if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout+hx
            byout=byout+hy
            bzout=bzout+hz
            !x1y2z2
            kfail=ifailin
            call undumag_bpolyeder(x,-y,-z,hx,hy,hz,kfail)
            if (ifail.ne.-1.and.kfail.ne.-1) ifail=ifail+kfail
            if (kinside.gt.0) then
              linside=kinside
              kinside=0
            endif
            bxout=bxout-hx
            byout=byout+hy
            bzout=bzout+hz
          endif

        endif !ixsym

      endif !(nmag.ne.0)

111   continue

      if (Abs(bxout).lt.1.0d-15) bxout=0.0d0
      if (Abs(byout).lt.1.0d-15) byout=0.0d0
      if (Abs(bzout).lt.1.0d-15) bzout=0.0d0

c      if (iwarnbound.ne.kfail) kfail=100+ifail

      if (ncwires.gt.0) then
        call undumag_bcoils(x,y,z,bx,by,bz,ifail)
        bxout=bxout+bx
        byout=byout+by
        bzout=bzout+bz
      endif

      if (kbextern.ne.0) then
        bxout=bxout+bxex
        byout=byout+byex
        bzout=bzout+bzex
      endif

      kinside=linside
c13.6.2024      if (kinside.gt.0) ifail=ifail-20000

      return
      end
+DECK,undumag_bpolypl2.
*CMZ :  2.05/06 10/10/2024  11.17.58  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  12.39.31  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.46.26  by  Michael Scheer
*CMZ :  1.17/02 09/10/2014  14.45.46  by  Michael Scheer
*CMZ :  1.17/01 03/10/2014  09.56.30  by  Michael Scheer
*CMZ :  1.16/04 16/04/2014  14.24.21  by  Michael Scheer
*CMZ :  1.12/16 01/06/2007  11.17.50  by  Michael Scheer
*CMZ :  2.00/00 16/08/2004  15.07.36  by  Michael Scheer
*CMZ :  1.03/00 16/08/2004  14.00.31  by  Michael Scheer
*CMZ :  1.02/04 13/08/2004  15.35.19  by  Michael Scheer
*-- Author :    Michael Scheer   13/08/2004
      subroutine undumag_bpolypl2(xpl,ypl,col,ixyz)

+seq,bpolyederf90u.

      implicit none

+seq,bpolyeder,if=static.

      real xpl(2), ypl(2), x(2), y(2), col,rlwidtho
      integer ixyz

      if (nbforcx*nbforcy*nbforcz.eq.0) return

      call muwk(0,0)

      call mgset('PLCI',col)
      call mgset('PMCI',col)
      call mgset('MTYP',31.)
      call mgset('MSCF',5.)

      call mshplt_get_line_width(rlwidtho)
      call mshplt_set_line_width(rlwidtho*2.)

      if (ixyz.eq.12) then
        x(1)=sngl(torqcenxmm)
        y(1)=sngl(torqcenymm)
        call mpm(1,x,y)
        x(1)=sngl(outbox(1,1))
        y(1)=sngl(outbox(1,2))
        x(2)=sngl(outbox(2,1))
        y(2)=sngl(outbox(2,2))
        call mshplt_box(x(1),y(1),x(2),y(2))
        call muwk(0,0)
      else if (ixyz.eq.13) then
        x(1)=sngl(torqcenxmm)
        y(1)=sngl(torqcenzmm)
        call mpm(1,x,y)
        x(1)=sngl(outbox(1,1))
        y(1)=sngl(outbox(1,3))
        x(2)=sngl(outbox(2,1))
        y(2)=sngl(outbox(2,3))
        call mshplt_box(x(1),y(1),x(2),y(2))
      else if (ixyz.eq.23) then
        x(1)=sngl(torqcenzmm)
        y(1)=sngl(torqcenymm)
        call mpm(1,x,y)
        x(1)=sngl(outbox(1,3))
        y(1)=sngl(outbox(1,2))
        x(2)=sngl(outbox(2,3))
        y(2)=sngl(outbox(2,2))
        call mshplt_box(x(1),y(1),x(2),y(2))

      else

        call mgset('PMCI',1.)

        x(1)=xpl(1)
        x(2)=xpl(2)
        y(1)=ypl(1)
        y(2)=ypl(1)
        call mpl(2,x,y)

        x(1)=xpl(1)
        x(2)=xpl(1)
        y(1)=ypl(1)
        y(2)=ypl(2)
        call mpl(2,x,y)

        x(1)=xpl(1)
        x(2)=xpl(2)
        y(1)=ypl(2)
        y(2)=ypl(2)
        call mpl(2,x,y)

        x(1)=xpl(2)
        x(2)=xpl(2)
        y(1)=ypl(1)
        y(2)=ypl(2)
        call mpl(2,x,y)

      endif

      call mshplt_set_line_width(rlwidtho)
      call muwk(0,0)

      return
      end
+DECK,undumag_force_dipoles.
*CMZ :  2.05/07 12/10/2024  07.30.51  by  Michael Scheer
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  1.25/00 29/01/2018  11.03.33  by  Michael Scheer
*CMZ :  1.24/01 13/10/2017  08.16.08  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  14.26.18  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  08.44.11  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  09.27.56  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  12.25.04  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.16.46  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  16.55.27  by  Michael Scheer
*-- Author :    Michael Scheer   24/01/2017
      subroutine undumag_force_dipoles

      use undumagf90m
      use bpolyederf90m

      use commandlinef90m

      use commandlinef90m

      implicit none

      double precision :: eps=0.0001 !Meter
      double precision x,y,z,xm,xp,ym,yp,zm,zp,bxm,bym,bzm,bxp,byp,bzp,p(3),pn,
     &  dbxdx,dbxdy,dbxdz,
     &  dbydx,dbydy,dbydz,
     &  dbzdx,dbzdy,dbzdz

      integer imag,ifail,kmag,luno,kfail,moth,kmoth

      call util_zeit_kommentar(lun6,"Starting force calculations for dipole approximation")

      print*," "
      print*,"** Undumag_force_dipoles is obsolete, be careful ***"
      print*," "

      if (kallodip.ne.1) then
        x=0.0d0
        y=0.0d0
        z=0.0d0
        call undumag_dipoles_field(x,y,z,bxm,bym,bzm,ifail)
      endif

      fxdip=0.0d0
      fydip=0.0d0
      fzdip=0.0d0

      txdip=0.0d0
      tydip=0.0d0
      tzdip=0.0d0

      if (chforcemag.eq.'') goto 9999

      if (kforcemag.eq.0) then
        write(lun6,*)
        write(lun6,*)"*** Warning in undumag_force_dipoles: Magnet ",
     &    trim(chforcemag),
     &    " not found ***"
        write(lun6,*)"*** Check undumag_magnets.lis ***"
        write(lun6,*)
        goto 9999
      endif

      kmoth=bpebc(15,kforcemag)
      do kmag=1,ndipoles
        moth=nint(dipoles(9,kmag))
        if (moth.eq.kmoth) then
          call undumag_force_dipoles_nos(kmag,kfail)
        endif
      enddo

 9999 continue

      write(lun6,*)
      write(lun6,*)'* FxDip [N], FyDip [N], FzDip [N]:'
      write(lun6,'(3f15.4)')fxdip,fydip,fzdip
      write(lun6,*)
      write(lun6,*)'* TxDip, TyDip, TzDip [Nmm]:'
      write(lun6,'(3f15.4)')txdip*1000.0d0,tydip*1000.0d0,tzdip*1000.0d0
      write(lun6,*)

      open(newunit=luno,file='undumag.dfr')
      write(luno,*)'* FxDip, FyDip, FzDip [N]:'
      write(luno,'(3f15.4)')fxdip,fydip,fzdip
      write(luno,*)'* TxDip, TyDip, TzDip [Nmm]:'
      write(luno,'(3f15.4)')txdip*1000.0d0,tydip*1000.0d0,tzdip*1000.0d0
      close(luno)

      call util_zeit_kommentar(lun6,"Force calculations for dipole approximation finished")

      return
      end
+DECK,undumag_bpolyeder_corr.
*CMZ :  2.05/05 25/06/2024  08.45.36  by  Michael Scheer
*CMZ :  2.05/02 02/11/2023  14.14.41  by  Michael Scheer
*CMZ :  2.02/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.01/03 15/07/2019  11.55.46  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  13.35.13  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.55.33  by  Michael Scheer
*CMZ :  1.20/00 22/06/2017  08.44.13  by  Michael Scheer
*CMZ :  1.15/11 20/04/2017  16.01.40  by  Michael Scheer
*CMZ :  1.15/03 02/04/2017  15.55.59  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  17.59.10  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  13.53.21  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.31.38  by  Michael Scheer
*CMZ :  1.11/03 16/01/2017  12.22.22  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  09.47.59  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.07/00 23/09/2016  09.19.06  by  Michael Scheer
*CMZ :  1.04/01 14/09/2016  15.10.51  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.27.23  by  Michael Scheer
*CMZ :  0.00/13 28/07/2016  16.09.29  by  Michael Scheer
*CMZ :  0.00/09 06/07/2016  08.42.18  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  13.18.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.13  by  Michael Scheer
*CMZ :  0.00/01 25/04/2016  16.03.15  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.41.34  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  09.46.51  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  13.27.16  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.31.31  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  13.53.25  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  10.43.50  by  Michael Scheer
*CMZ :  1.17/03 21/03/2016  18.38.48  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine undumag_bpolyeder_corr(xin,yin,zin,bxout,byout,bzout,ifail)
c
c      Calculation of magnetic field of polyhedron according to
c      Oleb Chubar, Pascal Elleaume and Joel Chavanne
c      J. Synchrotron Rad. (1998) 5, 481-484
c
c Paper contains an error: The rotation matrix is wrong, since for nz=-1 the
c                          determinant is -1, which yields to errors??.
+self,if=omp.
      use omp_lib
+self.
      use bpolyederf90m
      use undumagf90m

      use commandlinef90m

      implicit none

+seq,seqdebug.
+seq,debugutil.

      double precision xin,yin,zin,bxout,byout,bzout
      double precision r1(3),r2(3),dlab(3),blab(3)
      double precision ts(3,3),tsinv(3,3),bplan(3),bcvn,vnormlab(3)
      double precision xx,yy,zz,xxrot,yyrot,zzrot,xx00,xxsh
      double precision a,b,z,qx,qy,qz,qxp,qyp,qzp,qxm,qym,qzm,
     &  pi4inv,reverse,tiny2,
     &  bxm,bym,bzm,bxp,byp,bzp,rr0,rrm
      double precision q(3,3),vmagrot(3),vmaglab(3),h(3),
     &  xr(2),yr(2),zr(2),dum,dume,bo(3,nthreadp)

      double precision xmin,xmax,ymin,ymax,zmin,zmax,bx,by,bz

      parameter (pi4inv=0.0795774715459477d0)

      integer ical,kc
      integer itiny,iwtiny,jtiny,ifound
      integer imag,iplan,icorn,i,j,k,ip2,kwarn,ic
      integer nx,ny,nz,ifail,ishim,ishima,iimag,nmag1,nmag2,iout,
     &  kfail(nthreadp),kinsidelocal(nthreadp)

      integer nmaxth,ith
      integer :: idebug=0

      save bo,nmaxth,ith,ical,kinsidelocal

      data ical/0/

      if (magmag.gt.0) then
        write(lun6,*)"*** Error: Call to undumag_bpolyeder_corr in undumag_bpolyeder_corr!"
        stop
      endif

      bxout=0.0d0
      byout=0.0d0
      bzout=0.0d0

      tiny2=tiny*tiny

      ifail=0

c calculate field at (xin,yin,zin)

      if (magmag.lt.0) then
        return
      endif !magmag.le.0

c      if (xin.eq.0.0d0) return
      xx=xin*1000.0d0
      yy=yin*1000.0d0
      zz=zin*1000.0d0

      itiny=0
      jtiny=0
      iwtiny=0

      if (ical.eq.0) then
        nmaxth=1
        ith=1
+self,if=omp.
        nmaxth=nthreads
        nmaxth=OMP_GET_MAX_THREADS()
        if (nthreads.gt.0) nmaxth=min(nmaxth,nthreads,nthreadp)
        write(lun6,*)"Number of CPU cores used:",nmaxth
+self.
        bo=0.0d0
        ical=1
      endif

c      ical=ical+1
c      write(lun6,*)"eder",ical,nmaxth
      bo=0.0d0
      kinsidelocal=kinside
      kfail=0

      iseqdebug=0

+self,if=omp.
!$OMP PARALLEL NUM_THREADS(nmaxth) DEFAULT(PRIVATE) SHARED(kfail,iseqdebug,kinsidelocal,ical,bpetm,window,bpebc,bpemag,ibpeplan,ibpecorn,bperot,bo,iwarnbound,nwarnbound) FIRSTPRIVATE(nmag,itiny,jtiny,iwtiny,tiny,xx,yy,zz)
c      if (ical.eq.4) stop
      ith=OMP_GET_THREAD_NUM()+1
      bo(1:3,ith)=0.0d0
!$OMP DO
+self.
      do imag=1,nmag

        if (iseqdebug.eq.-9.and.imag.eq.3) then
c          c64_debug='in corrp'
          call util_break
        endif

        if (bpebc(17,imag).lt.0.0d0) then
          cycle
        endif

        if (abs(xx-bpebc(1,imag)).le.window) then

          !non-zero magnetization and no virgin shim
          if (bpebc(7,imag).ne.0.0d0.and.bpebc(7,imag).ne.9999.) then

            if(bpebc(8,imag).eq.1) then !not rectangular nor cylindrical magnet

c check, if we are inside of magnet; we assume convex shape
              if (kinsidelocal(ith).ne.-1) then

                iout=-1

                do iplan=1,ibpeplan(imag)

                  dlab(1)=xx-bpemag(1,1,iplan,imag)
                  dlab(2)=yy-bpemag(2,1,iplan,imag)
                  dlab(3)=zz-bpemag(3,1,iplan,imag)

                  vnormlab(1)=bpetm(1,8,iplan,imag)
                  vnormlab(2)=bpetm(2,8,iplan,imag)
                  vnormlab(3)=bpetm(3,8,iplan,imag)

                  if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &                dlab(3)*vnormlab(3).gt.0.d0) then
                    iout=1
                    goto 97
                  endif

                enddo !iplan

                if (iout.eq.-1) then
                  kinsidelocal(ith)=imag
                endif !iout

97              continue
              endif !inside?

              do iplan=1,ibpeplan(imag)

                bcvn=-bpetm(1,7,iplan,imag)*pi4inv
c                write(lun6,*)"undumag_bpolyeder_corr:",imag,iplan,bpetm(1,7,iplan,imag)

                bplan(1)=0.d0
                bplan(2)=0.d0
                bplan(3)=0.d0

c transform everything to the nz=(0,0,1) system

c                if (iseqdebug.ne.0) write(lun6,*)"bcvn:",bcvn
                if (bcvn.eq.0.0d0) cycle

                if (ibpecorn(iplan,imag).gt.0) then

                  ts(1:3,1:3)=bpetm(1:3,1:3,iplan,imag)
                  tsinv(1:3,1:3)=bpetm(1:3,4:6,iplan,imag)

c                  do i=1,3
c                    do j=1,3
c                      ts(i,j)=bpetm(i,j,iplan,imag)
c                      tsinv(i,j)=bpetm(i,j+3,iplan,imag)
c                    enddo
c                  enddo

                  xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
                  yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
                  zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

                  do icorn=1,ibpecorn(iplan,imag)-1

                    ip2=icorn+1

                    r1(1)=bperot(1,icorn,iplan,imag)-xxrot
                    r1(2)=bperot(2,icorn,iplan,imag)-yyrot
                    r1(3)=bperot(3,icorn,iplan,imag)-zzrot

                    r2(1)=bperot(1,ip2,iplan,imag)-xxrot
                    r2(2)=bperot(2,ip2,iplan,imag)-yyrot
                    r2(3)=bperot(3,ip2,iplan,imag)-zzrot

                    if (abs(r1(1)-r2(1)).gt.tiny) then

                      a=(r2(2)-r1(2))/(r2(1)-r1(1))
                      b=r1(2)-a*r1(1)

                      if (abs(a).lt.tiny2) then
                        a=0.0d0
                        b=r1(2)
                      endif

                      z=r1(3)
                      kwarn=0

                      call undumag_bpeq(r1(1),r2(1),a,b,z,qx,qy,qz,
     &                  tiny,reverse,kwarn)

c                      if (bcvn.ne.0.0d0) then
                      if (qx.ne.qx.or.qy.ne.qy.or.qz.ne.qz
     &                    .or.
     &                    (kwarn.ne.0.and.kwarn.ne.6)) then
                        kfail(ith)=imag
                        goto 799
                      endif !qx,qy,qz, kwarn

                      bplan(1)=bplan(1)-qx*bcvn
                      bplan(2)=bplan(2)-qy*bcvn
                      bplan(3)=bplan(3)-qz*bcvn
c                      endif !bcvn

                    endif
                  enddo !icorn=1,ncorn

                  blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
                  blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
                  blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

                  if (
     &                blab(1).ne.blab(1)
     &                .or.
     &                blab(2).ne.blab(2)
     &                .or.
     &                blab(3).ne.blab(3)
     &                ) then
                    write(lun6,*)"*** Error 3 in undumag_bpolyeder_corr: blab is not a number (NaN) ***"
                    write(lun6,*)
     &                "imag,iplan,xin,yin,zin:",imag,iplan,xin,yin,zin
                    write(lun6,*)"blab",blab
                    write(lun6,*)"tsinv",tsinv
                    stop
                  endif
                  bo(1,ith)=bo(1,ith)+blab(1)
                  bo(2,ith)=bo(2,ith)+blab(2)
                  bo(3,ith)=bo(3,ith)+blab(3)
                endif !ncorn

              enddo ! iplan=1,nplan

            else !bpebc(8,imag) .eq. 1

              if (kinsidelocal(ith).ne.-1) then

                iout=-1

                do iplan=1,ibpeplan(imag)

                  dlab(1)=xx-bpemag(1,1,iplan,imag)
                  dlab(2)=yy-bpemag(2,1,iplan,imag)
                  dlab(3)=zz-bpemag(3,1,iplan,imag)

                  vnormlab(1)=bpetm(1,8,iplan,imag)
                  vnormlab(2)=bpetm(2,8,iplan,imag)
                  vnormlab(3)=bpetm(3,8,iplan,imag)

c                  write(lun6,*)"x,dlab:",xx,dlab
c                  write(lun6,*)"vnormlablab:",vnormlab
                  if( dlab(1)*vnormlab(1)+dlab(2)*vnormlab(2)+
     &                dlab(3)*vnormlab(3).gt.0.d0) then
                    iout=1
                    goto 911
                  endif

                enddo !iplan

                if (iout.eq.-1) then
                  kinsidelocal(ith)=imag
                endif !iout

911             continue
              endif !inside?

c rectangular or cylindrical magnet
              vmaglab(1:3)=bpebc(4:6,imag)

c transform everything to the nz=(0,0,1) system and rotate it parallel to x-axis

              ts(1:3,1:3)=bpetm(1:3,1:3,1,imag)
              tsinv(1:3,1:3)=bpetm(1:3,4:6,1,imag)

              xxrot=ts(1,1)*xx+ts(1,2)*yy+ts(1,3)*zz
              yyrot=ts(2,1)*xx+ts(2,2)*yy+ts(2,3)*zz
              zzrot=ts(3,1)*xx+ts(3,2)*yy+ts(3,3)*zz

              vmagrot(1)=
     &          ts(1,1)*vmaglab(1)+ts(1,2)*vmaglab(2)+ts(1,3)*vmaglab(3)
              vmagrot(2)=
     &          ts(2,1)*vmaglab(1)+ts(2,2)*vmaglab(2)+ts(2,3)*vmaglab(3)
              vmagrot(3)=
     &          ts(3,1)*vmaglab(1)+ts(3,2)*vmaglab(2)+ts(3,3)*vmaglab(3)

              xr(1)=bperot(1,1,1,imag)-xxrot
              xr(2)=bperot(1,2,1,imag)-xxrot
              yr(1)=bperot(2,1,1,imag)-yyrot
              yr(2)=bperot(2,3,1,imag)-yyrot
              zr(1)=bperot(3,1,1,imag)-zzrot
              zr(2)=bperot(3,1,3,imag)-zzrot

              if (xr(1).eq.0.0d0) xr(1)=1.0d-15
              if (xr(2).eq.0.0d0) xr(2)=1.0d-15
              if (yr(1).eq.0.0d0) yr(1)=1.0d-15
              if (yr(2).eq.0.0d0) yr(2)=1.0d-15
              if (zr(1).eq.0.0d0) zr(1)=1.0d-15
              if (zr(2).eq.0.0d0) zr(2)=1.0d-15

              q=0.0d0

              q(1,2)=1.0d0
              q(1,3)=1.0d0
              q(2,3)=1.0d0

c              if (xr(1).eq.0.0d0.or.yr(1).eq.0.0d0.or.zr(1).eq.0.0d0
c     &            .or.xr(2).eq.0.0d0.or.yr(2).eq.0.0d0.or.zr(2).eq.0.0d0
c     &            ) then
c                xx=xx+tiny2
cc                yy=yy+tiny2
c                zz=zz+tiny2
c                goto 1
c              endif

              do i=1,2
                do j=1,2
                  do k=1,2
                    q(1,1)=q(1,1)+
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                yr(j)/xr(i)*zr(k)/
     &                sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
     &                )

                    q(2,2)=q(2,2)+
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                xr(j)/yr(i)*zr(k)/
     &                sqrt(yr(i)**2+xr(j)**2+zr(k)**2)
     &                )

                     dum=
     &                (-1)**(i+j+k+1)*
     &                atan(
     &                yr(j)/zr(i)*xr(k)/
     &                sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
     &                )
                    q(3,3)=q(3,3)+dum
c                    write(lun6,*)"--- imag,zzrot",imag,zzrot
c                    write(lun6,*)"i,j,k",i,j,k,xr(k),yr(j),zr(i)
c                    write(lun6,*)"xx,dum,q33",xx,dum,q(3,3)

                    dum=zr(k)+sqrt(xr(i)**2+yr(j)**2+zr(k)**2)
                    dume=(-1.0d0)**(i+j+k)

                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(1,2)=q(1,2)*dum
                      else
                        q(1,2)=q(1,2)/dum
                      endif
                    endif

                    dum=yr(k)+sqrt(xr(i)**2+zr(j)**2+yr(k)**2)
                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(1,3)=q(1,3)*dum
                      else
                        q(1,3)=q(1,3)/dum
                      endif
                    endif

                    dum=xr(k)+sqrt(zr(i)**2+yr(j)**2+xr(k)**2)
                    if (dum.ne.0.0d0) then
                      if (dume.gt.0.0d0) then
                        q(2,3)=q(2,3)*dum
                      else
                        q(2,3)=q(2,3)/dum
                      endif
                    endif

                  enddo !k
                enddo !j
              enddo !i

              q(1,2)=log(q(1,2))
              q(1,3)=log(q(1,3))
              q(2,3)=log(q(2,3))

              q(2,1)=q(1,2)
              q(3,1)=q(1,3)
              q(3,2)=q(2,3)

              h(1)=
     &          -(q(1,1)*vmagrot(1)+q(1,2)*vmagrot(2)+q(1,3)*vmagrot(3))*
     &          pi4inv
              h(2)=
     &          -(q(2,1)*vmagrot(1)+q(2,2)*vmagrot(2)+q(2,3)*vmagrot(3))*
     &          pi4inv
              h(3)=
     &          -(q(3,1)*vmagrot(1)+q(3,2)*vmagrot(2)+q(3,3)*vmagrot(3))*
     &          pi4inv

              bplan(1)=h(1)
              bplan(2)=h(2)
              bplan(3)=h(3)

c              write(lun6,*)"h============================:",h

              blab(1)=tsinv(1,1)*bplan(1)+tsinv(1,2)*bplan(2)+tsinv(1,3)*bplan(3)
              blab(2)=tsinv(2,1)*bplan(1)+tsinv(2,2)*bplan(2)+tsinv(2,3)*bplan(3)
              blab(3)=tsinv(3,1)*bplan(1)+tsinv(3,2)*bplan(2)+tsinv(3,3)*bplan(3)

              bo(1,ith)=bo(1,ith)+blab(1)
              bo(2,ith)=bo(2,ith)+blab(2)
              bo(3,ith)=bo(3,ith)+blab(3)

            endif !(bpebc(8,imag).eq.1)

          endif !non-zero magnetization

c        write(lun6,'(3g15.5)'),xin,imag,imag,bo(2,ith)

        endif !window
799     continue
      enddo !imag=1,nmag
+self,if=omp.
!$OMP END DO
!$OMP END PARALLEL
+self.

9999  continue


      do ic=1,nmaxth
        ifail=ifail+kfail(ic)
        bxout=bxout+bo(1,ic)
        byout=byout+bo(2,ic)
        bzout=bzout+bo(3,ic)
      enddo

      if (kinside.ne.-1) then
        kinside=0
        ifound=0
        do ic=1,nmaxth
          kinside=kinside+kinsidelocal(ic)
          if(kinsidelocal(ic).gt.0) ifound=ifound+1
          if (ifound.gt.1) then
            write(lun6,*)"*** Error in undumag_bpolyeder_corr: Colliding Magnet: ",kinsidelocal(ic)
c            stop
          endif
          if (idebug.ne.0) then
            if (kinsidelocal(ic).ne.0) then
              do kc=1,nmaxth
                if (kc.eq.ic) cycle
                if (kinsidelocal(kc).ne.0) then
                  write(lun6,*)"nThread, kinsidelocal(nThread)",
     &              kc,kinsidelocal(kc)
                endif
              enddo
            endif
          endif !idebug
        enddo
      endif

      if (bxout.ne.bxout.or.byout.ne.byout.or.bzout.ne.bzout
     &  .or.bxout.gt.1.0d30
     &  .or.byout.gt.1.0d30
     &    .or.bzout.gt.1.0d30) then
        bxout=0.0d0
        byout=0.0d0
        bzout=0.0d0
        ifail=-1
      endif

      if (abs(bxout).le.1.0d-15) bxout=0.0d0
      if (abs(byout).le.1.0d-15) byout=0.0d0
      if (abs(bzout).le.1.0d-15) bzout=0.0d0

c      if (ical.gt.2) stop

      return
      end
+DECK,clcmag_sym.
*CMZ :  2.05/07 25/10/2024  11.41.44  by  Michael Scheer
*CMZ :  2.04/19 17/09/2023  20.40.22  by  Michael Scheer
*CMZ :  2.04/07 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.04/06 02/05/2023  10.37.14  by  Michael Scheer
*CMZ :  2.04/04 06/03/2023  16.27.00  by  Michael Scheer
*CMZ :  2.03/00 31/08/2022  08.24.49  by  Michael Scheer
*CMZ :  2.02/02 17/02/2022  11.05.25  by  Michael Scheer
*CMZ :  2.02/01 10/02/2022  21.54.35  by  Michael Scheer
*-- Author :    Michael Scheer   01/10/2021
      subroutine clcmag_sym

      use undumagf90m
      use bpolyederf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      double precision xsymmm,xlen,dx,dxcon(100),
     &  xmin,xmax,ymin,ymax,zmin,zmax,tiny2

      real g(3)

      integer i

      if (ixsym.lt.0.or.iysym.lt.0.or.izsym.lt.0) then
        print*,"*** Error in clcmag_sym: Hard symmetry operations, i.e. duplication of magnets not allowed ***"
        stop
      endif

      xcentershift=0.0d0

      xcwmin= 1.0d30
      xcwmax=-1.0d30
      ycwmin= 1.0d30
      ycwmax=-1.0d30
      zcwmin= 1.0d30
      zcwmax=-1.0d30

      if (ncwires.gt.0) then
        do i=1,ncwires
          if (abs(wire(2,i)).lt.1.0e-30) cycle
          if (wire(3,i).lt.xcwmin) xcwmin=wire(3,i)
          if (wire(6,i).lt.xcwmin) xcwmin=wire(6,i)
          if (wire(3,i).gt.xcwmax) xcwmax=wire(3,i)
          if (wire(6,i).gt.xcwmax) xcwmax=wire(6,i)
          if (wire(4,i).lt.ycwmin) ycwmin=wire(4,i)
          if (wire(7,i).lt.ycwmin) ycwmin=wire(7,i)
          if (wire(4,i).gt.ycwmax) ycwmax=wire(4,i)
          if (wire(7,i).gt.ycwmax) ycwmax=wire(7,i)
          if (wire(5,i).lt.zcwmin) zcwmin=wire(5,i)
          if (wire(8,i).lt.zcwmin) zcwmin=wire(8,i)
          if (wire(5,i).gt.zcwmax) zcwmax=wire(5,i)
          if (wire(8,i).gt.zcwmax) zcwmax=wire(8,i)
        enddo
      endif

      xmin=xmin_t
      ymin=ymin_t
      zmin=zmin_t

      xmax=xmax_t
      ymax=ymax_t
      zmax=zmax_t

      xsymmm=xsym

      if (xsymmm.eq.9999.0d0) xsymmm=xcenter
      if (xsym.ne.9999.0d0) xsym=xsym/1000.0d0

      xsymmm_t=xsymmm

      if (kxcenter.ne.0) then

        if (ixsym.eq.0) then
          xcentershift=xcenter-(xmax_t+xmin_t)/2.0d0
        else
          xcentershift=xcenter-xsymmm
        endif

        xmin_t=xmin_t+xcentershift
        xmax_t=xmax_t+xcentershift

        do i=1,ncwires
          wire(3,i)=wire(3,i)+xcentershift
          wire(6,i)=wire(6,i)+xcentershift
        enddo

        write(lun6,*)
        write(lun6,*) "xcenter, shift:",xcenter,xcentershift
        write(lun6,*)

      endif !kxcenter

      if (nmag_t+nspecmag_t.eq.0.or.(nxconv.eq.0.and.dxconv.eq.0.0d0)) then
        nxconv=1
        xconv(1)=0.0d0
        goto 1234
      endif

      nxconv=abs(nxconv)

      if (xconvmin.eq.9999.0d0) then
        xconvmin=xmin_t+mod(xmin_t,perlen)-1.0d0*perlen
        if (xconvmin.gt.xcwmin) xconvmin=xcwmin
      endif !(xconvmin.eq.9999.0d0) then

      if (xconvmax.eq.9999.0d0) then
        if (kxcenter.ne.0) then
          xconvmax=xcenter
        else
          xconvmax=xmax_t-mod(xmax_t,perlen)+2.0d0*perlen
        endif
        if (xconvmax.lt.xcwmax) xconvmax=xcwmax
      endif !(xconvmax.eq.9999.0d0) then

      if (xconvmax.le.xconvmin) xconvmin=xconvmax-perlen/2.0d0

      if (nxconv.eq.9999) then
        nxconv=min(100,nint((xconvmax-xconvmin)/perlen*2)+1)
      else if (nxconv.gt.100) then
        write(lun6,*)"*** Warning in clcmag_sym: nxconv changed to limit of 100 ***"
        nxconv=100
      endif

      if (dxconv.eq.0.0d0) then
        dxconv=(xconvmax-xconvmin)/max(1,nxconv-1)

      else if (dxconv.eq.9999.0d0) then
        dxconv=perlen/2.0d0
        if (perlen.le.0.0d0) then
          stop "*** Error in clcmag_sym: Negative period-length ***"
        endif
        nxconv=nint((xconvmax-xconvmin)/dxconv)+1
        if (nxconv.gt.100) then
          write(lun6,*)"*** Warning in clcmag_sym: dxconv changed to limit nxconv to 100 ***"
          nxconv=100
        endif
        dxconv=(xconvmax-xconvmin)/max(1,nxconv-1)

      else if (dxconv.lt.0.0d0) then
        dxcon(1)=0.0d0
        dx=1.0d0
        do i=2,nxconv
          dxcon(i)=dxcon(i-1) + dx
          dx=dx*abs(dxconv)
        enddo
        xlen=dxcon(nxconv)
        do i=2,nxconv
          xconv(i)=xconv(i-1) + (dxcon(i)-dxcon(i-1))*(xconvmax-xconvmin)/xlen
        enddo
      else
        do i=1,nxconv
          xconv(i)=xconvmin+dxconv*(i-1)
        enddo
      endif !(dxconv.lt.0.0d0) then

      do i=1,nxconv
        ! to avoid boundary effects:
        call util_random(2,g)
        g=g-0.5
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        xconv(i)=(xconv(i)+g(1)*randoxa)/1000.0d0
      enddo

      yconv=yconv/1000.0d0

      if (abs(g(2)).lt.randoz10) then
        if (g(2).gt.0.0d0) then
          g(2)=g(2)+randoz10
        else
          g(2)=g(2)-randoz10
        endif
      endif

      if (zconv.eq.0.0d0) then
        if (randoza.gt.0.0d0) then
          zconv=(zconv+g(2)*randoza)/1000.0d0
        else
          zconv=(zconv+randoza)/1000.0d0
        endif
      else
        zconv=zconv/1000.0d0
      endif

1234  continue

      window=uwindow
      kdebug=kudebug

      tiny=1.1d-6
      tiny=corrtiny

      if (nmag_t+nspecmag_t.eq.0.and.ncwires+nrace.eq.0.and.kbextern.eq.0) then
        xmapmin=0.1
        xmapmax=0.1
      endif

      if (xmapmin.eq.9999.0d0) then
        xmapmin=xmin_t+mod(xmin_t,perlen)-9.0d0*perlen
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      else if (xmapmin.eq.9000.0d0) then
        xmapmin=xcenter-perlen/2.0d0
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      else if (xmapmin.eq.-9000.0d0) then
        xmapmin=xcenter-perlen/4.0d0
        if (xmapmin.gt.xcwmin) xmapmin=xcwmin
      endif

      if (xmapmax.eq.9999.0d0) then
        xmapmax=xmax_t-mod(xmax_t,perlen)+10.0d0*perlen
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      else if (xmapmax.eq.9000.0d0) then
        xmapmax=xcenter+perlen/2.0d0
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      else if (xmapmax.eq.-9000.0d0) then
        xmapmax=xcenter+perlen/4.0d0
        if (xmapmax.lt.xcwmax) xmapmax=xcwmax
      endif

      if (dxmap.eq.0.0d0.and.nxmap.eq.0.0d0) then
        nxmap=1
      endif

      if (dxmap.eq.9999.0d0) then
        if (nxbeff.gt.1) then
          dxmap=perlen/(nxbeff-1)
        else
          dxmap=perlen
        endif
      endif

      if (dxmap.ne.0.0d0) nxmap=nint((xmapmax-xmapmin)/dxmap)+1

      if (nxmap.le.0) then
        write(lun6,*)"*** Warning in clcmag_sym: nxmap.le.0 ***"
      endif

      if (nymap.le.0) nymap=1
      if (nzmap.le.0) nzmap=1

      if (ixsym.gt.0) then
        if (xmin.lt.xsymmm-tiny2.and.xmax.gt.xsymmm+tiny2) then
          write(lun6,*)"*** Error in input: Option ixsym is set, but not all x-values are on the same side of xsymm!"
          write(lun6,*)"*** Program undumag aborted ***"
          stop
        endif
        dx=xsymmm-xmin
        xmax=xsymmm+dx
        xsym=xsymmm/1000.0d0
        xmapmax=-xmapmin
      else
        xmin=xmin_t
        xmax=xmax_t
      endif

      if (iysym.ne.0) then
        if (ymin.lt.-tiny2.and.ymax.gt.tiny2) then
          write(lun6,*)"*** Error in input: Option iysym is set, but not all y-values have the same sign!"
          if (iysym.gt.0) then
            write(lun6,*)"*** Program undumag aborted ***"
            stop
          endif
        endif
        ymax=max(abs(ymax),abs(ymin))
        ymin=-ymax
      else
        ymin=ymin_t
        ymax=ymax_t
      endif

      if (izsym.ne.0) then
        if (zmin.lt.-tiny2.and.zmax.gt.tiny2) then
          if (izsym.gt.0) then
            write(lun6,*)"*** Error in input: Option izsym is set, but not all z-values have the same sign!"
            write(lun6,*)"*** Program undumag aborted ***"
            stop
          else if (izsym.lt.0) then
            write(lun6,*)"*** Warning in input: Option izsym is set, but not all z-values have the same sign!"
          endif
        endif
        zmax=max(abs(zmax),abs(zmin))
        zmin=-zmax
      else
        zmin=zmin_t
        zmax=zmax_t
      endif

      if (dxmap.ne.0.0d0) then
        nxmap=nint((xmapmax-xmapmin)/dxmap)+1
      endif

      xmin_t=xmin
      ymin_t=ymin
      zmin_t=zmin

      xmax_t=xmax
      ymax_t=ymax
      zmax_t=zmax

      if (nmag_t+nspecmag_t.gt.0) then
        xmin_t=min(xmin_t,xcwmin)
        xmax_t=max(xmax_t,xcwmax)
        ymin_t=min(ymin_t,ycwmin)
        ymax_t=max(ymax_t,ycwmax)
        zmin_t=min(zmin_t,zcwmin)
        zmax_t=max(zmax_t,zcwmax)
      else
        xmin_t=xcwmin
        xmax_t=xcwmax
        ymin_t=ycwmin
        ymax_t=ycwmax
        zmin_t=zcwmin
        zmax_t=zcwmax
      endif

      return
      end
+DECK,clcmag_bpolyplot.
*CMZ :  2.05/07 25/10/2024  11.42.23  by  Michael Scheer
*CMZ :  2.05/06 10/10/2024  11.18.39  by  Michael Scheer
*CMZ :  2.05/05 25/06/2024  10.28.04  by  Michael Scheer
*CMZ :  2.04/11 28/08/2023  14.35.56  by  Michael Scheer
*CMZ :  2.04/10 23/08/2023  16.06.46  by  Michael Scheer
*CMZ :  2.04/09 16/08/2023  09.50.47  by  Michael Scheer
*CMZ :  2.04/07 07/08/2023  12.29.11  by  Michael Scheer
*CMZ :  2.04/03 04/03/2023  17.12.50  by  Michael Scheer
*CMZ :  2.04/01 13/02/2023  14.10.28  by  Michael Scheer
*CMZ :  2.03/00 23/07/2022  08.30.04  by  Michael Scheer
*CMZ :  2.02/02 18/02/2022  10.24.23  by  Michael Scheer
*CMZ :  2.02/01 30/01/2022  08.39.29  by  Michael Scheer
*CMZ :  2.02/00 21/10/2020  09.46.44  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  13.07.52  by  Michael Scheer
*CMZ :  2.01/02 25/04/2018  11.48.35  by  Michael Scheer
*CMZ :  1.25/01 19/03/2018  16.23.08  by  Michael Scheer
*CMZ :  1.25/00 15/03/2018  21.02.34  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.20.09  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  12.45.15  by  Michael Scheer
*CMZ :  1.17/08 27/05/2017  10.32.42  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  14.33.44  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.09.14  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.50  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.39.32  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.47.10  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.49.25  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.46.16  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.01.00  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  13.31.06  by  Michael Scheer
*CMZ :  1.02/01 08/09/2016  15.25.02  by  Michael Scheer
*CMZ :  1.02/00 23/08/2016  12.01.08  by  Michael Scheer
*CMZ :  0.00/13 31/07/2016  16.05.11  by  Michael Scheer
*CMZ :  0.00/01 25/04/2016  15.07.20  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.27.40  by  Michael Scheer
*CMZ :  1.17/02 09/10/2014  14.52.20  by  Michael Scheer
*CMZ :  1.17/01 03/10/2014  11.25.46  by  Michael Scheer
*CMZ :  1.17/00 25/08/2014  15.14.09  by  Michael Scheer
*CMZ :  1.16/04 16/04/2014  15.34.26  by  Michael Scheer
*CMZ :  1.16/01 14/03/2014  12.26.15  by  Michael Scheer
*CMZ :  1.12/16 01/06/2007  11.17.50  by  Michael Scheer
*CMZ :  1.12/08 02/08/2006  17.03.41  by  Michael Scheer
*CMZ :  1.11/03 21/06/2005  12.56.55  by  Michael Scheer
*CMZ :  1.11/01 01/03/2005  09.45.36  by  Michael Scheer
*CMZ :  1.10/04 25/02/2005  11.55.05  by  Michael Scheer
*CMZ :  2.52/05 17/08/2004  08.54.30  by  Michael Scheer
*CMZ :  1.01/01 11/08/2004  13.30.53  by  Michael Scheer
*CMZ :  1.01/00 02/03/2004  17.00.13  by  Michael Scheer
*CMZ :  1.00/01 27/02/2004  14.29.35  by  Michael Scheer
*CMZ :  1.00/00 26/02/2004  17.21.29  by  Michael Scheer
*CMZ :  0.99/13 26/02/2004  16.14.57  by  Michael Scheer
*CMZ :  0.99/12 26/02/2004  12.02.34  by  Michael Scheer
*CMZ :  0.99/11 25/02/2004  15.21.06  by  Michael Scheer
*CMZ :  0.99/10 25/02/2004  13.42.35  by  Michael Scheer
*CMZ :  0.99/09 20/02/2004  17.26.48  by  Michael Scheer
*CMZ :  0.99/08 20/02/2004  16.32.55  by  Michael Scheer
*CMZ :  0.99/07 16/02/2004  15.21.29  by  Michael Scheer
*CMZ :  0.99/03 12/02/2004  13.55.05  by  Michael Scheer
*CMZ :  0.99/00 26/01/2004  17.03.49  by  Michael Scheer
*CMZ :  0.00/08 23/01/2004  12.52.23  by  Michael Scheer
*CMZ :  0.00/07 16/01/2004  11.05.44  by  Michael Scheer
*CMZ :  0.00/06 09/01/2004  15.55.17  by  Michael Scheer
*CMZ :  0.00/05 23/12/2003  14.52.54  by  Michael Scheer
*CMZ :  0.00/04 23/12/2003  10.15.07  by  Michael Scheer
*CMZ :  0.00/02 15/12/2003  12.43.34  by  Michael Scheer
*CMZ :  0.00/01 10/12/2003  17.56.52  by  Michael Scheer
*-- Author :    Michael Scheer   02/12/2003
      subroutine clcmag_bpolyplot(iplot,xmin,xmax,ymin,ymax,zmin,zmax,
     &  theta,phi,nwitems,ncwires,wire)

+seq,bpolyederf90u.

      use commandlinef90m
      use magnets_structure

      implicit none

+seq,mshplt.
+seq,bpolyeder,if=static.

      integer npawp
      parameter (npawp=10000)

      integer nwitems,ncwires
      double precision wire(nwitems,ncwires)

      real, dimension (:), allocatable :: rmothb,rmagb,rcolb,rplanb,rcornb,
     &  xb,yb,zb,bxb,byb,bzb,rmatb

      real, dimension (:), allocatable :: xpl,ypl,zpl,zplm,xmpl,ympl,zmpl
      integer, dimension (:), allocatable :: ispole,ispolemag

      real
     &  xplb(2),yplb(2),zplb(2),xt(1),yt(1),zt(1),
     &  xplbo(2),yplbo(2),zplbo(2),rmtyp31,rmtyp24,rmtyp20,rlwidth,rlwidtho

      real xyzmin,xyzmax,xmin,xmax,ymin,ymax,zmin,zmax,theta,phi,
     &  x,y,z,bx,by,bz,dx,dy,dz,bxo,byo,bzo,bo,eps,
     &  xmn,xmx,ymn,ymx,zmn,zmx,
     &  xmmn,xmmx,ymmn,ymmx,zmmn,zmmx,
     &  xplmin,xplmax,yplmin,yplmax,zplmin,zplmax,
     &  rmoth,rmag,rcol,rplan,rcorn,rmat,
     &  xc,yc,zc,xmc(1),ymc(1),zmc(1),dot0,circ0,pscal,vn,vnx,vnz

      integer i,iplot,iplot1,iplot10,iplot100,idev,
     &  imag,icol,iplan,icorn,kpole,
     &  iplano,ncorno,iline,iw,nline,iallo,
     &  ncorn,ncornmax,igird,imago,impl,izero,nfirst,nlast

      integer :: luncnf,lunmag,ical=0

      character(64) ctitle,cline
      character(32), dimension(:), allocatable ::  cnam,cmoth

      data dot0/25./
      data circ0/5./
      data rmtyp20/20./
      data rmtyp24/-9999./
      data rmtyp31/31./

      data eps/0.01/

      iallo=0
      ical=ical+1

      write(lun6,*)
      if (kunduplot_mode.eq.0) then
        write(lun6,*) "Reading file undumag.mag and writing geometry to plotfile undumag.eps"
      else
        write(lun6,*) "Reading file undumag.mag and writing geometry to plotfile undumag_3d.eps"
      endif
      write(lun6,*)

      open(newunit=luncnf,file='.mshplt.cnf')

      write(luncnf,'(a)')"0 !idev, 0: viewer is not used"
      write(luncnf,'(a)')"-20. -20. !plot size in cm, negative values indicate HIGZ compatible mode"
      write(luncnf,'(a)')"1.0 !rescaling factor; if not one, plot files are copied and rescaled"
      write(luncnf,'(a)')"0 0 800 800 !bounding box"
      if (kunduplot_mode.ne.0) then
        write(luncnf,'(a)')"undumag_3d.eps !base name of plotfiles"
      else
        write(luncnf,'(a)')"undumag.eps !base name of plotfiles"
      endif
      write(luncnf,'(a)')"$UNDUMAG/shell/undumag_viewer.sh"
      write(luncnf,'(a)')"$UNDUMAG/shell/undumag_kill_viewer.sh"

      close(luncnf)

      iplano=0
      nline=0

      xmn=sngl(xmin_t)
      xmx=sngl(xmax_t)
      ymn=sngl(ymin_t)
      ymx=sngl(ymax_t)
      zmn=sngl(zmin_t)
      zmx=sngl(zmax_t)

      if (jrunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      ncornmax=ncornmax_t
      if (ncwires.gt.0) then
        ncornmax=max(2,ncornmax_t)
      endif

      open(newunit=lunmag,file='undumag.mag',status='old')
      read(lunmag,'(a)')cline
1     read(lunmag,*,end=9) rmoth,rmag,rcol,rplan,rcorn,x,y,z,bx,by,bz,rmat
      if (bx**2+by**2+bz**2.eq.0.0d0) goto 1
      nline=nline+1
      goto 1
9     rewind(lunmag)

      allocate(
     &  rmothb(nline),rmagb(nline),rcolb(nline),rplanb(nline),rcornb(nline),
     &  xb(nline),yb(nline),zb(nline),bxb(nline),byb(nline),bzb(nline),
     &  rmatb(nline),cnam(nline),cmoth(nline),ispole(nline),ispolemag(nline))

      read(lunmag,'(a)')cline

      do i=1,nline
        read(lunmag,*)
     &  rmothb(i),rmagb(i),rcolb(i),rplanb(i),rcornb(i),
     &  xb(i),yb(i),zb(i),bxb(i),byb(i),bzb(i),
     &    rmatb(i),cnam(i),cmoth(i),ispole(i)
        if (rmatb(i).eq.0) then
          bxb(i)=0.0
          byb(i)=0.0
          bzb(i)=0.0
        endif
        if (abs(bxb(i)).lt.1.0e-12) bxb(i)=0.0
        if (abs(byb(i)).lt.1.0e-12) byb(i)=0.0
        if (abs(bzb(i)).lt.1.0e-12) bzb(i)=0.0
        imag=nint(rmagb(i))
        ispolemag(imag)=ispole(i)
      enddo

      close(lunmag)

      if (ncornmax.eq.0.and.ncwires.le.0) then
        write(lun6,*)"*** Warning in clcmag_bpolyplot: Nothing to plot!?"
        goto 9999
      endif

      allocate(xpl(ncornmax))
      allocate(ypl(ncornmax))
      allocate(zpl(ncornmax))
      allocate(zplm(ncornmax))

      allocate(xmpl(ncornmax*nplanmax_t))
      allocate(ympl(ncornmax*nplanmax_t))
      allocate(zmpl(ncornmax*nplanmax_t))

      iallo=1

      call mlimit(npawp)

      if (jdate.ne.0) then
        call mplopt('DATE',1)
      else
        call mplopt('NDAT',1)
      endif

      call mplint(idev)

      if (jdate.ne.0) then
        call mplopt('DATE',1)
      else
        call mplopt('NDAT',1)
      endif

      call mplset('YGTI',0.)
      call mplset('GSIZ',0.3)
      call mgset('TXCI',1.)

      iplot100=abs(iplot)/100
      iplot10=(abs(iplot)-iplot100*100)/10
      iplot1=abs(iplot)-iplot100*100-iplot10*10

      call mshplt_get_line_width(rlwidtho)
      rlwidth=rlwidtho
      call mshplt_set_line_width(rlwidtho/2.)

c--- Open plotfiles {

      if (iplot.gt.0) then

        if (idev.ne.0) then
          call mgmeta(98,-111)    !seite 22
        else
          call mgmeta(-98,-111)    !seite 22
        endif

      else if (iplot.lt.0) then

        if (idev.ne.0) then
          call mgmeta(98,-113)    !seite 22
        else
          call mgmeta(-98,-113)    !seite 22
        endif

      endif !iplot

c--- Open plotfiles }

      iplano=1

      if (xmin.eq.9999.) then
        xplmin=xmn
      else
        xplmin=xmin
      endif

      if (xmax.eq.9999.) then
        xplmax=xmx
      else
        xplmax=xmax
      endif

      if (ymin.eq.9999.) then
        yplmin=ymn
      else
        yplmin=ymin
      endif

      if (ymax.eq.9999.) then
        yplmax=ymx
      else
        yplmax=ymax
      endif

      if (zmin.eq.9999.) then
        zplmin=zmn
      else
        zplmin=zmin
      endif

      if (zmax.eq.9999.) then
        zplmax=zmx
      else
        zplmax=zmax
      endif

      if (nbforcx*nbforcy*nbforcy.ne.0) then
        dx=(sngl(outbox(2,1))-sngl(outbox(1,1)))*0.1
        if (xplmin.ge.sngl(outbox(1,1))) xplmin=sngl(outbox(1,1))-dx
        if (xplmax.le.sngl(outbox(2,1))) xplmax=sngl(outbox(2,1))+dx
        dy=(sngl(outbox(2,2))-sngl(outbox(1,2)))*0.1
        if (yplmin.ge.sngl(outbox(1,2))) yplmin=sngl(outbox(1,2))-dy
        if (yplmax.le.sngl(outbox(2,2))) yplmax=sngl(outbox(2,2))+dy
        dz=(sngl(outbox(2,3))-sngl(outbox(1,3)))*0.1
        if (zplmin.ge.sngl(outbox(1,3))) zplmin=sngl(outbox(1,3))-dz
        if (zplmax.le.sngl(outbox(2,3))) zplmax=sngl(outbox(2,3))+dz
      endif

      dx=(xplmax-xplmin)*0.05
      if (xmin.eq.9999.) then
        xplmin=xplmin-dx
      endif

      if (xmax.eq.9999.) then
        xplmax=xplmax+dx
      endif

      dy=(yplmax-yplmin)*0.05
      if (ymin.eq.9999.) then
        yplmin=yplmin-dy
      endif

      if (ymax.eq.9999.) then
        yplmax=yplmax+dy
      endif

      dz=(zplmax-zplmin)*0.05
      if (zmin.eq.9999.) then
        zplmin=zplmin-dz
      endif

      if (zmax.eq.9999.) then
        zplmax=zplmax+dz
      endif

      if (dx.eq.0.0d0) then
        dx=1.05
        xplmin=xplmin-dx
        xplmax=xplmax+dx
      endif

      if (dy.eq.0.0d0) then
        dy=1.05
        yplmin=yplmin-dy
        yplmax=yplmax+dy
      endif

      if (dz.eq.0.0d0) then
        dz=1.05
        zplmin=zplmin-dz
        zplmax=zplmax+dz
      endif

      if (xplmax.le.xplmin.or.zplmax.le.zplmin.or.zplmax.le.zplmin) then
        write(lun6,*)'*** Warning in clcmag_bpolyplot: Bad coordinate system for plotting '
        goto 9999
      endif

      pscal=min(3.,sqrt(10000./((xplmax-xplmin)*(zplmax-zplmin))))

c--- 3D, top and side views {

      if (jcomment.ne.0) call mtitle(trim(ctitle))

      call mplzon(1,1,1,' ')
      call mplfra(0.,10.,0.,10.,'AB')

      if (kunduplot_mode.eq.0) then

        call mplset('YMGL',0.5)

        if (theta.ne.0.0.or.phi.ne.0.0) then

          call mgset('CHHE',0.2)
          call mplzon(2,2,1,'S')
          call mplfr3(0.,1.,0.,1.,0.,1.,theta,phi,'W')

          xpl(1)=-0.8
          xpl(2)=-0.6
          ypl(1)=-0.8
          ypl(2)=-0.8
          zpl(1)=0.0
          zpl(2)=0.0
          xt(1)=xpl(1)+(xpl(2)-xpl(1))*1.3
          yt(1)=ypl(1)+(ypl(2)-ypl(1))*1.3
          zt(1)=zpl(1)+(zpl(2)-zpl(1))*1.3
          call mshplt_3dto2d(1,xt,-zt,yt,xt,zt)
          call mtx(xt(1),zt(1),'x')
          call mshplt_3dto2d(2,xpl,-zpl,ypl,xpl,ypl)
          call mpl(2,xpl,ypl)

          xpl(1)=-0.8
          xpl(2)=-0.8
          ypl(1)=-0.8
          ypl(2)=-0.6
          zpl(1)=0.0
          zpl(2)=0.0

          xt(1)=xpl(1)+(xpl(2)-xpl(1))*1.3
          yt(1)=ypl(1)+(ypl(2)-ypl(1))*1.3
          zt(1)=zpl(1)+(zpl(2)-zpl(1))*1.3
          call mshplt_3dto2d(1,xt,-zt,yt,xt,zt)
          call mtx(xt(1),zt(1),'y')
          call mshplt_3dto2d(2,xpl,-zpl,ypl,xpl,ypl)
          call mpl(2,xpl,ypl)

          xpl(1)=-0.8
          xpl(2)=-0.8
          ypl(1)=-0.8
          ypl(2)=-0.8
          zpl(1)=0.
          zpl(2)=0.2

          xt(1)=xpl(1)+(xpl(2)-xpl(1))*1.3
          yt(1)=ypl(1)+(ypl(2)-ypl(1))*1.3
          zt(1)=zpl(1)+(zpl(2)-zpl(1))*1.3
          call mshplt_3dto2d(1,xt,-zt,yt,xt,zt)
          call mtx(xt(1),zt(1),'z')
          call mshplt_3dto2d(2,xpl,-zpl,ypl,xpl,ypl)
          call mpl(2,xpl,ypl)
          call muwk(0,0)

          call mplzon(1,1,1,'S')
          call mplfra(0.,10.,0.,10.,'AB')
        endif

        call mgset('CHHE',0.5)
        call mtx(4.1,4.1,'upper magnets')
        call mtx(4.1,0.9,'lower magnets')
        call mgset('CHHE',0.4)
        call mtx(4.6,1.4,'x[mm]')
        call mtx(4.6,-1.8,'x[mm]')
        call mshplt_set_text_angle(90.)
        call mtx(-1.,2.4,'z[mm]')
        call mtx(-1.,-0.6,'z[mm]')
        call mshplt_set_text_angle(0.)
        call mplset('YMGL',2.)
        call mplset('YMGL',0.5)
        call mgset('CHHE',0.4)
        call muwk(0,0)
        call mplzon(2,2,1,'S')
      else
        call mplset('YMGL',0.5)
        call mplzon(1,1,1,' ')
        call mgset('CHHE',0.4)
        if (theta.ne.0.0.or.phi.ne.0.0) then

          call mplfr3(0.,1.,0.,1.,0.,1.,theta,phi,'W')
          call mplfra(0.,1.,0.,1.,'AB')

          xpl(1)=0.2
          xpl(2)=0.3
          ypl(1)=0.0
          ypl(2)=0.0
          zpl(1)=0.0
          zpl(2)=0.0
          xt(1)=xpl(1)+(xpl(2)-xpl(1))*1.3
          yt(1)=ypl(1)+(ypl(2)-ypl(1))*1.3
          zt(1)=zpl(1)+(zpl(2)-zpl(1))*1.3
          call mshplt_3dto2d(1,xt,-zt,yt,xt,zt)
          call mtx(xt(1),zt(1),'x')
          call mshplt_3dto2d(2,xpl,-zpl,ypl,xpl,ypl)
          call mpl(2,xpl,ypl)

          xpl(1)=0.2
          xpl(2)=0.2
          ypl(1)=0.0
          ypl(2)=0.1
          zpl(1)=0.0
          zpl(2)=0.0
          xt(1)=xpl(1)+(xpl(2)-xpl(1))*1.3
          yt(1)=ypl(1)+(ypl(2)-ypl(1))*1.3
          zt(1)=zpl(1)+(zpl(2)-zpl(1))*1.3
          call mshplt_3dto2d(1,xt,-zt,yt,xt,zt)
          call mtx(xt(1),zt(1),'y')
          call mshplt_3dto2d(2,xpl,-zpl,ypl,xpl,ypl)
          call mpl(2,xpl,ypl)

          xpl(1)=0.2
          xpl(2)=0.2
          ypl(1)=0.0
          ypl(2)=0.0
          zpl(1)=0.0
          zpl(2)=0.1
          xt(1)=xpl(1)+(xpl(2)-xpl(1))*1.3
          yt(1)=ypl(1)+(ypl(2)-ypl(1))*1.3
          zt(1)=zpl(1)+(zpl(2)-zpl(1))*1.3
          call mshplt_3dto2d(1,xt,-zt,yt,xt,zt)
          call mtx(xt(1),zt(1),'z')
          call mshplt_3dto2d(2,xpl,-zpl,ypl,xpl,ypl)
          call mpl(2,xpl,ypl)
          call muwk(0,0)

        endif
        call mplzon(1,1,1,'S')
      endif

      iplano=1

c y is vertical (WAVE-system)
      if (theta.eq.0.0.and.phi.eq.0.0) then

        !call mplfra(xplmin,xplmax,yplmin,yplmax,' ')
        call mshplt_frame(xplmin,xplmax,yplmin,yplmax,'x[mm]','y[mm]',' ')
        !call mplax('x (mm)', 'y (mm)')
        !call muwk(0,0)

        if (nbforcx*nbforcy*nbforcz.ne.0)
     &    call undumag_bpolypl2(forxpl,forypl,forcol,12)

        do iline=1,nline

          x=xb(iline)
          y=yb(iline)
          z=zb(iline)
          bx=bxb(iline)
          by=byb(iline)
          bz=bzb(iline)

          if (bx**2+by**2+bz**2.eq.0.0d0.and.ispole(iline).eq.0) cycle

          imag=nint(rmagb(iline))
          icol=nint(rcolb(iline))
          iplan=nint(rplanb(iline))
          icorn=nint(rcornb(iline))

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &          xpl(i).lt.xplmin.or.
     &          xpl(i).gt.xplmax.or.
     &          ypl(i).lt.yplmin.or.
     &          ypl(i).gt.yplmax.or.
     &          zpl(i).lt.zplmin.or.
     &          zpl(i).gt.zplmax
     &          ) cycle
            enddo

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mshplt_set_line_width(rlwidth/5.)
            call mgset('PLCI',1.)
            call mpl(ncorno,xpl,ypl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*5.0*rlwidth
              ypl(i)=ypl(i)+(yc-ypl(i))*5.0*rlwidth
              zpl(i)=zpl(i)+(zc-zpl(i))*5.0*rlwidth
              zplm(i)=-zpl(i)
            enddo

            call mshplt_set_line_width(rlwidth/2.)
            call mgset('PLCI',rcol)
            call mpl(ncorno,xpl,ypl)

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)

        enddo !nline

        call mshplt_set_line_width(rlwidth*2.)

        do iw=1,ncwires
          if (abs(wire(2,iw)).eq.0.0d0) cycle
          rcol=sngl(wire(9,iw))
          call mgset('PLCI',rcol)
          xpl(1)=sngl(wire(3,iw))
          xpl(2)=sngl(wire(6,iw))
          ypl(1)=sngl(wire(4,iw))
          ypl(2)=sngl(wire(7,iw))
          call mpl(2,xpl,ypl)
        enddo
        call mshplt_set_line_width(rlwidth/2.)

      else !:if (theta.eq.0.0.and.phi.eq.0.0) then

        xyzmin=min(xplmin,yplmin,zplmin)!*0.8
        xyzmax=max(xplmax,yplmax,zplmax)!*0.8

        !dx=(xyzmax-xyzmin)*0.1*0.0
c        call mplfr3(xyzmin,xyzmax,
c     &    -xyzmax,-xyzmin,
c     &    xyzmin,xyzmax,theta,phi,'W')

        !call mplfr3(xplmin,xplmax,zplmin,zplmax,yplmin,yplmax,theta,phi,'W')
        call mplfr3(xyzmin,xyzmax,xyzmin,xyzmax,xyzmin,xyzmax,theta,phi,'W')
        !goto 9999

        do iline=1,nline

          x=xb(iline)
          y=yb(iline)
          z=zb(iline)
          bx=bxb(iline)
          by=byb(iline)
          bz=bzb(iline)

          if (bx**2+by**2+bz**2.eq.0.0d0.and.ispole(iline).eq.0) cycle

          imag=nint(rmagb(iline))
          icol=nint(rcolb(iline))
          iplan=nint(rplanb(iline))
          icorn=nint(rcornb(iline))

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            do i=1,ncorno
              if (
     &          xpl(i).lt.xplmin.or.
     &          xpl(i).gt.xplmax.or.
     &          ypl(i).lt.yplmin.or.
     &          ypl(i).gt.yplmax.or.
     &          zpl(i).lt.zplmin.or.
     &          zpl(i).gt.zplmax
     &          ) cycle
            enddo

            do i=1,ncorno
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',1.)
            call mpl3(ncorno,xpl,zplm,ypl)

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            do i=1,ncorno
              xpl(i)=xpl(i)+(xc-xpl(i))*0.015*rcol
              ypl(i)=ypl(i)+(yc-ypl(i))*0.015*rcol
              zpl(i)=zpl(i)+(zc-zpl(i))*0.015*rcol
              zplm(i)=-zpl(i)
            enddo

            call mgset('PLCI',rcol)
            call mpl3(ncorno,xpl,zplm,ypl)

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)

        enddo !nline

        call mshplt_set_line_width(rlwidth*2.)
        do iw=1,ncwires
          if (abs(wire(2,iw)).eq.0.0d0) cycle
          rcol=sngl(wire(9,iw))
          call mgset('PLCI',rcol)
          xpl(1)=sngl(wire(3,iw))
          xpl(2)=sngl(wire(6,iw))
          ypl(1)=sngl(wire(4,iw))
          ypl(2)=sngl(wire(7,iw))
          zpl(1)=-sngl(wire(5,iw))
          zpl(2)=-sngl(wire(8,iw))
          call mpl3(2,xpl,zpl,ypl)
        enddo
        call mshplt_set_line_width(rlwidth/2.)

      endif !(theta.eq.0.0.and.phi.eq.0.0) then

      call muwk(0,0)

      if (kunduplot_mode.ne.0) goto 9999

c--- 3D }

c--- y vs z or z vs y {

      !call mplfra(zplmin,zplmax,yplmin,yplmax,' ')
      !call mplax('z (mm)', 'y (mm)')
      call mshplt_frame(zplmin,zplmax,yplmin,yplmax,'z[mm]','y[mm]',' ')
c      print*,"Bau 2"
      if (nbforcx*nbforcy*nbforcz.ne.0)
     &  call undumag_bpolypl2(forzpl,forypl,forcol,23)

      iplano=1

      do iline=1,nline

        x=xb(iline)
        y=yb(iline)
        z=zb(iline)
        bx=bxb(iline)
        by=byb(iline)
        bz=bzb(iline)

        if (bx**2+by**2+bz**2.eq.0.0d0.and.ispole(iline).eq.0) cycle

        imag=nint(rmagb(iline))
        icol=nint(rcolb(iline))
        iplan=nint(rplanb(iline))
        icorn=nint(rcornb(iline))

        ncorn=abs(icorn)

        if (iline.eq.nline) then

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)

        endif !(iline.eq.nline

        if(iplan.ne.iplano.or.iline.eq.nline) then

          do i=1,ncorno
            zplm(i)=-zpl(i)
          enddo

          call mshplt_set_line_width(rlwidth/5.)
          call mgset('PLCI',1.)
          call mpl(ncorno,zpl,ypl)

          xc=0.
          yc=0.
          zc=0.

          do i=1,ncorno-1
            xc=xc+xpl(i)
            yc=yc+ypl(i)
            zc=zc+zpl(i)
          enddo

          xc=xc/(ncorno-1)
          yc=yc/(ncorno-1)
          zc=zc/(ncorno-1)

          izero=0
          do i=1,ncorno
            if (
     &        abs(yc-ypl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &        ) izero=1
            xpl(i)=xpl(i)+(xc-xpl(i))*2.0*rlwidth
            ypl(i)=ypl(i)+(yc-ypl(i))*2.0*rlwidth
            zpl(i)=zpl(i)+(zc-zpl(i))*2.0*rlwidth
            zplm(i)=-zpl(i)
          enddo

          call mgset('PLCI',rcol)

          if (izero.ne.0) call mpl(ncorno,zpl,ypl)

        endif !iplano

        xpl(ncorn)=x
        ypl(ncorn)=y
        zpl(ncorn)=z

        iplano=iplan
        ncorno=ncorn
        rcol=rcolb(iline)

      enddo !nline

      call mshplt_set_line_width(rlwidth*2.)

      do iw=1,ncwires
        if (abs(wire(2,iw)).eq.0.0d0) cycle
        rcol=sngl(wire(9,iw))
        call mgset('PLCI',rcol)
        xpl(1)=sngl(wire(3,iw))
        xpl(2)=sngl(wire(6,iw))
        ypl(1)=sngl(wire(4,iw))
        ypl(2)=sngl(wire(7,iw))
        zpl(1)=sngl(wire(5,iw))
        zpl(2)=sngl(wire(8,iw))
        call mpl(2,zpl,ypl)
      enddo

      call mshplt_set_line_width(rlwidth/2.)
      call mshplt_set_line_width(rlwidtho)

c      print*,"Bau 3"
      if (nbforcx*nbforcy*nbforcz.ne.0)
     &  call undumag_bpolypl2(forzpl,forypl,forcol,23)

c--- y vs z or z vs y }

c--- top views of girder {

      call muwk(0,0)
      call mplzon(1,4,3,'S')

      do igird=1,2

c--- z vs x, y is vertical coordinate {
        !hier
        call mplfra(xplmin,xplmax,zplmin,zplmax,' ')
        !call mplax('x (mm)', 'z (mm)')
        !call mshplt_frame(xplmin,xplmax,zplmin,zplmax,'x[mm]','z[mm]',' ')

c        print*,"Bau 4"
        if (nbforcx*nbforcy*nbforcz.ne.0)
     &    call undumag_bpolypl2(forxpl,forzpl,forcol,13)

        if (nline.gt.0) then
          imago=int(rmagb(nline))
          kpole=ispolemag(imago)
          iplano=1
          impl=0
        endif

        do iline=1,nline

          x=xb(iline)
          y=yb(iline)
          z=zb(iline)

          bx=bxb(iline)
          by=byb(iline)
          bz=bzb(iline)

          if (bx**2+by**2+bz**2.eq.0.0d0.and.ispole(iline).eq.0) cycle

          imag=nint(rmagb(iline))
          icol=nint(rcolb(iline))
          iplan=nint(rplanb(iline))
          icorn=nint(rcornb(iline))

          ncorn=abs(icorn)

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if (imag.ne.imago.or.iline.eq.nline) then

            xmc(1)=0.
            ymc(1)=0.
            zmc(1)=0.

            xmmx=-1.0e30
            xmmn= 1.0e30
            ymmx=-1.0e30
            ymmn= 1.0e30
            zmmx=-1.0e30
            zmmn= 1.0e30

            do i=1,impl-1
              xmc(1)=xmc(1)+xmpl(i)
              ymc(1)=ymc(1)+ympl(i)
              zmc(1)=zmc(1)+zmpl(i)
              if (xmpl(i).gt.xmmx) xmmx=xmpl(i)
              if (xmpl(i).lt.xmmn) xmmn=xmpl(i)
              if (ympl(i).gt.ymmx) ymmx=ympl(i)
              if (ympl(i).lt.ymmn) ymmn=ympl(i)
              if (zmpl(i).gt.zmmx) zmmx=zmpl(i)
              if (zmpl(i).lt.zmmn) zmmn=zmpl(i)
            enddo

            xmc(1)=xmc(1)/(impl-1)
            ymc(1)=ymc(1)/(impl-1)
            zmc(1)=zmc(1)/(impl-1)

            dx=xmmx-xmmn
            dy=ymmx-ymmn
            dz=zmmx-zmmn

            impl=0

          endif !imag.ne.imago

          impl=impl+1

          if (iline.eq.nline) then

            xpl(ncorn)=x
            ypl(ncorn)=y
            zpl(ncorn)=z

            xmpl(impl)=x
            ympl(impl)=y
            zmpl(impl)=z

            bxo=bx
            byo=by
            bzo=bz

            iplano=iplan
            ncorno=ncorn
            rcol=rcolb(iline)

          endif !(iline.eq.nline

          if(iplan.ne.iplano.or.iline.eq.nline) then

            xc=0.
            yc=0.
            zc=0.

            do i=1,ncorno-1
              xc=xc+xpl(i)
              yc=yc+ypl(i)
              zc=zc+zpl(i)
            enddo

            xc=xc/(ncorno-1)
            yc=yc/(ncorno-1)
            zc=zc/(ncorno-1)

            if (igird.eq.1.and.yc.ge.0.0) then

              do i=1,ncorno
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',1.)
              call mpl(ncorno,xpl,zpl)

              izero=0
              do i=1,ncorno
                if (
     &            abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &            ) izero=1
                xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcol
                ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcol
                zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcol
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcol)
              if (izero.ne.0) call mpl(ncorno,xpl,zpl)

              if (imag.ne.imago.or.iline.eq.nline) then

                bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)

                if (abs(bxo).lt.bo*eps) bxo=0.0
                if (abs(byo).lt.bo*eps) byo=0.0
                if (abs(bzo).lt.bo*eps) bzo=0.0

                xplb(1)=xmc(1)-2.*bxo/bo*dx/6.
                xplb(2)=xmc(1)+2.*bxo/bo*dx/6.
                yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                zplb(1)=zmc(1)-2.*bzo/bo*dz/5.
                zplb(2)=zmc(1)+2.*bzo/bo*dz/5.

                xplbo(1)=xplb(1)
                xplbo(2)=xplb(2)
                yplbo(1)=yplb(1)
                yplbo(2)=yplb(2)
                zplbo(1)=zplb(1)
                zplbo(2)=zplb(2)

                if (kpole.eq.0) call mpl(2,xplbo,zplbo)

                vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                if (vn.ne.0.0d0) then

                  vnx=(xplbo(2)-xplbo(1))/vn
                  vnz=(zplbo(2)-zplbo(1))/vn

                  xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                  xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                endif !vn

                if (byo.gt.1.e-9) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp20)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                else if (byo.lt.0.0) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp31)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                endif

              endif !imago

            else if (igird.eq.2.and.yc.le.0.0) then

              do i=1,ncorno
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',1.)
              call mpl(ncorno,xpl,zpl)

              izero=0
              do i=1,ncorno
                if (
     &            abs(xc-xpl(i)).gt.1.0e-6 .and. abs(zc-zpl(i)).gt.1.0e-6
     &            ) izero=1
                xpl(i)=xpl(i)+(xc-xpl(i))*0.03*rcol
                ypl(i)=ypl(i)+(yc-ypl(i))*0.03*rcol
                zpl(i)=zpl(i)+(zc-zpl(i))*0.03*rcol
                zplm(i)=-zpl(i)
              enddo

              call mgset('PLCI',rcol)
              if (izero.ne.0) call mpl(ncorno,xpl,zpl)

              if (imag.ne.imago.or.iline.eq.nline) then

                bo=sqrt(bxo*bxo+byo*byo+bzo*bzo)
                if (abs(bxo).lt.bo*eps) bxo=0.0
                if (abs(byo).lt.bo*eps) byo=0.0
                if (abs(bzo).lt.bo*eps) bzo=0.0

                xplb(1)=xmc(1)-2.*bxo/bo*dx/6.
                xplb(2)=xmc(1)+2.*bxo/bo*dx/6.
                yplb(1)=ymc(1)-2.*byo/bo*dy/8.
                yplb(2)=ymc(1)+2.*byo/bo*dy/8.
                zplb(1)=zmc(1)-2.*bzo/bo*dz/5.
                zplb(2)=zmc(1)+2.*bzo/bo*dz/5.

                xplbo(1)=xplb(1)
                xplbo(2)=xplb(2)
                yplbo(1)=yplb(1)
                yplbo(2)=yplb(2)
                zplbo(1)=zplb(1)
                zplbo(2)=zplb(2)

                if (kpole.eq.0) call mpl(2,xplbo,zplbo)

                vn=sqrt((xplbo(2)-xplbo(1))**2+(zplbo(2)-zplbo(1))**2)

                if (vn.ne.0.0d0) then

                  vnx=(xplbo(2)-xplbo(1))/vn
                  vnz=(zplbo(2)-zplbo(1))/vn

                  xplb(1)=xplbo(2)+vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)-vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                  xplb(1)=xplbo(2)-vnz*dx/10.0-vnx*dx/10.0
                  zplb(1)=zplbo(2)+vnx*dz/10.0-vnz*dz/10.0

                  if (kpole.eq.0) call mpl(2,xplb,zplb)

                endif !vn

                if (byo.gt.1.e-9) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp20)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                else if (byo.lt.0.0) then
                  call mgset('MTYP',rmtyp24)
                  call mgset('MSCF',circ0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                  call mgset('MTYP',rmtyp31)
                  call mgset('MSCF',dot0*pscal/5.)
                  call mpm(1,xmc(1),zmc(1))
                endif

              endif !imago

            endif !yc

          endif !iplano

          xpl(ncorn)=x
          ypl(ncorn)=y
          zpl(ncorn)=z

          xmpl(impl)=x
          ympl(impl)=y
          zmpl(impl)=z

          bxo=bx
          byo=by
          bzo=bz

          iplano=iplan
          ncorno=ncorn
          rcol=rcolb(iline)
          imago=imag
          kpole=ispolemag(imago)

        enddo !nline

c        print*,"Bau 5"
        if (nbforcx*nbforcy*nbforcz.ne.0) call undumag_bpolypl2(forxpl,forzpl,forcol,13)

        if (igird.eq.1) then
          call mshplt_set_line_width(rlwidth*2.)
          do iw=1,ncwires
            if (abs(wire(2,iw)).eq.0.0d0) cycle
            rcol=sngl(wire(9,iw))
            call mgset('PLCI',rcol)
            xpl(1)=sngl(wire(3,iw))
            xpl(2)=sngl(wire(6,iw))
            ypl(1)=sngl(wire(4,iw))
            ypl(2)=sngl(wire(7,iw))
            zpl(1)=sngl(wire(5,iw))
            zpl(2)=sngl(wire(8,iw))
            if (ypl(1).gt.0.0.or.ypl(2).gt.0.0) call mpl(2,xpl,zpl)
          enddo
          call mshplt_set_line_width(rlwidth/2.)
        else
          call mshplt_set_line_width(rlwidth*2.)
          do iw=1,ncwires
            if (abs(wire(2,iw)).eq.0.0d0) cycle
            rcol=sngl(wire(9,iw))
            call mgset('PLCI',rcol)
            xpl(1)=sngl(wire(3,iw))
            xpl(2)=sngl(wire(6,iw))
            ypl(1)=sngl(wire(4,iw))
            ypl(2)=sngl(wire(7,iw))
            zpl(1)=sngl(wire(5,iw))
            zpl(2)=sngl(wire(8,iw))
            if (ypl(1).lt.0.0.or.ypl(2).lt.0.0) call mpl(2,xpl,zpl)
          enddo
          call mshplt_set_line_width(rlwidth/2.)
        endif

      enddo !igird

      call muwk(0,0)

c--- y vs x }

c--- top views of girder}

c--- 3D, top and side views }

9999  continue

      if (iallo.eq.1) then
        deallocate(xpl)
        deallocate(ypl)
        deallocate(zpl)
        deallocate(zplm)
        deallocate(xmpl)
        deallocate(ympl)
        deallocate(zmpl)
      endif

c      call mgmeta(0,0)
c      call mplend

      call mshplt_end

      write(lun6,*)"Done"
      write(lun6,*)

      deallocate(rmothb,rmagb,rcolb,rplanb,rcornb,
     &  xb,yb,zb,bxb,byb,bzb,rmatb)

      return
      end
+DECK,clcmag_ini_force.
*CMZ :  2.05/06 11/10/2024  10.23.55  by  Michael Scheer
*CMZ :  2.05/05 30/06/2024  16.25.45  by  Michael Scheer
*CMZ :  2.02/02 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 14/01/2022  12.54.16  by  Michael Scheer
*CMZ :  2.02/00 31/03/2021  20.30.51  by  Michael Scheer
*CMZ :  2.01/08 13/08/2020  11.27.23  by  Michael Scheer
*CMZ :  2.01/05 26/06/2020  16.04.15  by  Michael Scheer
*CMZ :  2.01/04 18/07/2019  13.56.54  by  Michael Scheer
*CMZ :  2.01/03 13/06/2019  15.03.29  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  14.56.07  by  Michael Scheer
*CMZ :  2.01/01 24/04/2018  17.15.25  by  Michael Scheer
*CMZ :  2.01/00 24/04/2018  14.30.21  by  Michael Scheer
*CMZ :  2.00/03 23/04/2018  17.47.12  by  Michael Scheer
*CMZ :  2.00/00 12/04/2018  08.39.07  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  19.09.03  by  Michael Scheer
*CMZ :  1.25/03 23/03/2018  16.25.38  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.30.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  15.59.20  by  Michael Scheer
*CMZ :  1.25/00 16/03/2018  12.35.49  by  Michael Scheer
*CMZ :  1.24/01 16/10/2017  19.08.03  by  Michael Scheer
*CMZ :  1.23/07 10/10/2017  13.53.24  by  Michael Scheer
*CMZ :  1.23/04 04/10/2017  11.50.12  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  18.37.06  by  Michael Scheer
*CMZ :  1.23/02 17/09/2017  11.21.15  by  Michael Scheer
*CMZ :  1.22/02 02/08/2017  16.23.00  by  Michael Scheer
*CMZ :  1.22/01 21/07/2017  14.53.35  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  08.50.03  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  11.30.39  by  Michael Scheer
*CMZ :  1.20/02 22/06/2017  15.56.28  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  12.48.09  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  13.11.48  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.31.54  by  Michael Scheer
*CMZ :  1.18/03 13/06/2017  15.30.31  by  Michael Scheer
*CMZ :  1.18/02 13/06/2017  14.09.42  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  09.19.34  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  16.04.28  by  Michael Scheer
*CMZ :  1.17/06 21/05/2017  12.55.08  by  Michael Scheer
*CMZ :  1.16/00 07/05/2017  12.22.37  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  12.23.38  by  Michael Scheer
*CMZ :  1.15/11 26/04/2017  11.23.30  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.22.06  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  14.32.29  by  Michael Scheer
*CMZ :  1.15/06 04/04/2017  13.29.10  by  Michael Scheer
*CMZ :  1.15/05 04/04/2017  12.46.33  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.15.21  by  Michael Scheer
*CMZ :  1.15/02 01/04/2017  19.50.52  by  Michael Scheer
*CMZ :  1.15/00 28/03/2017  11.26.05  by  Michael Scheer
*CMZ :  1.14/00 22/03/2017  09.16.41  by  Michael Scheer
*CMZ :  1.13/03 16/03/2017  10.00.53  by  Michael Scheer
*CMZ :  1.13/02 09/03/2017  17.14.36  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  15.40.55  by  Michael Scheer
*CMZ :  1.13/00 02/03/2017  16.37.53  by  Michael Scheer
*CMZ :  1.12/00 24/02/2017  08.47.15  by  Michael Scheer
*CMZ :  1.11/07 23/02/2017  17.24.23  by  Michael Scheer
*CMZ :  1.11/06 23/02/2017  13.18.36  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.27.44  by  Michael Scheer
*CMZ :  1.11/04 25/01/2017  10.13.44  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.40  by  Michael Scheer
*CMZ :  1.11/01 06/01/2017  13.46.07  by  Michael Scheer
*CMZ :  1.11/00 04/01/2017  15.56.40  by  Michael Scheer
*CMZ :  1.10/03 05/12/2016  15.36.58  by  Michael Scheer
*CMZ :  1.10/02 30/11/2016  16.12.02  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.02.58  by  Michael Scheer
*CMZ :  1.10/00 01/11/2016  09.47.47  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  09.08.03  by  Michael Scheer
*CMZ :  1.09/00 04/10/2016  09.12.28  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  18.54.27  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.39.27  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.51.14  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.43.31  by  Michael Scheer
*CMZ :  1.06/00 21/09/2016  13.02.17  by  Michael Scheer
*CMZ :  1.05/00 17/09/2016  10.32.16  by  Michael Scheer
*CMZ :  1.04/03 15/09/2016  17.35.03  by  Michael Scheer
*CMZ :  1.04/02 15/09/2016  16.29.44  by  Michael Scheer
*CMZ :  1.04/00 14/09/2016  10.45.28  by  Michael Scheer
*CMZ :  1.03/00 13/09/2016  13.31.19  by  Michael Scheer
*CMZ :  1.02/03 12/09/2016  11.37.12  by  Michael Scheer
*CMZ :  1.02/02 12/09/2016  10.20.23  by  Michael Scheer
*CMZ :  1.02/01 11/09/2016  12.27.52  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  14.10.42  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  17.52.14  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  12.06.57  by  Michael Scheer
*CMZ :  0.00/12 21/07/2016  09.03.47  by  Michael Scheer
*CMZ :  0.00/11 20/07/2016  16.13.39  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  15.05.25  by  Michael Scheer
*CMZ :  0.00/09 04/07/2016  17.54.03  by  Michael Scheer
*CMZ :  0.00/06 22/06/2016  13.38.55  by  Michael Scheer
*CMZ :  0.00/05 14/06/2016  13.51.40  by  Michael Scheer
*CMZ :  0.00/04 13/05/2016  14.27.24  by  Michael Scheer
*CMZ :  0.00/02 29/04/2016  09.17.43  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  15.56.38  by  Michael Scheer
*CMZ :  0.00/00 20/04/2016  12.48.03  by  Michael Scheer
*CMZ :  1.17/15 19/04/2016  15.54.31  by  Michael Scheer
*CMZ :  1.17/14 13/04/2016  12.32.55  by  Michael Scheer
*CMZ :  1.17/13 08/04/2016  11.47.10  by  Michael Scheer
*CMZ :  1.17/12 06/04/2016  14.29.22  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  12.46.06  by  Michael Scheer
*CMZ :  1.17/10 04/04/2016  14.46.34  by  Michael Scheer
*CMZ :  1.17/09 04/04/2016  09.41.39  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.58.50  by  Michael Scheer
*CMZ :  1.17/07 04/04/2016  08.42.21  by  Michael Scheer
*-- Author :    Michael Scheer   01/04/2016
      subroutine clcmag_ini_force

      use commandlinef90m
      use bpolyederf90m
      use undumagf90m
      use magnets_structure
      !use displacement

      implicit none

+seq,phyconparam.
+seq,seqdebug.
+seq,random.

      double precision undumag_variable_getval,val
      double precision xminfb,xmaxfb,yminfb,ymaxfb,zminfb,zmaxfb,x,y,z,gcen(3)

      integer imag,luno,ix,iy,iz

      nowarnugv=1

      val=undumag_variable_getval('iplforce')
      if (val.ne.-9999.0d29) iplforce=nint(val)

      val=undumag_variable_getval('ubflenx')
      if (val.ne.-9999.0d29) ubflenx=val
      val=undumag_variable_getval('ubfleny')
      if (val.ne.-9999.0d29) ubfleny=val
      val=undumag_variable_getval('ubflenz')
      if (val.ne.-9999.0d29) ubflenz=val

      val=undumag_variable_getval('ubfcenx')
      if (val.ne.-9999.0d29) ubfcenx=val
      val=undumag_variable_getval('ubfceny')
      if (val.ne.-9999.0d29) ubfceny=val
      val=undumag_variable_getval('ubfcenz')
      if (val.ne.-9999.0d29) ubfcenz=val

      val=undumag_variable_getval('utorqcenx')
      if (val.ne.-9999.0d29) utorqcenx=val
      val=undumag_variable_getval('utorqceny')
      if (val.ne.-9999.0d29) utorqceny=val
      val=undumag_variable_getval('utorqcenz')
      if (val.ne.-9999.0d29) utorqcenz=val

      val=undumag_variable_getval('mbforcex')
      if (val.ne.-9999.0d29) mbforcex=nint(val)
      val=undumag_variable_getval('mbforcey')
      if (val.ne.-9999.0d29) mbforcey=nint(val)
      val=undumag_variable_getval('mbforcez')
      if (val.ne.-9999.0d29) mbforcez=nint(val)

      val=undumag_variable_getval('mfcolor')
      if (val.ne.-9999.0d29) mfcolor=nint(val)

      nowarnugv=0

      ndivfby=max(ndivfboxy,1)

      ubflenx=ubflenx+2.0*dedgefb
      ubfleny=ubfleny+2.0*dedgefb
      ubflenz=ubflenz+2.0*dedgefb

      if (iforce.ne.9999) then

        if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
        if (utorqceny.eq.9999.0d0) utorqceny=ubfceny
        if (utorqcenz.eq.9999.0d0) utorqcenz=ubfcenz

        bfcenxmm=ubfcenx
        bfcenymm=ubfceny
        bfcenzmm=ubfcenz
        bflenxmm=ubflenx
        bflenymm=ubfleny
        bflenzmm=ubflenz
        torqcenxmm=utorqcenx
        torqcenymm=utorqceny
        torqcenzmm=utorqcenz
        bfcenx=ubfcenx/1000.0d0
        bfceny=ubfceny/1000.0d0
        bfcenz=ubfcenz/1000.0d0
        bflenx=ubflenx/1000.0d0
        bfleny=ubfleny/1000.0d0
        bflenz=ubflenz/1000.0d0
        torqcenx=utorqcenx/1000.0d0
        torqceny=utorqceny/1000.0d0
        torqcenz=utorqcenz/1000.0d0
        jplforce=iplforce
        if (iforce.eq.0) then
          mbforcex=0
          mbforcey=0
          mbforcez=0
        endif
        nbforcx=mbforcex
        nbforcy=mbforcey
        nbforcz=mbforcez
        iforcol=mfcolor
        forcol=iforcol
        forxpl(1)=sngl(bfcenxmm-bflenxmm/2.)
        forxpl(2)=sngl(bfcenxmm+bflenxmm/2.)
        forypl(1)=sngl(bfcenymm-bflenymm/2.)
        forypl(2)=sngl(bfcenymm+bflenymm/2.)
        forzpl(1)=sngl(bfcenzmm-bflenzmm/2.)
        forzpl(2)=sngl(bfcenzmm+bflenzmm/2.)

      endif !(iforce.ne.9999) then

      forxpl=forxpl+sngl(xcentershift)

      kforcemag=0

      if (iforce.eq.9999.or.iforcedip.ne.0) then

        if (chforcemag.eq.'') then
          write(lun6,*)"*** iforce=9999, but chforcemag is an empty string ***"
          write(lun6,*)
          stop
        endif

        write(lun6,*)""
        write(lun6,*)"      chforcemag: ",trim(adjustl(chforcemag))
        do imag=1,nmagtot_t
          if (
     &      t_magcopy(imag)%cnam.eq.chforcemag
     &      .or.
     &      t_magcopy(imag)%cmoth.eq.chforcemag
     &        ) then
            kforcemag=imag
            exit
          endif
        enddo

        if (kforcemag.eq.0) then
          write(lun6,*)"*** Magnet ",trim(chforcemag),"  for force calculations not found ***"
          write(lun6,*)"*** Check undumag_magnets.lis ***"
          stop
        endif

        if (chforcemag.eq.'') then
          chforcemag='None'
        endif

      endif !iforce, iforcedip

      if (iforce.eq.9999) then

        xminfb=1.0d30
        xmaxfb=-1.0d30
        yminfb=1.0d30
        ymaxfb=-1.0d30
        zminfb=1.0d30
        zmaxfb=-1.0d30

        do imag=1,nmagtot_t

          if (
     &        t_magcopy(imag)%cnam.ne.chforcemag
     &        .and.
     &        t_magcopy(imag)%cmoth.ne.chforcemag
     &        ) then
            cycle
          endif

          gcen=t_magcopy(imag)%gcen

          x=t_magcopy(imag)%xmin+gcen(1)+xcentershift
          y=t_magcopy(imag)%ymin+gcen(2)
          z=t_magcopy(imag)%zmin+gcen(3)

          if (x.lt.xminfb) xminfb=x
          if (y.lt.yminfb) yminfb=y
          if (z.lt.zminfb) zminfb=z

          x=t_magcopy(imag)%xmax+gcen(1)+xcentershift
          y=t_magcopy(imag)%ymax+gcen(2)
          z=t_magcopy(imag)%zmax+gcen(3)

          if (x.gt.xmaxfb) xmaxfb=x
          if (y.gt.ymaxfb) ymaxfb=y
          if (z.gt.zmaxfb) zmaxfb=z

        enddo

        ubfcenx=(xmaxfb+xminfb)/2.0d0
        ubflenx=(xmaxfb-xminfb)
        if (ixsym.ne.0.and.(xmin_t.le.xsym.or.xmax_t.ge.xsym)) then
          ubfcenz=xsym
          ubflenz=2.0d0*ubflenz
        endif

        ubfceny=(ymaxfb+yminfb)/2.0d0
        ubfleny=(ymaxfb-yminfb)

        ubfcenz=(zmaxfb+zminfb)/2.0d0
        ubflenz=(zmaxfb-zminfb)
        if (izsym.ne.0) then
          ubfcenz=0.0d0
          ubflenz=2.0d0*ubflenz
        endif

        ubflenx=ubflenx+2.0*dedgefb
        ubfleny=ubfleny+2.0*dedgefb
        ubflenz=ubflenz+2.0*dedgefb

        if (utorqcenx.eq.9999.0d0) utorqcenx=ubfcenx
        if (utorqceny.eq.9999.0d0) utorqceny=ubfceny
        if (utorqcenz.eq.9999.0d0) utorqcenz=ubfcenz

        bfcenxmm=ubfcenx
        bfcenymm=ubfceny
        bfcenzmm=ubfcenz
        bflenxmm=ubflenx
        bflenymm=ubfleny
        bflenzmm=ubflenz
        torqcenxmm=utorqcenx
        torqcenymm=utorqceny
        torqcenzmm=utorqcenz
        bfcenx=ubfcenx/1000.0d0
        bfceny=ubfceny/1000.0d0
        bfcenz=ubfcenz/1000.0d0
        bflenx=ubflenx/1000.0d0
        bfleny=ubfleny/1000.0d0
        bflenz=ubflenz/1000.0d0
        torqcenx=utorqcenx/1000.0d0
        torqceny=utorqceny/1000.0d0
        torqcenz=utorqcenz/1000.0d0
        jplforce=iplforce
        if (iforce.eq.0) then
          mbforcex=0
          mbforcey=0
          mbforcez=0
        endif
        nbforcx=mbforcex
        nbforcy=mbforcey
        nbforcz=mbforcez
        iforcol=mfcolor
        forcol=iforcol
        forxpl(1)=sngl(bfcenxmm-bflenxmm/2.)
        forxpl(2)=sngl(bfcenxmm+bflenxmm/2.)
        forypl(1)=sngl(bfcenymm-bflenymm/2.)
        forypl(2)=sngl(bfcenymm+bflenymm/2.)
        forzpl(1)=sngl(bfcenzmm-bflenzmm/2.)
        forzpl(2)=sngl(bfcenzmm+bflenzmm/2.)

      endif !(iforce.eq.9999) then

      if (mbforcex*mbforcey*mbforcez.gt.0) then
        outbox(1,1)=ubfcenx-ubflenx/2.
        outbox(2,1)=ubfcenx+ubflenx/2.
        outbox(1,2)=ubfceny-ubfleny/2.
        outbox(2,2)=ubfceny+ubfleny/2.
        outbox(1,3)=ubfcenz-ubflenz/2.
        outbox(2,3)=ubfcenz+ubflenz/2.
      else
        outbox(1,1)=+1.0d30
        outbox(2,1)=-1.0d30
        outbox(1,2)=+1.0d30
        outbox(2,2)=-1.0d30
        outbox(1,3)=+1.0d30
        outbox(2,3)=-1.0d30
      endif

      open(newunit=luno,file='force.box')
      do ix=1,2
        do iy=1,2
          do iz=1,2
            write(luno,*)outbox(ix,1),outbox(iy,2),outbox(iz,3)
          enddo
        enddo
      enddo
      close(luno)

      end
+DECK,clcmag_to_radia.
*CMZ :  2.05/07 23/10/2024  21.45.50  by  Michael Scheer
*CMZ :  2.05/06 11/10/2024  10.28.47  by  Michael Scheer
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 09/02/2022  19.36.16  by  Michael Scheer
*CMZ :  2.02/00 09/01/2021  12.08.32  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  12.47.44  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  15.45.12  by  Michael Scheer
*CMZ :  1.25/04 04/04/2018  11.40.25  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.27.59  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.25.43  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  09.00.40  by  Michael Scheer
*CMZ :  1.23/02 11/09/2017  15.35.11  by  Michael Scheer
*CMZ :  1.18/01 08/06/2017  14.20.17  by  Michael Scheer
*CMZ :  1.15/10 11/04/2017  11.14.47  by  Michael Scheer
*CMZ :  1.15/00 24/03/2017  10.28.46  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  17.33.35  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  10.15.10  by  Michael Scheer
*CMZ :  1.11/03 13/01/2017  15.10.38  by  Michael Scheer
*CMZ :  1.11/00 03/01/2017  16.16.45  by  Michael Scheer
*-- Author :    Michael Scheer   12/12/2016
      subroutine clcmag_to_radia

      use undumagf90m
      use bpolyederf90m
      use commandlinef90m
      use magnets_structure

! Interface to radia notebook. It writes the geometry to snipplets for RADIA
! Restriction:
! Isotropic materials must have a magnetization less then 0.01
!
! RADIA coordinate system: y is longitudinal, z is vertical
! UNDUMAG: x is longitudinal, y is vertical

      implicit none

+seq,phyconparam.

      double precision, dimension (:), allocatable :: x,y,z,brrec

      integer, dimension (:), allocatable :: khull,imatrec,imatiron,
     &  imatmagpol

      double precision :: gcen(3)

      real :: hfe,bfe

      integer ::
     &  nsymx,nsymy,nsymz,npoi,nmatfe,nlast,nfirst,nface,ncyl,ncolor,mater
     &  ,lunrad,lunfe,lmat,kproto,kpoi,k,ironmode,iron,imp,ipoi,imag,imat
     &  ,ifound,i,iface,ieof,nbr,nUnduMag,nUnduPol,nMagPolTot,lenout,lunproc,
     &  istat=0

      character(2048) cline,cbuff(10),cout
      character(64) chmat
      character(32) c32,c32x,c32y,c32z

      ncyl=0

      maxpoints=max(maxpoints,ncornmax*nplanmax)

      allocate(x(maxpoints),y(maxpoints),z(maxpoints),khull(maxpoints))
      allocate(brrec(nmagtot_t),imatrec(nmagtot_t),
     &  imatiron(nmagtot_t),imatmagpol(nmagtot_t))

      nbr=0
      nmatfe=0
      brrec=0.0d0
      imatrec=0

      do imag=1,nmagtot_t
        kproto=t_magcopy(imag)%kproto
        ifound=0
        if (t_magnets(kproto)%ispole.ne.0) then
          do i=1,nmatfe
            if (t_magnets(kproto)%imat.eq.imatiron(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) then
            cycle
          endif
          nmatfe=nmatfe+1
          imatiron(nmatfe)=t_magnets(kproto)%imat
          imatmagpol(imag)=nmatfe
        else
          do i=1,nbr
            if (brrec(i).eq.t_magcopy(imag)%brn.and.
     &          t_magnets(kproto)%imat.eq.imatrec(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) cycle
          nbr=nbr+1
          brrec(nbr)=t_magcopy(imag)%brn
          imatrec(nbr)=t_magnets(kproto)%imat
          imatmagpol(imag)=nbr
        endif
      enddo

      nsymx=1
      nsymy=1
      nsymz=1

      if (ixsymo.lt.0) nsymx=nsymx*2
      if (iysymo.lt.0) nsymy=nsymy*2
      if (izsymo.lt.0) nsymz=nsymz*2

      open(newunit=lunrad,file='undumag.nb')

      write(lunrad,*)' '
      write(lunrad,*)'(*-- Begin of lines generated by UNDUMAG --*)'
      write(lunrad,*)'(*-- Version ',trim(chuvers),' --*)'
      write(lunrad,*)' '
      write(lunrad,*)'<<Radia`; Off[General::"spell1"];'
      write(lunrad,*)' '
      write(cline,*)kundurun
      call util_string_trim(cline,nfirst,nlast)
      write(lunrad,*)'(*'
      call util_zeit_kommentar(lunrad,"Run: "//cline(nfirst:nlast))
      write(lunrad,*)'*)'

      write(lunrad,*)"(*"
      write(lunrad,*)"Comment: "//trim(unducomment)
      write(lunrad,*)"*)"
      write(lunrad,*)' '
      write(lunrad,*)'run = ',kundurun,";"
      write(lunrad,*)'comment = "'//trim(unducomment)//'";'
      write(lunrad,*)' '
      write(lunrad,*)'(* --- Variables of undumag.nam ---*)'
      write(lunrad,*)' '
      write(lunrad,*)'iUnduXsym = ',ixsymo,";"
      write(lunrad,*)'iUnduYsym = ',iysymo,";"
      write(lunrad,*)'iUnduZsym = ',izsymo,";"
      write(lunrad,*)' '
      write(lunrad,*)'UnduSymX = ',xsym,";"
      write(lunrad,*)' '
      write(lunrad,*)"kDraw = ",iunduplot,";"
      write(lunrad,*)"unduplot_theta = ",unduplot_theta,";"
      write(lunrad,*)"unduplot_phi = ",unduplot_phi,";"
      write(lunrad,*)' '

      write(c32x,*)xcenter
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXCenter = ",c32x," ;"
      write(c32x,*)xcentershift
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXCenterShift = ",c32x," ;"
      write(lunrad,*)' '
      write(c32x,*)utorqcenx
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenX = ",c32x," ;"
      write(c32x,*)utorqceny
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenY = ",c32x," ;"
      write(c32x,*)utorqcenz
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduTorqCenZ = ",c32x," ;"
      write(lunrad,*)' '
      write(c32x,*)xmapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXMapMin = ",c32x," ;"
      write(c32x,*)xmapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduXMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduXMap = ",nxmap," ;"
      write(lunrad,*)' '
      write(c32x,*)ymapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduYMapMin = ",c32x," ;"
      write(c32x,*)ymapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduYMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduYMap = ",nymap," ;"
      write(lunrad,*)' '
      write(c32x,*)zmapmin
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduZMapMin = ",c32x," ;"
      write(c32x,*)zmapmax
      call undumag_double_to_radia(c32x)
      write(lunrad,*)"UnduZMapMax = ",c32x," ;"
      write(lunrad,*)"nUnduZMap = ",nzmap," ;"
      write(lunrad,*)' '
      write(lunrad,*)' '
      write(lunrad,*)"nUnduNoPolMap = ",knopolmap," ;"
      write(lunrad,*)"nUnduNoMagMap = ",knomagmap," ;"
      write(lunrad,*)' '
+self,if=uvarrad.

      write(lunrad,*)' '
      write(lunrad,*)'(* --- Variables of undumag.clc ---*)'
      write(lunrad,*)' '

      do i=1,nvar_t
        write(lunrad,*) trim(t_variables(i)%cname),' = ',t_variables(i)%val,';'
      enddo !nvar_t
+self.,if=uvarrad.

      write(lunrad,*)' '
      write(lunrad,*)'(* --- Materials of undumag.clc ---*)'
      write(lunrad,*)' '

      do i=1,nbr
        imat=imatrec(i)
        if (imat.eq.0) cycle
        write(c32,*)i
c        if (matmaps(1,imat).eq.1) then
          if (matmaps(2,imat).eq.1) then
            write(c32x,'(f6.4)')bcmat(2,1,imat) !-1.0d0
            write(c32y,'(f6.4)')bcmat(3,1,imat) !-1.0d0
            write(c32z,'(g12.5)')brrec(i)
            write(lunrad,*)
     &        "UmatREC[" // trim(adjustl(c32)) // "] = radMatLin[{" //
     &        trim(adjustl(c32x)) // "," //
     &        trim(adjustl(c32y)) //
     &        "}," // trim(adjustl(c32z)) // "];"
          else
            print*,"*** Error in clcmag_to_radia: mode",
     &        matmaps(2,imat), " not yet implemented for REC material ",imat
            print*,""
            !stop "--- UNDUMAG aborted ---"
          endif
c        else
c          print*,"*** Error in clcmag_to_radia: Unknown material or mode", imat,
c     &      matmaps(:,imat)
c          print*,""
c          !stop "--- UNDUMAG aborted ---"
c        endif
      enddo

      do i=1,nmatfe
        imat=imatiron(i)
        if (imat.eq.0) cycle
        write(c32,*)i
        if (matmaps(2,imat).eq.2) then
          write(lunrad,*)
     &      "UmatIron[" // trim(adjustl(c32)) // "] = radMatSatIso[{"
          do k=2,nclcmat
            read(clcmat(k),*)iron,lmat,ironmode,cbuff(1)
            if (iron.eq.imat) then
              open(newunit=lunfe,file=trim(cbuff(1)),status='old')
              ieof=0
              do while (ieof.eq.0)
                call util_skip_comment_end(lunfe,ieof)
                if (ieof.ne.0) exit
                read(lunfe,*) hfe,bfe
                write(lunrad,*)"{",hfe,",",bfe,"},"
              enddo
              backspace(lunrad)
              write(lunrad,*)"{",hfe,",",bfe,"}"
              close(lunfe)
            endif
          enddo
          write(lunrad,*)"}];"
        else
          print*,"*** Error in clcmag_to_radia: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          !stop "--- UNDUMAG aborted ---"
        endif
      enddo

      write(lunrad,*)' '
      write(lunrad,*)'(* --- Poles and magnets of undumag.clc ---*)'
      write(lunrad,*)' '

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        ! radObjPolyhdr[
        ! {
        !   {x1,y1,z1}, ..., {xn,yn,zn} Corners
        ! },
        ! {
        !   {f1n1,f1n2,...}, ...., {f2n1,f2n2,...} Faces
        ! },
        ! {mx,my,mz}:{0,0,0}]

        nface=t_magnets(kproto)%nface
        ncolor=t_magnets(kproto)%icol

        write(lunrad,*)"   ",trim(t_magcopy(imp)%cnam)//" = radObjPolyhdr["
        write(lunrad,*)"        { (* List of points *)"

        gcen=t_magcopy(imp)%gcen

        do kpoi=1,t_magnets(kproto)%nhull
          write(c32x,*)sngl(t_magnets(kproto)%xhull(kpoi)+gcen(1)+xcentershift)
          call undumag_double_to_radia(c32x)
          write(c32y,*)sngl(t_magnets(kproto)%yhull(kpoi)+gcen(2))
          call undumag_double_to_radia(c32y)
          write(c32z,*)sngl(t_magnets(kproto)%zhull(kpoi)+gcen(3))
          call undumag_double_to_radia(c32z)
          if (kpoi.lt.t_magnets(kproto)%nhull) then
            write(lunrad,*)
     &        "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"},"
          else
            write(lunrad,*)
     &        "           {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
          endif
        enddo !kpoi

        write(lunrad,*)"        }, (* End of list of points *)"

        write(lunrad,*)"        { (* List of faces *)"

        kpoi=1
        do iface=1,nface
          npoi=t_magnets(kproto)%kface(kpoi)
          cline="         {"
          do ipoi=kpoi+1,kpoi+npoi
            call util_string_append_num(cline,t_magnets(kproto)%kface(ipoi),
     &        nfirst,nlast)
            if (ipoi.lt.kpoi+npoi) then
              call util_string_append(cline,',',nfirst,nlast)
            else
              call util_string_append(cline,'},',nfirst,nlast)
            endif
          enddo !ipoi
          if (iface.lt.nface) then
            write(lunrad,*)cline(1:nlast)
            call util_string_append(cline,'},',nfirst,nlast)
          else
            write(lunrad,*)cline(1:nlast-1)
          endif
          kpoi=kpoi+npoi+1
        enddo !nface

        write(lunrad,*)"        }, (* End of list of faces *)"

        if (t_magnets(kproto)%IsPole.eq.0) then
          write(c32x,*)t_magnets(kproto)%br(1)
          call undumag_double_to_radia(c32x)
          write(c32y,*)t_magnets(kproto)%br(2)
          call undumag_double_to_radia(c32y)
          write(c32z,*)t_magnets(kproto)%br(3)
          call undumag_double_to_radia(c32z)
          write(lunrad,*)"         {",trim(c32z),",",trim(c32x),",",trim(c32y),"}"
          mater = imatmagpol(imp)
          write(chmat,*)mater
          call util_string_trim(chmat,nfirst,nlast)
          chmat="UmatREC["//chmat(nfirst:nlast)//"]"
        else
          write(lunrad,*)"         {0,0,0}"
          write(lunrad,*)"       ];"
          mater = imatmagpol(imp)
          write(chmat,*)mater
          call util_string_trim(chmat,nfirst,nlast)
          chmat="UmatIron["//chmat(nfirst:nlast)//"]"
        endif !Pole/Mag

        if (t_magnets(kproto)%nzdiv*t_magnets(kproto)%nydiv*t_magnets(kproto)%nxdiv.gt.1) then
          write(lunrad,*)' '
          write(cline,*)
     &      "      radObjDivMag["//trim(adjustl(t_magcopy(imp)%cnam))//", {{",
     &      t_magnets(kproto)%nzdiv,",",
     &      sngl(t_magnets(kproto)%zfracdiv),"},",t_magnets(kproto)%nxdiv,
     &      ",{",t_magnets(kproto)%nydiv,",",
     &      sngl(t_magnets(kproto)%yfracdiv),"}},kxkykz->Numb];"
          call util_remove_double_blanks(cline,cout,lenout)
          write(lunrad,*)'       ',cout(1:lenout)
          write(lunrad,*)' '
        endif

        write(lunrad,*)" "
        write(lunrad,*)"       radMatApl["//trim(adjustl(t_magcopy(imp)%cnam))//","//
     &    trim(chmat)//"];"

        if (ncolor.eq.2) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{1,0,0},0.0001];"
        else if (ncolor.eq.3) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{0,1,0},0.0001];"
        else if (ncolor.eq.4) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{0,0,1},0.0001];"
        else if (ncolor.eq.5) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{1,1,0},0.0001];"
        else if (ncolor.eq.6) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{1,0,1},0.0001];"
        else if (ncolor.eq.7) then
          write(lunrad,*)"       radObjDrwAtr["//trim(adjustl(t_magcopy(imp)%cnam))//
     &      ",{0,1,1},0.0001];"
        endif

        write(lunrad,*)" "

      enddo !imp=1,nmagtot_t

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        if (t_magnets(kproto)%IsPole.eq.0) then

          nUnduMag=nUnduMag+1

          write(c32,*)nUnduMag
          write(lunrad,*)"       nUnduMag = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       UnduMag[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"

          nMagPolTot=nMagPolTot+1

          write(c32,*)nMagPolTot
          write(lunrad,*)"       nMagPolTot = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       AllMagPols[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"
          write(lunrad,*)" "

          if (t_magcopy(imp)%cnam.eq.chforcemag) then
            write(lunrad,*)' '
            write(lunrad,*)"       iForceTyp = 1;"
            write(c32,*)nUnduMag
            write(lunrad,*)"      nForce = " // trim(adjustl(c32)) //";"
            write(lunrad,*)' '
            write(lunrad,*)" "
          endif

        else

          nUnduPol=nUnduPol+1
          write(c32,*)nUnduPol
          write(lunrad,*)"       nUnduPol = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       UnduPol[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"

          nMagPolTot=nMagPolTot+1

          write(c32,*)nMagPolTot
          write(lunrad,*)"       nMagPolTot = " // trim(adjustl(c32)) // ";"
          write(lunrad,*)"       AllMagPols[" // trim(adjustl(c32)) // "] = " //
     &      trim(adjustl(t_magcopy(imp)%cnam)) // ";"
          write(lunrad,*)" "

          if (t_magcopy(imp)%cnam.eq.chforcemag) then
            write(lunrad,*)' '
            write(lunrad,*)"       iForceTyp = 1;"
            write(c32,*)nUnduPol
            write(lunrad,*)"      nForce = " // trim(adjustl(c32)) //";"
            write(lunrad,*)' '
            write(lunrad,*)" "
          endif

        endif !Pole/Mag

      enddo !imp=1,nmagtot_t

      deallocate(brrec)

      write(lunrad,*)' '
      write(lunrad,*)'(*-- End of lines generated by UNDUMAG --*)'
      write(lunrad,*)' '

      write(lunrad,*)' '
      write(lunrad,*)'(*-- Reading undumag_proc.nb and appending to undumag.nb --*)'
      write(lunrad,*)' '

      open(newunit=lunproc,file='undumag_proc.nb',status='old', iostat=istat)

      if (istat.ne.0) then
        write(lun6,*)"*** Error in clcmag_to_radia: File undumag_proc.nb not found ***"
      else

        ieof=0
        cline=''

        do while (ieof.eq.0)
          read(lunproc,'(a)',iostat=ieof) cline
          if (ieof.eq.0) write(lunrad,'(a)') trim(cline)
        enddo
        close(lunproc)

      endif

      flush(lunrad)
      close(lunrad)

      return
      end
+DECK,clccoil_to_coils.
*CMZ :  2.05/07 24/10/2024  11.22.22  by  Michael Scheer
*CMZ :  2.05/03 06/11/2023  13.51.20  by  Michael Scheer
*CMZ :  2.04/13 31/08/2023  13.05.39  by  Michael Scheer
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/02 03/03/2022  12.09.38  by  Michael Scheer
*CMZ :  2.02/01 19/10/2021  13.27.41  by  Michael Scheer
*-- Author :    Michael Scheer   20/04/2021
      subroutine clccoil_to_coils

      use undumagf90m
      use commandlinef90m
      use magnets_structure

      implicit none

      character(2048) cline,cline1
      character(128) cword,ckey

      double precision curr,x1,y1,z1,x2,y2,z2,
     &  wind19(19),bx,by,bz,p(100)

      integer i,ib,nw,icolor
      integer ipos(2,1000),nwords,nc,nwc,istat,nf,nfila

      integer lunf,ieof

      character(32) c32

      nrace=0
      nwind=0
      ncrace=0
      narc=0
      ncarc=0
      nrbar=0
      nthwir=0
      ncwires=0

      if (ncoils_t.le.0) then
        allocate(wire(nwitems,1)) !to avoid problmens in undumag_bpolyplot
        return
      endif

      if (ixsym.ne.0.or.iysym.ne.0.or.izsym.ne.0) then
        print*,' '
        print*,'*** Warning: Requested symmertry operations are NOT applied to coils ***'
        print*,' '
        call sleep(2)
      endif

      allocate(t_coils(ncoils_t))

      nw=0
      nwc=0
      nc=0
      ib=0

      if (kechocalc.ne.0) then
        print*,""
        print*,"Entered clcoil_to_coils:"
        print*,""
      endif

      do while (ib.lt.nclccoil-1)

        ib=ib+1
        cline=clccoil(ib)

        if (kechocalc.ne.0) print*,trim(cline)

        call clcstring_to_vars(cline)
        call util_string_split(cline,1000,nwords,ipos,istat)

        if (cline(ipos(1,1):ipos(2,1)).eq.'Coil') cycle

        ckey=trim(adjustl(cline(ipos(1,1):ipos(2,1))))
        nc=nc+1

        if (nwords.gt.1) then
          t_coils(nc)%cnam=cline(ipos(1,2):ipos(2,2))
        else
          write(c32,*)nc
          t_coils(nc)%cnam="Coil_" // adjustl(trim(c32))
        endif

        t_coils(nc)%ctype=trim(ckey)

        ib=ib+1
        cline=clccoil(ib)
        if (kechocalc.ne.0) print*,trim(cline)
        call clcstring_to_vars(cline)
        call util_string_split(cline,1000,nwords,ipos,istat)
        cword=cline(ipos(1,1):ipos(2,1))

        if (ckey.eq.'Filaments') then

          read(cword,*)nf
          t_coils(nc)%iibuff=ib

          nfila=0
          do i=1,nf
            ib=ib+1
            cline=clccoil(ib)
            if (kechocalc.ne.0) print*,trim(cline)
            call clcstring_to_vars(cline)
            call util_string_split(cline,1000,nwords,ipos,istat)
            cword=cline(ipos(1,1):ipos(2,1))
            read(cword,*)curr
c            if (curr.eq.0.0d0) cycle
            cword=cline(ipos(1,2):ipos(2,2))
            read(cword,*)x1
            cword=cline(ipos(1,3):ipos(2,3))
            read(cword,*)y1
            cword=cline(ipos(1,4):ipos(2,4))
            read(cword,*)z1
            cword=cline(ipos(1,5):ipos(2,5))
            read(cword,*)x2
            cword=cline(ipos(1,6):ipos(2,6))
            read(cword,*)y2
            cword=cline(ipos(1,7):ipos(2,7))
            read(cword,*)z2
            if ((x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
            nfila=nfila+1
          enddo

          if (nfila.eq.0) then
            nc=nc-1
          endif

          ncwires=ncwires+nfila
          t_coils(nc)%iebuff=ib
          t_coils(nc)%params(1)=nfila

        else if (ckey.eq.'File') then

          nfila=0
          cline=trim(adjustl(clccoil(ib)))
          t_coils(nc)%cparams=trim(cline)
          open(newunit=lunf,file=cline,status='old')

          do while (.true.)
            call util_skip_comment_empty_end(lunf,ieof)
            if (ieof.ne.0) exit
            read(lunf,'(a)') cline
            if (kechocalc.ne.0) print*,trim(cline)
            call clcstring_to_vars(cline)
            read(cline,*)curr,x1,y1,z1,x2,y2,z2,icolor
c            if (curr.eq.0.0d0.or.(x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
            if ((x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
            nfila=nfila+1
          enddo
          close(lunf)

          if (nfila.eq.0) then
            nc=nc-1
          endif

          ncwires=ncwires+nfila
          t_coils(nc)%params(1)=nfila

        else if (ckey.eq.'RectWindings') then
          read(cline,*)t_coils(nc)%params(1:19)
c          if (t_coils(nc)%params(1).eq.0.0d0) then
c            nc=nc-1
c            cycle
c          endif
          nwind=nwind+1
        else if (ckey.eq.'Rectangular') then
          read(cline,*)t_coils(nc)%params(1:17)
c          if (t_coils(nc)%params(1).eq.0.0d0) then
c            nc=nc-1
c            cycle
c          endif
          nrace=nrace+1
        else if (ckey.eq.'RectangCirc') then
          read(cline,*)t_coils(nc)%params(1:17)
c          if (t_coils(nc)%params(1).eq.0.0d0) then
c            nc=nc-1
c            cycle
c          endif
          ncrace=ncrace+1
        else if (ckey.eq.'RectArc') then
          ib=ib+1
          cline1=clccoil(ib)
          if (kechocalc.ne.0) print*,trim(cline1)
          call clcstring_to_vars(cline1)
          cline=trim(adjustl(cline)) // " " // trim(adjustl(cline1))
          read(cline,*)t_coils(nc)%params(1:21)
c          if (t_coils(nc)%params(1).eq.0.0d0) then
c            nc=nc-1
c            cycle
c          endif
          narc=narc+1
        else if (ckey.eq.'CircArc') then
          ib=ib+1
          cline1=clccoil(ib)
          if (kechocalc.ne.0) print*,trim(cline1)
          call clcstring_to_vars(cline1)
          cline=trim(adjustl(cline)) // " " // trim(adjustl(cline1))
          read(cline,*)t_coils(nc)%params(1:20)
c          if (t_coils(nc)%params(1).eq.0.0d0) then
c            nc=nc-1
c            cycle
c          endif
          ncarc=ncarc+1
        else if (ckey.eq.'RectBar') then
          ib=ib+1
          cline1=clccoil(ib)
          if (kechocalc.ne.0) print*,trim(cline1)
          cline1=clccoil(ib)
          call clcstring_to_vars(cline1)
          cline=trim(adjustl(cline)) // " " // trim(adjustl(cline1))
          read(cline,*)t_coils(nc)%params(1:19)
c          if (t_coils(nc)%params(1).eq.0.0d0) then
c            nc=nc-1
c            cycle
c          endif
          nrbar=nrbar+1
        else if (ckey.eq.'ThickWire') then
          ib=ib+1
          cline1=clccoil(ib)
          if (kechocalc.ne.0) print*,trim(cline1)
          call clcstring_to_vars(cline1)
          cline=trim(adjustl(cline)) // " " // trim(adjustl(cline1))
          read(cline,*)t_coils(nc)%params(1:18)
c          if (t_coils(nc)%params(1).eq.0.0d0) then
c            nc=nc-1
c            cycle
c          endif
          nthwir=nthwir+1
        endif !ckey

      enddo !nclccoil

      if (ncwires.gt.0) then
        allocate(wire(nwitems,ncwires))
        wire=0.0d0
      endif

      if (nwind.gt.0) then
        allocate(wind(19,nwind))
        wind=0.0d0
      endif

      if (nrace.gt.0) then
        allocate(race(17,nrace))
        race=0.0d0
      endif

      if (ncrace.gt.0) then
        allocate(crace(17,ncrace))
        crace=0.0d0
      endif

      if (narc.gt.0) then
        allocate(arc(21,narc))
        arc=0.0d0
      endif

      if (ncarc.gt.0) then
        allocate(carc(20,ncarc))
        carc=0.0d0
      endif

      if (nrbar.gt.0) then
        allocate(rectbar(19,nrbar))
        rectbar=0.0d0
      endif

      if (nthwir.gt.0) then
        allocate(thickwire(18,nthwir))
        thickwire=0.0d0
      endif

      ncoils_t=nc

      ncwires=0
      nrace=0
      nwind=0
      ncrace=0
      narc=0
      ncarc=0
      nrbar=0
      nthwir=0

      nw=0
      nc=0
      ib=0

      do nc=1,ncoils_t

        p(1:100)=t_coils(nc)%params(1:100)
        ckey=trim(adjustl(t_coils(nc)%ctype))

        if (ckey.eq.'Filaments') then

          nwc=nwc+1

          do ib=t_coils(nc)%iibuff+1,t_coils(nc)%iebuff
            cline=clccoil(ib)
            call clcstring_to_vars(cline)
            call util_string_split(cline,1000,nwords,ipos,istat)
            cword=cline(ipos(1,1):ipos(2,1))
            read(cword,*)curr
c            if (curr.eq.0.0d0) cycle
            cword=cline(ipos(1,2):ipos(2,2))
            read(cword,*)x1
            cword=cline(ipos(1,3):ipos(2,3))
            read(cword,*)y1
            cword=cline(ipos(1,4):ipos(2,4))
            read(cword,*)z1
            cword=cline(ipos(1,5):ipos(2,5))
            read(cword,*)x2
            cword=cline(ipos(1,6):ipos(2,6))
            read(cword,*)y2
            cword=cline(ipos(1,7):ipos(2,7))
            read(cword,*)z2
            if ((x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
            ncwires=ncwires+1
            cword=cline(ipos(1,8):ipos(2,8))
            read(cword,*)icolor
            wire(1,ncwires)=1 !type
            wire(2,ncwires)=curr
            wire(3,ncwires)=x1
            wire(4,ncwires)=y1
            wire(5,ncwires)=z1
            wire(6,ncwires)=x2
            wire(7,ncwires)=y2
            wire(8,ncwires)=z2
            wire(9,ncwires)=icolor
            wire(10,ncwires)=nc
            wire(11,ncwires)=nwc
          enddo

        else if (ckey.eq.'File') then
          cline=t_coils(nc)%cparams
          open(newunit=lunf,file=cline,status='old')
          nwc=nwc+1
          do i=1,nint(t_coils(nc)%params(1))
            call util_skip_comment_empty_end(lunf,ieof)
            read(lunf,'(a)') cline
            call clcstring_to_vars(cline)
            read(cline,*)curr,x1,y1,z1,x2,y2,z2,icolor
            if ((x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
c            if (curr.eq.0.0d0.or.(x1-x2)**2+(y2-y1)**2+(z2-z1)**2.eq.0.0d0) cycle
            ncwires=ncwires+1
            wire(1,ncwires)=1 !type
            wire(2,ncwires)=curr
            wire(3,ncwires)=x1
            wire(4,ncwires)=y1
            wire(5,ncwires)=z1
            wire(6,ncwires)=x2
            wire(7,ncwires)=y2
            wire(8,ncwires)=z2
            wire(9,ncwires)=icolor
            wire(10,ncwires)=nc
            wire(11,ncwires)=nwc
          enddo
          close(lunf)
        else if (ckey.eq.'RectWindings') then
          wind19=t_coils(nc)%params(1:19)
          nwind=nwind+1
          wind(1,nwind)=wind19(1)
          wind(2:17,nwind)=wind19(4:19)
          wind(18:19,nwind)=wind19(2:3)
        else if (ckey.eq.'Rectangular') then
          nrace=nrace+1
          race(1:17,nrace)=t_coils(nc)%params(1:17)
        else if (ckey.eq.'RectangCirc') then
          ncrace=ncrace+1
          crace(1:17,ncrace)=t_coils(nc)%params(1:17)
        else if (ckey.eq.'RectArc') then
          narc=narc+1
          arc(1:21,narc)=t_coils(nc)%params(1:21)
        else if (ckey.eq.'CircArc') then
          ncarc=ncarc+1
          carc(1:20,ncarc)=t_coils(nc)%params(1:20)
        else if (ckey.eq.'RectBar') then
          nrbar=nrbar+1
          rectbar(1:19,nrbar)=t_coils(nc)%params(1:19)
        else if (ckey.eq.'ThickWire') then
          nthwir=nthwir+1
          thickwire(1:18,nthwir)=t_coils(nc)%params(1:18)
        endif !ckey

      enddo !nclccoil

      call undumag_bcoils(0.0d0,0.0d0,0.0d0,bx,by,bz,istat)

      return
      end
+DECK,undumag_beffy_beffz.
*CMZ :          26/10/2024  17.45.51  by  Michael Scheer
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/02 26/02/2022  12.52.35  by  Michael Scheer
*CMZ :  2.02/01 10/11/2021  10.13.19  by  Michael Scheer
*CMZ :  2.02/00 29/03/2021  09.45.50  by  Michael Scheer
*CMZ :  2.01/08 15/08/2020  08.14.56  by  Michael Scheer
*CMZ :  2.01/05 05/06/2020  17.09.33  by  Michael Scheer
*CMZ :  2.01/04 29/07/2019  12.05.13  by  Michael Scheer
*CMZ :  2.01/03 16/07/2019  09.25.31  by  Michael Scheer
*CMZ :  2.01/02 27/04/2018  16.20.58  by  Michael Scheer
*CMZ :  2.00/03 19/04/2018  11.05.57  by  Michael Scheer
*CMZ :  2.00/01 16/04/2018  13.46.37  by  Michael Scheer
*CMZ :  1.25/05 05/04/2018  16.46.42  by  Michael Scheer
*CMZ :  1.25/04 03/04/2018  11.15.27  by  Michael Scheer
*CMZ :  1.25/03 03/04/2018  08.01.24  by  Michael Scheer
*CMZ :  1.25/02 21/03/2018  13.03.12  by  Michael Scheer
*CMZ :  1.25/01 20/03/2018  16.17.42  by  Michael Scheer
*CMZ :  1.25/00 14/03/2018  12.58.50  by  Michael Scheer
*CMZ :  1.24/01 13/10/2017  11.37.28  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  14.05.37  by  Michael Scheer
*CMZ :  1.23/04 05/10/2017  12.07.37  by  Michael Scheer
*CMZ :  1.23/03 25/09/2017  15.55.08  by  Michael Scheer
*CMZ :  1.23/02 18/09/2017  15.18.42  by  Michael Scheer
*CMZ :  1.22/02 04/08/2017  07.56.26  by  Michael Scheer
*CMZ :  1.22/01 20/07/2017  14.55.33  by  Michael Scheer
*CMZ :  1.22/00 05/07/2017  10.09.09  by  Michael Scheer
*CMZ :  1.20/03 29/06/2017  15.38.45  by  Michael Scheer
*CMZ :  1.20/01 22/06/2017  13.35.35  by  Michael Scheer
*CMZ :  1.20/00 21/06/2017  16.39.29  by  Michael Scheer
*CMZ :  1.19/00 20/06/2017  12.15.48  by  Michael Scheer
*CMZ :  1.18/03 14/06/2017  09.22.03  by  Michael Scheer
*CMZ :  1.18/01 07/06/2017  16.12.25  by  Michael Scheer
*CMZ :  1.18/00 02/06/2017  09.38.06  by  Michael Scheer
*CMZ :  1.17/08 30/05/2017  15.20.49  by  Michael Scheer
*CMZ :  1.17/07 24/05/2017  08.36.20  by  Michael Scheer
*CMZ :  1.17/06 18/05/2017  22.30.31  by  Michael Scheer
*CMZ :  1.15/12 04/05/2017  15.55.38  by  Michael Scheer
*CMZ :  1.15/11 24/04/2017  17.57.38  by  Michael Scheer
*CMZ :  1.15/10 19/04/2017  12.15.17  by  Michael Scheer
*CMZ :  1.15/09 07/04/2017  14.51.07  by  Michael Scheer
*CMZ :  1.15/08 06/04/2017  09.01.37  by  Michael Scheer
*CMZ :  1.15/07 04/04/2017  13.49.11  by  Michael Scheer
*CMZ :  1.15/05 03/04/2017  13.40.53  by  Michael Scheer
*CMZ :  1.15/04 03/04/2017  12.57.38  by  Michael Scheer
*CMZ :  1.15/03 02/04/2017  15.45.35  by  Michael Scheer
*CMZ :  1.15/02 02/04/2017  09.38.56  by  Michael Scheer
*CMZ :  1.15/01 28/03/2017  15.25.06  by  Michael Scheer
*CMZ :  1.15/00 27/03/2017  15.13.40  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  14.39.06  by  Michael Scheer
*CMZ :  1.13/03 10/03/2017  12.16.46  by  Michael Scheer
*CMZ :  1.13/01 08/03/2017  16.26.29  by  Michael Scheer
*CMZ :  1.11/05 22/02/2017  12.53.52  by  Michael Scheer
*CMZ :  1.11/04 23/01/2017  17.22.15  by  Michael Scheer
*CMZ :  1.11/03 17/01/2017  14.50.28  by  Michael Scheer
*CMZ :  1.11/00 07/12/2016  12.48.13  by  Michael Scheer
*CMZ :  1.10/02 24/11/2016  10.22.30  by  Michael Scheer
*CMZ :  1.10/01 18/11/2016  15.52.38  by  Michael Scheer
*CMZ :  1.10/00 18/11/2016  09.18.26  by  Michael Scheer
*CMZ :  1.09/01 06/10/2016  14.12.02  by  Michael Scheer
*CMZ :  1.07/03 27/09/2016  13.45.21  by  Michael Scheer
*CMZ :  1.07/02 25/09/2016  13.30.02  by  Michael Scheer
*CMZ :  1.07/01 25/09/2016  11.49.21  by  Michael Scheer
*CMZ :  1.07/00 24/09/2016  14.57.45  by  Michael Scheer
*CMZ :  1.06/01 21/09/2016  15.31.52  by  Michael Scheer
*CMZ :  1.06/00 20/09/2016  14.13.49  by  Michael Scheer
*CMZ :  1.02/01 09/09/2016  15.30.08  by  Michael Scheer
*CMZ :  1.02/00 29/08/2016  12.45.07  by  Michael Scheer
*CMZ :  1.01/00 21/08/2016  12.03.06  by  Michael Scheer
*CMZ :  1.00/00 19/08/2016  18.37.39  by  Michael Scheer
*CMZ :  0.00/13 16/08/2016  11.57.51  by  Michael Scheer
*CMZ :  0.00/11 18/07/2016  09.18.11  by  Michael Scheer
*CMZ :  0.00/10 13/07/2016  14.57.35  by  Michael Scheer
*CMZ :  0.00/09 28/06/2016  15.42.08  by  Michael Scheer
*CMZ :  0.00/06 16/06/2016  14.14.37  by  Michael Scheer
*CMZ :  0.00/05 13/06/2016  12.45.02  by  Michael Scheer
*CMZ :  0.00/02 30/04/2016  13.12.13  by  Michael Scheer
*CMZ :  0.00/01 26/04/2016  14.02.34  by  Michael Scheer
*CMZ :  1.17/11 05/04/2016  15.51.06  by  Michael Scheer
*CMZ :  1.17/08 04/04/2016  08.57.43  by  Michael Scheer
*CMZ :  1.17/07 03/04/2016  19.38.32  by  Michael Scheer
*CMZ :  1.17/06 01/04/2016  12.58.26  by  Michael Scheer
*CMZ :  1.17/05 27/03/2016  12.40.54  by  Michael Scheer
*CMZ :  1.17/04 24/03/2016  15.11.21  by  Michael Scheer
*CMZ :  1.17/03 22/03/2016  07.59.20  by  Michael Scheer
*CMZ :  1.17/02 07/03/2016  16.32.54  by  Michael Scheer
*-- Author :    Michael Scheer   07/03/2016
      subroutine undumag_beffy_beffz(
     &  byint1f,bzint1f,
     &  byint2f,bzint2f,
     &  byint1inf,bzint1inf,
     &  byint1fnor,bzint1fnor,
     &  byint2fnor,bzint2fnor,
     &  byexint,bzexint)

      use bpolyederf90m
      use undumagf90m
      use commandlinef90m

      implicit none

+seq,seqdebug.
+seq,random.
+seq,mshplt.

      double precision, dimension (:,:,:,:), allocatable :: bmap
      double precision, dimension (:,:), allocatable :: hmvoxel,hmagvox
      double precision, dimension (:), allocatable ::
     &  xint,bxa,bya,bza,
     &  byint,bzint,byint2,bzint2,
     &  xinti,bxai,byai,bzai,bym,bzm,
     &  byinti,bzinti,byint2i,bzint2i,
     &  xintnor,bxanor,byanor,bzanor,
     &  byintnor,bzintnor,byint2nor,bzint2nor,
     &  xintd,bxad,byad,bzad,
     &  byintd,bzintd,byint2d,bzint2d,
     &  ws1,ws2,ws3,ws4,coef

      integer, dimension (:), allocatable :: kfailbeff,kfailbyeff,kfailbzeff

      double precision bmnbeff,bmxbeff,beff,dkeff,bp(3),a(3),x,xx,y,z,
     &  xminbeffnor,xmaxbeffnor,xmaxbeff,xminbeff,dxkbmode,dx,yopt,yp(3),
     &  quadperlen,xopt,halfperlen,by,bx,bz,b,bprog,a3(3),x3(3),dkeffz,bmaxp,
     &  dkeffznor,dkeffnor,dum,bmxbeffznor,bmnbeffznor,bmxbeffz,bmxbeffnor,
     &  bmnbeffz,b3(3),beffnor,beffz,beffznor,bmnbeffnor,bmaxbeffnor,bmaxbeff,
     &  bmnbeffy,bmxbeffy,dkeffy,byint2fnor,bmnbeffynor,bmxbeffynor,dkeffynor

      double precision beffy,beffynor,byexint,bzexint,byint1f,
     &  byint1fnor,byint1inf,byint2f,bymaxbeff,bzint1f,bzint1fnor,
     &  bzint1inf,bzint2f,bzint2fnor,bzmaxbeff,xbeffo,xbymax,xbzmax

      real g(3),xpl(2),ypl(2),dxpl,yplmin,yplmax,xplmin,xplmax,dypl

      integer modus,lun,idis,ixbeff,ixbeffnor,irecover,itry,ix,kfail,ibmax,
     &  ifail,ibmin,i,nfirst,nlast

      character(64) ctitle,cline
      character(24) cbeff,cbint

      allocate (
     &  xintnor(nxbeff),
     &  byintnor(nxbeff),bzintnor(nxbeff),
     &  byint2nor(nxbeff),bzint2nor(nxbeff),
     &  bxanor(nxbeff),byanor(nxbeff),bzanor(nxbeff),
     &  xint(nxbeff),
     &  byint(nxbeff),bzint(nxbeff),
     &  byint2(nxbeff),bzint2(nxbeff),
     &  bxa(nxbeff),bya(nxbeff),bza(nxbeff),
     &  ws1(nxbeff),ws2(nxbeff),ws3(nxbeff),ws4(nxbeff),coef(nxbeff),
     &  kfailbeff(nxbeff))

c      if (xbeff.eq.9999.0d0) xbeff=xconv(nxconv/2+1)
      if (xbeff.eq.9999.0d0) xbeff=xcenter
      if (xbeff.eq.-9999.0d0) xbeff=(xmapmin+xmapmax)/2.0d0

      xbeffo=xbeff

      halfperlen=perlen/2.0d0
      quadperlen=perlen/4.0d0

      bymaxbeff=-1.0d30
      bzmaxbeff=-1.0d30

      if (kbeffmode.eq.0) then
        xminbeff=xbeff-perlen*0.51
        xmaxbeff=xbeff+perlen*0.51
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
        dxkbmode=abs(kbeffmode)*dx
      else
        xminbeff=xbeff-quadperlen
        xmaxbeff=xbeff+quadperlen
        dx=(xmaxbeff-xminbeff)/(nxbeff-1)
        dxkbmode=abs(kbeffmode)*dx
        xminbeffnor=xminbeff
        xmaxbeffnor=xmaxbeff
      endif

      xbymax=xbeff
      xbzmax=xbeff

      do ix=1,nxbeff

        x=xminbeff+(ix-1)*dx
        xx=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          cycle
        endif

        call util_random(3,g)
        g=g-0.5
c+self,if=rando10.
        if (abs(g(1)).lt.randox10) then
          if (g(1).gt.0.0d0) then
            g(1)=g(1)+randox10
          else
            g(1)=g(1)-randox10
          endif
        endif
        if (abs(g(2)).lt.randoy10) then
          if (g(2).gt.0.0d0) then
            g(2)=g(2)+randoy10
          else
            g(2)=g(2)-randoy10
          endif
        endif
        if (abs(g(3)).lt.randoz10) then
          if (g(3).gt.0.0d0) then
            g(3)=g(3)+randoz10
          else
            g(3)=g(3)-randoz10
          endif
        endif

c+self.,if=rando10.
        if (randox.ge.0.0d0) then
          x=x+g(1)*randoxa ! millimeter!
        else
          x=x+randoxa ! millimeter!
        endif

        xint(ix)=x

        if (kbeffmode.ne.0.and.abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
          if (x.lt.xbeff) then
            x=xx+abs(xx-x)
          else
            x=xx-abs(xx-x)
          endif
        endif

        if (randoy.ge.0.0d0) then
          y=g(2)*randoya
        else
          y=randoya
        endif
        if (randoz.ge.0.0d0) then
          z=g(3)*randoza
        else
          z=randoza
        endif

        if (kbeffmode.eq.0) then
          call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &      bx,by,bz,ifail)
        else
          if (abs(abs(x-xbeff)-quadperlen).lt.dxkbmode) then
            cycle
          endif
          if (abs(x-xbeff).le.quadperlen) then
            call undumag_field(x/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
          else if (x.lt.xbeff) then
            call undumag_field((x+halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          else
            call undumag_field((x-halfperlen)/1000.0d0,y/1000.0d0,z/1000.0d0,
     &        bx,by,bz,ifail)
            bx=-bx
            by=-by
            bz=-bz
          endif
        endif !kbeffmode

        if (ifail.ne.0) cycle

        if (abs(by).gt.bymaxbeff) then
          bymaxbeff=abs(by)
          xbymax=xminbeff+(ix-1)*dx
        endif

        if (abs(bz).gt.bzmaxbeff) then
          bzmaxbeff=abs(bz)
          xbzmax=xminbeff+(ix-1)*dx
        endif

      enddo !ix

      if (bymaxbeff.lt.1.0d-4*bzmaxbeff) xbymax=xbzmax
      if (bzmaxbeff.lt.1.0d-4*bymaxbeff) xbzmax=xbymax

      xbeff=xbymax

      xminbeff=xbeff-perlen/2.0d0
      xmaxbeff=xbeff+perlen/2.0d0

      if (abs(xbeffo-xminbeff).le.quadperlen) then
        xminbeff=xminbeff-halfperlen
        xmaxbeff=xmaxbeff-halfperlen
      else if (xbeffo-xminbeff.gt.halfperlen*1.001) then
        xminbeff=xminbeff+halfperlen
        xmaxbeff=xmaxbeff+halfperlen
      endif

      if (xbeffz.ne.-9999.0d0) then
        xbeff=xbeffz
        xminbeff=xbeff-perlen/2.0d0
        xmaxbeff=xbeff+perlen/2.0d0
      endif

      call undumag_beff(xminbeff,xmaxbeff,bmnbeffy,bmxbeffy,beffy,dkeffy,
     &  bmnbeffynor,bmxbeffynor,beffynor,dkeffynor,1)

      xbeff=xbzmax

      xminbeff=xbeff-perlen/2.0d0
      xmaxbeff=xbeff+perlen/2.0d0

      if (abs(xbeffo-xminbeff).le.quadperlen) then
        xminbeff=xminbeff-halfperlen
        xmaxbeff=xmaxbeff-halfperlen
      else if (xbeffo-xminbeff.gt.halfperlen*1.001) then
        xminbeff=xminbeff+halfperlen
        xmaxbeff=xmaxbeff+halfperlen
      endif

      if (xbeffz.ne.-9999.0d0) then
        xbeff=xbeffz
        xminbeff=xbeff-perlen/2.0d0
        xmaxbeff=xbeff+perlen/2.0d0
      endif

      call undumag_beff(xminbeff,xmaxbeff,bmnbeffz,bmxbeffz,beffz,dkeffz,
     &  bmnbeffznor,bmxbeffznor,beffznor,dkeffznor,0)

      write(lun6,*)
      write(lun6,*)"XminBeff, XmaxBeff (with recovered points):",
     &  sngl(xminbeff),sngl(xmaxbeff)

      if (beffz.gt.0.0d0) then
        if (abs((bmxbeffz-bmnbeffz)/2.0d0/beffz-1.0d0).gt.0.1) then
          write(lun6,*)
          write(lun6,*)"*** WARNING: BzEff differs more than 10 percent from min/max-values of Bz ***"
          write(lun6,*)
        endif
      endif

      if (beffy.gt.0.0d0) then
        if (abs((bmxbeffy-bmnbeffy)/2.0d0/beffy-1.0d0).gt.0.1) then
          write(lun6,*)
          write(lun6,*)"*** WARNING: ByEff differs more than 10 percent from min/max values of By ***"
          write(lun6,*)
        endif
      endif

      write(lun6,*)"ByMin, ByMax, (ByMax-ByMin)/2, ByEff (with recovered points):",
     &  sngl(bmnbeffy),sngl(bmxbeffy),
     &  sngl((bmxbeffy-bmnbeffy)/2.0d0),sngl(beffy)

      write(lun6,*)"BzMin, BzMax, (BzMax-BzMin)/2, BzEff (with recovered points):",
     &  sngl(bmnbeffz),sngl(bmxbeffz),
     &  sngl((bmxbeffz-bmnbeffz)/2.0d0),sngl(beffz)

      dkeff=sqrt(dkeffy**2+dkeffz**2)
      beff=sqrt(beffy**2+beffz**2)

      write(lun6,*)
      write(lun6,*)"Beff = Sqrt( ByEff**2 + BzEff**2 ) (with recovered points):",
     &  sngl(beff)
      write(lun6,*)
      write(lun6,*)"Keff and first harmonic [eV] (with recovered points):",
     &  sngl(dkeff),sngl(950.0d0*ebeam**2/(1.0d0+dkeff**2/2.0d0)/(perlen/10.0d0))
      write(lun6,*)

      write(lun6,*)
      write(lun6,*)"XminBeff, XmaxBeff (without recovered points):",
     &  sngl(xminbeffnor),sngl(xmaxbeffnor)

      write(lun6,*)"ByMin, ByMax, (ByMax-ByMin)/2, ByEff (without recovered points):",
     &  sngl(bmnbeffynor),sngl(bmxbeffynor),
     &  sngl((bmxbeffynor-bmnbeffynor)/2.0d0),sngl(beffnor)

      write(lun6,*)"BzMin, BzMax, (BzMax-BzMin)/2, BzEff (without recovered points):",
     &  sngl(bmnbeffznor),sngl(bmxbeffznor),
     &  sngl((bmxbeffznor-bmnbeffznor)/2.0d0),sngl(beffznor)

      dkeffnor=sqrt(dkeffynor**2+dkeffznor**2)
      beffnor=sqrt(beffynor**2+beffznor**2)

      write(lun6,*)
      write(lun6,*)"Beff = Sqrt( ByEff**2 + BzEff**2 ) (without recovered points):",
     &  sngl(beffnor)
      write(lun6,*)
      write(lun6,*)"Keff and first harmonic [eV] (without recovered points):",
     &  sngl(dkeffnor),sngl(950.0d0*ebeam**2/(1.0d0+dkeffnor**2/2.0d0)/
     &  (perlen/10.0d0))
      write(lun6,*)

      call util_zeit_kommentar(lun6,"Writing undumag.beff")

      open(newunit=lun,file="undumag.beff")

      write(lun,*)"* Run:"
      write(lun,*)kundurun
      write(lun,*)"* XminBeff XmaxBeff:"
      write(lun,*)
     &  sngl(xminbeff),sngl(xmaxbeff)
      write(lun,*)"* ByMin, ByMax, (ByMax-ByMin)/2, ByEff:"
      write(lun,*)
     &  sngl(bmnbeffy),sngl(bmxbeffy),
     &  sngl((bmxbeffy-bmnbeffy)/2.0d0),sngl(beffy)
      write(lun,*)"* BzMin, BzMax, (BzMax-BzMin)/2, BzEff:"
      write(lun,*)
     &  sngl(bmnbeffz),sngl(bmxbeffz),
     &  sngl((bmxbeffz-bmnbeffz)/2.0d0),sngl(beffz)
      write(lun,*)"* Beff = Sqrt( ByEff**2 + BzEff**2 ), Keff, 1. Harm. [eV]:"
      write(lun,*) sngl(beff), sngl(dkeff)
     &  ,sngl(950.0d0*ebeam**2/(1.0d0+dkeff**2/2.0d0)/(perlen/10.0d0))
      write(lun,*)"* ByInt1, BzInt1, ByInt2, BzInt2:"
      write(lun,*)
     &  sngl(byint1f),sngl(bzint1f),
     &  sngl(byint2f),sngl(bzint2f)
      write(lun,*)"* ByInt1Inf, BzInt1Inf:"
      write(lun,*)
     &  sngl(byint1inf),sngl(bzint1inf)
      write(lun,*)"* ByMin, ByMax, (ByMax-ByMin)/2, ByEff, without recovered points:"
      write(lun,*)
     &  sngl(bmnbeffynor),sngl(bmxbeffynor),
     &  sngl((bmxbeffynor-bmnbeffynor)/2.0d0),sngl(beffynor)
      write(lun,*)"* BzMin, BzMax, (BzMax-BzMin)/2, BzEff, without recovered points:"
      write(lun,*)
     &  sngl(bmnbeffznor),sngl(bmxbeffznor),
     &  sngl((bmxbeffznor-bmnbeffznor)/2.0d0),sngl(beffznor)
      write(lun,*)"* Beff = Sqrt( ByEff**2 + BzEff**2 ), without recovered points:"
      write(lun,*)
     &  sngl(beffnor)
      write(lun,*)"* ByInt1, BzInt1, ByInt2, BzInt2, without recovered points:"
      write(lun,*)
     &  sngl(byint1fnor),sngl(bzint1fnor),
     &  sngl(byint2fnor),sngl(bzint2fnor)
      write(lun,*) "External field [T]:"
      write(lun,*) sngl(bxex),sngl(byex),sngl(bzex)
      write(lun,*)"1. Integrals ByI and BzI [Tmm] of external field:"
      write(lun,*)sngl(byexint),sngl(bzexint)
      flush(lun)
      close(lun)
c Calculate beff}

      call util_zeit_kommentar(lun6,"Writing undumag_beff.eps")

      call mshplt_init(20,15.,15.,25,25,600,600,
     &  'undumag_beff.eps','','',0.)

      if (kdate.eq.0) then
        call mplopt('NDAT',1)
      else
        call mplopt('DATE',1)
      endif
      if (krunnum.ne.0) then
        write(ctitle,*)kundurun
        call util_string_trim(ctitle,nfirst,nlast)
        ctitle=trim(usercom)//", Run: "//ctitle(nfirst:nlast)
      else
        ctitle=trim(usercom)
      endif

      if (kcomment.ne.0) call mtitle(trim(ctitle))
      call mshplt_hplset('YGTI',-0.5)

      gsiz_ps=0.4

      xplmin=xbeffo-perlen
      xplmax=xbeffo+perlen

! By
      yplmin=min(-beff,-sqrt(min(bmxbeffy**2,bmnbeffy**2)+bmxbeffz**2))
      yplmax=max(beff,sqrt(bmxbeffy**2+bmxbeffz**2))
      yplmin=-max(abs(bmnbeffy),abs(bmxbeffy),abs(bmnbeffz),abs(bmxbeffz))
      yplmax=-yplmin

      dxpl=xplmax-xplmin
      dypl=yplmax-yplmin

      if (dxpl.le.1.0e-9) dxpl=1.
      if (dypl.le.1.0e-9) dypl=1.

      call mshplt_set_pad(4.,19.,3.,18.)

      call mshplt_set_text_angle(90.)
      call mshplt_text_ndc(-0.1,0.9,'B [T]')
      call mshplt_set_text_angle(0.)
      call mshplt_text_ndc(0.85,-0.1,'x [mm]')

      call mgset('CHHE',0.5)
      cbeff="Beff = "
      write(cbeff(7:14),'(f6.3)')beff
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.3,cbeff)
      cbeff="Keff = "
      write(cbeff(7:14),'(f6.3)')dkeff
      call mshplt_text_ndc(0.7,0.25,cbeff)

      call mshplt_set_text_color(0,1,0,0)

      cbeff="ByMax = "
      write(cbeff(7:14),'(f6.3)')bmxbeffy
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.9,cbeff)
      cbeff="ByMin = "
      write(cbeff(7:14),'(f6.3)')bmnbeffy
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.83,cbeff)

      call mshplt_set_text_color(0,0,0,1)

      cbeff="BzMax = "
      write(cbeff(7:14),'(f6.3)')bmxbeffz
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.75,cbeff)

      cbeff="BzMin = "
      write(cbeff(7:14),'(f6.3)')bmnbeffz
      cbeff(15:15)="T"
      call mshplt_text_ndc(0.7,0.68,cbeff)

      call mshplt_set_text_color(1,0,0,0)
      call mgset('CHHE',0.4)

      call mshplt_frame(
     &  xplmin,
     &  xplmax,
     &  yplmin-dypl*0.1,
     &  yplmax+dypl*0.1,
     &  ' ',' ',' ')

      call mshplt_set_text_angle(0.)

      call mgset('PLCI',2.)
      open(newunit=lun,file="undumag_byeff.dat")

      read(lun,*,end=91)i,xpl(1),ypl(1),bz,i

      do ix=2,nxbeff
        read(lun,*,end=91)i,xpl(2),ypl(2),bz,i
        call mpl(2,xpl,ypl)
        xpl(1)=xpl(2)
        ypl(1)=ypl(2)
      enddo

91    close(lun)

      call mgset('PLCI',4.)
      open(newunit=lun,file="undumag_bzeff.dat")

      read(lun,*,end=92)i,xpl(1),by,ypl(1),i
      do ix=2,nxbeff
        read(lun,*,end=92)i,xpl(2),by,ypl(2),i
        call mpl(2,xpl,ypl)
        xpl(1)=xpl(2)
        ypl(1)=ypl(2)
      enddo

92    close(lun)

      call muwk(0,0)
      call mshplt_end

      return
      end
+DECK,clcmag_to_radia_python.
*CMZ :  2.05/07 23/10/2024  21.56.41  by  Michael Scheer
*CMZ :  2.05/05 01/07/2024  09.35.55  by  Michael Scheer
*CMZ :  2.05/04 27/11/2023  18.54.15  by  Michael Scheer
*CMZ :  2.04/28 29/09/2023  11.43.35  by  Michael Scheer
*CMZ :  2.04/22 22/09/2023  12.32.06  by  Michael Scheer
*CMZ :  2.04/21 21/09/2023  16.03.24  by  Michael Scheer
*CMZ :  2.04/20 21/09/2023  10.10.06  by  Michael Scheer
*CMZ :  2.04/19 18/09/2023  10.41.10  by  Michael Scheer
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 09/02/2022  19.36.16  by  Michael Scheer
*CMZ :  2.02/00 09/01/2021  12.08.32  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  12.47.44  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  15.45.12  by  Michael Scheer
*CMZ :  1.25/04 04/04/2018  11.40.25  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.27.59  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.25.43  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  09.00.40  by  Michael Scheer
*CMZ :  1.23/02 11/09/2017  15.35.11  by  Michael Scheer
*CMZ :  1.18/01 08/06/2017  14.20.17  by  Michael Scheer
*CMZ :  1.15/10 11/04/2017  11.14.47  by  Michael Scheer
*CMZ :  1.15/00 24/03/2017  10.28.46  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  17.33.35  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  10.15.10  by  Michael Scheer
*CMZ :  1.11/03 13/01/2017  15.10.38  by  Michael Scheer
*CMZ :  1.11/00 03/01/2017  16.16.45  by  Michael Scheer
*-- Author :    Michael Scheer   12/12/2016
      subroutine clcmag_to_radia_python

      use undumagf90m
      use bpolyederf90m
      use commandlinef90m
      use magnets_structure

! Interface to RADIA under Python.
! It writes the geometry to snipplets for RADIA
! Restriction:
! Isotropic materials must have a magnetization less then 0.01
!
! RADIA coordinate system: y is longitudinal, z is vertical
! UNDUMAG: x is longitudinal, y is vertical

      implicit none

+seq,phyconparam.

      double precision, dimension (:), allocatable :: x,y,z,brrec

      integer, dimension (:), allocatable :: khull,imatrec,imatiron,
     &  imatmagpol

      double precision :: gcen(3)

      real :: hfe,bfe

      integer ::
     &  nsymx,nsymy,nsymz,npoi,nmatfe,nlast,nfirst,nface,ncyl,ncolor,mater
     &  ,lunrad,lunfe,lmat,kproto,kpoi,k,ironmode,iron,imp,ipoi,imag,imat
     &  ,ifound,i,iface,ieof,nbr,nUnduMag,nUnduPol,nMagPolTot,lenout,lunproc,
     &  istat=0,ivox,kmagnet,kvoxel,ixdiv,iydiv,izdiv

      character(2048) cline,cbuff(10),cout,clunrad
      character(64) chmat,cnam
      character(32) c32,c32x,c32y,c32z
      character(17) chtime

      ncyl=0

      maxpoints=max(maxpoints,ncornmax*nplanmax)

      allocate(x(maxpoints),y(maxpoints),z(maxpoints),khull(maxpoints))
      allocate(brrec(nmagtot_t),imatrec(nmagtot_t),
     &  imatiron(nmagtot_t),imatmagpol(nmagtot_t))

      nbr=0
      nmatfe=0
      brrec=0.0d0
      imatrec=0

      do imag=1,nmagtot_t
        kproto=t_magcopy(imag)%kproto
        ifound=0
        if (t_magnets(kproto)%ispole.ne.0) then
          do i=1,nmatfe
            if (t_magnets(kproto)%imat.eq.imatiron(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) then
            cycle
          endif
          nmatfe=nmatfe+1
          imatiron(nmatfe)=t_magnets(kproto)%imat
          imatmagpol(imag)=nmatfe
        else
          do i=1,nbr
            if (brrec(i).eq.t_magcopy(imag)%brn.and.
     &          t_magnets(kproto)%imat.eq.imatrec(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) cycle
          nbr=nbr+1
          brrec(nbr)=t_magcopy(imag)%brn
          imatrec(nbr)=t_magnets(kproto)%imat
          imatmagpol(imag)=nbr
        endif
      enddo

      nsymx=1
      nsymy=1
      nsymz=1

      if (ixsymo.lt.0) nsymx=nsymx*2
      if (iysymo.lt.0) nsymy=nsymy*2
      if (izsymo.lt.0) nsymz=nsymz*2

      open(newunit=lunrad,file='undumag_radia.py')

      write(lunrad,'(a)')'#-- Begin of lines generated by UNDUMAG --'
      write(lunrad,'(a)')'#-- Version ' // trim(chuvers) // ' --'
      write(lunrad,'(a)')' '
      write(lunrad,'(a)')'from __future__ import print_function #Python 2.7 compatibility'
      write(lunrad,'(a)') 'import radia as rad'
      write(lunrad,'(a)') 'import numpy as np'
      write(lunrad,'(a)') 'import time, os, sys, platform'
      write(lunrad,'(a)') 'from numpy import *'
      write(lunrad,'(a)') '# obsolete! from pyhull import qconvex'
      write(lunrad,'(a)')' '
      write(lunrad,'(a)') 'NL = "\n"'
      write(lunrad,'(a)')' '
      write(lunrad,'(a)')"print('\nRADIA Library Version:', rad.UtiVer(), '\n')"
      write(lunrad,'(a)')

      write(c32x,*) kundurun
      call util_time_and_date(chtime)
      write(lunrad,'(a)')'# Run: ' // trim(c32x) // ' ' // chtime
      write(lunrad,'(a)')'run = ' // trim(c32x)

      write(lunrad,'(a)')" "
      write(lunrad,'(a)')"# Comment: "//trim(unducomment)
      write(lunrad,'(a)')
      write(lunrad,'(a)')'comment = "' // trim(unducomment) // '"'
      write(lunrad,'(a)')

      write(lunrad,'(a)')'# --- Variables of undumag.nam ---'
      write(clunrad,*)

      write(c32x,*)ixsymo
      write(lunrad,'(a)')'iUnduXsym = ' // c32x
      write(c32x,*)iysymo
      write(lunrad,'(a)')'iUnduYsym = ' // c32x
      write(c32x,*)izsymo
      write(lunrad,'(a)')'iUnduZsym = ' // c32x

      write(c32x,*)
     &  xsym
      write(lunrad,'(a)')'UnduSymX = ' // c32x
      write(c32x,*)
     &  iunduplot
      write(lunrad,'(a)')"kDraw = " // c32x
      write(c32x,*)
     &  unduplot_theta
      write(lunrad,'(a)')"unduplot_theta = " // c32x
      write(c32x,*)
     &  unduplot_phi
      write(lunrad,'(a)')"unduplot_phi = " // c32x

      write(c32x,*)xcenter
      write(lunrad,'(a)')"UnduXCenter = " // c32x

      write(c32x,*)iforce
      write(lunrad,'(a)')'iUnduForce = ' // c32x
      write(lunrad,'(a)')'ForceMagPol = -1'
      write(lunrad,'(a)')

      write(c32x,*)xcentershift
      write(lunrad,'(a)')"UnduXCenterShift = " // c32x
      write(c32x,*)utorqcenx
      write(lunrad,'(a)')"UnduTorqCenX = " // c32x
      write(c32x,*)utorqceny
      write(lunrad,'(a)')"UnduTorqCenY = " // c32x
      write(c32x,*)utorqcenz
      write(lunrad,'(a)')"UnduTorqCenZ = " // c32x

      write(lunrad,'(a)')
      write(c32x,*)xmapmin
      write(lunrad,'(a)')"UnduXMapMin = " // c32x
      write(c32x,*)xmapmax
      write(lunrad,'(a)')"UnduXMapMax = " // c32x
      write(c32x,*) nxmap
      write(lunrad,'(a)')"nUnduXMap = " // c32x

      write(lunrad,'(a)')
      write(c32x,*) ymapmin
      write(lunrad,'(a)')"UnduYMapMin = " // c32x
      write(c32x,*) ymapmax
      write(lunrad,'(a)')"UnduYMapMax = " // c32x
      write(c32x,*) nymap
      write(lunrad,'(a)')"nUnduYMap = " // c32x

      write(lunrad,'(a)')
      write(c32x,*)zmapmin
      write(lunrad,'(a)')"UnduZMapMin = " // c32x
      write(c32x,*)zmapmax
      write(lunrad,'(a)')"UnduZMapMax = " // c32x
      write(c32x,*) nzmap
      write(lunrad,'(a)')"nUnduZMap = " // c32x

      write(lunrad,'(a)')
      write(c32x,*)
     &  knopolmap
      write(lunrad,'(a)')"nUnduNoPolMap = " // c32x
      write(c32x,*)
     &  knomagmap
      write(lunrad,'(a)')"nUnduNoMagMap = " // c32x
      write(lunrad,'(a)')

c+self,if=uvarrad.

      write(lunrad,'(a)')
      write(lunrad,'(a)')'# --- Variables of undumag.clc ---'
      write(lunrad,'(a)')

      do i=1,nvar_t
        write(clunrad,*) trim(t_variables(i)%cname),' = ',t_variables(i)%val
        write(lunrad,'(a)') trim(adjustl(clunrad))
      enddo !nvar_t
c+self.,if=uvarrad.

      write(lunrad,'(a)')
      write(lunrad,'(a)')'# --- Materials of undumag.clc ---'
      write(lunrad,'(a)')

      write(lunrad,'(a)')'UmatREC = []'
      do i=1,nbr
        imat=imatrec(i)
        if (imat.eq.0) cycle
c        if (matmaps(1,imat).eq.1) then
          if (matmaps(2,imat).eq.1) then
            write(c32x,'(f6.4)')bcmat(2,1,imat) !-1.0d0
            write(c32y,'(f6.4)')bcmat(3,1,imat) !-1.0d0
            write(c32z,'(g12.5)')brrec(i)
            write(clunrad,'(a)')
     &        "UmatREC.append(rad.MatLin([" //
     &        trim(adjustl(c32x)) // "," //
     &        trim(adjustl(c32y)) //
     &        "]," // trim(adjustl(c32z)) // "))"
            write(lunrad,'(a)') trim(clunrad)
          else
            print*,"*** Error in clcmag_to_radia_python: mode",
     &        matmaps(2,imat), " not yet implemented for REC material ",imat
            print*,""
            !stop "--- UNDUMAG aborted ---"
          endif
c        else
c          print*,"*** Error in clcmag_to_radia_python: Unknown material or mode", imat,
c     &      matmaps(:,imat)
c          print*,""
c          !stop "--- UNDUMAG aborted ---"
c        endif
      enddo

      write(lunrad,'(a)')'UmatIron = []'
      do i=1,nmatfe
        imat=imatiron(i)
        if (imat.eq.0) cycle
        if (matmaps(1,imat).eq.2) then
          write(lunrad,'(a)')
     &      "UmatIron.append(rad.MatSatIsoTab([ \"
          do k=2,nclcmat
            read(clcmat(k),*)iron,lmat,ironmode,cbuff(1)
            if (iron.eq.imat) then
              open(newunit=lunfe,file=trim(cbuff(1)),status='old')
              ieof=0
              do while (ieof.eq.0)
                call util_skip_comment_end(lunfe,ieof)
                if (ieof.ne.0) exit
                read(lunfe,*) hfe,bfe
                write(clunrad,*)"[",hfe,",",bfe,"],"
                write(lunrad,'(a)') trim(clunrad)
              enddo
              backspace(lunrad)
              write(clunrad,*)"[",hfe,",",bfe,"]]))"
              write(lunrad,'(a)') trim(clunrad)
              close(lunfe)
            endif
          enddo
        else
          print*,"*** Error in clcmag_to_radia_python: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          !stop "--- UNDUMAG aborted ---"
        endif
      enddo

      write(lunrad,'(a)')
      write(lunrad,'(a)')'# --- Poles and magnets of undumag.clc ---'
      write(lunrad,'(a)')

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        ! radObjPolyhdr[
        ! [
        !   [x1,y1,z1], ..., [xn,yn,zn] Corners
        ! ],
        ! [
        !   [f1n1,f1n2,...], ...., [f2n1,f2n2,...] Faces
        ! ],
        ! [mx,my,mz]:[0,0,0]]

        if(t_magnets(kproto)%ctype.ne.'Cylinder') then

          nface=t_magnets(kproto)%nface
          ncolor=t_magnets(kproto)%icol

          write(lunrad,'(a)')trim(t_magcopy(imp)%cnam)//" = rad.ObjPolyhdr([ \"

          gcen=t_magcopy(imp)%gcen

          do kpoi=1,t_magnets(kproto)%nhull

            write(c32x,*)sngl(t_magnets(kproto)%xhull(kpoi)+gcen(1))
            write(c32y,*)sngl(t_magnets(kproto)%yhull(kpoi)+gcen(2))
            write(c32z,*)sngl(t_magnets(kproto)%zhull(kpoi)+gcen(3))

            if (kpoi.lt.t_magnets(kproto)%nhull) then
              write(clunrad,*)
     &          "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"],"
              write(lunrad,'(a)') trim(clunrad)
            else
              write(clunrad,*)
     &          "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"]],[ \"
              write(lunrad,'(a)') trim(clunrad)
            endif
          enddo !kpoi

          kpoi=1

          do iface=1,nface

            npoi=t_magnets(kproto)%kface(kpoi)
            cline="         ["

            do ipoi=kpoi+1,kpoi+npoi
              call util_string_append_num(cline,t_magnets(kproto)%kface(ipoi),
     &          nfirst,nlast)
              if (ipoi.lt.kpoi+npoi) then
                call util_string_append(cline,',',nfirst,nlast)
              else
                call util_string_append(cline,'],',nfirst,nlast)
              endif
            enddo !ipoi

            if (iface.lt.nface) then
              write(lunrad,'(a)')cline(1:nlast)
              call util_string_append(cline,'],',nfirst,nlast)
            else
              write(lunrad,'(a)')cline(1:nlast-1) // '], \'
            endif
            kpoi=kpoi+npoi+1
          enddo !nface

          if (t_magnets(kproto)%IsPole.eq.0) then
            write(c32x,*)t_magcopy(imp)%br(1)
            write(c32y,*)t_magcopy(imp)%br(2)
            write(c32z,*)t_magcopy(imp)%br(3)
            write(clunrad,*)"         [",trim(c32z),",",trim(c32x),",",trim(c32y),"])"
            write(lunrad,'(a)') trim(clunrad)
            mater = imatmagpol(imp)
            write(chmat,*)mater-1
            call util_string_trim(chmat,nfirst,nlast)
            chmat="UmatREC["//chmat(nfirst:nlast)//"]"
          else
            write(lunrad,'(a)')"[0,0,0])"
            mater = imatmagpol(imp)
            write(chmat,*)mater-1
            call util_string_trim(chmat,nfirst,nlast)
            chmat="UmatIron["//chmat(nfirst:nlast)//"]"
          endif !Pole/Mag

          if (t_magnets(kproto)%nzdiv*t_magnets(kproto)%nydiv*t_magnets(kproto)%nxdiv.gt.1) then
            write(lunrad,'(a)')
            write(cline,*)
     &        "rad.ObjDivMag("//trim(adjustl(t_magcopy(imp)%cnam))//", [[",
     &        t_magnets(kproto)%nzdiv,",",
     &        sngl(t_magnets(kproto)%zfracdiv),"],",t_magnets(kproto)%nxdiv,
     &        ",[",t_magnets(kproto)%nydiv,",",
     &        sngl(t_magnets(kproto)%yfracdiv),"]],'kxkykz->Numb')"
            call util_remove_double_blanks(cline,cout,lenout)
            write(lunrad,'(a)') cout(2:lenout)
            write(lunrad,'(a)')
          endif

          write(lunrad,'(a)')
          write(lunrad,'(a)')"rad.MatApl("//trim(adjustl(t_magcopy(imp)%cnam))//","//
     &      trim(chmat)//")"

          if (ncolor.eq.2) then
            write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(adjustl(t_magcopy(imp)%cnam))//
     &        ",[1,0,0],0.0001)"
          else if (ncolor.eq.3) then
            write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(adjustl(t_magcopy(imp)%cnam))//
     &        ",[0,1,0],0.0001)"
          else if (ncolor.eq.4) then
            write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(adjustl(t_magcopy(imp)%cnam))//
     &        ",[0,0,1],0.0001)"
            write(lunrad,'(a)') trim(clunrad)
          else if (ncolor.eq.5) then
            write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(adjustl(t_magcopy(imp)%cnam))//
     &        ",[1,1,],0.0001)"
          else if (ncolor.eq.6) then
            write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(adjustl(t_magcopy(imp)%cnam))//
     &        ",[1,0,1],0.0001)"
          else if (ncolor.eq.7) then
            write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(adjustl(t_magcopy(imp)%cnam))//
     &        ",[0,1,1],0.0001)"
          endif

          write(lunrad,'(a)')

        else !cylinder:

          do ivox=1,nvoxcopy_t

            kproto=t_voxcopy(ivox)%kproto
            if (t_magnets(kproto)%ctype.ne.'Cylinder') cycle

            kmagnet=t_voxcopy(ivox)%kmagnet
            kvoxel=t_voxcopy(ivox)%kvoxel

            cline=adjustl(t_magcopy(imp)%cnam)
            call util_string_append(cline,'_',nfirst,nlast)
            ixdiv=t_magnets(kproto)%t_voxels(kvoxel)%ixdiv
            call util_string_append_num(cline,ixdiv,nfirst,nlast)
            call util_string_append(cline,'_',nfirst,nlast)
            iydiv=t_magnets(kproto)%t_voxels(kvoxel)%iydiv
            call util_string_append_num(cline,iydiv,nfirst,nlast)
            call util_string_append(cline,'_',nfirst,nlast)
            izdiv=t_magnets(kproto)%t_voxels(kvoxel)%izdiv
            call util_string_append_num(cline,izdiv,nfirst,nlast)
            cnam=trim(cline)
            call util_string_append(cline," = rad.ObjPolyhdr([ \",nfirst,nlast)

            write(lunrad,'(a)') trim(cline)

            gcen=t_voxcopy(ivox)%gcen

            npoi=t_magnets(kproto)%t_voxels(kvoxel)%nhull
            do ipoi=1,npoi

              write(c32x,*)sngl(t_magnets(kproto)%t_voxels(kvoxel)%xhull(ipoi)+
     &          gcen(1))
              write(c32y,*)sngl(t_magnets(kproto)%t_voxels(kvoxel)%yhull(ipoi)+
     &          gcen(2))
              write(c32z,*)sngl(t_magnets(kproto)%t_voxels(kvoxel)%zhull(ipoi)+
     &          gcen(3))

              if (ipoi.lt.npoi) then
                write(clunrad,*)
     &            "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"],"
                write(lunrad,'(a)') trim(clunrad)
              else
                write(clunrad,*)
     &            "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"]],[ \"
                write(lunrad,'(a)') trim(clunrad)
              endif

            enddo !ipoi

            nface=t_magnets(kproto)%t_voxels(kvoxel)%nface
            do iface=1,t_magnets(kproto)%t_voxels(kvoxel)%nface

              k=t_magnets(kproto)%t_voxels(kvoxel)%lface(iface)
              npoi=t_magnets(kproto)%t_voxels(kvoxel)%kface(k)

              cline="         ["

              do ipoi=1,npoi
                call util_string_append_num(cline,
     &            t_magnets(kproto)%t_voxels(kvoxel)%kface(k+ipoi),nfirst,nlast)
                if (ipoi.lt.npoi) then
                  call util_string_append(cline,',',nfirst,nlast)
                else
                  call util_string_append(cline,'],',nfirst,nlast)
                endif
              enddo !ipoi

              if (iface.lt.nface) then
                write(lunrad,'(a)')cline(1:nlast)
c                call util_string_append(cline,'],',nfirst,nlast)
              else
                write(lunrad,'(a)')cline(1:nlast-1) // '], \'
              endif

            enddo !nface

            if (t_magnets(kproto)%IsPole.eq.0) then
              write(c32x,*)t_voxcopy(kvoxel)%br(1)
              write(c32y,*)t_voxcopy(kvoxel)%br(2)
              write(c32z,*)t_voxcopy(kvoxel)%br(3)
              write(clunrad,*)"         [",trim(c32z),",",trim(c32x),",",trim(c32y),"])"
              write(lunrad,'(a)') trim(clunrad)
              mater = imatmagpol(imp)
              write(chmat,*)mater-1
              call util_string_trim(chmat,nfirst,nlast)
              chmat="UmatREC["//chmat(nfirst:nlast)//"]"
            else
              write(lunrad,'(a)')"[0,0,0])"
              mater = imatmagpol(imp)
              write(chmat,*)mater-1
              call util_string_trim(chmat,nfirst,nlast)
              chmat="UmatIron["//chmat(nfirst:nlast)//"]"
            endif !Pole/Mag

            write(lunrad,'(a)')
            write(lunrad,'(a)')"rad.MatApl("//trim(cnam)//","//
     &        trim(chmat)//")"

            if (ncolor.eq.2) then
              write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(cnam)//
     &          ",[1,0,0],0.0001)"
            else if (ncolor.eq.3) then
              write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(cnam)//
     &          ",[0,1,0],0.0001)"
            else if (ncolor.eq.4) then
              write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(cnam)//
     &          ",[0,0,1],0.0001)"
              write(lunrad,'(a)') trim(clunrad)
            else if (ncolor.eq.5) then
              write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(cnam)//
     &          ",[1,1,],0.0001)"
            else if (ncolor.eq.6) then
              write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(cnam)//
     &          ",[1,0,1],0.0001)"
            else if (ncolor.eq.7) then
              write(lunrad,'(a)')"rad.ObjDrwAtr("//trim(cnam)//
     &          ",[0,1,1],0.0001)"
            endif

            write(lunrad,'(a)')

          enddo !nvoxcopy_t

        endif !(t_magnets(kproto)%ctype.ne.'Cylinder') then

      enddo !imp=1,nmagtot_t

      write(lunrad,'(a)')"UnduMag = []"
      write(lunrad,'(a)')"AllMagPols = []"
      write(lunrad,'(a)')"UnduPol = []"

      nUnduMag = 0
      nUnduPol = 0
      nMagPolTot = 0

      write(lunrad,'(a)')"nUnduMag = 0"
      write(lunrad,'(a)')"nUnduPol = 0"
      write(lunrad,'(a)')"nMagPolTot = 0"

      do imp=1,nmagtot_t

        if(t_magnets(kproto)%ctype.ne.'Cylinder') then

          kproto=t_magcopy(imp)%kproto

          if (t_magnets(kproto)%IsPole.eq.0) then

            nUnduMag=nUnduMag+1

            write(lunrad,'(a)')"UnduMag.append(" //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"

            nMagPolTot=nMagPolTot+1

            write(lunrad,'(a)')"AllMagPols.append(" //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ')'
            write(lunrad,'(a)')

            if (iforce.ne.0.and.t_magcopy(imp)%cnam.eq.chforcemag) then
              write(lunrad,'(a)')
              write(lunrad,'(a)')"iForceTyp = 1"
              write(lunrad,'(a)')"ForceMagPol = " // trim(chforcemag)
              write(lunrad,'(a)')
            endif

          else

            nUnduPol=nUnduPol+1

            write(c32,*)nUnduPol
            write(lunrad,'(a)')"nUnduPol = " // trim(adjustl(c32))
            write(lunrad,'(a)')"UnduPol.append(" //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"

            nMagPolTot=nMagPolTot+1

            write(lunrad,'(a)')"AllMagPols.append(" //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ')'
            write(lunrad,'(a)')

            if (iforce.ne.0.and.t_magcopy(imp)%cnam.eq.chforcemag) then
              write(lunrad,'(a)')
              write(lunrad,'(a)')"iForceTyp = 1"
              write(lunrad,'(a)')"ForceMagPol = " // trim(chforcemag)
              write(lunrad,'(a)')
            endif

          endif !Pole/Mag

        else !Cylinder

          do ivox=1,nvoxcopy_t

            kproto=t_voxcopy(ivox)%kproto
            if (t_magnets(kproto)%ctype.ne.'Cylinder') cycle

            if (t_magnets(kproto)%IsPole.eq.0) then
              nUnduMag=nUnduMag+1
            else
              nUnduPol=nUnduPol+1
            endif

            kmagnet=t_voxcopy(ivox)%kmagnet
            kvoxel=t_voxcopy(ivox)%kvoxel

            cline=adjustl(t_magcopy(imp)%cnam)
            call util_string_append(cline,'_',nfirst,nlast)
            ixdiv=t_magnets(kproto)%t_voxels(kvoxel)%ixdiv
            call util_string_append_num(cline,ixdiv,nfirst,nlast)
            call util_string_append(cline,'_',nfirst,nlast)
            iydiv=t_magnets(kproto)%t_voxels(kvoxel)%iydiv
            call util_string_append_num(cline,iydiv,nfirst,nlast)
            call util_string_append(cline,'_',nfirst,nlast)
            izdiv=t_magnets(kproto)%t_voxels(kvoxel)%izdiv
            call util_string_append_num(cline,izdiv,nfirst,nlast)
            cnam=trim(cline)

            if (t_magnets(kproto)%IsPole.eq.0) then
              write(lunrad,'(a)')"UnduMag.append(" //trim(cnam)// ')'
            else
              write(lunrad,'(a)')"UnduPol.append(" //trim(cnam)// ')'
            endif

            nMagPolTot=nMagPolTot+1

            write(lunrad,'(a)')"AllMagPols.append(" //trim(cnam)// ')'
            write(lunrad,'(a)')

            if (iforce.ne.0.and.t_magcopy(imp)%cnam.eq.chforcemag) then
              write(lunrad,'(a)')
              write(lunrad,'(a)')"iForceTyp = 1"
              write(lunrad,'(a)')"ForceMagPol = " // trim(chforcemag)
              write(lunrad,'(a)')
              print*,"*** Warning in clcmag_to_radia_python: Force calculations for cylinders not yet tested..."
            endif

          enddo !nvox

        endif !(t_magnets(kproto)%ctype.ne.'Cylinder') then

      enddo !imp=1,nmagtot_t

      write(c32,*)nUnduMag
      write(lunrad,'(a)')"nUnduMag = " // trim(adjustl(c32))
      write(c32,*)nUnduPol
      write(lunrad,'(a)')"nUnduPol = " // trim(adjustl(c32))
      write(c32,*)nMagPolTot
      write(lunrad,'(a)')"nMagPolTot = " // trim(adjustl(c32))

      deallocate(brrec)

      write(c32,*) ncwires
      write(lunrad,'(a)')'nUnduFilaments = ' // trim(adjustl(c32))

      if (iunduplot.lt.0.or.iundugeo.lt.0.or.ivrml.lt.0) then
        write(lunrad,'(a)')'iSolve = 0'
      else
        write(lunrad,'(a)')'iSolve = 1'
      endif

      write(lunrad,'(a)')
      write(lunrad,'(a)')'#-- End of lines generated by UNDUMAG --'
      write(lunrad,'(a)')

      write(lunrad,'(a)')
      write(lunrad,'(a)')'#-- Reading undumag_proc.py and appending to undumag_radia.py --'
      write(lunrad,'(a)')

      open(newunit=lunproc,file='undumag_proc.py',status='old', iostat=istat)

      if (istat.ne.0) then

        write(lun6,*)"*** Error in clcmag_to_radia_python: File undumag_proc.py not found ***"

      else

        ieof=0
        cline=''

        do while (ieof.eq.0)
          read(lunproc,'(a)',iostat=ieof) cline
          if (ieof.eq.0) write(lunrad,'(a)') trim(cline)
        enddo
        close(lunproc)

      endif

      flush(lunrad)
      close(lunrad)

      return
      end
+DECK,clcmag_to_msh_radia.
*CMZ :  2.05/06 11/10/2024  10.29.40  by  Michael Scheer
*CMZ :  2.05/05 01/07/2024  09.43.02  by  Michael Scheer
*CMZ :  2.04/28 30/09/2023  08.41.15  by  Michael Scheer
*CMZ :  2.04/22 22/09/2023  12.32.06  by  Michael Scheer
*CMZ :  2.04/21 21/09/2023  16.03.24  by  Michael Scheer
*CMZ :  2.04/20 21/09/2023  10.10.06  by  Michael Scheer
*CMZ :  2.04/19 18/09/2023  10.41.10  by  Michael Scheer
*CMZ :  2.03/00 22/08/2023  09.03.52  by  Michael Scheer
*CMZ :  2.02/01 09/02/2022  19.36.16  by  Michael Scheer
*CMZ :  2.02/00 09/01/2021  12.08.32  by  Michael Scheer
*CMZ :  2.01/03 15/02/2019  12.47.44  by  Michael Scheer
*CMZ :  2.00/00 11/04/2018  15.45.12  by  Michael Scheer
*CMZ :  1.25/04 04/04/2018  11.40.25  by  Michael Scheer
*CMZ :  1.24/00 12/10/2017  13.27.59  by  Michael Scheer
*CMZ :  1.23/07 12/10/2017  08.25.43  by  Michael Scheer
*CMZ :  1.23/05 06/10/2017  09.00.40  by  Michael Scheer
*CMZ :  1.23/02 11/09/2017  15.35.11  by  Michael Scheer
*CMZ :  1.18/01 08/06/2017  14.20.17  by  Michael Scheer
*CMZ :  1.15/10 11/04/2017  11.14.47  by  Michael Scheer
*CMZ :  1.15/00 24/03/2017  10.28.46  by  Michael Scheer
*CMZ :  1.14/00 21/03/2017  17.33.35  by  Michael Scheer
*CMZ :  1.11/04 24/01/2017  10.15.10  by  Michael Scheer
*CMZ :  1.11/03 13/01/2017  15.10.38  by  Michael Scheer
*CMZ :  1.11/00 03/01/2017  16.16.45  by  Michael Scheer
*-- Author :    Michael Scheer   12/12/2016
      subroutine clcmag_to_msh_radia

      use undumagf90m
      use bpolyederf90m
      use commandlinef90m
      use magnets_structure

! Interface to RADIA under Python, using mshradia.py

! Isotropic materials must have a magnetization less then 0.01
!
! RADIA coordinate system: y is longitudinal, z is vertical
! UNDUMAG: x is longitudinal, y is vertical

      implicit none

+seq,phyconparam.

      double precision, dimension (:), allocatable :: x,y,z,brrec

      integer, dimension (:), allocatable :: khull,imatrec,imatiron,
     &  imatmagpol

      double precision :: gcen(3)

      real :: hfe,bfe

      integer ::
     &  nsymx,nsymy,nsymz,npoi,nmatfe,nlast,nfirst,nface,ncyl,ncolor,mater
     &  ,lunrad,lunfe,lmat,kproto,kpoi,k,ironmode,iron,imp,ipoi,imag,imat
     &  ,ifound,i,iface,ieof,nbr,nUnduMag,nUnduPol,nMagPolTot,lenout,lunproc,
     &  istat=0,ivox,kmagnet,kvoxel,ixdiv,iydiv,izdiv

      character(2048) cline,cbuff(10),cout,clunrad
      character(64) chmat,cnam
      character(32) c32,c32x,c32y,c32z
      character(17) chtime

      ncyl=0

      maxpoints=max(maxpoints,ncornmax*nplanmax)

      allocate(x(maxpoints),y(maxpoints),z(maxpoints),khull(maxpoints))
      allocate(brrec(nmagtot_t),imatrec(nmagtot_t),
     &  imatiron(nmagtot_t),imatmagpol(nmagtot_t))

      nbr=0
      nmatfe=0
      brrec=0.0d0
      imatrec=0

      do imag=1,nmagtot_t
        kproto=t_magcopy(imag)%kproto
        ifound=0
        if (t_magnets(kproto)%ispole.ne.0) then
          do i=1,nmatfe
            if (t_magnets(kproto)%imat.eq.imatiron(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) then
            cycle
          endif
          nmatfe=nmatfe+1
          imatiron(nmatfe)=t_magnets(kproto)%imat
          imatmagpol(imag)=nmatfe
        else
          do i=1,nbr
            if (brrec(i).eq.t_magcopy(imag)%brn.and.
     &          t_magnets(kproto)%imat.eq.imatrec(i)) then
              ifound=1
              imatmagpol(imag)=i
              exit
            endif
          enddo
          if (ifound.eq.1) cycle
          nbr=nbr+1
          brrec(nbr)=t_magcopy(imag)%brn
          imatrec(nbr)=t_magnets(kproto)%imat
          imatmagpol(imag)=nbr
        endif
      enddo

      nsymx=1
      nsymy=1
      nsymz=1

      if (ixsymo.lt.0) nsymx=nsymx*2
      if (iysymo.lt.0) nsymy=nsymy*2
      if (izsymo.lt.0) nsymz=nsymz*2

      open(newunit=lunrad,file='undumag_msh_radia.py')

      write(lunrad,'(a)')'#-- Begin of lines generated by UNDUMAG --'
      write(lunrad,'(a)')'#-- Version ' // trim(chuvers) // ' --'
      write(lunrad,'(a)')' '
      write(lunrad,'(a)') 'from __future__ import print_function #Python 2.7 compatibility'
+self,if=deby.
      write(lunrad,'(a)') 'import ipdb'
+self.
      write(lunrad,'(a)') 'import radia as rad'
      write(lunrad,'(a)') 'import numpy as np'
      write(lunrad,'(a)') 'import time, os, sys, platform'
      write(lunrad,'(a)') 'from numpy import *'
      write(lunrad,'(a)') 'from copy import *'
      write(lunrad,'(a)') 'from numpy import *'
      write(lunrad,'(a)') ' '
      write(lunrad,'(a)') 'from scipy.spatial.transform import Rotation as ROT'
      write(lunrad,'(a)') '# obsolete! from pyhull import qconvex'
      write(lunrad,'(a)') 'from scipy.spatial import ConvexHull'
      write(lunrad,'(a)') ' '
      write(lunrad,'(a)') 'import matplotlib as mpl'
      write(lunrad,'(a)') 'mpl.use("TkAgg")'

      write(lunrad,'(a)') 'import matplotlib.pyplot as plt'
      write(lunrad,'(a)') 'from mpl_toolkits.mplot3d import Axes3D'
      write(lunrad,'(a)') 'from mpl_toolkits import mplot3d'
      write(lunrad,'(a)') 'from matplotlib import cm #color maps'
      write(lunrad,'(a)') ' '
      write(lunrad,'(a)') 'import mshradia as msh'
      write(lunrad,'(a)') 'from mshradia import *'
      write(lunrad,'(a)') ' '
c      write(lunrad,'(a)') 'global mshObs,mshTrf,mshNames,mshColors,mshCnt,mshCntMaster,mshCntMembers'
c      write(lunrad,'(a)') 'global Ax,Fig'
c      write(lunrad,'(a)') 'global MagVoxelField, PolVoxelField'
      write(lunrad,'(a)') ' '
      write(lunrad,'(a)') 'msh.mshObs = {}'
      write(lunrad,'(a)') 'msh.mshTrf = {}'
      write(lunrad,'(a)') 'msh.mshNames = {}'
      write(lunrad,'(a)') 'msh.mshColors = {}'
      write(lunrad,'(a)') 'msh.mshCnt = {}'
      write(lunrad,'(a)') 'msh.mshCntMembers = {}'
      write(lunrad,'(a)') 'msh.mshCntMaster = []'

      write(lunrad,'(a)') 'MagVoxelField = []'
      write(lunrad,'(a)') 'PolVoxelField = []'
      write(lunrad,'(a)') ' '
      write(lunrad,'(a)') 'NL = "\n"'
      write(lunrad,'(a)')' '
      write(lunrad,'(a)')"print('\nRADIA Library Version:', rad.UtiVer(), '\n')"
      write(lunrad,'(a)')

      write(c32x,*) kundurun
      call util_time_and_date(chtime)
      write(lunrad,'(a)')'# Run: ' // trim(c32x) // ' ' // chtime
      write(lunrad,'(a)')'run = ' // trim(c32x)

      write(lunrad,'(a)')" "
      write(lunrad,'(a)')"# Comment: "//trim(unducomment)
      write(lunrad,'(a)')
      write(lunrad,'(a)')'comment = "' // trim(unducomment) // '"'
      write(lunrad,'(a)')

      write(lunrad,'(a)')'# --- Variables of undumag.nam ---'
      write(clunrad,*)

      write(c32x,*)ixsymo
      write(lunrad,'(a)')'iUnduXsym = ' // c32x
      write(c32x,*)iysymo
      write(lunrad,'(a)')'iUnduYsym = ' // c32x
      write(c32x,*)izsymo
      write(lunrad,'(a)')'iUnduZsym = ' // c32x

      write(c32x,*)
     &  xsym
      write(lunrad,'(a)')'UnduSymX = ' // c32x
      write(c32x,*)
     &  iunduplot
      write(lunrad,'(a)')"kDraw = " // c32x
      write(c32x,*)
     &  unduplot_theta
      write(lunrad,'(a)')"unduplot_theta = " // c32x
      write(c32x,*)
     &  unduplot_phi
      write(lunrad,'(a)')"unduplot_phi = " // c32x

      write(c32x,*)xcenter
      write(lunrad,'(a)')"UnduXCenter = " // c32x

      write(c32x,*)iforce
      write(lunrad,'(a)')'iUnduForce = ' // c32x
      write(lunrad,'(a)')'ForceMagPol = -1'

      if (iforce.ne.0.and.len_trim(chforcemag).eq.0) then
        print*," "
        print*,"*** Error in clcmag_to_msh_radia: Force calculations only implemented for item named CHFORCEMAG ***"
        print*," "
        write(lunrad,'(a)')'iUnduForce = 0'
      endif
      write(lunrad,'(a)')

      write(c32x,*)xcentershift
      write(lunrad,'(a)')"UnduXCenterShift = " // c32x
      write(c32x,*)utorqcenx
      write(lunrad,'(a)')"UnduTorqCenX = " // c32x
      write(c32x,*)utorqceny
      write(lunrad,'(a)')"UnduTorqCenY = " // c32x
      write(c32x,*)utorqcenz
      write(lunrad,'(a)')"UnduTorqCenZ = " // c32x

      write(lunrad,'(a)')
      write(c32x,*)xmapmin
      write(lunrad,'(a)')"UnduXMapMin = " // c32x
      write(c32x,*)xmapmax
      write(lunrad,'(a)')"UnduXMapMax = " // c32x
      write(c32x,*) nxmap
      write(lunrad,'(a)')"nUnduXMap = " // c32x

      write(lunrad,'(a)')
      write(c32x,*) ymapmin
      write(lunrad,'(a)')"UnduYMapMin = " // c32x
      write(c32x,*) ymapmax
      write(lunrad,'(a)')"UnduYMapMax = " // c32x
      write(c32x,*) nymap
      write(lunrad,'(a)')"nUnduYMap = " // c32x

      write(lunrad,'(a)')
      write(c32x,*)zmapmin
      write(lunrad,'(a)')"UnduZMapMin = " // c32x
      write(c32x,*)zmapmax
      write(lunrad,'(a)')"UnduZMapMax = " // c32x
      write(c32x,*) nzmap
      write(lunrad,'(a)')"nUnduZMap = " // c32x

      write(lunrad,'(a)')
      write(c32x,*)
     &  knopolmap
      write(lunrad,'(a)')"nUnduNoPolMap = " // c32x
      write(c32x,*)
     &  knomagmap
      write(lunrad,'(a)')"nUnduNoMagMap = " // c32x
      write(lunrad,'(a)')

      write(lunrad,'(a)')
      write(lunrad,'(a)')'# --- Variables of undumag.clc ---'
      write(lunrad,'(a)')

      do i=1,nvar_t
        write(clunrad,*) trim(t_variables(i)%cname),' = ',t_variables(i)%val
        write(lunrad,'(a)') trim(adjustl(clunrad))
      enddo !nvar_t

      write(lunrad,'(a)')
      write(lunrad,'(a)')'# --- Materials of undumag.clc ---'
      write(lunrad,'(a)')

      write(lunrad,'(a)')'UmatREC = []'
      do i=1,nbr
        imat=imatrec(i)
        if (imat.eq.0) cycle
        if (matmaps(1,imat).eq.1) then
          if (matmaps(2,imat).eq.1) then
            write(c32x,'(f6.4)')bcmat(2,1,imat) !-1.0d0
            write(c32y,'(f6.4)')bcmat(3,1,imat) !-1.0d0
            write(c32z,'(g12.5)')brrec(i)
            write(clunrad,'(a)')
     &        "UmatREC.append(rad.MatLin([" //
     &        trim(adjustl(c32x)) // "," //
     &        trim(adjustl(c32y)) //
     &        "]," // trim(adjustl(c32z)) // "))"
            write(lunrad,'(a)') trim(clunrad)
          else
            print*,"*** Error in clcmag_to_msh_radia: mode",
     &        matmaps(2,imat), " not yet implemented for REC material ",imat
            print*,""
            !stop "--- UNDUMAG aborted ---"
          endif
        else
          print*,"*** Error in clcmag_to_msh_radia: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          !stop "--- UNDUMAG aborted ---"
        endif
      enddo

      write(lunrad,'(a)')'UmatIron = []'
      do i=1,nmatfe
        imat=imatiron(i)
        if (imat.eq.0) cycle
        if (matmaps(1,imat).eq.2) then
          write(lunrad,'(a)')
     &      "UmatIron.append(rad.MatSatIsoTab([ \"
          do k=2,nclcmat
            read(clcmat(k),*)iron,lmat,ironmode,cbuff(1)
            if (iron.eq.imat) then
              open(newunit=lunfe,file=trim(cbuff(1)),status='old')
              ieof=0
              do while (ieof.eq.0)
                call util_skip_comment_end(lunfe,ieof)
                if (ieof.ne.0) exit
                read(lunfe,*) hfe,bfe
                write(clunrad,*)"[",hfe,",",bfe,"],"
                write(lunrad,'(a)') trim(clunrad)
              enddo
              backspace(lunrad)
              write(clunrad,*)"[",hfe,",",bfe,"]]))"
              write(lunrad,'(a)') trim(clunrad)
              close(lunfe)
            endif
          enddo
        else
          print*,"*** Error in clcmag_to_msh_radia: Unknown material or mode", imat,
     &      matmaps(:,imat)
          print*,""
          !stop "--- UNDUMAG aborted ---"
        endif
      enddo

      write(lunrad,'(a)')
      write(lunrad,'(a)')'# --- Poles and magnets of undumag.clc ---'
      write(lunrad,'(a)')

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        ! radObjPolyhdr[
        ! [
        !   [x1,y1,z1], ..., [xn,yn,zn] Corners
        ! ],
        ! [
        !   [f1n1,f1n2,...], ...., [f2n1,f2n2,...] Faces
        ! ],
        ! [mx,my,mz]:[0,0,0]]

        if(t_magnets(kproto)%ctype.ne.'Cylinder') then

          nface=t_magnets(kproto)%nface
          ncolor=t_magnets(kproto)%icol

          gcen=t_magcopy(imp)%gcen

          write(lunrad,'(a)')"vertices = [ \"

          do kpoi=1,t_magnets(kproto)%nhull

            write(c32x,*)sngl(t_magnets(kproto)%xhull(kpoi)+gcen(1)+xcentershift)
            write(c32y,*)sngl(t_magnets(kproto)%yhull(kpoi)+gcen(2))
            write(c32z,*)sngl(t_magnets(kproto)%zhull(kpoi)+gcen(3))

            if (kpoi.lt.t_magnets(kproto)%nhull) then
              write(clunrad,*)
     &          "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"],"
              write(lunrad,'(a)') trim(clunrad)
            else
              write(clunrad,*)
     &          "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"]]"
              write(lunrad,'(a)') trim(clunrad)
              write(lunrad,'(a)') ''
            endif
          enddo !kpoi

          write(lunrad,'(a)')"vertices,ifaces,faces,bounds = msh.mshhull3d(vertices)"
          write(lunrad,'(a)') ''

          cnam=t_magcopy(imp)%cnam

          if (t_magnets(kproto)%IsPole.eq.0) then
            write(c32x,*)t_magcopy(imp)%br(1)*t_magcopy(imp)%brn
            write(c32y,*)t_magcopy(imp)%br(2)*t_magcopy(imp)%brn
            write(c32z,*)t_magcopy(imp)%br(3)*t_magcopy(imp)%brn
            write(lunrad,'(a)')"Br = [" // trim(c32z) // "," // trim(c32x) // "," // trim(c32y) // "]"
          else
            write(lunrad,'(a)')"Br = [0.0,0.0,0.0]"
          endif !Pole/Mag

          c32=''

          if (ncolor.eq.0) then
            c32='white'
          else if (ncolor.eq.1) then
            c32='black'
          else if (ncolor.eq.2) then
            c32='red'
          else if (ncolor.eq.3) then
            c32='green'
          else if (ncolor.eq.4) then
            c32='blue'
          else if (ncolor.eq.5) then
            c32='yellow'
          else if (ncolor.eq.6) then
            c32='magenta'
          else if (ncolor.eq.7) then
            c32='cyan'
          else if (ncolor.eq.7) then
            c32='green'
          else if (ncolor.eq.8) then
            c32='gray'
          endif

          write(lunrad,'(a)')
     &      trim(cnam) // " = msh.mshObjPolyhdr(vertices,ifaces,faces,bounds,Br,'" // trim(cnam) // "','" // trim(c32) // "')"
          write(lunrad,'(a)') ''

          if (t_magnets(kproto)%IsPole.eq.0) then
            mater = imatmagpol(imp)
            write(chmat,*)mater-1
            call util_string_trim(chmat,nfirst,nlast)
            chmat="UmatREC["//chmat(nfirst:nlast)//"]"
          else
            mater = imatmagpol(imp)
            write(chmat,*)mater-1
            call util_string_trim(chmat,nfirst,nlast)
            chmat="UmatIron["//chmat(nfirst:nlast)//"]"
          endif !Pole/Mag

          if (t_magnets(kproto)%nzdiv*t_magnets(kproto)%nydiv*t_magnets(kproto)%nxdiv.gt.1) then
            write(lunrad,'(a)')
            write(cline,*)
     &        "rad.ObjDivMag("//trim(adjustl(t_magcopy(imp)%cnam))//", [[",
     &        t_magnets(kproto)%nzdiv,",",
     &        sngl(t_magnets(kproto)%zfracdiv),"],",t_magnets(kproto)%nxdiv,
     &        ",[",t_magnets(kproto)%nydiv,",",
     &        sngl(t_magnets(kproto)%yfracdiv),"]],'kxkykz->Numb')"
            call util_remove_double_blanks(cline,cout,lenout)
            write(lunrad,'(a)') cout(2:lenout)
            write(lunrad,'(a)')
          endif

          write(lunrad,'(a)')
          write(lunrad,'(a)')"rad.MatApl("//trim(adjustl(t_magcopy(imp)%cnam))//","//
     &      trim(chmat)//")"

        else !cylinder:

          do ivox=1,nvoxcopy_t

            kproto=t_voxcopy(ivox)%kproto
            if (t_magnets(kproto)%ctype.ne.'Cylinder') cycle

            kmagnet=t_voxcopy(ivox)%kmagnet
            kvoxel=t_voxcopy(ivox)%kvoxel

            cline=adjustl(t_magcopy(imp)%cnam)
            call util_string_append(cline,'_',nfirst,nlast)
            ixdiv=t_magnets(kproto)%t_voxels(kvoxel)%ixdiv
            call util_string_append_num(cline,ixdiv,nfirst,nlast)
            call util_string_append(cline,'_',nfirst,nlast)
            iydiv=t_magnets(kproto)%t_voxels(kvoxel)%iydiv
            call util_string_append_num(cline,iydiv,nfirst,nlast)
            call util_string_append(cline,'_',nfirst,nlast)
            izdiv=t_magnets(kproto)%t_voxels(kvoxel)%izdiv
            call util_string_append_num(cline,izdiv,nfirst,nlast)
            cnam=trim(cline)
            call util_string_append(cline," = rad.ObjPolyhdr([ \",nfirst,nlast)

            write(lunrad,'(a)') trim(cline)

            gcen=t_voxcopy(ivox)%gcen

            npoi=t_magnets(kproto)%t_voxels(kvoxel)%nhull
            do ipoi=1,npoi

              write(c32x,*)sngl(t_magnets(kproto)%t_voxels(kvoxel)%xhull(ipoi)+
     &          gcen(1)+xcentershift)
              write(c32y,*)sngl(t_magnets(kproto)%t_voxels(kvoxel)%yhull(ipoi)+
     &          gcen(2))
              write(c32z,*)sngl(t_magnets(kproto)%t_voxels(kvoxel)%zhull(ipoi)+
     &          gcen(3))

              if (ipoi.lt.npoi) then
                write(clunrad,*)
     &            "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"],"
                write(lunrad,'(a)') trim(clunrad)
              else
                write(clunrad,*)
     &            "           [",trim(c32z),",",trim(c32x),",",trim(c32y),"]],[ \"
                write(lunrad,'(a)') trim(clunrad)
              endif

            enddo !ipoi

            nface=t_magnets(kproto)%t_voxels(kvoxel)%nface
            do iface=1,t_magnets(kproto)%t_voxels(kvoxel)%nface

              k=t_magnets(kproto)%t_voxels(kvoxel)%lface(iface)
              npoi=t_magnets(kproto)%t_voxels(kvoxel)%kface(k)

              cline="         ["

              do ipoi=1,npoi
                call util_string_append_num(cline,
     &            t_magnets(kproto)%t_voxels(kvoxel)%kface(k+ipoi),nfirst,nlast)
                if (ipoi.lt.npoi) then
                  call util_string_append(cline,',',nfirst,nlast)
                else
                  call util_string_append(cline,'],',nfirst,nlast)
                endif
              enddo !ipoi

              if (iface.lt.nface) then
                write(lunrad,'(a)')cline(1:nlast)
c                call util_string_append(cline,'],',nfirst,nlast)
              else
                write(lunrad,'(a)')cline(1:nlast-1) // '], \'
              endif

            enddo !nface

            if (t_magnets(kproto)%IsPole.eq.0) then
              write(c32x,*)t_voxcopy(kvoxel)%br(1)
              write(c32y,*)t_voxcopy(kvoxel)%br(2)
              write(c32z,*)t_voxcopy(kvoxel)%br(3)
              write(clunrad,*)"         [",trim(c32z),",",trim(c32x),",",trim(c32y),"])"
              write(lunrad,'(a)') trim(clunrad)
              mater = imatmagpol(imp)
              write(chmat,*)mater-1
              call util_string_trim(chmat,nfirst,nlast)
              chmat="UmatREC["//chmat(nfirst:nlast)//"]"
            else
              write(lunrad,'(a)')"[0,0,0])"
              mater = imatmagpol(imp)
              write(chmat,*)mater-1
              call util_string_trim(chmat,nfirst,nlast)
              chmat="UmatIron["//chmat(nfirst:nlast)//"]"
            endif !Pole/Mag

            write(lunrad,'(a)')
            write(lunrad,'(a)')"rad.MatApl("//trim(cnam)//","//
     &        trim(chmat)//")"

          enddo !nvoxcopy_t

        endif !(t_magnets(kproto)%ctype.ne.'Cylinder') then

      enddo !imp=1,nmagtot_t

      write(lunrad,'(a)')"UnduMag = msh.mshObjCnt('UnduMag')"
      write(lunrad,'(a)')"UnduPol = msh.mshObjCnt('UnduPol')"
      write(lunrad,'(a)')"AllMagPols = msh.mshObjCnt('AllMagPols')"

      nUnduMag = 0
      nUnduPol = 0
      nMagPolTot = 0

      write(lunrad,'(a)')"nUnduMag = 0"
      write(lunrad,'(a)')"nUnduPol = 0"
      write(lunrad,'(a)')"nMagPolTot = 0"

      do imp=1,nmagtot_t

        kproto=t_magcopy(imp)%kproto

        if(t_magnets(kproto)%ctype.ne.'Cylinder') then

          if (t_magnets(kproto)%IsPole.eq.0) then

            nUnduMag=nUnduMag+1

            write(c32,*)nUnduMag
            write(lunrad,'(a)')"nUnduMag = " // trim(adjustl(c32))
            write(lunrad,'(a)')"msh.mshObjAddToCnt(UnduMag," //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"

            nMagPolTot=nMagPolTot+1

            write(c32,*)nMagPolTot
            write(lunrad,'(a)')"nMagPolTot = " // trim(adjustl(c32))
            write(lunrad,'(a)')"msh.mshObjAddToCnt(AllMagPols," //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"
            write(lunrad,'(a)')

            if (iforce.ne.0.and.t_magcopy(imp)%cnam.eq.chforcemag) then
              write(lunrad,'(a)')
              write(lunrad,'(a)')"iForceTyp = 1"
              write(lunrad,'(a)')"# ForceMagPol = msh.mshMagPols[msh.mshNames[" // trim(chforcemag) // "]]"
              write(lunrad,'(a)')"ForceMagPol = " // trim(chforcemag)
              write(lunrad,'(a)')
            endif

          else ! IsPole

            nUnduPol=nUnduPol+1

            write(c32,*)nUnduPol
            write(lunrad,'(a)')"nUnduPol = " // trim(adjustl(c32))
            write(lunrad,'(a)')"msh.mshObjAddToCnt(UnduPol," //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"

            nMagPolTot=nMagPolTot+1

            write(c32,*)nMagPolTot
            write(lunrad,'(a)')"nMagPolTot = " // trim(adjustl(c32))
            write(lunrad,'(a)')"msh.mshObjAddToCnt(AllMagPols," //
     &        trim(adjustl(t_magcopy(imp)%cnam)) // ")"
            write(lunrad,'(a)')

            if (iforce.ne.0.and.t_magcopy(imp)%cnam.eq.chforcemag) then
              write(lunrad,'(a)')
              write(lunrad,'(a)')"iForceTyp = 1"
              write(lunrad,'(a)')"# ForceMagPol = msh.mshMagPols[msh.mshNames[" // trim(chforcemag) // "]]"
              write(lunrad,'(a)')"ForceMagPol = " // trim(chforcemag)
              write(lunrad,'(a)')
            endif

          endif !IsPole

        else ! Cylinder

          do ivox=1,nvoxcopy_t

            if (t_magnets(kproto)%ctype.ne.'Cylinder') cycle

            if (t_magnets(kproto)%IsPole.eq.0) then

              kmagnet=t_voxcopy(ivox)%kmagnet
              kvoxel=t_voxcopy(ivox)%kvoxel

              nUnduMag=nUnduMag+1

              cline=adjustl(t_magcopy(imp)%cnam)
              call util_string_append(cline,'_',nfirst,nlast)
              ixdiv=t_magnets(kproto)%t_voxels(kvoxel)%ixdiv
              call util_string_append_num(cline,ixdiv,nfirst,nlast)
              call util_string_append(cline,'_',nfirst,nlast)
              iydiv=t_magnets(kproto)%t_voxels(kvoxel)%iydiv
              call util_string_append_num(cline,iydiv,nfirst,nlast)
              call util_string_append(cline,'_',nfirst,nlast)
              izdiv=t_magnets(kproto)%t_voxels(kvoxel)%izdiv
              call util_string_append_num(cline,izdiv,nfirst,nlast)
              cnam=trim(cline)

              write(c32,*)nUnduMag
              write(lunrad,'(a)')"nUnduMag = " // trim(adjustl(c32))
              write(lunrad,'(a)')"msh.mshObjAddToCnt(UnduMag," //
     &          trim(adjustl(t_magcopy(imp)%cnam)) // ")"

              nMagPolTot=nMagPolTot+1

              write(c32,*)nMagPolTot
              write(lunrad,'(a)')"nMagPolTot = " // trim(adjustl(c32))
              write(lunrad,'(a)')"msh.mshObjAddToCnt(AllMagMags," //
     &          trim(adjustl(t_magcopy(imp)%cnam)) // ")"
              write(lunrad,'(a)')

              if (iforce.ne.0.and.t_magcopy(imp)%cnam.eq.chforcemag) then
                write(lunrad,'(a)')' '
                write(lunrad,'(a)')"iForceTyp = 1"
                write(lunrad,'(a)')"# ForceMagPol = msh.mshMagPols[msh.mshNames[" // trim(chforcemag) // "]]"
                write(lunrad,'(a)')"ForceMagPol = " // trim(chforcemag)
                write(lunrad,'(a)')
                print*,"*** Warning in clcmag_to_msh_radia: Force calculations for cylinders not yet tested..."
              endif

            else !IsPole

              kmagnet=t_voxcopy(ivox)%kmagnet
              kvoxel=t_voxcopy(ivox)%kvoxel

              nUnduPol=nUnduPol+1

              cline=adjustl(t_magcopy(imp)%cnam)
              call util_string_append(cline,'_',nfirst,nlast)
              ixdiv=t_magnets(kproto)%t_voxels(kvoxel)%ixdiv
              call util_string_append_num(cline,ixdiv,nfirst,nlast)
              call util_string_append(cline,'_',nfirst,nlast)
              iydiv=t_magnets(kproto)%t_voxels(kvoxel)%iydiv
              call util_string_append_num(cline,iydiv,nfirst,nlast)
              call util_string_append(cline,'_',nfirst,nlast)
              izdiv=t_magnets(kproto)%t_voxels(kvoxel)%izdiv
              call util_string_append_num(cline,izdiv,nfirst,nlast)
              cnam=trim(cline)

              write(c32,*)nUnduPol
              write(lunrad,'(a)')"nUnduPol = " // trim(adjustl(c32))
              write(lunrad,'(a)')"msh.mshObjAddToCnt(UnduPol," //
     &          trim(adjustl(t_magcopy(imp)%cnam)) // ")"

              nMagPolTot=nMagPolTot+1

              write(c32,*)nMagPolTot
              write(lunrad,'(a)')"nMagPolTot = " // trim(adjustl(c32))
              write(lunrad,'(a)')"msh.mshObjAddToCnt(AllMagPols," //
     &          trim(adjustl(t_magcopy(imp)%cnam)) // ")"
              write(lunrad,'(a)')

              if (t_magcopy(imp)%cnam.eq.chforcemag) then
                write(lunrad,'(a)')
                write(lunrad,'(a)')"iForceTyp = 1"
                write(lunrad,'(a)')"ForceMagPol = " // trim(chforcemag)
                write(lunrad,'(a)')
                print*,"*** Warning in clcmag_to_msh_radia: Force calculations for cylinders not yet tested..."
              endif

            endif !IsPole

          enddo !nvox

        endif !(t_magnets(kproto)%ctype.ne.'Cylinder') then

      enddo !imp=1,nmagtot_t

      deallocate(brrec)

      write(c32,*) ncwires
      write(lunrad,'(a)')'nUnduFilaments = ' // trim(adjustl(c32))

c      if (iunduplot.lt.0.or.iundugeo.lt.0.or.ivrml.lt.0) then
c        write(lunrad,'(a)')'iSolve = 0'
c      else
        write(lunrad,'(a)')'iSolve = 1'
c      endif

      write(lunrad,'(a)')
      write(lunrad,'(a)')'#-- End of lines generated by UNDUMAG --'
      write(lunrad,'(a)')

      write(lunrad,'(a)')
      write(lunrad,'(a)')'#-- Reading undumag_proc_msh_radia.py and appending to undumag_msh_radia.py --'
      write(lunrad,'(a)')

      open(newunit=lunproc,file='undumag_proc_msh_radia.py',status='old', iostat=istat)

      if (istat.ne.0) then

        write(lun6,*)"*** Error in clcmag_to_msh_radia: File undumag_proc_msh_radia.py not found ***"

      else

        ieof=0
        cline=''

        do while (ieof.eq.0)
          read(lunproc,'(a)',iostat=ieof) cline
          if (ieof.eq.0) write(lunrad,'(a)') trim(cline)
        enddo
        close(lunproc)

      endif

      flush(lunrad)
      close(lunrad)

      return
      end
